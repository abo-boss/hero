/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_react-simplemde-editor_dist_SimpleMdeReact_mjs"],{

/***/ "?f052":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror-spell-checker/src/js/spell-checker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/codemirror-spell-checker/src/js/spell-checker.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)\n\n// Requires\nvar Typo = __webpack_require__(/*! typo-js */ \"(app-pages-browser)/./node_modules/typo-js/typo.js\");\n// Create function\nfunction CodeMirrorSpellChecker(options) {\n    // Initialize\n    options = options || {};\n    // Verify\n    if (typeof options.codeMirrorInstance !== \"function\" || typeof options.codeMirrorInstance.defineMode !== \"function\") {\n        console.log(\"CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`\");\n        return;\n    }\n    // Because some browsers don't support this functionality yet\n    if (!String.prototype.includes) {\n        String.prototype.includes = function() {\n            \"use strict\";\n            return String.prototype.indexOf.apply(this, arguments) !== -1;\n        };\n    }\n    // Define the new mode\n    options.codeMirrorInstance.defineMode(\"spell-checker\", function(config) {\n        // Load AFF/DIC data\n        if (!CodeMirrorSpellChecker.aff_loading) {\n            CodeMirrorSpellChecker.aff_loading = true;\n            var xhr_aff = new XMLHttpRequest();\n            xhr_aff.open(\"GET\", \"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff\", true);\n            xhr_aff.onload = function() {\n                if (xhr_aff.readyState === 4 && xhr_aff.status === 200) {\n                    CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;\n                    CodeMirrorSpellChecker.num_loaded++;\n                    if (CodeMirrorSpellChecker.num_loaded == 2) {\n                        CodeMirrorSpellChecker.typo = new Typo(\"en_US\", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {\n                            platform: \"any\"\n                        });\n                    }\n                }\n            };\n            xhr_aff.send(null);\n        }\n        if (!CodeMirrorSpellChecker.dic_loading) {\n            CodeMirrorSpellChecker.dic_loading = true;\n            var xhr_dic = new XMLHttpRequest();\n            xhr_dic.open(\"GET\", \"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic\", true);\n            xhr_dic.onload = function() {\n                if (xhr_dic.readyState === 4 && xhr_dic.status === 200) {\n                    CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;\n                    CodeMirrorSpellChecker.num_loaded++;\n                    if (CodeMirrorSpellChecker.num_loaded == 2) {\n                        CodeMirrorSpellChecker.typo = new Typo(\"en_US\", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {\n                            platform: \"any\"\n                        });\n                    }\n                }\n            };\n            xhr_dic.send(null);\n        }\n        // Define what separates a word\n        var rx_word = '!\"#$%&()*+,-./:;<=>?@[\\\\]^_`{|}~ ';\n        // Create the overlay and such\n        var overlay = {\n            token: function(stream) {\n                var ch = stream.peek();\n                var word = \"\";\n                if (rx_word.includes(ch)) {\n                    stream.next();\n                    return null;\n                }\n                while((ch = stream.peek()) != null && !rx_word.includes(ch)){\n                    word += ch;\n                    stream.next();\n                }\n                if (CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word)) return \"spell-error\"; // CSS class: cm-spell-error\n                return null;\n            }\n        };\n        var mode = options.codeMirrorInstance.getMode(config, config.backdrop || \"text/plain\");\n        return options.codeMirrorInstance.overlayMode(mode, overlay, true);\n    });\n}\n_c = CodeMirrorSpellChecker;\n// Initialize data globally to reduce memory consumption\nCodeMirrorSpellChecker.num_loaded = 0;\nCodeMirrorSpellChecker.aff_loading = false;\nCodeMirrorSpellChecker.dic_loading = false;\nCodeMirrorSpellChecker.aff_data = \"\";\nCodeMirrorSpellChecker.dic_data = \"\";\nCodeMirrorSpellChecker.typo;\n// Export\nmodule.exports = CodeMirrorSpellChecker;\nvar _c;\n$RefreshReg$(_c, \"CodeMirrorSpellChecker\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yLXNwZWxsLWNoZWNrZXIvc3JjL2pzL3NwZWxsLWNoZWNrZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0dBQWtHO0FBQ3JGO0FBR2IsV0FBVztBQUNYLElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDLG1FQUFTO0FBRzVCLGtCQUFrQjtBQUNsQixTQUFTQyx1QkFBdUJDLE9BQU87SUFDdEMsYUFBYTtJQUNiQSxVQUFVQSxXQUFXLENBQUM7SUFHdEIsU0FBUztJQUNULElBQUcsT0FBT0EsUUFBUUMsa0JBQWtCLEtBQUssY0FBYyxPQUFPRCxRQUFRQyxrQkFBa0IsQ0FBQ0MsVUFBVSxLQUFLLFlBQVk7UUFDbkhDLFFBQVFDLEdBQUcsQ0FBQztRQUNaO0lBQ0Q7SUFHQSw2REFBNkQ7SUFDN0QsSUFBRyxDQUFDQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsRUFBRTtRQUM5QkYsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLEdBQUc7WUFDM0I7WUFDQSxPQUFPRixPQUFPQyxTQUFTLENBQUNFLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLElBQUksRUFBRUMsZUFBZSxDQUFDO1FBQzdEO0lBQ0Q7SUFHQSxzQkFBc0I7SUFDdEJWLFFBQVFDLGtCQUFrQixDQUFDQyxVQUFVLENBQUMsaUJBQWlCLFNBQVNTLE1BQU07UUFDckUsb0JBQW9CO1FBQ3BCLElBQUcsQ0FBQ1osdUJBQXVCYSxXQUFXLEVBQUU7WUFDdkNiLHVCQUF1QmEsV0FBVyxHQUFHO1lBQ3JDLElBQUlDLFVBQVUsSUFBSUM7WUFDbEJELFFBQVFFLElBQUksQ0FBQyxPQUFPLHNFQUFzRTtZQUMxRkYsUUFBUUcsTUFBTSxHQUFHO2dCQUNoQixJQUFHSCxRQUFRSSxVQUFVLEtBQUssS0FBS0osUUFBUUssTUFBTSxLQUFLLEtBQUs7b0JBQ3REbkIsdUJBQXVCb0IsUUFBUSxHQUFHTixRQUFRTyxZQUFZO29CQUN0RHJCLHVCQUF1QnNCLFVBQVU7b0JBRWpDLElBQUd0Qix1QkFBdUJzQixVQUFVLElBQUksR0FBRzt3QkFDMUN0Qix1QkFBdUJ1QixJQUFJLEdBQUcsSUFBSXpCLEtBQUssU0FBU0UsdUJBQXVCb0IsUUFBUSxFQUFFcEIsdUJBQXVCd0IsUUFBUSxFQUFFOzRCQUNqSEMsVUFBVTt3QkFDWDtvQkFDRDtnQkFDRDtZQUNEO1lBQ0FYLFFBQVFZLElBQUksQ0FBQztRQUNkO1FBRUEsSUFBRyxDQUFDMUIsdUJBQXVCMkIsV0FBVyxFQUFFO1lBQ3ZDM0IsdUJBQXVCMkIsV0FBVyxHQUFHO1lBQ3JDLElBQUlDLFVBQVUsSUFBSWI7WUFDbEJhLFFBQVFaLElBQUksQ0FBQyxPQUFPLHNFQUFzRTtZQUMxRlksUUFBUVgsTUFBTSxHQUFHO2dCQUNoQixJQUFHVyxRQUFRVixVQUFVLEtBQUssS0FBS1UsUUFBUVQsTUFBTSxLQUFLLEtBQUs7b0JBQ3REbkIsdUJBQXVCd0IsUUFBUSxHQUFHSSxRQUFRUCxZQUFZO29CQUN0RHJCLHVCQUF1QnNCLFVBQVU7b0JBRWpDLElBQUd0Qix1QkFBdUJzQixVQUFVLElBQUksR0FBRzt3QkFDMUN0Qix1QkFBdUJ1QixJQUFJLEdBQUcsSUFBSXpCLEtBQUssU0FBU0UsdUJBQXVCb0IsUUFBUSxFQUFFcEIsdUJBQXVCd0IsUUFBUSxFQUFFOzRCQUNqSEMsVUFBVTt3QkFDWDtvQkFDRDtnQkFDRDtZQUNEO1lBQ0FHLFFBQVFGLElBQUksQ0FBQztRQUNkO1FBR0EsK0JBQStCO1FBQy9CLElBQUlHLFVBQVU7UUFHZCw4QkFBOEI7UUFDOUIsSUFBSUMsVUFBVTtZQUNiQyxPQUFPLFNBQVNDLE1BQU07Z0JBQ3JCLElBQUlDLEtBQUtELE9BQU9FLElBQUk7Z0JBQ3BCLElBQUlDLE9BQU87Z0JBRVgsSUFBR04sUUFBUXJCLFFBQVEsQ0FBQ3lCLEtBQUs7b0JBQ3hCRCxPQUFPSSxJQUFJO29CQUNYLE9BQU87Z0JBQ1I7Z0JBRUEsTUFBTSxDQUFDSCxLQUFLRCxPQUFPRSxJQUFJLEVBQUMsS0FBTSxRQUFRLENBQUNMLFFBQVFyQixRQUFRLENBQUN5QixJQUFLO29CQUM1REUsUUFBUUY7b0JBQ1JELE9BQU9JLElBQUk7Z0JBQ1o7Z0JBRUEsSUFBR3BDLHVCQUF1QnVCLElBQUksSUFBSSxDQUFDdkIsdUJBQXVCdUIsSUFBSSxDQUFDYyxLQUFLLENBQUNGLE9BQ3BFLE9BQU8sZUFBZSw0QkFBNEI7Z0JBRW5ELE9BQU87WUFDUjtRQUNEO1FBRUEsSUFBSUcsT0FBT3JDLFFBQVFDLGtCQUFrQixDQUFDcUMsT0FBTyxDQUM1QzNCLFFBQVFBLE9BQU80QixRQUFRLElBQUk7UUFHNUIsT0FBT3ZDLFFBQVFDLGtCQUFrQixDQUFDdUMsV0FBVyxDQUFDSCxNQUFNUixTQUFTO0lBQzlEO0FBQ0Q7S0FoR1M5QjtBQW1HVCx3REFBd0Q7QUFDeERBLHVCQUF1QnNCLFVBQVUsR0FBRztBQUNwQ3RCLHVCQUF1QmEsV0FBVyxHQUFHO0FBQ3JDYix1QkFBdUIyQixXQUFXLEdBQUc7QUFDckMzQix1QkFBdUJvQixRQUFRLEdBQUc7QUFDbENwQix1QkFBdUJ3QixRQUFRLEdBQUc7QUFDbEN4Qix1QkFBdUJ1QixJQUFJO0FBRzNCLFNBQVM7QUFDVG1CLE9BQU9DLE9BQU8sR0FBRzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yLXNwZWxsLWNoZWNrZXIvc3JjL2pzL3NwZWxsLWNoZWNrZXIuanM/Nzc4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVc2Ugc3RyaWN0IG1vZGUgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0cmljdF9tb2RlKVxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gUmVxdWlyZXNcbnZhciBUeXBvID0gcmVxdWlyZShcInR5cG8tanNcIik7XG5cblxuLy8gQ3JlYXRlIGZ1bmN0aW9uXG5mdW5jdGlvbiBDb2RlTWlycm9yU3BlbGxDaGVja2VyKG9wdGlvbnMpIHtcblx0Ly8gSW5pdGlhbGl6ZVxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXG5cdC8vIFZlcmlmeVxuXHRpZih0eXBlb2Ygb3B0aW9ucy5jb2RlTWlycm9ySW5zdGFuY2UgIT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygb3B0aW9ucy5jb2RlTWlycm9ySW5zdGFuY2UuZGVmaW5lTW9kZSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0Y29uc29sZS5sb2coXCJDb2RlTWlycm9yIFNwZWxsIENoZWNrZXI6IFlvdSBtdXN0IHByb3ZpZGUgYW4gaW5zdGFuY2Ugb2YgQ29kZU1pcnJvciB2aWEgdGhlIG9wdGlvbiBgY29kZU1pcnJvckluc3RhbmNlYFwiKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXG5cdC8vIEJlY2F1c2Ugc29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoaXMgZnVuY3Rpb25hbGl0eSB5ZXRcblx0aWYoIVN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMpIHtcblx0XHRTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKSAhPT0gLTE7XG5cdFx0fTtcblx0fVxuXG5cblx0Ly8gRGVmaW5lIHRoZSBuZXcgbW9kZVxuXHRvcHRpb25zLmNvZGVNaXJyb3JJbnN0YW5jZS5kZWZpbmVNb2RlKFwic3BlbGwtY2hlY2tlclwiLCBmdW5jdGlvbihjb25maWcpIHtcblx0XHQvLyBMb2FkIEFGRi9ESUMgZGF0YVxuXHRcdGlmKCFDb2RlTWlycm9yU3BlbGxDaGVja2VyLmFmZl9sb2FkaW5nKSB7XG5cdFx0XHRDb2RlTWlycm9yU3BlbGxDaGVja2VyLmFmZl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdHZhciB4aHJfYWZmID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHR4aHJfYWZmLm9wZW4oXCJHRVRcIiwgXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvY29kZW1pcnJvci5zcGVsbC1jaGVja2VyL2xhdGVzdC9lbl9VUy5hZmZcIiwgdHJ1ZSk7XG5cdFx0XHR4aHJfYWZmLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZih4aHJfYWZmLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyX2FmZi5zdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRcdENvZGVNaXJyb3JTcGVsbENoZWNrZXIuYWZmX2RhdGEgPSB4aHJfYWZmLnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0XHRDb2RlTWlycm9yU3BlbGxDaGVja2VyLm51bV9sb2FkZWQrKztcblxuXHRcdFx0XHRcdGlmKENvZGVNaXJyb3JTcGVsbENoZWNrZXIubnVtX2xvYWRlZCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRDb2RlTWlycm9yU3BlbGxDaGVja2VyLnR5cG8gPSBuZXcgVHlwbyhcImVuX1VTXCIsIENvZGVNaXJyb3JTcGVsbENoZWNrZXIuYWZmX2RhdGEsIENvZGVNaXJyb3JTcGVsbENoZWNrZXIuZGljX2RhdGEsIHtcblx0XHRcdFx0XHRcdFx0cGxhdGZvcm06IFwiYW55XCJcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHhocl9hZmYuc2VuZChudWxsKTtcblx0XHR9XG5cblx0XHRpZighQ29kZU1pcnJvclNwZWxsQ2hlY2tlci5kaWNfbG9hZGluZykge1xuXHRcdFx0Q29kZU1pcnJvclNwZWxsQ2hlY2tlci5kaWNfbG9hZGluZyA9IHRydWU7XG5cdFx0XHR2YXIgeGhyX2RpYyA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0eGhyX2RpYy5vcGVuKFwiR0VUXCIsIFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2NvZGVtaXJyb3Iuc3BlbGwtY2hlY2tlci9sYXRlc3QvZW5fVVMuZGljXCIsIHRydWUpO1xuXHRcdFx0eGhyX2RpYy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoeGhyX2RpYy5yZWFkeVN0YXRlID09PSA0ICYmIHhocl9kaWMuc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0XHRDb2RlTWlycm9yU3BlbGxDaGVja2VyLmRpY19kYXRhID0geGhyX2RpYy5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0Q29kZU1pcnJvclNwZWxsQ2hlY2tlci5udW1fbG9hZGVkKys7XG5cblx0XHRcdFx0XHRpZihDb2RlTWlycm9yU3BlbGxDaGVja2VyLm51bV9sb2FkZWQgPT0gMikge1xuXHRcdFx0XHRcdFx0Q29kZU1pcnJvclNwZWxsQ2hlY2tlci50eXBvID0gbmV3IFR5cG8oXCJlbl9VU1wiLCBDb2RlTWlycm9yU3BlbGxDaGVja2VyLmFmZl9kYXRhLCBDb2RlTWlycm9yU3BlbGxDaGVja2VyLmRpY19kYXRhLCB7XG5cdFx0XHRcdFx0XHRcdHBsYXRmb3JtOiBcImFueVwiXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR4aHJfZGljLnNlbmQobnVsbCk7XG5cdFx0fVxuXG5cblx0XHQvLyBEZWZpbmUgd2hhdCBzZXBhcmF0ZXMgYSB3b3JkXG5cdFx0dmFyIHJ4X3dvcmQgPSBcIiFcXFwiIyQlJigpKissLS4vOjs8PT4/QFtcXFxcXV5fYHt8fX4gXCI7XG5cblxuXHRcdC8vIENyZWF0ZSB0aGUgb3ZlcmxheSBhbmQgc3VjaFxuXHRcdHZhciBvdmVybGF5ID0ge1xuXHRcdFx0dG9rZW46IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRcdFx0XHR2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXHRcdFx0XHR2YXIgd29yZCA9IFwiXCI7XG5cblx0XHRcdFx0aWYocnhfd29yZC5pbmNsdWRlcyhjaCkpIHtcblx0XHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d2hpbGUoKGNoID0gc3RyZWFtLnBlZWsoKSkgIT0gbnVsbCAmJiAhcnhfd29yZC5pbmNsdWRlcyhjaCkpIHtcblx0XHRcdFx0XHR3b3JkICs9IGNoO1xuXHRcdFx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihDb2RlTWlycm9yU3BlbGxDaGVja2VyLnR5cG8gJiYgIUNvZGVNaXJyb3JTcGVsbENoZWNrZXIudHlwby5jaGVjayh3b3JkKSlcblx0XHRcdFx0XHRyZXR1cm4gXCJzcGVsbC1lcnJvclwiOyAvLyBDU1MgY2xhc3M6IGNtLXNwZWxsLWVycm9yXG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBtb2RlID0gb3B0aW9ucy5jb2RlTWlycm9ySW5zdGFuY2UuZ2V0TW9kZShcblx0XHRcdGNvbmZpZywgY29uZmlnLmJhY2tkcm9wIHx8IFwidGV4dC9wbGFpblwiXG5cdFx0KTtcblxuXHRcdHJldHVybiBvcHRpb25zLmNvZGVNaXJyb3JJbnN0YW5jZS5vdmVybGF5TW9kZShtb2RlLCBvdmVybGF5LCB0cnVlKTtcblx0fSk7XG59XG5cblxuLy8gSW5pdGlhbGl6ZSBkYXRhIGdsb2JhbGx5IHRvIHJlZHVjZSBtZW1vcnkgY29uc3VtcHRpb25cbkNvZGVNaXJyb3JTcGVsbENoZWNrZXIubnVtX2xvYWRlZCA9IDA7XG5Db2RlTWlycm9yU3BlbGxDaGVja2VyLmFmZl9sb2FkaW5nID0gZmFsc2U7XG5Db2RlTWlycm9yU3BlbGxDaGVja2VyLmRpY19sb2FkaW5nID0gZmFsc2U7XG5Db2RlTWlycm9yU3BlbGxDaGVja2VyLmFmZl9kYXRhID0gXCJcIjtcbkNvZGVNaXJyb3JTcGVsbENoZWNrZXIuZGljX2RhdGEgPSBcIlwiO1xuQ29kZU1pcnJvclNwZWxsQ2hlY2tlci50eXBvO1xuXG5cbi8vIEV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBDb2RlTWlycm9yU3BlbGxDaGVja2VyOyJdLCJuYW1lcyI6WyJUeXBvIiwicmVxdWlyZSIsIkNvZGVNaXJyb3JTcGVsbENoZWNrZXIiLCJvcHRpb25zIiwiY29kZU1pcnJvckluc3RhbmNlIiwiZGVmaW5lTW9kZSIsImNvbnNvbGUiLCJsb2ciLCJTdHJpbmciLCJwcm90b3R5cGUiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJhcHBseSIsImFyZ3VtZW50cyIsImNvbmZpZyIsImFmZl9sb2FkaW5nIiwieGhyX2FmZiIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJhZmZfZGF0YSIsInJlc3BvbnNlVGV4dCIsIm51bV9sb2FkZWQiLCJ0eXBvIiwiZGljX2RhdGEiLCJwbGF0Zm9ybSIsInNlbmQiLCJkaWNfbG9hZGluZyIsInhocl9kaWMiLCJyeF93b3JkIiwib3ZlcmxheSIsInRva2VuIiwic3RyZWFtIiwiY2giLCJwZWVrIiwid29yZCIsIm5leHQiLCJjaGVjayIsIm1vZGUiLCJnZXRNb2RlIiwiYmFja2Ryb3AiLCJvdmVybGF5TW9kZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror-spell-checker/src/js/spell-checker.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/addon/display/autorefresh.js":
/*!**************************************************************!*\
  !*** ./node_modules/codemirror/addon/display/autorefresh.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    CodeMirror1.defineOption(\"autoRefresh\", false, function(cm, val) {\n        if (cm.state.autoRefresh) {\n            stopListening(cm, cm.state.autoRefresh);\n            cm.state.autoRefresh = null;\n        }\n        if (val && cm.display.wrapper.offsetHeight == 0) startListening(cm, cm.state.autoRefresh = {\n            delay: val.delay || 250\n        });\n    });\n    function startListening(cm, state) {\n        function check() {\n            if (cm.display.wrapper.offsetHeight) {\n                stopListening(cm, state);\n                if (cm.display.lastWrapHeight != cm.display.wrapper.clientHeight) cm.refresh();\n            } else {\n                state.timeout = setTimeout(check, state.delay);\n            }\n        }\n        state.timeout = setTimeout(check, state.delay);\n        state.hurry = function() {\n            clearTimeout(state.timeout);\n            state.timeout = setTimeout(check, 50);\n        };\n        CodeMirror1.on(window, \"mouseup\", state.hurry);\n        CodeMirror1.on(window, \"keyup\", state.hurry);\n    }\n    function stopListening(_cm, state) {\n        clearTimeout(state.timeout);\n        CodeMirror1.off(window, \"mouseup\", state.hurry);\n        CodeMirror1.off(window, \"keyup\", state.hurry);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvYXV0b3JlZnJlc2guanMiLCJtYXBwaW5ncyI6IkFBQUEsMkRBQTJEO0FBQzNELHFFQUFxRTtBQUVwRSxVQUFTQSxHQUFHO0lBQ1gsSUFBSSxJQUF1RCxFQUN6REEsSUFBSUcsbUJBQU9BLENBQUMsNkZBQXNCO1NBQy9CLEVBR0NHO0FBQ1IsR0FBRyxTQUFTQSxXQUFVO0lBQ3BCO0lBRUFBLFlBQVdDLFlBQVksQ0FBQyxlQUFlLE9BQU8sU0FBU0MsRUFBRSxFQUFFQyxHQUFHO1FBQzVELElBQUlELEdBQUdFLEtBQUssQ0FBQ0MsV0FBVyxFQUFFO1lBQ3hCQyxjQUFjSixJQUFJQSxHQUFHRSxLQUFLLENBQUNDLFdBQVc7WUFDdENILEdBQUdFLEtBQUssQ0FBQ0MsV0FBVyxHQUFHO1FBQ3pCO1FBQ0EsSUFBSUYsT0FBT0QsR0FBR0ssT0FBTyxDQUFDQyxPQUFPLENBQUNDLFlBQVksSUFBSSxHQUM1Q0MsZUFBZVIsSUFBSUEsR0FBR0UsS0FBSyxDQUFDQyxXQUFXLEdBQUc7WUFBQ00sT0FBT1IsSUFBSVEsS0FBSyxJQUFJO1FBQUc7SUFDdEU7SUFFQSxTQUFTRCxlQUFlUixFQUFFLEVBQUVFLEtBQUs7UUFDL0IsU0FBU1E7WUFDUCxJQUFJVixHQUFHSyxPQUFPLENBQUNDLE9BQU8sQ0FBQ0MsWUFBWSxFQUFFO2dCQUNuQ0gsY0FBY0osSUFBSUU7Z0JBQ2xCLElBQUlGLEdBQUdLLE9BQU8sQ0FBQ00sY0FBYyxJQUFJWCxHQUFHSyxPQUFPLENBQUNDLE9BQU8sQ0FBQ00sWUFBWSxFQUM5RFosR0FBR2EsT0FBTztZQUNkLE9BQU87Z0JBQ0xYLE1BQU1ZLE9BQU8sR0FBR0MsV0FBV0wsT0FBT1IsTUFBTU8sS0FBSztZQUMvQztRQUNGO1FBQ0FQLE1BQU1ZLE9BQU8sR0FBR0MsV0FBV0wsT0FBT1IsTUFBTU8sS0FBSztRQUM3Q1AsTUFBTWMsS0FBSyxHQUFHO1lBQ1pDLGFBQWFmLE1BQU1ZLE9BQU87WUFDMUJaLE1BQU1ZLE9BQU8sR0FBR0MsV0FBV0wsT0FBTztRQUNwQztRQUNBWixZQUFXb0IsRUFBRSxDQUFDQyxRQUFRLFdBQVdqQixNQUFNYyxLQUFLO1FBQzVDbEIsWUFBV29CLEVBQUUsQ0FBQ0MsUUFBUSxTQUFTakIsTUFBTWMsS0FBSztJQUM1QztJQUVBLFNBQVNaLGNBQWNnQixHQUFHLEVBQUVsQixLQUFLO1FBQy9CZSxhQUFhZixNQUFNWSxPQUFPO1FBQzFCaEIsWUFBV3VCLEdBQUcsQ0FBQ0YsUUFBUSxXQUFXakIsTUFBTWMsS0FBSztRQUM3Q2xCLFlBQVd1QixHQUFHLENBQUNGLFFBQVEsU0FBU2pCLE1BQU1jLEtBQUs7SUFDN0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L2F1dG9yZWZyZXNoLmpzPzQxZjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0LzUvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZClcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKVxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIlxuXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwiYXV0b1JlZnJlc2hcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICBpZiAoY20uc3RhdGUuYXV0b1JlZnJlc2gpIHtcbiAgICAgIHN0b3BMaXN0ZW5pbmcoY20sIGNtLnN0YXRlLmF1dG9SZWZyZXNoKVxuICAgICAgY20uc3RhdGUuYXV0b1JlZnJlc2ggPSBudWxsXG4gICAgfVxuICAgIGlmICh2YWwgJiYgY20uZGlzcGxheS53cmFwcGVyLm9mZnNldEhlaWdodCA9PSAwKVxuICAgICAgc3RhcnRMaXN0ZW5pbmcoY20sIGNtLnN0YXRlLmF1dG9SZWZyZXNoID0ge2RlbGF5OiB2YWwuZGVsYXkgfHwgMjUwfSlcbiAgfSlcblxuICBmdW5jdGlvbiBzdGFydExpc3RlbmluZyhjbSwgc3RhdGUpIHtcbiAgICBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgIGlmIChjbS5kaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoY20sIHN0YXRlKVxuICAgICAgICBpZiAoY20uZGlzcGxheS5sYXN0V3JhcEhlaWdodCAhPSBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KVxuICAgICAgICAgIGNtLnJlZnJlc2goKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2ssIHN0YXRlLmRlbGF5KVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS50aW1lb3V0ID0gc2V0VGltZW91dChjaGVjaywgc3RhdGUuZGVsYXkpXG4gICAgc3RhdGUuaHVycnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdGF0ZS50aW1lb3V0KVxuICAgICAgc3RhdGUudGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2ssIDUwKVxuICAgIH1cbiAgICBDb2RlTWlycm9yLm9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIHN0YXRlLmh1cnJ5KVxuICAgIENvZGVNaXJyb3Iub24od2luZG93LCBcImtleXVwXCIsIHN0YXRlLmh1cnJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcExpc3RlbmluZyhfY20sIHN0YXRlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXQpXG4gICAgQ29kZU1pcnJvci5vZmYod2luZG93LCBcIm1vdXNldXBcIiwgc3RhdGUuaHVycnkpXG4gICAgQ29kZU1pcnJvci5vZmYod2luZG93LCBcImtleXVwXCIsIHN0YXRlLmh1cnJ5KVxuICB9XG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkZWZpbmVPcHRpb24iLCJjbSIsInZhbCIsInN0YXRlIiwiYXV0b1JlZnJlc2giLCJzdG9wTGlzdGVuaW5nIiwiZGlzcGxheSIsIndyYXBwZXIiLCJvZmZzZXRIZWlnaHQiLCJzdGFydExpc3RlbmluZyIsImRlbGF5IiwiY2hlY2siLCJsYXN0V3JhcEhlaWdodCIsImNsaWVudEhlaWdodCIsInJlZnJlc2giLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImh1cnJ5IiwiY2xlYXJUaW1lb3V0Iiwib24iLCJ3aW5kb3ciLCJfY20iLCJvZmYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/addon/display/autorefresh.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/addon/display/fullscreen.js":
/*!*************************************************************!*\
  !*** ./node_modules/codemirror/addon/display/fullscreen.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    CodeMirror1.defineOption(\"fullScreen\", false, function(cm, val, old) {\n        if (old == CodeMirror1.Init) old = false;\n        if (!old == !val) return;\n        if (val) setFullscreen(cm);\n        else setNormal(cm);\n    });\n    function setFullscreen(cm) {\n        var wrap = cm.getWrapperElement();\n        cm.state.fullScreenRestore = {\n            scrollTop: window.pageYOffset,\n            scrollLeft: window.pageXOffset,\n            width: wrap.style.width,\n            height: wrap.style.height\n        };\n        wrap.style.width = \"\";\n        wrap.style.height = \"auto\";\n        wrap.className += \" CodeMirror-fullscreen\";\n        document.documentElement.style.overflow = \"hidden\";\n        cm.refresh();\n    }\n    function setNormal(cm) {\n        var wrap = cm.getWrapperElement();\n        wrap.className = wrap.className.replace(/\\s*CodeMirror-fullscreen\\b/, \"\");\n        document.documentElement.style.overflow = \"\";\n        var info = cm.state.fullScreenRestore;\n        wrap.style.width = info.width;\n        wrap.style.height = info.height;\n        window.scrollTo(info.scrollLeft, info.scrollTop);\n        cm.refresh();\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvZnVsbHNjcmVlbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBRXBFLFVBQVNBLEdBQUc7SUFDWCxJQUFJLElBQXVELEVBQ3pEQSxJQUFJRyxtQkFBT0EsQ0FBQyw2RkFBc0I7U0FDL0IsRUFHYUc7QUFDcEIsR0FBRyxTQUFTQSxXQUFVO0lBQ3BCO0lBRUFBLFlBQVdDLFlBQVksQ0FBQyxjQUFjLE9BQU8sU0FBU0MsRUFBRSxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7UUFDaEUsSUFBSUEsT0FBT0osWUFBV0ssSUFBSSxFQUFFRCxNQUFNO1FBQ2xDLElBQUksQ0FBQ0EsT0FBTyxDQUFDRCxLQUFLO1FBQ2xCLElBQUlBLEtBQUtHLGNBQWNKO2FBQ2xCSyxVQUFVTDtJQUNqQjtJQUVBLFNBQVNJLGNBQWNKLEVBQUU7UUFDdkIsSUFBSU0sT0FBT04sR0FBR08saUJBQWlCO1FBQy9CUCxHQUFHUSxLQUFLLENBQUNDLGlCQUFpQixHQUFHO1lBQUNDLFdBQVdDLE9BQU9DLFdBQVc7WUFBRUMsWUFBWUYsT0FBT0csV0FBVztZQUM3REMsT0FBT1QsS0FBS1UsS0FBSyxDQUFDRCxLQUFLO1lBQUVFLFFBQVFYLEtBQUtVLEtBQUssQ0FBQ0MsTUFBTTtRQUFBO1FBQ2hGWCxLQUFLVSxLQUFLLENBQUNELEtBQUssR0FBRztRQUNuQlQsS0FBS1UsS0FBSyxDQUFDQyxNQUFNLEdBQUc7UUFDcEJYLEtBQUtZLFNBQVMsSUFBSTtRQUNsQkMsU0FBU0MsZUFBZSxDQUFDSixLQUFLLENBQUNLLFFBQVEsR0FBRztRQUMxQ3JCLEdBQUdzQixPQUFPO0lBQ1o7SUFFQSxTQUFTakIsVUFBVUwsRUFBRTtRQUNuQixJQUFJTSxPQUFPTixHQUFHTyxpQkFBaUI7UUFDL0JELEtBQUtZLFNBQVMsR0FBR1osS0FBS1ksU0FBUyxDQUFDSyxPQUFPLENBQUMsOEJBQThCO1FBQ3RFSixTQUFTQyxlQUFlLENBQUNKLEtBQUssQ0FBQ0ssUUFBUSxHQUFHO1FBQzFDLElBQUlHLE9BQU94QixHQUFHUSxLQUFLLENBQUNDLGlCQUFpQjtRQUNyQ0gsS0FBS1UsS0FBSyxDQUFDRCxLQUFLLEdBQUdTLEtBQUtULEtBQUs7UUFBRVQsS0FBS1UsS0FBSyxDQUFDQyxNQUFNLEdBQUdPLEtBQUtQLE1BQU07UUFDOUROLE9BQU9jLFFBQVEsQ0FBQ0QsS0FBS1gsVUFBVSxFQUFFVyxLQUFLZCxTQUFTO1FBQy9DVixHQUFHc0IsT0FBTztJQUNaO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZGlzcGxheS9mdWxsc2NyZWVuLmpzP2JmZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0LzUvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge1xuICAgIGlmIChvbGQgPT0gQ29kZU1pcnJvci5Jbml0KSBvbGQgPSBmYWxzZTtcbiAgICBpZiAoIW9sZCA9PSAhdmFsKSByZXR1cm47XG4gICAgaWYgKHZhbCkgc2V0RnVsbHNjcmVlbihjbSk7XG4gICAgZWxzZSBzZXROb3JtYWwoY20pO1xuICB9KTtcblxuICBmdW5jdGlvbiBzZXRGdWxsc2NyZWVuKGNtKSB7XG4gICAgdmFyIHdyYXAgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIGNtLnN0YXRlLmZ1bGxTY3JlZW5SZXN0b3JlID0ge3Njcm9sbFRvcDogd2luZG93LnBhZ2VZT2Zmc2V0LCBzY3JvbGxMZWZ0OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdyYXAuc3R5bGUud2lkdGgsIGhlaWdodDogd3JhcC5zdHlsZS5oZWlnaHR9O1xuICAgIHdyYXAuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgIHdyYXAuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgd3JhcC5jbGFzc05hbWUgKz0gXCIgQ29kZU1pcnJvci1mdWxsc2NyZWVuXCI7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBjbS5yZWZyZXNoKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXROb3JtYWwoY20pIHtcbiAgICB2YXIgd3JhcCA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgd3JhcC5jbGFzc05hbWUgPSB3cmFwLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqQ29kZU1pcnJvci1mdWxsc2NyZWVuXFxiLywgXCJcIik7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJcIjtcbiAgICB2YXIgaW5mbyA9IGNtLnN0YXRlLmZ1bGxTY3JlZW5SZXN0b3JlO1xuICAgIHdyYXAuc3R5bGUud2lkdGggPSBpbmZvLndpZHRoOyB3cmFwLnN0eWxlLmhlaWdodCA9IGluZm8uaGVpZ2h0O1xuICAgIHdpbmRvdy5zY3JvbGxUbyhpbmZvLnNjcm9sbExlZnQsIGluZm8uc2Nyb2xsVG9wKTtcbiAgICBjbS5yZWZyZXNoKCk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsImRlZmluZU9wdGlvbiIsImNtIiwidmFsIiwib2xkIiwiSW5pdCIsInNldEZ1bGxzY3JlZW4iLCJzZXROb3JtYWwiLCJ3cmFwIiwiZ2V0V3JhcHBlckVsZW1lbnQiLCJzdGF0ZSIsImZ1bGxTY3JlZW5SZXN0b3JlIiwic2Nyb2xsVG9wIiwid2luZG93IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJ3aWR0aCIsInN0eWxlIiwiaGVpZ2h0IiwiY2xhc3NOYW1lIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJvdmVyZmxvdyIsInJlZnJlc2giLCJyZXBsYWNlIiwiaW5mbyIsInNjcm9sbFRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/addon/display/fullscreen.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/addon/display/placeholder.js":
/*!**************************************************************!*\
  !*** ./node_modules/codemirror/addon/display/placeholder.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    CodeMirror1.defineOption(\"placeholder\", \"\", function(cm, val, old) {\n        var prev = old && old != CodeMirror1.Init;\n        if (val && !prev) {\n            cm.on(\"blur\", onBlur);\n            cm.on(\"change\", onChange);\n            cm.on(\"swapDoc\", onChange);\n            CodeMirror1.on(cm.getInputField(), \"compositionupdate\", cm.state.placeholderCompose = function() {\n                onComposition(cm);\n            });\n            onChange(cm);\n        } else if (!val && prev) {\n            cm.off(\"blur\", onBlur);\n            cm.off(\"change\", onChange);\n            cm.off(\"swapDoc\", onChange);\n            CodeMirror1.off(cm.getInputField(), \"compositionupdate\", cm.state.placeholderCompose);\n            clearPlaceholder(cm);\n            var wrapper = cm.getWrapperElement();\n            wrapper.className = wrapper.className.replace(\" CodeMirror-empty\", \"\");\n        }\n        if (val && !cm.hasFocus()) onBlur(cm);\n    });\n    function clearPlaceholder(cm) {\n        if (cm.state.placeholder) {\n            cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);\n            cm.state.placeholder = null;\n        }\n    }\n    function setPlaceholder(cm) {\n        clearPlaceholder(cm);\n        var elt = cm.state.placeholder = document.createElement(\"pre\");\n        elt.style.cssText = \"height: 0; overflow: visible\";\n        elt.style.direction = cm.getOption(\"direction\");\n        elt.className = \"CodeMirror-placeholder CodeMirror-line-like\";\n        var placeHolder = cm.getOption(\"placeholder\");\n        if (typeof placeHolder == \"string\") placeHolder = document.createTextNode(placeHolder);\n        elt.appendChild(placeHolder);\n        cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);\n    }\n    function onComposition(cm) {\n        setTimeout(function() {\n            var empty = false;\n            if (cm.lineCount() == 1) {\n                var input = cm.getInputField();\n                empty = input.nodeName == \"TEXTAREA\" ? !cm.getLine(0).length : !/[^\\u200b]/.test(input.querySelector(\".CodeMirror-line\").textContent);\n            }\n            if (empty) setPlaceholder(cm);\n            else clearPlaceholder(cm);\n        }, 20);\n    }\n    function onBlur(cm) {\n        if (isEmpty(cm)) setPlaceholder(cm);\n    }\n    function onChange(cm) {\n        var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);\n        wrapper.className = wrapper.className.replace(\" CodeMirror-empty\", \"\") + (empty ? \" CodeMirror-empty\" : \"\");\n        if (empty) setPlaceholder(cm);\n        else clearPlaceholder(cm);\n    }\n    function isEmpty(cm) {\n        return cm.lineCount() === 1 && cm.getLine(0) === \"\";\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvcGxhY2Vob2xkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsMkRBQTJEO0FBQzNELHFFQUFxRTtBQUVwRSxVQUFTQSxHQUFHO0lBQ1gsSUFBSSxJQUF1RCxFQUN6REEsSUFBSUcsbUJBQU9BLENBQUMsNkZBQXNCO1NBQy9CLEVBR2FHO0FBQ3BCLEdBQUcsU0FBU0EsV0FBVTtJQUNwQkEsWUFBV0MsWUFBWSxDQUFDLGVBQWUsSUFBSSxTQUFTQyxFQUFFLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUM5RCxJQUFJQyxPQUFPRCxPQUFPQSxPQUFPSixZQUFXTSxJQUFJO1FBQ3hDLElBQUlILE9BQU8sQ0FBQ0UsTUFBTTtZQUNoQkgsR0FBR0ssRUFBRSxDQUFDLFFBQVFDO1lBQ2ROLEdBQUdLLEVBQUUsQ0FBQyxVQUFVRTtZQUNoQlAsR0FBR0ssRUFBRSxDQUFDLFdBQVdFO1lBQ2pCVCxZQUFXTyxFQUFFLENBQUNMLEdBQUdRLGFBQWEsSUFBSSxxQkFBcUJSLEdBQUdTLEtBQUssQ0FBQ0Msa0JBQWtCLEdBQUc7Z0JBQWFDLGNBQWNYO1lBQUk7WUFDcEhPLFNBQVNQO1FBQ1gsT0FBTyxJQUFJLENBQUNDLE9BQU9FLE1BQU07WUFDdkJILEdBQUdZLEdBQUcsQ0FBQyxRQUFRTjtZQUNmTixHQUFHWSxHQUFHLENBQUMsVUFBVUw7WUFDakJQLEdBQUdZLEdBQUcsQ0FBQyxXQUFXTDtZQUNsQlQsWUFBV2MsR0FBRyxDQUFDWixHQUFHUSxhQUFhLElBQUkscUJBQXFCUixHQUFHUyxLQUFLLENBQUNDLGtCQUFrQjtZQUNuRkcsaUJBQWlCYjtZQUNqQixJQUFJYyxVQUFVZCxHQUFHZSxpQkFBaUI7WUFDbENELFFBQVFFLFNBQVMsR0FBR0YsUUFBUUUsU0FBUyxDQUFDQyxPQUFPLENBQUMscUJBQXFCO1FBQ3JFO1FBRUEsSUFBSWhCLE9BQU8sQ0FBQ0QsR0FBR2tCLFFBQVEsSUFBSVosT0FBT047SUFDcEM7SUFFQSxTQUFTYSxpQkFBaUJiLEVBQUU7UUFDMUIsSUFBSUEsR0FBR1MsS0FBSyxDQUFDVSxXQUFXLEVBQUU7WUFDeEJuQixHQUFHUyxLQUFLLENBQUNVLFdBQVcsQ0FBQ0MsVUFBVSxDQUFDQyxXQUFXLENBQUNyQixHQUFHUyxLQUFLLENBQUNVLFdBQVc7WUFDaEVuQixHQUFHUyxLQUFLLENBQUNVLFdBQVcsR0FBRztRQUN6QjtJQUNGO0lBQ0EsU0FBU0csZUFBZXRCLEVBQUU7UUFDeEJhLGlCQUFpQmI7UUFDakIsSUFBSXVCLE1BQU12QixHQUFHUyxLQUFLLENBQUNVLFdBQVcsR0FBR0ssU0FBU0MsYUFBYSxDQUFDO1FBQ3hERixJQUFJRyxLQUFLLENBQUNDLE9BQU8sR0FBRztRQUNwQkosSUFBSUcsS0FBSyxDQUFDRSxTQUFTLEdBQUc1QixHQUFHNkIsU0FBUyxDQUFDO1FBQ25DTixJQUFJUCxTQUFTLEdBQUc7UUFDaEIsSUFBSWMsY0FBYzlCLEdBQUc2QixTQUFTLENBQUM7UUFDL0IsSUFBSSxPQUFPQyxlQUFlLFVBQVVBLGNBQWNOLFNBQVNPLGNBQWMsQ0FBQ0Q7UUFDMUVQLElBQUlTLFdBQVcsQ0FBQ0Y7UUFDaEI5QixHQUFHaUMsT0FBTyxDQUFDQyxTQUFTLENBQUNDLFlBQVksQ0FBQ1osS0FBS3ZCLEdBQUdpQyxPQUFPLENBQUNDLFNBQVMsQ0FBQ0UsVUFBVTtJQUN4RTtJQUVBLFNBQVN6QixjQUFjWCxFQUFFO1FBQ3ZCcUMsV0FBVztZQUNULElBQUlDLFFBQVE7WUFDWixJQUFJdEMsR0FBR3VDLFNBQVMsTUFBTSxHQUFHO2dCQUN2QixJQUFJQyxRQUFReEMsR0FBR1EsYUFBYTtnQkFDNUI4QixRQUFRRSxNQUFNQyxRQUFRLElBQUksYUFBYSxDQUFDekMsR0FBRzBDLE9BQU8sQ0FBQyxHQUFHQyxNQUFNLEdBQ3hELENBQUMsWUFBWUMsSUFBSSxDQUFDSixNQUFNSyxhQUFhLENBQUMsb0JBQW9CQyxXQUFXO1lBQzNFO1lBQ0EsSUFBSVIsT0FBT2hCLGVBQWV0QjtpQkFDckJhLGlCQUFpQmI7UUFDeEIsR0FBRztJQUNMO0lBRUEsU0FBU00sT0FBT04sRUFBRTtRQUNoQixJQUFJK0MsUUFBUS9DLEtBQUtzQixlQUFldEI7SUFDbEM7SUFDQSxTQUFTTyxTQUFTUCxFQUFFO1FBQ2xCLElBQUljLFVBQVVkLEdBQUdlLGlCQUFpQixJQUFJdUIsUUFBUVMsUUFBUS9DO1FBQ3REYyxRQUFRRSxTQUFTLEdBQUdGLFFBQVFFLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLHFCQUFxQixNQUFPcUIsQ0FBQUEsUUFBUSxzQkFBc0IsRUFBQztRQUV6RyxJQUFJQSxPQUFPaEIsZUFBZXRCO2FBQ3JCYSxpQkFBaUJiO0lBQ3hCO0lBRUEsU0FBUytDLFFBQVEvQyxFQUFFO1FBQ2pCLE9BQU8sR0FBSXVDLFNBQVMsT0FBTyxLQUFPdkMsR0FBRzBDLE9BQU8sQ0FBQyxPQUFPO0lBQ3REO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZGlzcGxheS9wbGFjZWhvbGRlci5qcz81ZDA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC81L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24oXCJwbGFjZWhvbGRlclwiLCBcIlwiLCBmdW5jdGlvbihjbSwgdmFsLCBvbGQpIHtcbiAgICB2YXIgcHJldiA9IG9sZCAmJiBvbGQgIT0gQ29kZU1pcnJvci5Jbml0O1xuICAgIGlmICh2YWwgJiYgIXByZXYpIHtcbiAgICAgIGNtLm9uKFwiYmx1clwiLCBvbkJsdXIpO1xuICAgICAgY20ub24oXCJjaGFuZ2VcIiwgb25DaGFuZ2UpO1xuICAgICAgY20ub24oXCJzd2FwRG9jXCIsIG9uQ2hhbmdlKTtcbiAgICAgIENvZGVNaXJyb3Iub24oY20uZ2V0SW5wdXRGaWVsZCgpLCBcImNvbXBvc2l0aW9udXBkYXRlXCIsIGNtLnN0YXRlLnBsYWNlaG9sZGVyQ29tcG9zZSA9IGZ1bmN0aW9uKCkgeyBvbkNvbXBvc2l0aW9uKGNtKSB9KVxuICAgICAgb25DaGFuZ2UoY20pO1xuICAgIH0gZWxzZSBpZiAoIXZhbCAmJiBwcmV2KSB7XG4gICAgICBjbS5vZmYoXCJibHVyXCIsIG9uQmx1cik7XG4gICAgICBjbS5vZmYoXCJjaGFuZ2VcIiwgb25DaGFuZ2UpO1xuICAgICAgY20ub2ZmKFwic3dhcERvY1wiLCBvbkNoYW5nZSk7XG4gICAgICBDb2RlTWlycm9yLm9mZihjbS5nZXRJbnB1dEZpZWxkKCksIFwiY29tcG9zaXRpb251cGRhdGVcIiwgY20uc3RhdGUucGxhY2Vob2xkZXJDb21wb3NlKVxuICAgICAgY2xlYXJQbGFjZWhvbGRlcihjbSk7XG4gICAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IHdyYXBwZXIuY2xhc3NOYW1lLnJlcGxhY2UoXCIgQ29kZU1pcnJvci1lbXB0eVwiLCBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAodmFsICYmICFjbS5oYXNGb2N1cygpKSBvbkJsdXIoY20pO1xuICB9KTtcblxuICBmdW5jdGlvbiBjbGVhclBsYWNlaG9sZGVyKGNtKSB7XG4gICAgaWYgKGNtLnN0YXRlLnBsYWNlaG9sZGVyKSB7XG4gICAgICBjbS5zdGF0ZS5wbGFjZWhvbGRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtLnN0YXRlLnBsYWNlaG9sZGVyKTtcbiAgICAgIGNtLnN0YXRlLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0UGxhY2Vob2xkZXIoY20pIHtcbiAgICBjbGVhclBsYWNlaG9sZGVyKGNtKTtcbiAgICB2YXIgZWx0ID0gY20uc3RhdGUucGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgIGVsdC5zdHlsZS5jc3NUZXh0ID0gXCJoZWlnaHQ6IDA7IG92ZXJmbG93OiB2aXNpYmxlXCI7XG4gICAgZWx0LnN0eWxlLmRpcmVjdGlvbiA9IGNtLmdldE9wdGlvbihcImRpcmVjdGlvblwiKTtcbiAgICBlbHQuY2xhc3NOYW1lID0gXCJDb2RlTWlycm9yLXBsYWNlaG9sZGVyIENvZGVNaXJyb3ItbGluZS1saWtlXCI7XG4gICAgdmFyIHBsYWNlSG9sZGVyID0gY20uZ2V0T3B0aW9uKFwicGxhY2Vob2xkZXJcIilcbiAgICBpZiAodHlwZW9mIHBsYWNlSG9sZGVyID09IFwic3RyaW5nXCIpIHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGxhY2VIb2xkZXIpXG4gICAgZWx0LmFwcGVuZENoaWxkKHBsYWNlSG9sZGVyKVxuICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShlbHQsIGNtLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db21wb3NpdGlvbihjbSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW1wdHkgPSBmYWxzZVxuICAgICAgaWYgKGNtLmxpbmVDb3VudCgpID09IDEpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY20uZ2V0SW5wdXRGaWVsZCgpXG4gICAgICAgIGVtcHR5ID0gaW5wdXQubm9kZU5hbWUgPT0gXCJURVhUQVJFQVwiID8gIWNtLmdldExpbmUoMCkubGVuZ3RoXG4gICAgICAgICAgOiAhL1teXFx1MjAwYl0vLnRlc3QoaW5wdXQucXVlcnlTZWxlY3RvcihcIi5Db2RlTWlycm9yLWxpbmVcIikudGV4dENvbnRlbnQpXG4gICAgICB9XG4gICAgICBpZiAoZW1wdHkpIHNldFBsYWNlaG9sZGVyKGNtKVxuICAgICAgZWxzZSBjbGVhclBsYWNlaG9sZGVyKGNtKVxuICAgIH0sIDIwKVxuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVyKGNtKSB7XG4gICAgaWYgKGlzRW1wdHkoY20pKSBzZXRQbGFjZWhvbGRlcihjbSk7XG4gIH1cbiAgZnVuY3Rpb24gb25DaGFuZ2UoY20pIHtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCksIGVtcHR5ID0gaXNFbXB0eShjbSk7XG4gICAgd3JhcHBlci5jbGFzc05hbWUgPSB3cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKFwiIENvZGVNaXJyb3ItZW1wdHlcIiwgXCJcIikgKyAoZW1wdHkgPyBcIiBDb2RlTWlycm9yLWVtcHR5XCIgOiBcIlwiKTtcblxuICAgIGlmIChlbXB0eSkgc2V0UGxhY2Vob2xkZXIoY20pO1xuICAgIGVsc2UgY2xlYXJQbGFjZWhvbGRlcihjbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5KGNtKSB7XG4gICAgcmV0dXJuIChjbS5saW5lQ291bnQoKSA9PT0gMSkgJiYgKGNtLmdldExpbmUoMCkgPT09IFwiXCIpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkZWZpbmVPcHRpb24iLCJjbSIsInZhbCIsIm9sZCIsInByZXYiLCJJbml0Iiwib24iLCJvbkJsdXIiLCJvbkNoYW5nZSIsImdldElucHV0RmllbGQiLCJzdGF0ZSIsInBsYWNlaG9sZGVyQ29tcG9zZSIsIm9uQ29tcG9zaXRpb24iLCJvZmYiLCJjbGVhclBsYWNlaG9sZGVyIiwid3JhcHBlciIsImdldFdyYXBwZXJFbGVtZW50IiwiY2xhc3NOYW1lIiwicmVwbGFjZSIsImhhc0ZvY3VzIiwicGxhY2Vob2xkZXIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzZXRQbGFjZWhvbGRlciIsImVsdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsImRpcmVjdGlvbiIsImdldE9wdGlvbiIsInBsYWNlSG9sZGVyIiwiY3JlYXRlVGV4dE5vZGUiLCJhcHBlbmRDaGlsZCIsImRpc3BsYXkiLCJsaW5lU3BhY2UiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwic2V0VGltZW91dCIsImVtcHR5IiwibGluZUNvdW50IiwiaW5wdXQiLCJub2RlTmFtZSIsImdldExpbmUiLCJsZW5ndGgiLCJ0ZXN0IiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiaXNFbXB0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/addon/display/placeholder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/addon/edit/continuelist.js":
/*!************************************************************!*\
  !*** ./node_modules/codemirror/addon/edit/continuelist.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    var listRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]\\s|[*+-]\\s|(\\d+)([.)]))(\\s*)/, emptyListRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]|[*+-]|(\\d+)[.)])(\\s*)$/, unorderedListRE = /[*+-]\\s/;\n    CodeMirror1.commands.newlineAndIndentContinueMarkdownList = function(cm) {\n        if (cm.getOption(\"disableInput\")) return CodeMirror1.Pass;\n        var ranges = cm.listSelections(), replacements = [];\n        for(var i = 0; i < ranges.length; i++){\n            var pos = ranges[i].head;\n            // If we're not in Markdown mode, fall back to normal newlineAndIndent\n            var eolState = cm.getStateAfter(pos.line);\n            var inner = CodeMirror1.innerMode(cm.getMode(), eolState);\n            if (inner.mode.name !== \"markdown\" && inner.mode.helperType !== \"markdown\") {\n                cm.execCommand(\"newlineAndIndent\");\n                return;\n            } else {\n                eolState = inner.state;\n            }\n            var inList = eolState.list !== false;\n            var inQuote = eolState.quote !== 0;\n            var line = cm.getLine(pos.line), match = listRE.exec(line);\n            var cursorBeforeBullet = /^\\s*$/.test(line.slice(0, pos.ch));\n            if (!ranges[i].empty() || !inList && !inQuote || !match || cursorBeforeBullet) {\n                cm.execCommand(\"newlineAndIndent\");\n                return;\n            }\n            if (emptyListRE.test(line)) {\n                var endOfQuote = inQuote && />\\s*$/.test(line);\n                var endOfList = !/>\\s*$/.test(line);\n                if (endOfQuote || endOfList) cm.replaceRange(\"\", {\n                    line: pos.line,\n                    ch: 0\n                }, {\n                    line: pos.line,\n                    ch: pos.ch + 1\n                });\n                replacements[i] = \"\\n\";\n            } else {\n                var indent = match[1], after = match[5];\n                var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(\">\") >= 0);\n                var bullet = numbered ? parseInt(match[3], 10) + 1 + match[4] : match[2].replace(\"x\", \" \");\n                replacements[i] = \"\\n\" + indent + bullet + after;\n                if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);\n            }\n        }\n        cm.replaceSelections(replacements);\n    };\n    // Auto-updating Markdown list numbers when a new item is added to the\n    // middle of a list\n    function incrementRemainingMarkdownListNumbers(cm, pos) {\n        var startLine = pos.line, lookAhead = 0, skipCount = 0;\n        var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];\n        do {\n            lookAhead += 1;\n            var nextLineNumber = startLine + lookAhead;\n            var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);\n            if (nextItem) {\n                var nextIndent = nextItem[1];\n                var newNumber = parseInt(startItem[3], 10) + lookAhead - skipCount;\n                var nextNumber = parseInt(nextItem[3], 10), itemNumber = nextNumber;\n                if (startIndent === nextIndent && !isNaN(nextNumber)) {\n                    if (newNumber === nextNumber) itemNumber = nextNumber + 1;\n                    if (newNumber > nextNumber) itemNumber = newNumber + 1;\n                    cm.replaceRange(nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]), {\n                        line: nextLineNumber,\n                        ch: 0\n                    }, {\n                        line: nextLineNumber,\n                        ch: nextLine.length\n                    });\n                } else {\n                    if (startIndent.length > nextIndent.length) return;\n                    // This doesn't run if the next line immediately indents, as it is\n                    // not clear of the users intention (new indented item or same level)\n                    if (startIndent.length < nextIndent.length && lookAhead === 1) return;\n                    skipCount += 1;\n                }\n            }\n        }while (nextItem);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2VkaXQvY29udGludWVsaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLDJEQUEyRDtBQUMzRCxxRUFBcUU7QUFFcEUsVUFBU0EsR0FBRztJQUNYLElBQUksSUFBdUQsRUFDekRBLElBQUlHLG1CQUFPQSxDQUFDLDZGQUFzQjtTQUMvQixFQUdhRztBQUNwQixHQUFHLFNBQVNBLFdBQVU7SUFDcEI7SUFFQSxJQUFJQyxTQUFTLDREQUNUQyxjQUFjLHVEQUNkQyxrQkFBa0I7SUFFdEJILFlBQVdJLFFBQVEsQ0FBQ0Msb0NBQW9DLEdBQUcsU0FBU0MsRUFBRTtRQUNwRSxJQUFJQSxHQUFHQyxTQUFTLENBQUMsaUJBQWlCLE9BQU9QLFlBQVdRLElBQUk7UUFDeEQsSUFBSUMsU0FBU0gsR0FBR0ksY0FBYyxJQUFJQyxlQUFlLEVBQUU7UUFDbkQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE9BQU9JLE1BQU0sRUFBRUQsSUFBSztZQUN0QyxJQUFJRSxNQUFNTCxNQUFNLENBQUNHLEVBQUUsQ0FBQ0csSUFBSTtZQUV4QixzRUFBc0U7WUFDdEUsSUFBSUMsV0FBV1YsR0FBR1csYUFBYSxDQUFDSCxJQUFJSSxJQUFJO1lBQ3hDLElBQUlDLFFBQVFuQixZQUFXb0IsU0FBUyxDQUFDZCxHQUFHZSxPQUFPLElBQUlMO1lBQy9DLElBQUlHLE1BQU1HLElBQUksQ0FBQ0MsSUFBSSxLQUFLLGNBQWNKLE1BQU1HLElBQUksQ0FBQ0UsVUFBVSxLQUFLLFlBQVk7Z0JBQzFFbEIsR0FBR21CLFdBQVcsQ0FBQztnQkFDZjtZQUNGLE9BQU87Z0JBQ0xULFdBQVdHLE1BQU1PLEtBQUs7WUFDeEI7WUFFQSxJQUFJQyxTQUFTWCxTQUFTWSxJQUFJLEtBQUs7WUFDL0IsSUFBSUMsVUFBVWIsU0FBU2MsS0FBSyxLQUFLO1lBRWpDLElBQUlaLE9BQU9aLEdBQUd5QixPQUFPLENBQUNqQixJQUFJSSxJQUFJ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MUMsTUFBTSxHQUFHOEMsV0FBVzlDLE1BQU0sRUFBRTtvQkFDNUMsa0VBQWtFO29CQUNsRSxxRUFBcUU7b0JBQ3JFLElBQUksWUFBYUEsTUFBTSxHQUFHOEMsV0FBVzlDLE1BQU0sSUFBTXVDLGNBQWMsR0FBSTtvQkFDbkVDLGFBQWE7Z0JBQ2Y7WUFDRjtRQUNGLFFBQVNLLFVBQVU7SUFDckI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9lZGl0L2NvbnRpbnVlbGlzdC5qcz80OTEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC81L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGxpc3RSRSA9IC9eKFxccyopKD5bPiBdKnxbKistXSBcXFtbeCBdXFxdXFxzfFsqKy1dXFxzfChcXGQrKShbLildKSkoXFxzKikvLFxuICAgICAgZW1wdHlMaXN0UkUgPSAvXihcXHMqKSg+Wz4gXSp8WyorLV0gXFxbW3ggXVxcXXxbKistXXwoXFxkKylbLildKShcXHMqKSQvLFxuICAgICAgdW5vcmRlcmVkTGlzdFJFID0gL1sqKy1dXFxzLztcblxuICBDb2RlTWlycm9yLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnRDb250aW51ZU1hcmtkb3duTGlzdCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgaWYgKGNtLmdldE9wdGlvbihcImRpc2FibGVJbnB1dFwiKSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgcmVwbGFjZW1lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSByYW5nZXNbaV0uaGVhZDtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IGluIE1hcmtkb3duIG1vZGUsIGZhbGwgYmFjayB0byBub3JtYWwgbmV3bGluZUFuZEluZGVudFxuICAgICAgdmFyIGVvbFN0YXRlID0gY20uZ2V0U3RhdGVBZnRlcihwb3MubGluZSk7XG4gICAgICB2YXIgaW5uZXIgPSBDb2RlTWlycm9yLmlubmVyTW9kZShjbS5nZXRNb2RlKCksIGVvbFN0YXRlKTtcbiAgICAgIGlmIChpbm5lci5tb2RlLm5hbWUgIT09IFwibWFya2Rvd25cIiAmJiBpbm5lci5tb2RlLmhlbHBlclR5cGUgIT09IFwibWFya2Rvd25cIikge1xuICAgICAgICBjbS5leGVjQ29tbWFuZChcIm5ld2xpbmVBbmRJbmRlbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVvbFN0YXRlID0gaW5uZXIuc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbkxpc3QgPSBlb2xTdGF0ZS5saXN0ICE9PSBmYWxzZTtcbiAgICAgIHZhciBpblF1b3RlID0gZW9sU3RhdGUucXVvdGUgIT09IDA7XG5cbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShwb3MubGluZSksIG1hdGNoID0gbGlzdFJFLmV4ZWMobGluZSk7XG4gICAgICB2YXIgY3Vyc29yQmVmb3JlQnVsbGV0ID0gL15cXHMqJC8udGVzdChsaW5lLnNsaWNlKDAsIHBvcy5jaCkpO1xuICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSB8fCAoIWluTGlzdCAmJiAhaW5RdW90ZSkgfHwgIW1hdGNoIHx8IGN1cnNvckJlZm9yZUJ1bGxldCkge1xuICAgICAgICBjbS5leGVjQ29tbWFuZChcIm5ld2xpbmVBbmRJbmRlbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbXB0eUxpc3RSRS50ZXN0KGxpbmUpKSB7XG4gICAgICAgIHZhciBlbmRPZlF1b3RlID0gaW5RdW90ZSAmJiAvPlxccyokLy50ZXN0KGxpbmUpXG4gICAgICAgIHZhciBlbmRPZkxpc3QgPSAhLz5cXHMqJC8udGVzdChsaW5lKVxuICAgICAgICBpZiAoZW5kT2ZRdW90ZSB8fCBlbmRPZkxpc3QpIGNtLnJlcGxhY2VSYW5nZShcIlwiLCB7XG4gICAgICAgICAgbGluZTogcG9zLmxpbmUsIGNoOiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBsaW5lOiBwb3MubGluZSwgY2g6IHBvcy5jaCArIDFcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxhY2VtZW50c1tpXSA9IFwiXFxuXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5kZW50ID0gbWF0Y2hbMV0sIGFmdGVyID0gbWF0Y2hbNV07XG4gICAgICAgIHZhciBudW1iZXJlZCA9ICEodW5vcmRlcmVkTGlzdFJFLnRlc3QobWF0Y2hbMl0pIHx8IG1hdGNoWzJdLmluZGV4T2YoXCI+XCIpID49IDApO1xuICAgICAgICB2YXIgYnVsbGV0ID0gbnVtYmVyZWQgPyAocGFyc2VJbnQobWF0Y2hbM10sIDEwKSArIDEpICsgbWF0Y2hbNF0gOiBtYXRjaFsyXS5yZXBsYWNlKFwieFwiLCBcIiBcIik7XG4gICAgICAgIHJlcGxhY2VtZW50c1tpXSA9IFwiXFxuXCIgKyBpbmRlbnQgKyBidWxsZXQgKyBhZnRlcjtcblxuICAgICAgICBpZiAobnVtYmVyZWQpIGluY3JlbWVudFJlbWFpbmluZ01hcmtkb3duTGlzdE51bWJlcnMoY20sIHBvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY20ucmVwbGFjZVNlbGVjdGlvbnMocmVwbGFjZW1lbnRzKTtcbiAgfTtcblxuICAvLyBBdXRvLXVwZGF0aW5nIE1hcmtkb3duIGxpc3QgbnVtYmVycyB3aGVuIGEgbmV3IGl0ZW0gaXMgYWRkZWQgdG8gdGhlXG4gIC8vIG1pZGRsZSBvZiBhIGxpc3RcbiAgZnVuY3Rpb24gaW5jcmVtZW50UmVtYWluaW5nTWFya2Rvd25MaXN0TnVtYmVycyhjbSwgcG9zKSB7XG4gICAgdmFyIHN0YXJ0TGluZSA9IHBvcy5saW5lLCBsb29rQWhlYWQgPSAwLCBza2lwQ291bnQgPSAwO1xuICAgIHZhciBzdGFydEl0ZW0gPSBsaXN0UkUuZXhlYyhjbS5nZXRMaW5lKHN0YXJ0TGluZSkpLCBzdGFydEluZGVudCA9IHN0YXJ0SXRlbVsxXTtcblxuICAgIGRvIHtcbiAgICAgIGxvb2tBaGVhZCArPSAxO1xuICAgICAgdmFyIG5leHRMaW5lTnVtYmVyID0gc3RhcnRMaW5lICsgbG9va0FoZWFkO1xuICAgICAgdmFyIG5leHRMaW5lID0gY20uZ2V0TGluZShuZXh0TGluZU51bWJlciksIG5leHRJdGVtID0gbGlzdFJFLmV4ZWMobmV4dExpbmUpO1xuXG4gICAgICBpZiAobmV4dEl0ZW0pIHtcbiAgICAgICAgdmFyIG5leHRJbmRlbnQgPSBuZXh0SXRlbVsxXTtcbiAgICAgICAgdmFyIG5ld051bWJlciA9IChwYXJzZUludChzdGFydEl0ZW1bM10sIDEwKSArIGxvb2tBaGVhZCAtIHNraXBDb3VudCk7XG4gICAgICAgIHZhciBuZXh0TnVtYmVyID0gKHBhcnNlSW50KG5leHRJdGVtWzNdLCAxMCkpLCBpdGVtTnVtYmVyID0gbmV4dE51bWJlcjtcblxuICAgICAgICBpZiAoc3RhcnRJbmRlbnQgPT09IG5leHRJbmRlbnQgJiYgIWlzTmFOKG5leHROdW1iZXIpKSB7XG4gICAgICAgICAgaWYgKG5ld051bWJlciA9PT0gbmV4dE51bWJlcikgaXRlbU51bWJlciA9IG5leHROdW1iZXIgKyAxO1xuICAgICAgICAgIGlmIChuZXdOdW1iZXIgPiBuZXh0TnVtYmVyKSBpdGVtTnVtYmVyID0gbmV3TnVtYmVyICsgMTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXG4gICAgICAgICAgICBuZXh0TGluZS5yZXBsYWNlKGxpc3RSRSwgbmV4dEluZGVudCArIGl0ZW1OdW1iZXIgKyBuZXh0SXRlbVs0XSArIG5leHRJdGVtWzVdKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsaW5lOiBuZXh0TGluZU51bWJlciwgY2g6IDBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBsaW5lOiBuZXh0TGluZU51bWJlciwgY2g6IG5leHRMaW5lLmxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdGFydEluZGVudC5sZW5ndGggPiBuZXh0SW5kZW50Lmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgIC8vIFRoaXMgZG9lc24ndCBydW4gaWYgdGhlIG5leHQgbGluZSBpbW1lZGlhdGVseSBpbmRlbnRzLCBhcyBpdCBpc1xuICAgICAgICAgIC8vIG5vdCBjbGVhciBvZiB0aGUgdXNlcnMgaW50ZW50aW9uIChuZXcgaW5kZW50ZWQgaXRlbSBvciBzYW1lIGxldmVsKVxuICAgICAgICAgIGlmICgoc3RhcnRJbmRlbnQubGVuZ3RoIDwgbmV4dEluZGVudC5sZW5ndGgpICYmIChsb29rQWhlYWQgPT09IDEpKSByZXR1cm47XG4gICAgICAgICAgc2tpcENvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChuZXh0SXRlbSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsImxpc3RSRSIsImVtcHR5TGlzdFJFIiwidW5vcmRlcmVkTGlzdFJFIiwiY29tbWFuZHMiLCJuZXdsaW5lQW5kSW5kZW50Q29udGludWVNYXJrZG93bkxpc3QiLCJjbSIsImdldE9wdGlvbiIsIlBhc3MiLCJyYW5nZXMiLCJsaXN0U2VsZWN0aW9ucyIsInJlcGxhY2VtZW50cyIsImkiLCJsZW5ndGgiLCJwb3MiLCJoZWFkIiwiZW9sU3RhdGUiLCJnZXRTdGF0ZUFmdGVyIiwibGluZSIsImlubmVyIiwiaW5uZXJNb2RlIiwiZ2V0TW9kZSIsIm1vZGUiLCJuYW1lIiwiaGVscGVyVHlwZSIsImV4ZWNDb21tYW5kIiwic3RhdGUiLCJpbkxpc3QiLCJsaXN0IiwiaW5RdW90ZSIsInF1b3RlIiwiZ2V0TGluZSIsIm1hdGNoIiwiZXhlYyIsImN1cnNvckJlZm9yZUJ1bGxldCIsInRlc3QiLCJzbGljZSIsImNoIiwiZW1wdHkiLCJlbmRPZlF1b3RlIiwiZW5kT2ZMaXN0IiwicmVwbGFjZVJhbmdlIiwiaW5kZW50IiwiYWZ0ZXIiLCJudW1iZXJlZCIsImluZGV4T2YiLCJidWxsZXQiLCJwYXJzZUludCIsInJlcGxhY2UiLCJpbmNyZW1lbnRSZW1haW5pbmdNYXJrZG93bkxpc3ROdW1iZXJzIiwicmVwbGFjZVNlbGVjdGlvbnMiLCJzdGFydExpbmUiLCJsb29rQWhlYWQiLCJza2lwQ291bnQiLCJzdGFydEl0ZW0iLCJzdGFydEluZGVudCIsIm5leHRMaW5lTnVtYmVyIiwibmV4dExpbmUiLCJuZXh0SXRlbSIsIm5leHRJbmRlbnQiLCJuZXdOdW1iZXIiLCJuZXh0TnVtYmVyIiwiaXRlbU51bWJlciIsImlzTmFOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/addon/edit/continuelist.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/addon/mode/overlay.js":
/*!*******************************************************!*\
  !*** ./node_modules/codemirror/addon/mode/overlay.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n// Utility function that allows modes to be combined. The mode given\n// as the base argument takes care of most of the normal mode\n// functionality, but a second (typically simple) mode is used, which\n// can override the style of text. Both modes get to parse all of the\n// text, but when both assign a non-null style to a piece of code, the\n// overlay wins, unless the combine argument was true and not overridden,\n// or state.overlay.combineTokens was true, in which case the styles are\n// combined.\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    CodeMirror1.overlayMode = function(base, overlay, combine) {\n        return {\n            startState: function() {\n                return {\n                    base: CodeMirror1.startState(base),\n                    overlay: CodeMirror1.startState(overlay),\n                    basePos: 0,\n                    baseCur: null,\n                    overlayPos: 0,\n                    overlayCur: null,\n                    streamSeen: null\n                };\n            },\n            copyState: function(state) {\n                return {\n                    base: CodeMirror1.copyState(base, state.base),\n                    overlay: CodeMirror1.copyState(overlay, state.overlay),\n                    basePos: state.basePos,\n                    baseCur: null,\n                    overlayPos: state.overlayPos,\n                    overlayCur: null\n                };\n            },\n            token: function(stream, state) {\n                if (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) {\n                    state.streamSeen = stream;\n                    state.basePos = state.overlayPos = stream.start;\n                }\n                if (stream.start == state.basePos) {\n                    state.baseCur = base.token(stream, state.base);\n                    state.basePos = stream.pos;\n                }\n                if (stream.start == state.overlayPos) {\n                    stream.pos = stream.start;\n                    state.overlayCur = overlay.token(stream, state.overlay);\n                    state.overlayPos = stream.pos;\n                }\n                stream.pos = Math.min(state.basePos, state.overlayPos);\n                // state.overlay.combineTokens always takes precedence over combine,\n                // unless set to null\n                if (state.overlayCur == null) return state.baseCur;\n                else if (state.baseCur != null && state.overlay.combineTokens || combine && state.overlay.combineTokens == null) return state.baseCur + \" \" + state.overlayCur;\n                else return state.overlayCur;\n            },\n            indent: base.indent && function(state, textAfter, line) {\n                return base.indent(state.base, textAfter, line);\n            },\n            electricChars: base.electricChars,\n            innerMode: function(state) {\n                return {\n                    state: state.base,\n                    mode: base\n                };\n            },\n            blankLine: function(state) {\n                var baseToken, overlayToken;\n                if (base.blankLine) baseToken = base.blankLine(state.base);\n                if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);\n                return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + \" \" + overlayToken : overlayToken;\n            }\n        };\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL21vZGUvb3ZlcmxheS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBRXJFLG9FQUFvRTtBQUNwRSw2REFBNkQ7QUFDN0QscUVBQXFFO0FBQ3JFLHFFQUFxRTtBQUNyRSxzRUFBc0U7QUFDdEUseUVBQXlFO0FBQ3pFLHdFQUF3RTtBQUN4RSxZQUFZO0FBRVgsVUFBU0EsR0FBRztJQUNYLElBQUksSUFBdUQsRUFDekRBLElBQUlHLG1CQUFPQSxDQUFDLDZGQUFzQjtTQUMvQixFQUdhRztBQUNwQixHQUFHLFNBQVNBLFdBQVU7SUFDdEI7SUFFQUEsWUFBV0MsV0FBVyxHQUFHLFNBQVNDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxPQUFPO1FBQ3RELE9BQU87WUFDTEMsWUFBWTtnQkFDVixPQUFPO29CQUNMSCxNQUFNRixZQUFXSyxVQUFVLENBQUNIO29CQUM1QkMsU0FBU0gsWUFBV0ssVUFBVSxDQUFDRjtvQkFDL0JHLFNBQVM7b0JBQUdDLFNBQVM7b0JBQ3JCQyxZQUFZO29CQUFHQyxZQUFZO29CQUMzQkMsWUFBWTtnQkFDZDtZQUNGO1lBQ0FDLFdBQVcsU0FBU0MsS0FBSztnQkFDdkIsT0FBTztvQkFDTFYsTUFBTUYsWUFBV1csU0FBUyxDQUFDVCxNQUFNVSxNQUFNVixJQUFJO29CQUMzQ0MsU0FBU0gsWUFBV1csU0FBUyxDQUFDUixTQUFTUyxNQUFNVCxPQUFPO29CQUNwREcsU0FBU00sTUFBTU4sT0FBTztvQkFBRUMsU0FBUztvQkFDakNDLFlBQVlJLE1BQU1KLFVBQVU7b0JBQUVDLFlBQVk7Z0JBQzVDO1lBQ0Y7WUFFQUksT0FBTyxTQUFTQyxNQUFNLEVBQUVGLEtBQUs7Z0JBQzNCLElBQUlFLFVBQVVGLE1BQU1GLFVBQVUsSUFDMUJLLEtBQUtDLEdBQUcsQ0FBQ0osTUFBTU4sT0FBTyxFQUFFTSxNQUFNSixVQUFVLElBQUlNLE9BQU9HLEtBQUssRUFBRTtvQkFDNURMLE1BQU1GLFVBQVUsR0FBR0k7b0JBQ25CRixNQUFNTixPQUFPLEdBQUdNLE1BQU1KLFVBQVUsR0FBR00sT0FBT0csS0FBSztnQkFDakQ7Z0JBRUEsSUFBSUgsT0FBT0csS0FBSyxJQUFJTCxNQUFNTixPQUFPLEVBQUU7b0JBQ2pDTSxNQUFNTCxPQUFPLEdBQUdMLEtBQUtXLEtBQUssQ0FBQ0MsUUFBUUYsTUFBTVYsSUFBSTtvQkFDN0NVLE1BQU1OLE9BQU8sR0FBR1EsT0FBT0ksR0FBRztnQkFDNUI7Z0JBQ0EsSUFBSUosT0FBT0csS0FBSyxJQUFJTCxNQUFNSixVQUFVLEVBQUU7b0JBQ3BDTSxPQUFPSSxHQUFHLEdBQUdKLE9BQU9HLEtBQUs7b0JBQ3pCTCxNQUFNSCxVQUFVLEdBQUdOLFFBQVFVLEtBQUssQ0FBQ0MsUUFBUUYsTUFBTVQsT0FBTztvQkFDdERTLE1BQU1KLFVBQVUsR0FBR00sT0FBT0ksR0FBRztnQkFDL0I7Z0JBQ0FKLE9BQU9JLEdBQUcsR0FBR0gsS0FBS0MsR0FBRyxDQUFDSixNQUFNTixPQUFPLEVBQUVNLE1BQU1KLFVBQVU7Z0JBRXJELG9FQUFvRTtnQkFDcEUscUJBQXFCO2dCQUNyQixJQUFJSSxNQUFNSCxVQUFVLElBQUksTUFBTSxPQUFPRyxNQUFNTCxPQUFPO3FCQUM3QyxJQUFJSyxNQUFNTCxPQUFPLElBQUksUUFDakJLLE1BQU1ULE9BQU8sQ0FBQ2dCLGFBQWEsSUFDM0JmLFdBQVdRLE1BQU1ULE9BQU8sQ0FBQ2dCLGFBQWEsSUFBSSxNQUNqRCxPQUFPUCxNQUFNTCxPQUFPLEdBQUcsTUFBTUssTUFBTUgsVUFBVTtxQkFDMUMsT0FBT0csTUFBTUgsVUFBVTtZQUM5QjtZQUVBVyxRQUFRbEIsS0FBS2tCLE1BQU0sSUFBSSxTQUFTUixLQUFLLEVBQUVTLFNBQVMsRUFBRUMsSUFBSTtnQkFDcEQsT0FBT3BCLEtBQUtrQixNQUFNLENBQUNSLE1BQU1WLElBQUksRUFBRW1CLFdBQVdDO1lBQzVDO1lBQ0FDLGVBQWVyQixLQUFLcUIsYUFBYTtZQUVqQ0MsV0FBVyxTQUFTWixLQUFLO2dCQUFJLE9BQU87b0JBQUNBLE9BQU9BLE1BQU1WLElBQUk7b0JBQUV1QixNQUFNdkI7Z0JBQUk7WUFBRztZQUVyRXdCLFdBQVcsU0FBU2QsS0FBSztnQkFDdkIsSUFBSWUsV0FBV0M7Z0JBQ2YsSUFBSTFCLEtBQUt3QixTQUFTLEVBQUVDLFlBQVl6QixLQUFLd0IsU0FBUyxDQUFDZCxNQUFNVixJQUFJO2dCQUN6RCxJQUFJQyxRQUFRdUIsU0FBUyxFQUFFRSxlQUFlekIsUUFBUXVCLFNBQVMsQ0FBQ2QsTUFBTVQsT0FBTztnQkFFckUsT0FBT3lCLGdCQUFnQixPQUNyQkQsWUFDQ3ZCLFdBQVd1QixhQUFhLE9BQU9BLFlBQVksTUFBTUMsZUFBZUE7WUFDckU7UUFDRjtJQUNGO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vbW9kZS9vdmVybGF5LmpzPzczZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0LzUvTElDRU5TRVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgYWxsb3dzIG1vZGVzIHRvIGJlIGNvbWJpbmVkLiBUaGUgbW9kZSBnaXZlblxuLy8gYXMgdGhlIGJhc2UgYXJndW1lbnQgdGFrZXMgY2FyZSBvZiBtb3N0IG9mIHRoZSBub3JtYWwgbW9kZVxuLy8gZnVuY3Rpb25hbGl0eSwgYnV0IGEgc2Vjb25kICh0eXBpY2FsbHkgc2ltcGxlKSBtb2RlIGlzIHVzZWQsIHdoaWNoXG4vLyBjYW4gb3ZlcnJpZGUgdGhlIHN0eWxlIG9mIHRleHQuIEJvdGggbW9kZXMgZ2V0IHRvIHBhcnNlIGFsbCBvZiB0aGVcbi8vIHRleHQsIGJ1dCB3aGVuIGJvdGggYXNzaWduIGEgbm9uLW51bGwgc3R5bGUgdG8gYSBwaWVjZSBvZiBjb2RlLCB0aGVcbi8vIG92ZXJsYXkgd2lucywgdW5sZXNzIHRoZSBjb21iaW5lIGFyZ3VtZW50IHdhcyB0cnVlIGFuZCBub3Qgb3ZlcnJpZGRlbixcbi8vIG9yIHN0YXRlLm92ZXJsYXkuY29tYmluZVRva2VucyB3YXMgdHJ1ZSwgaW4gd2hpY2ggY2FzZSB0aGUgc3R5bGVzIGFyZVxuLy8gY29tYmluZWQuXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5vdmVybGF5TW9kZSA9IGZ1bmN0aW9uKGJhc2UsIG92ZXJsYXksIGNvbWJpbmUpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShiYXNlKSxcbiAgICAgICAgb3ZlcmxheTogQ29kZU1pcnJvci5zdGFydFN0YXRlKG92ZXJsYXkpLFxuICAgICAgICBiYXNlUG9zOiAwLCBiYXNlQ3VyOiBudWxsLFxuICAgICAgICBvdmVybGF5UG9zOiAwLCBvdmVybGF5Q3VyOiBudWxsLFxuICAgICAgICBzdHJlYW1TZWVuOiBudWxsXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTogQ29kZU1pcnJvci5jb3B5U3RhdGUoYmFzZSwgc3RhdGUuYmFzZSksXG4gICAgICAgIG92ZXJsYXk6IENvZGVNaXJyb3IuY29weVN0YXRlKG92ZXJsYXksIHN0YXRlLm92ZXJsYXkpLFxuICAgICAgICBiYXNlUG9zOiBzdGF0ZS5iYXNlUG9zLCBiYXNlQ3VyOiBudWxsLFxuICAgICAgICBvdmVybGF5UG9zOiBzdGF0ZS5vdmVybGF5UG9zLCBvdmVybGF5Q3VyOiBudWxsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbSAhPSBzdGF0ZS5zdHJlYW1TZWVuIHx8XG4gICAgICAgICAgTWF0aC5taW4oc3RhdGUuYmFzZVBvcywgc3RhdGUub3ZlcmxheVBvcykgPCBzdHJlYW0uc3RhcnQpIHtcbiAgICAgICAgc3RhdGUuc3RyZWFtU2VlbiA9IHN0cmVhbTtcbiAgICAgICAgc3RhdGUuYmFzZVBvcyA9IHN0YXRlLm92ZXJsYXlQb3MgPSBzdHJlYW0uc3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0uc3RhcnQgPT0gc3RhdGUuYmFzZVBvcykge1xuICAgICAgICBzdGF0ZS5iYXNlQ3VyID0gYmFzZS50b2tlbihzdHJlYW0sIHN0YXRlLmJhc2UpO1xuICAgICAgICBzdGF0ZS5iYXNlUG9zID0gc3RyZWFtLnBvcztcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uc3RhcnQgPT0gc3RhdGUub3ZlcmxheVBvcykge1xuICAgICAgICBzdHJlYW0ucG9zID0gc3RyZWFtLnN0YXJ0O1xuICAgICAgICBzdGF0ZS5vdmVybGF5Q3VyID0gb3ZlcmxheS50b2tlbihzdHJlYW0sIHN0YXRlLm92ZXJsYXkpO1xuICAgICAgICBzdGF0ZS5vdmVybGF5UG9zID0gc3RyZWFtLnBvcztcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5wb3MgPSBNYXRoLm1pbihzdGF0ZS5iYXNlUG9zLCBzdGF0ZS5vdmVybGF5UG9zKTtcblxuICAgICAgLy8gc3RhdGUub3ZlcmxheS5jb21iaW5lVG9rZW5zIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29tYmluZSxcbiAgICAgIC8vIHVubGVzcyBzZXQgdG8gbnVsbFxuICAgICAgaWYgKHN0YXRlLm92ZXJsYXlDdXIgPT0gbnVsbCkgcmV0dXJuIHN0YXRlLmJhc2VDdXI7XG4gICAgICBlbHNlIGlmIChzdGF0ZS5iYXNlQ3VyICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgIHN0YXRlLm92ZXJsYXkuY29tYmluZVRva2VucyB8fFxuICAgICAgICAgICAgICAgY29tYmluZSAmJiBzdGF0ZS5vdmVybGF5LmNvbWJpbmVUb2tlbnMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHN0YXRlLmJhc2VDdXIgKyBcIiBcIiArIHN0YXRlLm92ZXJsYXlDdXI7XG4gICAgICBlbHNlIHJldHVybiBzdGF0ZS5vdmVybGF5Q3VyO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGJhc2UuaW5kZW50ICYmIGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpIHtcbiAgICAgIHJldHVybiBiYXNlLmluZGVudChzdGF0ZS5iYXNlLCB0ZXh0QWZ0ZXIsIGxpbmUpO1xuICAgIH0sXG4gICAgZWxlY3RyaWNDaGFyczogYmFzZS5lbGVjdHJpY0NoYXJzLFxuXG4gICAgaW5uZXJNb2RlOiBmdW5jdGlvbihzdGF0ZSkgeyByZXR1cm4ge3N0YXRlOiBzdGF0ZS5iYXNlLCBtb2RlOiBiYXNlfTsgfSxcblxuICAgIGJsYW5rTGluZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBiYXNlVG9rZW4sIG92ZXJsYXlUb2tlbjtcbiAgICAgIGlmIChiYXNlLmJsYW5rTGluZSkgYmFzZVRva2VuID0gYmFzZS5ibGFua0xpbmUoc3RhdGUuYmFzZSk7XG4gICAgICBpZiAob3ZlcmxheS5ibGFua0xpbmUpIG92ZXJsYXlUb2tlbiA9IG92ZXJsYXkuYmxhbmtMaW5lKHN0YXRlLm92ZXJsYXkpO1xuXG4gICAgICByZXR1cm4gb3ZlcmxheVRva2VuID09IG51bGwgP1xuICAgICAgICBiYXNlVG9rZW4gOlxuICAgICAgICAoY29tYmluZSAmJiBiYXNlVG9rZW4gIT0gbnVsbCA/IGJhc2VUb2tlbiArIFwiIFwiICsgb3ZlcmxheVRva2VuIDogb3ZlcmxheVRva2VuKTtcbiAgICB9XG4gIH07XG59O1xuXG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJvdmVybGF5TW9kZSIsImJhc2UiLCJvdmVybGF5IiwiY29tYmluZSIsInN0YXJ0U3RhdGUiLCJiYXNlUG9zIiwiYmFzZUN1ciIsIm92ZXJsYXlQb3MiLCJvdmVybGF5Q3VyIiwic3RyZWFtU2VlbiIsImNvcHlTdGF0ZSIsInN0YXRlIiwidG9rZW4iLCJzdHJlYW0iLCJNYXRoIiwibWluIiwic3RhcnQiLCJwb3MiLCJjb21iaW5lVG9rZW5zIiwiaW5kZW50IiwidGV4dEFmdGVyIiwibGluZSIsImVsZWN0cmljQ2hhcnMiLCJpbm5lck1vZGUiLCJtb2RlIiwiYmxhbmtMaW5lIiwiYmFzZVRva2VuIiwib3ZlcmxheVRva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/addon/mode/overlay.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/addon/search/searchcursor.js":
/*!**************************************************************!*\
  !*** ./node_modules/codemirror/addon/search/searchcursor.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    var Pos = CodeMirror1.Pos;\n    function regexpFlags(regexp) {\n        var flags = regexp.flags;\n        return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\") + (regexp.global ? \"g\" : \"\") + (regexp.multiline ? \"m\" : \"\");\n    }\n    function ensureFlags(regexp, flags) {\n        var current = regexpFlags(regexp), target = current;\n        for(var i = 0; i < flags.length; i++)if (target.indexOf(flags.charAt(i)) == -1) target += flags.charAt(i);\n        return current == target ? regexp : new RegExp(regexp.source, target);\n    }\n    function maybeMultiline(regexp) {\n        return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source);\n    }\n    function searchRegexpForward(doc, regexp, start) {\n        regexp = ensureFlags(regexp, \"g\");\n        for(var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0){\n            regexp.lastIndex = ch;\n            var string = doc.getLine(line), match = regexp.exec(string);\n            if (match) return {\n                from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match\n            };\n        }\n    }\n    function searchRegexpForwardMultiline(doc, regexp, start) {\n        if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);\n        regexp = ensureFlags(regexp, \"gm\");\n        var string, chunk = 1;\n        for(var line = start.line, last = doc.lastLine(); line <= last;){\n            // This grows the search buffer in exponentially-sized chunks\n            // between matches, so that nearby matches are fast and don't\n            // require concatenating the whole document (in case we're\n            // searching for something that has tons of matches), but at the\n            // same time, the amount of retries is limited.\n            for(var i = 0; i < chunk; i++){\n                if (line > last) break;\n                var curLine = doc.getLine(line++);\n                string = string == null ? curLine : string + \"\\n\" + curLine;\n            }\n            chunk = chunk * 2;\n            regexp.lastIndex = start.ch;\n            var match = regexp.exec(string);\n            if (match) {\n                var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\");\n                var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length;\n                return {\n                    from: Pos(startLine, startCh),\n                    to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                    match: match\n                };\n            }\n        }\n    }\n    function lastMatchIn(string, regexp, endMargin) {\n        var match, from = 0;\n        while(from <= string.length){\n            regexp.lastIndex = from;\n            var newMatch = regexp.exec(string);\n            if (!newMatch) break;\n            var end = newMatch.index + newMatch[0].length;\n            if (end > string.length - endMargin) break;\n            if (!match || end > match.index + match[0].length) match = newMatch;\n            from = newMatch.index + 1;\n        }\n        return match;\n    }\n    function searchRegexpBackward(doc, regexp, start) {\n        regexp = ensureFlags(regexp, \"g\");\n        for(var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1){\n            var string = doc.getLine(line);\n            var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);\n            if (match) return {\n                from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match\n            };\n        }\n    }\n    function searchRegexpBackwardMultiline(doc, regexp, start) {\n        if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start);\n        regexp = ensureFlags(regexp, \"gm\");\n        var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch;\n        for(var line = start.line, first = doc.firstLine(); line >= first;){\n            for(var i = 0; i < chunkSize && line >= first; i++){\n                var curLine = doc.getLine(line--);\n                string = string == null ? curLine : curLine + \"\\n\" + string;\n            }\n            chunkSize *= 2;\n            var match = lastMatchIn(string, regexp, endMargin);\n            if (match) {\n                var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\");\n                var startLine = line + before.length, startCh = before[before.length - 1].length;\n                return {\n                    from: Pos(startLine, startCh),\n                    to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                    match: match\n                };\n            }\n        }\n    }\n    var doFold, noFold;\n    if (String.prototype.normalize) {\n        doFold = function(str) {\n            return str.normalize(\"NFD\").toLowerCase();\n        };\n        noFold = function(str) {\n            return str.normalize(\"NFD\");\n        };\n    } else {\n        doFold = function(str) {\n            return str.toLowerCase();\n        };\n        noFold = function(str) {\n            return str;\n        };\n    }\n    // Maps a position in a case-folded line back to a position in the original line\n    // (compensating for codepoints increasing in number during folding)\n    function adjustPos(orig, folded, pos, foldFunc) {\n        if (orig.length == folded.length) return pos;\n        for(var min = 0, max = pos + Math.max(0, orig.length - folded.length);;){\n            if (min == max) return min;\n            var mid = min + max >> 1;\n            var len = foldFunc(orig.slice(0, mid)).length;\n            if (len == pos) return mid;\n            else if (len > pos) max = mid;\n            else min = mid + 1;\n        }\n    }\n    function searchStringForward(doc, query, start, caseFold) {\n        // Empty string would match anything and never progress, so we\n        // define it to match nothing instead.\n        if (!query.length) return null;\n        var fold = caseFold ? doFold : noFold;\n        var lines = fold(query).split(/\\r|\\n\\r?/);\n        search: for(var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0){\n            var orig = doc.getLine(line).slice(ch), string = fold(orig);\n            if (lines.length == 1) {\n                var found = string.indexOf(lines[0]);\n                if (found == -1) continue search;\n                var start = adjustPos(orig, string, found, fold) + ch;\n                return {\n                    from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                    to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)\n                };\n            } else {\n                var cutFrom = string.length - lines[0].length;\n                if (string.slice(cutFrom) != lines[0]) continue search;\n                for(var i = 1; i < lines.length - 1; i++)if (fold(doc.getLine(line + i)) != lines[i]) continue search;\n                var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];\n                if (endString.slice(0, lastLine.length) != lastLine) continue search;\n                return {\n                    from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                    to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))\n                };\n            }\n        }\n    }\n    function searchStringBackward(doc, query, start, caseFold) {\n        if (!query.length) return null;\n        var fold = caseFold ? doFold : noFold;\n        var lines = fold(query).split(/\\r|\\n\\r?/);\n        search: for(var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1){\n            var orig = doc.getLine(line);\n            if (ch > -1) orig = orig.slice(0, ch);\n            var string = fold(orig);\n            if (lines.length == 1) {\n                var found = string.lastIndexOf(lines[0]);\n                if (found == -1) continue search;\n                return {\n                    from: Pos(line, adjustPos(orig, string, found, fold)),\n                    to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))\n                };\n            } else {\n                var lastLine = lines[lines.length - 1];\n                if (string.slice(0, lastLine.length) != lastLine) continue search;\n                for(var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)if (fold(doc.getLine(start + i)) != lines[i]) continue search;\n                var top = doc.getLine(line + 1 - lines.length), topString = fold(top);\n                if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;\n                return {\n                    from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                    to: Pos(line, adjustPos(orig, string, lastLine.length, fold))\n                };\n            }\n        }\n    }\n    function SearchCursor(doc, query, pos, options) {\n        this.atOccurrence = false;\n        this.afterEmptyMatch = false;\n        this.doc = doc;\n        pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n        this.pos = {\n            from: pos,\n            to: pos\n        };\n        var caseFold;\n        if (typeof options == \"object\") {\n            caseFold = options.caseFold;\n        } else {\n            caseFold = options;\n            options = null;\n        }\n        if (typeof query == \"string\") {\n            if (caseFold == null) caseFold = false;\n            this.matches = function(reverse, pos) {\n                return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);\n            };\n        } else {\n            query = ensureFlags(query, \"gm\");\n            if (!options || options.multiline !== false) this.matches = function(reverse, pos) {\n                return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);\n            };\n            else this.matches = function(reverse, pos) {\n                return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);\n            };\n        }\n    }\n    SearchCursor.prototype = {\n        findNext: function() {\n            return this.find(false);\n        },\n        findPrevious: function() {\n            return this.find(true);\n        },\n        find: function(reverse) {\n            var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n            if (this.afterEmptyMatch && this.atOccurrence) {\n                // do not return the same 0 width match twice\n                head = Pos(head.line, head.ch);\n                if (reverse) {\n                    head.ch--;\n                    if (head.ch < 0) {\n                        head.line--;\n                        head.ch = (this.doc.getLine(head.line) || \"\").length;\n                    }\n                } else {\n                    head.ch++;\n                    if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n                        head.ch = 0;\n                        head.line++;\n                    }\n                }\n                if (CodeMirror1.cmpPos(head, this.doc.clipPos(head)) != 0) {\n                    return this.atOccurrence = false;\n                }\n            }\n            var result = this.matches(reverse, head);\n            this.afterEmptyMatch = result && CodeMirror1.cmpPos(result.from, result.to) == 0;\n            if (result) {\n                this.pos = result;\n                this.atOccurrence = true;\n                return this.pos.match || true;\n            } else {\n                var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);\n                this.pos = {\n                    from: end,\n                    to: end\n                };\n                return this.atOccurrence = false;\n            }\n        },\n        from: function() {\n            if (this.atOccurrence) return this.pos.from;\n        },\n        to: function() {\n            if (this.atOccurrence) return this.pos.to;\n        },\n        replace: function(newText, origin) {\n            if (!this.atOccurrence) return;\n            var lines = CodeMirror1.splitLines(newText);\n            this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n            this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n        }\n    };\n    CodeMirror1.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n        return new SearchCursor(this.doc, query, pos, caseFold);\n    });\n    CodeMirror1.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n        return new SearchCursor(this, query, pos, caseFold);\n    });\n    CodeMirror1.defineExtension(\"selectMatches\", function(query, caseFold) {\n        var ranges = [];\n        var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n        while(cur.findNext()){\n            if (CodeMirror1.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n            ranges.push({\n                anchor: cur.from(),\n                head: cur.to()\n            });\n        }\n        if (ranges.length) this.setSelections(ranges, 0);\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3IuanMiLCJtYXBwaW5ncyI6IkFBQUEsMkRBQTJEO0FBQzNELHFFQUFxRTtBQUVwRSxVQUFTQSxHQUFHO0lBQ1gsSUFBSSxJQUF1RCxFQUN6REEsSUFBSUcsbUJBQU9BLENBQUMsNkZBQXNCO1NBQy9CLEVBR0NHO0FBQ1IsR0FBRyxTQUFTQSxXQUFVO0lBQ3BCO0lBQ0EsSUFBSUMsTUFBTUQsWUFBV0MsR0FBRztJQUV4QixTQUFTQyxZQUFZQyxNQUFNO1FBQ3pCLElBQUlDLFFBQVFELE9BQU9DLEtBQUs7UUFDeEIsT0FBT0EsU0FBUyxPQUFPQSxRQUFRLENBQUNELE9BQU9FLFVBQVUsR0FBRyxNQUFNLEVBQUMsSUFDdERGLENBQUFBLE9BQU9HLE1BQU0sR0FBRyxNQUFNLEVBQUMsSUFDdkJILENBQUFBLE9BQU9JLFNBQVMsR0FBRyxNQUFNLEVBQUM7SUFDakM7SUFFQSxTQUFTQyxZQUFZTCxNQUFNLEVBQUVDLEtBQUs7UUFDaEMsSUFBSUssVUFBVVAsWUFBWUMsU0FBU08sU0FBU0Q7UUFDNUMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlQLE1BQU1RLE1BQU0sRUFBRUQsSUFBSyxJQUFJRCxPQUFPRyxPQUFPLENBQUNULE1BQU1VLE1BQU0sQ0FBQ0gsT0FBTyxDQUFDLEdBQzdFRCxVQUFVTixNQUFNVSxNQUFNLENBQUNIO1FBQ3pCLE9BQU9GLFdBQVdDLFNBQVNQLFNBQVMsSUFBSVksT0FBT1osT0FBT2EsTUFBTSxFQUFFTjtJQUNoRTtJQUVBLFNBQVNPLGVBQWVkLE1BQU07UUFDNUIsT0FBTywwQkFBMEJlLElBQUksQ0FBQ2YsT0FBT2EsTUFBTTtJQUNyRDtJQUVBLFNBQVNHLG9CQUFvQkMsR0FBRyxFQUFFakIsTUFBTSxFQUFFa0IsS0FBSztRQUM3Q2xCLFNBQVNLLFlBQVlMLFFBQVE7UUFDN0IsSUFBSyxJQUFJbUIsT0FBT0QsTUFB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LEdBQUcsRUFBRVMsUUFBUTtRQUM1RSxPQUFPLElBQUlXLGFBQWEsSUFBSSxFQUFFWixPQUFPUixLQUFLUztJQUM1QztJQUVBdkUsWUFBV29HLGVBQWUsQ0FBQyxpQkFBaUIsU0FBUzlCLEtBQUssRUFBRUMsUUFBUTtRQUNsRSxJQUFJK0IsU0FBUyxFQUFFO1FBQ2YsSUFBSUMsTUFBTSxJQUFJLENBQUNDLGVBQWUsQ0FBQ2xDLE9BQU8sSUFBSSxDQUFDbUMsU0FBUyxDQUFDLFNBQVNsQztRQUM5RCxNQUFPZ0MsSUFBSWQsUUFBUSxHQUFJO1lBQ3JCLElBQUl6RixZQUFXNkYsTUFBTSxDQUFDVSxJQUFJdEUsRUFBRSxJQUFJLElBQUksQ0FBQ3dFLFNBQVMsQ0FBQyxTQUFTLEdBQUc7WUFDM0RILE9BQU9JLElBQUksQ0FBQztnQkFBQ0MsUUFBUUosSUFBSXhFLElBQUk7Z0JBQUk2RCxNQUFNVyxJQUFJdEUsRUFBRTtZQUFFO1FBQ2pEO1FBQ0EsSUFBSXFFLE9BQU8xRixNQUFNLEVBQ2YsSUFBSSxDQUFDZ0csYUFBYSxDQUFDTixRQUFRO0lBQy9CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vc2VhcmNoL3NlYXJjaGN1cnNvci5qcz8xMzg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC81L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSlcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpXG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcilcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCJcbiAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zXG5cbiAgZnVuY3Rpb24gcmVnZXhwRmxhZ3MocmVnZXhwKSB7XG4gICAgdmFyIGZsYWdzID0gcmVnZXhwLmZsYWdzXG4gICAgcmV0dXJuIGZsYWdzICE9IG51bGwgPyBmbGFncyA6IChyZWdleHAuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIilcbiAgICAgICsgKHJlZ2V4cC5nbG9iYWwgPyBcImdcIiA6IFwiXCIpXG4gICAgICArIChyZWdleHAubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlRmxhZ3MocmVnZXhwLCBmbGFncykge1xuICAgIHZhciBjdXJyZW50ID0gcmVnZXhwRmxhZ3MocmVnZXhwKSwgdGFyZ2V0ID0gY3VycmVudFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIGlmICh0YXJnZXQuaW5kZXhPZihmbGFncy5jaGFyQXQoaSkpID09IC0xKVxuICAgICAgdGFyZ2V0ICs9IGZsYWdzLmNoYXJBdChpKVxuICAgIHJldHVybiBjdXJyZW50ID09IHRhcmdldCA/IHJlZ2V4cCA6IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgdGFyZ2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVNdWx0aWxpbmUocmVnZXhwKSB7XG4gICAgcmV0dXJuIC9cXFxcc3xcXFxcbnxcXG58XFxcXFd8XFxcXER8XFxbXFxeLy50ZXN0KHJlZ2V4cC5zb3VyY2UpXG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hSZWdleHBGb3J3YXJkKGRvYywgcmVnZXhwLCBzdGFydCkge1xuICAgIHJlZ2V4cCA9IGVuc3VyZUZsYWdzKHJlZ2V4cCwgXCJnXCIpXG4gICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGxhc3QgPSBkb2MubGFzdExpbmUoKTsgbGluZSA8PSBsYXN0OyBsaW5lKyssIGNoID0gMCkge1xuICAgICAgcmVnZXhwLmxhc3RJbmRleCA9IGNoXG4gICAgICB2YXIgc3RyaW5nID0gZG9jLmdldExpbmUobGluZSksIG1hdGNoID0gcmVnZXhwLmV4ZWMoc3RyaW5nKVxuICAgICAgaWYgKG1hdGNoKVxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBtYXRjaC5pbmRleCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNofVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFJlZ2V4cEZvcndhcmRNdWx0aWxpbmUoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgaWYgKCFtYXliZU11bHRpbGluZShyZWdleHApKSByZXR1cm4gc2VhcmNoUmVnZXhwRm9yd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpXG5cbiAgICByZWdleHAgPSBlbnN1cmVGbGFncyhyZWdleHAsIFwiZ21cIilcbiAgICB2YXIgc3RyaW5nLCBjaHVuayA9IDFcbiAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgbGFzdCA9IGRvYy5sYXN0TGluZSgpOyBsaW5lIDw9IGxhc3Q7KSB7XG4gICAgICAvLyBUaGlzIGdyb3dzIHRoZSBzZWFyY2ggYnVmZmVyIGluIGV4cG9uZW50aWFsbHktc2l6ZWQgY2h1bmtzXG4gICAgICAvLyBiZXR3ZWVuIG1hdGNoZXMsIHNvIHRoYXQgbmVhcmJ5IG1hdGNoZXMgYXJlIGZhc3QgYW5kIGRvbid0XG4gICAgICAvLyByZXF1aXJlIGNvbmNhdGVuYXRpbmcgdGhlIHdob2xlIGRvY3VtZW50IChpbiBjYXNlIHdlJ3JlXG4gICAgICAvLyBzZWFyY2hpbmcgZm9yIHNvbWV0aGluZyB0aGF0IGhhcyB0b25zIG9mIG1hdGNoZXMpLCBidXQgYXQgdGhlXG4gICAgICAvLyBzYW1lIHRpbWUsIHRoZSBhbW91bnQgb2YgcmV0cmllcyBpcyBsaW1pdGVkLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuazsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lID4gbGFzdCkgYnJlYWtcbiAgICAgICAgdmFyIGN1ckxpbmUgPSBkb2MuZ2V0TGluZShsaW5lKyspXG4gICAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gY3VyTGluZSA6IHN0cmluZyArIFwiXFxuXCIgKyBjdXJMaW5lXG4gICAgICB9XG4gICAgICBjaHVuayA9IGNodW5rICogMlxuICAgICAgcmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0LmNoXG4gICAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhzdHJpbmcpXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHN0cmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCkuc3BsaXQoXCJcXG5cIiksIGluc2lkZSA9IG1hdGNoWzBdLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydC5saW5lICsgYmVmb3JlLmxlbmd0aCAtIDEsIHN0YXJ0Q2ggPSBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdLmxlbmd0aFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhzdGFydExpbmUsIHN0YXJ0Q2gpLFxuICAgICAgICAgICAgICAgIHRvOiBQb3Moc3RhcnRMaW5lICsgaW5zaWRlLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGUubGVuZ3RoID09IDEgPyBzdGFydENoICsgaW5zaWRlWzBdLmxlbmd0aCA6IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2h9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGFzdE1hdGNoSW4oc3RyaW5nLCByZWdleHAsIGVuZE1hcmdpbikge1xuICAgIHZhciBtYXRjaCwgZnJvbSA9IDBcbiAgICB3aGlsZSAoZnJvbSA8PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICByZWdleHAubGFzdEluZGV4ID0gZnJvbVxuICAgICAgdmFyIG5ld01hdGNoID0gcmVnZXhwLmV4ZWMoc3RyaW5nKVxuICAgICAgaWYgKCFuZXdNYXRjaCkgYnJlYWtcbiAgICAgIHZhciBlbmQgPSBuZXdNYXRjaC5pbmRleCArIG5ld01hdGNoWzBdLmxlbmd0aFxuICAgICAgaWYgKGVuZCA+IHN0cmluZy5sZW5ndGggLSBlbmRNYXJnaW4pIGJyZWFrXG4gICAgICBpZiAoIW1hdGNoIHx8IGVuZCA+IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxuICAgICAgICBtYXRjaCA9IG5ld01hdGNoXG4gICAgICBmcm9tID0gbmV3TWF0Y2guaW5kZXggKyAxXG4gICAgfVxuICAgIHJldHVybiBtYXRjaFxuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoUmVnZXhwQmFja3dhcmQoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdcIilcbiAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgY2ggPSBzdGFydC5jaCwgZmlyc3QgPSBkb2MuZmlyc3RMaW5lKCk7IGxpbmUgPj0gZmlyc3Q7IGxpbmUtLSwgY2ggPSAtMSkge1xuICAgICAgdmFyIHN0cmluZyA9IGRvYy5nZXRMaW5lKGxpbmUpXG4gICAgICB2YXIgbWF0Y2ggPSBsYXN0TWF0Y2hJbihzdHJpbmcsIHJlZ2V4cCwgY2ggPCAwID8gMCA6IHN0cmluZy5sZW5ndGggLSBjaClcbiAgICAgIGlmIChtYXRjaClcbiAgICAgICAgcmV0dXJuIHtmcm9tOiBQb3MobGluZSwgbWF0Y2guaW5kZXgpLFxuICAgICAgICAgICAgICAgIHRvOiBQb3MobGluZSwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hSZWdleHBCYWNrd2FyZE11bHRpbGluZShkb2MsIHJlZ2V4cCwgc3RhcnQpIHtcbiAgICBpZiAoIW1heWJlTXVsdGlsaW5lKHJlZ2V4cCkpIHJldHVybiBzZWFyY2hSZWdleHBCYWNrd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpXG4gICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdtXCIpXG4gICAgdmFyIHN0cmluZywgY2h1bmtTaXplID0gMSwgZW5kTWFyZ2luID0gZG9jLmdldExpbmUoc3RhcnQubGluZSkubGVuZ3RoIC0gc3RhcnQuY2hcbiAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgZmlyc3QgPSBkb2MuZmlyc3RMaW5lKCk7IGxpbmUgPj0gZmlyc3Q7KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rU2l6ZSAmJiBsaW5lID49IGZpcnN0OyBpKyspIHtcbiAgICAgICAgdmFyIGN1ckxpbmUgPSBkb2MuZ2V0TGluZShsaW5lLS0pXG4gICAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gY3VyTGluZSA6IGN1ckxpbmUgKyBcIlxcblwiICsgc3RyaW5nXG4gICAgICB9XG4gICAgICBjaHVua1NpemUgKj0gMlxuXG4gICAgICB2YXIgbWF0Y2ggPSBsYXN0TWF0Y2hJbihzdHJpbmcsIHJlZ2V4cCwgZW5kTWFyZ2luKVxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBzdHJpbmcuc2xpY2UoMCwgbWF0Y2guaW5kZXgpLnNwbGl0KFwiXFxuXCIpLCBpbnNpZGUgPSBtYXRjaFswXS5zcGxpdChcIlxcblwiKVxuICAgICAgICB2YXIgc3RhcnRMaW5lID0gbGluZSArIGJlZm9yZS5sZW5ndGgsIHN0YXJ0Q2ggPSBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdLmxlbmd0aFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhzdGFydExpbmUsIHN0YXJ0Q2gpLFxuICAgICAgICAgICAgICAgIHRvOiBQb3Moc3RhcnRMaW5lICsgaW5zaWRlLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGUubGVuZ3RoID09IDEgPyBzdGFydENoICsgaW5zaWRlWzBdLmxlbmd0aCA6IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2h9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRvRm9sZCwgbm9Gb2xkXG4gIGlmIChTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSkge1xuICAgIGRvRm9sZCA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLm5vcm1hbGl6ZShcIk5GRFwiKS50b0xvd2VyQ2FzZSgpIH1cbiAgICBub0ZvbGQgPSBmdW5jdGlvbihzdHIpIHsgcmV0dXJuIHN0ci5ub3JtYWxpemUoXCJORkRcIikgfVxuICB9IGVsc2Uge1xuICAgIGRvRm9sZCA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkgfVxuICAgIG5vRm9sZCA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyIH1cbiAgfVxuXG4gIC8vIE1hcHMgYSBwb3NpdGlvbiBpbiBhIGNhc2UtZm9sZGVkIGxpbmUgYmFjayB0byBhIHBvc2l0aW9uIGluIHRoZSBvcmlnaW5hbCBsaW5lXG4gIC8vIChjb21wZW5zYXRpbmcgZm9yIGNvZGVwb2ludHMgaW5jcmVhc2luZyBpbiBudW1iZXIgZHVyaW5nIGZvbGRpbmcpXG4gIGZ1bmN0aW9uIGFkanVzdFBvcyhvcmlnLCBmb2xkZWQsIHBvcywgZm9sZEZ1bmMpIHtcbiAgICBpZiAob3JpZy5sZW5ndGggPT0gZm9sZGVkLmxlbmd0aCkgcmV0dXJuIHBvc1xuICAgIGZvciAodmFyIG1pbiA9IDAsIG1heCA9IHBvcyArIE1hdGgubWF4KDAsIG9yaWcubGVuZ3RoIC0gZm9sZGVkLmxlbmd0aCk7Oykge1xuICAgICAgaWYgKG1pbiA9PSBtYXgpIHJldHVybiBtaW5cbiAgICAgIHZhciBtaWQgPSAobWluICsgbWF4KSA+PiAxXG4gICAgICB2YXIgbGVuID0gZm9sZEZ1bmMob3JpZy5zbGljZSgwLCBtaWQpKS5sZW5ndGhcbiAgICAgIGlmIChsZW4gPT0gcG9zKSByZXR1cm4gbWlkXG4gICAgICBlbHNlIGlmIChsZW4gPiBwb3MpIG1heCA9IG1pZFxuICAgICAgZWxzZSBtaW4gPSBtaWQgKyAxXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoU3RyaW5nRm9yd2FyZChkb2MsIHF1ZXJ5LCBzdGFydCwgY2FzZUZvbGQpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmcgd291bGQgbWF0Y2ggYW55dGhpbmcgYW5kIG5ldmVyIHByb2dyZXNzLCBzbyB3ZVxuICAgIC8vIGRlZmluZSBpdCB0byBtYXRjaCBub3RoaW5nIGluc3RlYWQuXG4gICAgaWYgKCFxdWVyeS5sZW5ndGgpIHJldHVybiBudWxsXG4gICAgdmFyIGZvbGQgPSBjYXNlRm9sZCA/IGRvRm9sZCA6IG5vRm9sZFxuICAgIHZhciBsaW5lcyA9IGZvbGQocXVlcnkpLnNwbGl0KC9cXHJ8XFxuXFxyPy8pXG5cbiAgICBzZWFyY2g6IGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBjaCA9IHN0YXJ0LmNoLCBsYXN0ID0gZG9jLmxhc3RMaW5lKCkgKyAxIC0gbGluZXMubGVuZ3RoOyBsaW5lIDw9IGxhc3Q7IGxpbmUrKywgY2ggPSAwKSB7XG4gICAgICB2YXIgb3JpZyA9IGRvYy5nZXRMaW5lKGxpbmUpLnNsaWNlKGNoKSwgc3RyaW5nID0gZm9sZChvcmlnKVxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHN0cmluZy5pbmRleE9mKGxpbmVzWzBdKVxuICAgICAgICBpZiAoZm91bmQgPT0gLTEpIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICB2YXIgc3RhcnQgPSBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBmb3VuZCwgZm9sZCkgKyBjaFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBmb3VuZCwgZm9sZCkgKyBjaCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBmb3VuZCArIGxpbmVzWzBdLmxlbmd0aCwgZm9sZCkgKyBjaCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3V0RnJvbSA9IHN0cmluZy5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGhcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShjdXRGcm9tKSAhPSBsaW5lc1swXSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIGlmIChmb2xkKGRvYy5nZXRMaW5lKGxpbmUgKyBpKSkgIT0gbGluZXNbaV0pIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICB2YXIgZW5kID0gZG9jLmdldExpbmUobGluZSArIGxpbmVzLmxlbmd0aCAtIDEpLCBlbmRTdHJpbmcgPSBmb2xkKGVuZCksIGxhc3RMaW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgaWYgKGVuZFN0cmluZy5zbGljZSgwLCBsYXN0TGluZS5sZW5ndGgpICE9IGxhc3RMaW5lKSBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgcmV0dXJuIHtmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgY3V0RnJvbSwgZm9sZCkgKyBjaCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhsaW5lICsgbGluZXMubGVuZ3RoIC0gMSwgYWRqdXN0UG9zKGVuZCwgZW5kU3RyaW5nLCBsYXN0TGluZS5sZW5ndGgsIGZvbGQpKX1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hTdHJpbmdCYWNrd2FyZChkb2MsIHF1ZXJ5LCBzdGFydCwgY2FzZUZvbGQpIHtcbiAgICBpZiAoIXF1ZXJ5Lmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICB2YXIgZm9sZCA9IGNhc2VGb2xkID8gZG9Gb2xkIDogbm9Gb2xkXG4gICAgdmFyIGxpbmVzID0gZm9sZChxdWVyeSkuc3BsaXQoL1xccnxcXG5cXHI/LylcblxuICAgIHNlYXJjaDogZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGZpcnN0ID0gZG9jLmZpcnN0TGluZSgpIC0gMSArIGxpbmVzLmxlbmd0aDsgbGluZSA+PSBmaXJzdDsgbGluZS0tLCBjaCA9IC0xKSB7XG4gICAgICB2YXIgb3JpZyA9IGRvYy5nZXRMaW5lKGxpbmUpXG4gICAgICBpZiAoY2ggPiAtMSkgb3JpZyA9IG9yaWcuc2xpY2UoMCwgY2gpXG4gICAgICB2YXIgc3RyaW5nID0gZm9sZChvcmlnKVxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHN0cmluZy5sYXN0SW5kZXhPZihsaW5lc1swXSlcbiAgICAgICAgaWYgKGZvdW5kID09IC0xKSBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgcmV0dXJuIHtmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQsIGZvbGQpKSxcbiAgICAgICAgICAgICAgICB0bzogUG9zKGxpbmUsIGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kICsgbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGFzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXVxuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKDAsIGxhc3RMaW5lLmxlbmd0aCkgIT0gbGFzdExpbmUpIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICBmb3IgKHZhciBpID0gMSwgc3RhcnQgPSBsaW5lIC0gbGluZXMubGVuZ3RoICsgMTsgaSA8IGxpbmVzLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICBpZiAoZm9sZChkb2MuZ2V0TGluZShzdGFydCArIGkpKSAhPSBsaW5lc1tpXSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIHZhciB0b3AgPSBkb2MuZ2V0TGluZShsaW5lICsgMSAtIGxpbmVzLmxlbmd0aCksIHRvcFN0cmluZyA9IGZvbGQodG9wKVxuICAgICAgICBpZiAodG9wU3RyaW5nLnNsaWNlKHRvcFN0cmluZy5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGgpICE9IGxpbmVzWzBdKSBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgcmV0dXJuIHtmcm9tOiBQb3MobGluZSArIDEgLSBsaW5lcy5sZW5ndGgsIGFkanVzdFBvcyh0b3AsIHRvcFN0cmluZywgdG9wLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCwgZm9sZCkpLFxuICAgICAgICAgICAgICAgIHRvOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgbGFzdExpbmUubGVuZ3RoLCBmb2xkKSl9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gU2VhcmNoQ3Vyc29yKGRvYywgcXVlcnksIHBvcywgb3B0aW9ucykge1xuICAgIHRoaXMuYXRPY2N1cnJlbmNlID0gZmFsc2VcbiAgICB0aGlzLmFmdGVyRW1wdHlNYXRjaCA9IGZhbHNlXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICBwb3MgPSBwb3MgPyBkb2MuY2xpcFBvcyhwb3MpIDogUG9zKDAsIDApXG4gICAgdGhpcy5wb3MgPSB7ZnJvbTogcG9zLCB0bzogcG9zfVxuXG4gICAgdmFyIGNhc2VGb2xkXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNhc2VGb2xkID0gb3B0aW9ucy5jYXNlRm9sZFxuICAgIH0gZWxzZSB7IC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIHdoZW4gY2FzZUZvbGQgd2FzIHRoZSA0dGggYXJndW1lbnRcbiAgICAgIGNhc2VGb2xkID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChjYXNlRm9sZCA9PSBudWxsKSBjYXNlRm9sZCA9IGZhbHNlXG4gICAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihyZXZlcnNlLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIChyZXZlcnNlID8gc2VhcmNoU3RyaW5nQmFja3dhcmQgOiBzZWFyY2hTdHJpbmdGb3J3YXJkKShkb2MsIHF1ZXJ5LCBwb3MsIGNhc2VGb2xkKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IGVuc3VyZUZsYWdzKHF1ZXJ5LCBcImdtXCIpXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5tdWx0aWxpbmUgIT09IGZhbHNlKVxuICAgICAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihyZXZlcnNlLCBwb3MpIHtcbiAgICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hSZWdleHBCYWNrd2FyZE11bHRpbGluZSA6IHNlYXJjaFJlZ2V4cEZvcndhcmRNdWx0aWxpbmUpKGRvYywgcXVlcnksIHBvcylcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihyZXZlcnNlLCBwb3MpIHtcbiAgICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hSZWdleHBCYWNrd2FyZCA6IHNlYXJjaFJlZ2V4cEZvcndhcmQpKGRvYywgcXVlcnksIHBvcylcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFNlYXJjaEN1cnNvci5wcm90b3R5cGUgPSB7XG4gICAgZmluZE5leHQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpbmQoZmFsc2UpfSxcbiAgICBmaW5kUHJldmlvdXM6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpbmQodHJ1ZSl9LFxuXG4gICAgZmluZDogZnVuY3Rpb24ocmV2ZXJzZSkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmRvYy5jbGlwUG9zKHJldmVyc2UgPyB0aGlzLnBvcy5mcm9tIDogdGhpcy5wb3MudG8pO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJFbXB0eU1hdGNoICYmIHRoaXMuYXRPY2N1cnJlbmNlKSB7XG4gICAgICAgIC8vIGRvIG5vdCByZXR1cm4gdGhlIHNhbWUgMCB3aWR0aCBtYXRjaCB0d2ljZVxuICAgICAgICBoZWFkID0gUG9zKGhlYWQubGluZSwgaGVhZC5jaClcbiAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICBoZWFkLmNoLS07XG4gICAgICAgICAgaWYgKGhlYWQuY2ggPCAwKSB7XG4gICAgICAgICAgICBoZWFkLmxpbmUtLTtcbiAgICAgICAgICAgIGhlYWQuY2ggPSAodGhpcy5kb2MuZ2V0TGluZShoZWFkLmxpbmUpIHx8IFwiXCIpLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZC5jaCsrO1xuICAgICAgICAgIGlmIChoZWFkLmNoID4gKHRoaXMuZG9jLmdldExpbmUoaGVhZC5saW5lKSB8fCBcIlwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhlYWQuY2ggPSAwO1xuICAgICAgICAgICAgaGVhZC5saW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChDb2RlTWlycm9yLmNtcFBvcyhoZWFkLCB0aGlzLmRvYy5jbGlwUG9zKGhlYWQpKSAhPSAwKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLmF0T2NjdXJyZW5jZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1hdGNoZXMocmV2ZXJzZSwgaGVhZClcbiAgICAgIHRoaXMuYWZ0ZXJFbXB0eU1hdGNoID0gcmVzdWx0ICYmIENvZGVNaXJyb3IuY21wUG9zKHJlc3VsdC5mcm9tLCByZXN1bHQudG8pID09IDBcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB0aGlzLnBvcyA9IHJlc3VsdFxuICAgICAgICB0aGlzLmF0T2NjdXJyZW5jZSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zLm1hdGNoIHx8IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbmQgPSBQb3MocmV2ZXJzZSA/IHRoaXMuZG9jLmZpcnN0TGluZSgpIDogdGhpcy5kb2MubGFzdExpbmUoKSArIDEsIDApXG4gICAgICAgIHRoaXMucG9zID0ge2Zyb206IGVuZCwgdG86IGVuZH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXRPY2N1cnJlbmNlID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnJvbTogZnVuY3Rpb24oKSB7aWYgKHRoaXMuYXRPY2N1cnJlbmNlKSByZXR1cm4gdGhpcy5wb3MuZnJvbX0sXG4gICAgdG86IGZ1bmN0aW9uKCkge2lmICh0aGlzLmF0T2NjdXJyZW5jZSkgcmV0dXJuIHRoaXMucG9zLnRvfSxcblxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uKG5ld1RleHQsIG9yaWdpbikge1xuICAgICAgaWYgKCF0aGlzLmF0T2NjdXJyZW5jZSkgcmV0dXJuXG4gICAgICB2YXIgbGluZXMgPSBDb2RlTWlycm9yLnNwbGl0TGluZXMobmV3VGV4dClcbiAgICAgIHRoaXMuZG9jLnJlcGxhY2VSYW5nZShsaW5lcywgdGhpcy5wb3MuZnJvbSwgdGhpcy5wb3MudG8sIG9yaWdpbilcbiAgICAgIHRoaXMucG9zLnRvID0gUG9zKHRoaXMucG9zLmZyb20ubGluZSArIGxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggKyAobGluZXMubGVuZ3RoID09IDEgPyB0aGlzLnBvcy5mcm9tLmNoIDogMCkpXG4gICAgfVxuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJnZXRTZWFyY2hDdXJzb3JcIiwgZnVuY3Rpb24ocXVlcnksIHBvcywgY2FzZUZvbGQpIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEN1cnNvcih0aGlzLmRvYywgcXVlcnksIHBvcywgY2FzZUZvbGQpXG4gIH0pXG4gIENvZGVNaXJyb3IuZGVmaW5lRG9jRXh0ZW5zaW9uKFwiZ2V0U2VhcmNoQ3Vyc29yXCIsIGZ1bmN0aW9uKHF1ZXJ5LCBwb3MsIGNhc2VGb2xkKSB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3IodGhpcywgcXVlcnksIHBvcywgY2FzZUZvbGQpXG4gIH0pXG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJzZWxlY3RNYXRjaGVzXCIsIGZ1bmN0aW9uKHF1ZXJ5LCBjYXNlRm9sZCkge1xuICAgIHZhciByYW5nZXMgPSBbXVxuICAgIHZhciBjdXIgPSB0aGlzLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgdGhpcy5nZXRDdXJzb3IoXCJmcm9tXCIpLCBjYXNlRm9sZClcbiAgICB3aGlsZSAoY3VyLmZpbmROZXh0KCkpIHtcbiAgICAgIGlmIChDb2RlTWlycm9yLmNtcFBvcyhjdXIudG8oKSwgdGhpcy5nZXRDdXJzb3IoXCJ0b1wiKSkgPiAwKSBicmVha1xuICAgICAgcmFuZ2VzLnB1c2goe2FuY2hvcjogY3VyLmZyb20oKSwgaGVhZDogY3VyLnRvKCl9KVxuICAgIH1cbiAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9ucyhyYW5nZXMsIDApXG4gIH0pXG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJQb3MiLCJyZWdleHBGbGFncyIsInJlZ2V4cCIsImZsYWdzIiwiaWdub3JlQ2FzZSIsImdsb2JhbCIsIm11bHRpbGluZSIsImVuc3VyZUZsYWdzIiwiY3VycmVudCIsInRhcmdldCIsImkiLCJsZW5ndGgiLCJpbmRleE9mIiwiY2hhckF0IiwiUmVnRXhwIiwic291cmNlIiwibWF5YmVNdWx0aWxpbmUiLCJ0ZXN0Iiwic2VhcmNoUmVnZXhwRm9yd2FyZCIsImRvYyIsInN0YXJ0IiwibGluZSIsImNoIiwibGFzdCIsImxhc3RMaW5lIiwibGFzdEluZGV4Iiwic3RyaW5nIiwiZ2V0TGluZSIsIm1hdGNoIiwiZXhlYyIsImZyb20iLCJpbmRleCIsInRvIiwic2VhcmNoUmVnZXhwRm9yd2FyZE11bHRpbGluZSIsImNodW5rIiwiY3VyTGluZSIsImJlZm9yZSIsInNsaWNlIiwic3BsaXQiLCJpbnNpZGUiLCJzdGFydExpbmUiLCJzdGFydENoIiwibGFzdE1hdGNoSW4iLCJlbmRNYXJnaW4iLCJuZXdNYXRjaCIsImVuZCIsInNlYXJjaFJlZ2V4cEJhY2t3YXJkIiwiZmlyc3QiLCJmaXJzdExpbmUiLCJzZWFyY2hSZWdleHBCYWNrd2FyZE11bHRpbGluZSIsImNodW5rU2l6ZSIsImRvRm9sZCIsIm5vRm9sZCIsIlN0cmluZyIsInByb3RvdHlwZSIsIm5vcm1hbGl6ZSIsInN0ciIsInRvTG93ZXJDYXNlIiwiYWRqdXN0UG9zIiwib3JpZyIsImZvbGRlZCIsInBvcyIsImZvbGRGdW5jIiwibWluIiwibWF4IiwiTWF0aCIsIm1pZCIsImxlbiIsInNlYXJjaFN0cmluZ0ZvcndhcmQiLCJxdWVyeSIsImNhc2VGb2xkIiwiZm9sZCIsImxpbmVzIiwic2VhcmNoIiwiZm91bmQiLCJjdXRGcm9tIiwiZW5kU3RyaW5nIiwic2VhcmNoU3RyaW5nQmFja3dhcmQiLCJsYXN0SW5kZXhPZiIsInRvcCIsInRvcFN0cmluZyIsIlNlYXJjaEN1cnNvciIsIm9wdGlvbnMiLCJhdE9jY3VycmVuY2UiLCJhZnRlckVtcHR5TWF0Y2giLCJjbGlwUG9zIiwibWF0Y2hlcyIsInJldmVyc2UiLCJmaW5kTmV4dCIsImZpbmQiLCJmaW5kUHJldmlvdXMiLCJoZWFkIiwiY21wUG9zIiwicmVzdWx0IiwicmVwbGFjZSIsIm5ld1RleHQiLCJvcmlnaW4iLCJzcGxpdExpbmVzIiwicmVwbGFjZVJhbmdlIiwiZGVmaW5lRXh0ZW5zaW9uIiwiZGVmaW5lRG9jRXh0ZW5zaW9uIiwicmFuZ2VzIiwiY3VyIiwiZ2V0U2VhcmNoQ3Vyc29yIiwiZ2V0Q3Vyc29yIiwicHVzaCIsImFuY2hvciIsInNldFNlbGVjdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/addon/search/searchcursor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/addon/selection/mark-selection.js":
/*!*******************************************************************!*\
  !*** ./node_modules/codemirror/addon/selection/mark-selection.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    CodeMirror1.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n        var prev = old && old != CodeMirror1.Init;\n        if (val && !prev) {\n            cm.state.markedSelection = [];\n            cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n            reset(cm);\n            cm.on(\"cursorActivity\", onCursorActivity);\n            cm.on(\"change\", onChange);\n        } else if (!val && prev) {\n            cm.off(\"cursorActivity\", onCursorActivity);\n            cm.off(\"change\", onChange);\n            clear(cm);\n            cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n        }\n    });\n    function onCursorActivity(cm) {\n        if (cm.state.markedSelection) cm.operation(function() {\n            update(cm);\n        });\n    }\n    function onChange(cm) {\n        if (cm.state.markedSelection && cm.state.markedSelection.length) cm.operation(function() {\n            clear(cm);\n        });\n    }\n    var CHUNK_SIZE = 8;\n    var Pos = CodeMirror1.Pos;\n    var cmp = CodeMirror1.cmpPos;\n    function coverRange(cm, from, to, addAt) {\n        if (cmp(from, to) == 0) return;\n        var array = cm.state.markedSelection;\n        var cls = cm.state.markedSelectionStyle;\n        for(var line = from.line;;){\n            var start = line == from.line ? from : Pos(line, 0);\n            var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n            var end = atEnd ? to : Pos(endLine, 0);\n            var mark = cm.markText(start, end, {\n                className: cls\n            });\n            if (addAt == null) array.push(mark);\n            else array.splice(addAt++, 0, mark);\n            if (atEnd) break;\n            line = endLine;\n        }\n    }\n    function clear(cm) {\n        var array = cm.state.markedSelection;\n        for(var i = 0; i < array.length; ++i)array[i].clear();\n        array.length = 0;\n    }\n    function reset(cm) {\n        clear(cm);\n        var ranges = cm.listSelections();\n        for(var i = 0; i < ranges.length; i++)coverRange(cm, ranges[i].from(), ranges[i].to());\n    }\n    function update(cm) {\n        if (!cm.somethingSelected()) return clear(cm);\n        if (cm.listSelections().length > 1) return reset(cm);\n        var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n        var array = cm.state.markedSelection;\n        if (!array.length) return coverRange(cm, from, to);\n        var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n        if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE || cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0) return reset(cm);\n        while(cmp(from, coverStart.from) > 0){\n            array.shift().clear();\n            coverStart = array[0].find();\n        }\n        if (cmp(from, coverStart.from) < 0) {\n            if (coverStart.to.line - from.line < CHUNK_SIZE) {\n                array.shift().clear();\n                coverRange(cm, from, coverStart.to, 0);\n            } else {\n                coverRange(cm, from, coverStart.from, 0);\n            }\n        }\n        while(cmp(to, coverEnd.to) < 0){\n            array.pop().clear();\n            coverEnd = array[array.length - 1].find();\n        }\n        if (cmp(to, coverEnd.to) > 0) {\n            if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n                array.pop().clear();\n                coverRange(cm, coverEnd.from, to);\n            } else {\n                coverRange(cm, coverEnd.to, to);\n            }\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL3NlbGVjdGlvbi9tYXJrLXNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBRXJFLDBEQUEwRDtBQUMxRCxFQUFFO0FBQ0YsZ0VBQWdFO0FBQ2hFLHdEQUF3RDtBQUN4RCw0REFBNEQ7QUFFM0QsVUFBU0EsR0FBRztJQUNYLElBQUksSUFBdUQsRUFDekRBLElBQUlHLG1CQUFPQSxDQUFDLDZGQUFzQjtTQUMvQixFQUdhRztBQUNwQixHQUFHLFNBQVNBLFdBQVU7SUFDcEI7SUFFQUEsWUFBV0MsWUFBWSxDQUFDLHFCQUFxQixPQUFPLFNBQVNDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO1FBQ3ZFLElBQUlDLE9BQU9ELE9BQU9BLE9BQU9KLFlBQVdNLElBQUk7UUFDeEMsSUFBSUgsT0FBTyxDQUFDRSxNQUFNO1lBQ2hCSCxHQUFHSyxLQUFLLENBQUNDLGVBQWUsR0FBRyxFQUFFO1lBQzdCTixHQUFHSyxLQUFLLENBQUNFLG9CQUFvQixHQUFHLE9BQU9OLE9BQU8sV0FBV0EsTUFBTTtZQUMvRE8sTUFBTVI7WUFDTkEsR0FBR1MsRUFBRSxDQUFDLGtCQUFrQkM7WUFDeEJWLEdBQUdTLEVBQUUsQ0FBQyxVQUFVRTtRQUNsQixPQUFPLElBQUksQ0FBQ1YsT0FBT0UsTUFBTTtZQUN2QkgsR0FBR1ksR0FBRyxDQUFDLGtCQUFrQkY7WUFDekJWLEdBQUdZLEdBQUcsQ0FBQyxVQUFVRDtZQUNqQkUsTUFBTWI7WUFDTkEsR0FBR0ssS0FBSyxDQUFDQyxlQUFlLEdBQUdOLEdBQUdLLEtBQUssQ0FBQ0Usb0JBQW9CLEdBQUc7UUFDN0Q7SUFDRjtJQUVBLFNBQVNHLGlCQUFpQlYsRUFBRTtRQUMxQixJQUFJQSxHQUFHSyxLQUFLLENBQUNDLGVBQWUsRUFDMUJOLEdBQUdjLFNBQVMsQ0FBQztZQUFhQyxPQUFPZjtRQUFLO0lBQzFDO0lBRUEs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QUNuQjZCLGFBQWFqQixLQUFLLENBQUMsRUFBRSxDQUFDa0IsSUFBSTtRQUM1QjtRQUNBLElBQUl4QixJQUFJRyxNQUFNb0IsV0FBV3BCLElBQUksSUFBSSxHQUFHO1lBQ2xDLElBQUlvQixXQUFXbkIsRUFBRSxDQUFDSSxJQUFJLEdBQUdMLEtBQUtLLElBQUksR0FBR1YsWUFBWTtnQkFDL0NRLE1BQU1vQixLQUFLLEdBQUdoQyxLQUFLO2dCQUNuQlEsV0FBV3JCLElBQUlzQixNQUFNb0IsV0FBV25CLEVBQUUsRUFBRTtZQUN0QyxPQUFPO2dCQUNMRixXQUFXckIsSUFBSXNCLE1BQU1vQixXQUFXcEIsSUFBSSxFQUFFO1lBQ3hDO1FBQ0Y7UUFFQSxNQUFPSCxJQUFJSSxJQUFJcUIsU0FBU3JCLEVBQUUsSUFBSSxFQUFHO1lBQy9CRSxNQUFNcUIsR0FBRyxHQUFHakMsS0FBSztZQUNqQitCLFdBQVduQixLQUFLLENBQUNBLE1BQU1ULE1BQU0sR0FBRyxFQUFFLENBQUMyQixJQUFJO1FBQ3pDO1FBQ0EsSUFBSXhCLElBQUlJLElBQUlxQixTQUFTckIsRUFBRSxJQUFJLEdBQUc7WUFDNUIsSUFBSUEsR0FBR0ksSUFBSSxHQUFHaUIsU0FBU3RCLElBQUksQ0FBQ0ssSUFBSSxHQUFHVixZQUFZO2dCQUM3Q1EsTUFBTXFCLEdBQUcsR0FBR2pDLEtBQUs7Z0JBQ2pCUSxXQUFXckIsSUFBSTRDLFNBQVN0QixJQUFJLEVBQUVDO1lBQ2hDLE9BQU87Z0JBQ0xGLFdBQVdyQixJQUFJNEMsU0FBU3JCLEVBQUUsRUFBRUE7WUFDOUI7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vc2VsZWN0aW9uL21hcmstc2VsZWN0aW9uLmpzPzQ1NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0LzUvTElDRU5TRVxuXG4vLyBCZWNhdXNlIHNvbWV0aW1lcyB5b3UgbmVlZCB0byBtYXJrIHRoZSBzZWxlY3RlZCAqdGV4dCouXG4vL1xuLy8gQWRkcyBhbiBvcHRpb24gJ3N0eWxlU2VsZWN0ZWRUZXh0JyB3aGljaCwgd2hlbiBlbmFibGVkLCBnaXZlc1xuLy8gc2VsZWN0ZWQgdGV4dCB0aGUgQ1NTIGNsYXNzIGdpdmVuIGFzIG9wdGlvbiB2YWx1ZSwgb3Jcbi8vIFwiQ29kZU1pcnJvci1zZWxlY3RlZHRleHRcIiB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwic3R5bGVTZWxlY3RlZFRleHRcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge1xuICAgIHZhciBwcmV2ID0gb2xkICYmIG9sZCAhPSBDb2RlTWlycm9yLkluaXQ7XG4gICAgaWYgKHZhbCAmJiAhcHJldikge1xuICAgICAgY20uc3RhdGUubWFya2VkU2VsZWN0aW9uID0gW107XG4gICAgICBjbS5zdGF0ZS5tYXJrZWRTZWxlY3Rpb25TdHlsZSA9IHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiA/IHZhbCA6IFwiQ29kZU1pcnJvci1zZWxlY3RlZHRleHRcIjtcbiAgICAgIHJlc2V0KGNtKTtcbiAgICAgIGNtLm9uKFwiY3Vyc29yQWN0aXZpdHlcIiwgb25DdXJzb3JBY3Rpdml0eSk7XG4gICAgICBjbS5vbihcImNoYW5nZVwiLCBvbkNoYW5nZSk7XG4gICAgfSBlbHNlIGlmICghdmFsICYmIHByZXYpIHtcbiAgICAgIGNtLm9mZihcImN1cnNvckFjdGl2aXR5XCIsIG9uQ3Vyc29yQWN0aXZpdHkpO1xuICAgICAgY20ub2ZmKFwiY2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgICAgIGNsZWFyKGNtKTtcbiAgICAgIGNtLnN0YXRlLm1hcmtlZFNlbGVjdGlvbiA9IGNtLnN0YXRlLm1hcmtlZFNlbGVjdGlvblN0eWxlID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG9uQ3Vyc29yQWN0aXZpdHkoY20pIHtcbiAgICBpZiAoY20uc3RhdGUubWFya2VkU2VsZWN0aW9uKVxuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkgeyB1cGRhdGUoY20pOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKGNtKSB7XG4gICAgaWYgKGNtLnN0YXRlLm1hcmtlZFNlbGVjdGlvbiAmJiBjbS5zdGF0ZS5tYXJrZWRTZWxlY3Rpb24ubGVuZ3RoKVxuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkgeyBjbGVhcihjbSk7IH0pO1xuICB9XG5cbiAgdmFyIENIVU5LX1NJWkUgPSA4O1xuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3M7XG4gIHZhciBjbXAgPSBDb2RlTWlycm9yLmNtcFBvcztcblxuICBmdW5jdGlvbiBjb3ZlclJhbmdlKGNtLCBmcm9tLCB0bywgYWRkQXQpIHtcbiAgICBpZiAoY21wKGZyb20sIHRvKSA9PSAwKSByZXR1cm47XG4gICAgdmFyIGFycmF5ID0gY20uc3RhdGUubWFya2VkU2VsZWN0aW9uO1xuICAgIHZhciBjbHMgPSBjbS5zdGF0ZS5tYXJrZWRTZWxlY3Rpb25TdHlsZTtcbiAgICBmb3IgKHZhciBsaW5lID0gZnJvbS5saW5lOzspIHtcbiAgICAgIHZhciBzdGFydCA9IGxpbmUgPT0gZnJvbS5saW5lID8gZnJvbSA6IFBvcyhsaW5lLCAwKTtcbiAgICAgIHZhciBlbmRMaW5lID0gbGluZSArIENIVU5LX1NJWkUsIGF0RW5kID0gZW5kTGluZSA+PSB0by5saW5lO1xuICAgICAgdmFyIGVuZCA9IGF0RW5kID8gdG8gOiBQb3MoZW5kTGluZSwgMCk7XG4gICAgICB2YXIgbWFyayA9IGNtLm1hcmtUZXh0KHN0YXJ0LCBlbmQsIHtjbGFzc05hbWU6IGNsc30pO1xuICAgICAgaWYgKGFkZEF0ID09IG51bGwpIGFycmF5LnB1c2gobWFyayk7XG4gICAgICBlbHNlIGFycmF5LnNwbGljZShhZGRBdCsrLCAwLCBtYXJrKTtcbiAgICAgIGlmIChhdEVuZCkgYnJlYWs7XG4gICAgICBsaW5lID0gZW5kTGluZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhcihjbSkge1xuICAgIHZhciBhcnJheSA9IGNtLnN0YXRlLm1hcmtlZFNlbGVjdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSBhcnJheVtpXS5jbGVhcigpO1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldChjbSkge1xuICAgIGNsZWFyKGNtKTtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIGNvdmVyUmFuZ2UoY20sIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShjbSkge1xuICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgcmV0dXJuIGNsZWFyKGNtKTtcbiAgICBpZiAoY20ubGlzdFNlbGVjdGlvbnMoKS5sZW5ndGggPiAxKSByZXR1cm4gcmVzZXQoY20pO1xuXG4gICAgdmFyIGZyb20gPSBjbS5nZXRDdXJzb3IoXCJzdGFydFwiKSwgdG8gPSBjbS5nZXRDdXJzb3IoXCJlbmRcIik7XG5cbiAgICB2YXIgYXJyYXkgPSBjbS5zdGF0ZS5tYXJrZWRTZWxlY3Rpb247XG4gICAgaWYgKCFhcnJheS5sZW5ndGgpIHJldHVybiBjb3ZlclJhbmdlKGNtLCBmcm9tLCB0byk7XG5cbiAgICB2YXIgY292ZXJTdGFydCA9IGFycmF5WzBdLmZpbmQoKSwgY292ZXJFbmQgPSBhcnJheVthcnJheS5sZW5ndGggLSAxXS5maW5kKCk7XG4gICAgaWYgKCFjb3ZlclN0YXJ0IHx8ICFjb3ZlckVuZCB8fCB0by5saW5lIC0gZnJvbS5saW5lIDw9IENIVU5LX1NJWkUgfHxcbiAgICAgICAgY21wKGZyb20sIGNvdmVyRW5kLnRvKSA+PSAwIHx8IGNtcCh0bywgY292ZXJTdGFydC5mcm9tKSA8PSAwKVxuICAgICAgcmV0dXJuIHJlc2V0KGNtKTtcblxuICAgIHdoaWxlIChjbXAoZnJvbSwgY292ZXJTdGFydC5mcm9tKSA+IDApIHtcbiAgICAgIGFycmF5LnNoaWZ0KCkuY2xlYXIoKTtcbiAgICAgIGNvdmVyU3RhcnQgPSBhcnJheVswXS5maW5kKCk7XG4gICAgfVxuICAgIGlmIChjbXAoZnJvbSwgY292ZXJTdGFydC5mcm9tKSA8IDApIHtcbiAgICAgIGlmIChjb3ZlclN0YXJ0LnRvLmxpbmUgLSBmcm9tLmxpbmUgPCBDSFVOS19TSVpFKSB7XG4gICAgICAgIGFycmF5LnNoaWZ0KCkuY2xlYXIoKTtcbiAgICAgICAgY292ZXJSYW5nZShjbSwgZnJvbSwgY292ZXJTdGFydC50bywgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3ZlclJhbmdlKGNtLCBmcm9tLCBjb3ZlclN0YXJ0LmZyb20sIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChjbXAodG8sIGNvdmVyRW5kLnRvKSA8IDApIHtcbiAgICAgIGFycmF5LnBvcCgpLmNsZWFyKCk7XG4gICAgICBjb3ZlckVuZCA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdLmZpbmQoKTtcbiAgICB9XG4gICAgaWYgKGNtcCh0bywgY292ZXJFbmQudG8pID4gMCkge1xuICAgICAgaWYgKHRvLmxpbmUgLSBjb3ZlckVuZC5mcm9tLmxpbmUgPCBDSFVOS19TSVpFKSB7XG4gICAgICAgIGFycmF5LnBvcCgpLmNsZWFyKCk7XG4gICAgICAgIGNvdmVyUmFuZ2UoY20sIGNvdmVyRW5kLmZyb20sIHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdmVyUmFuZ2UoY20sIGNvdmVyRW5kLnRvLCB0byk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkZWZpbmVPcHRpb24iLCJjbSIsInZhbCIsIm9sZCIsInByZXYiLCJJbml0Iiwic3RhdGUiLCJtYXJrZWRTZWxlY3Rpb24iLCJtYXJrZWRTZWxlY3Rpb25TdHlsZSIsInJlc2V0Iiwib24iLCJvbkN1cnNvckFjdGl2aXR5Iiwib25DaGFuZ2UiLCJvZmYiLCJjbGVhciIsIm9wZXJhdGlvbiIsInVwZGF0ZSIsImxlbmd0aCIsIkNIVU5LX1NJWkUiLCJQb3MiLCJjbXAiLCJjbXBQb3MiLCJjb3ZlclJhbmdlIiwiZnJvbSIsInRvIiwiYWRkQXQiLCJhcnJheSIsImNscyIsImxpbmUiLCJzdGFydCIsImVuZExpbmUiLCJhdEVuZCIsImVuZCIsIm1hcmsiLCJtYXJrVGV4dCIsImNsYXNzTmFtZSIsInB1c2giLCJzcGxpY2UiLCJpIiwicmFuZ2VzIiwibGlzdFNlbGVjdGlvbnMiLCJzb21ldGhpbmdTZWxlY3RlZCIsImdldEN1cnNvciIsImNvdmVyU3RhcnQiLCJmaW5kIiwiY292ZXJFbmQiLCJzaGlmdCIsInBvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/addon/selection/mark-selection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n// This is CodeMirror (https://codemirror.net/5), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n(function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    // Kludges for bugs and behavior differences that can't be feature\n    // detected are enabled based on userAgent etc sniffing.\n    var userAgent = navigator.userAgent;\n    var platform = navigator.platform;\n    var gecko = /gecko\\/\\d/i.test(userAgent);\n    var ie_upto10 = /MSIE \\d/.test(userAgent);\n    var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n    var edge = /Edge\\/(\\d+)/.exec(userAgent);\n    var ie = ie_upto10 || ie_11up || edge;\n    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n    var webkit = !edge && /WebKit\\//.test(userAgent);\n    var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n    var chrome = !edge && /Chrome\\/(\\d+)/.exec(userAgent);\n    var chrome_version = chrome && +chrome[1];\n    var presto = /Opera\\//.test(userAgent);\n    var safari = /Apple Computer/.test(navigator.vendor);\n    var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n    var phantom = /PhantomJS/.test(userAgent);\n    var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n    var android = /Android/.test(userAgent);\n    // This is woefully incomplete. Suggestions for alternative methods welcome.\n    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n    var mac = ios || /Mac/.test(platform);\n    var chromeOS = /\\bCrOS\\b/.test(userAgent);\n    var windows = /win/i.test(platform);\n    var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n    if (presto_version) {\n        presto_version = Number(presto_version[1]);\n    }\n    if (presto_version && presto_version >= 15) {\n        presto = false;\n        webkit = true;\n    }\n    // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n    var captureRightClick = gecko || ie && ie_version >= 9;\n    function classTest(cls) {\n        return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n    }\n    var rmClass = function(node, cls) {\n        var current = node.className;\n        var match = classTest(cls).exec(current);\n        if (match) {\n            var after = current.slice(match.index + match[0].length);\n            node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n        }\n    };\n    function removeChildren(e) {\n        for(var count = e.childNodes.length; count > 0; --count){\n            e.removeChild(e.firstChild);\n        }\n        return e;\n    }\n    function removeChildrenAndAdd(parent, e) {\n        return removeChildren(parent).appendChild(e);\n    }\n    function elt(tag, content, className, style) {\n        var e = document.createElement(tag);\n        if (className) {\n            e.className = className;\n        }\n        if (style) {\n            e.style.cssText = style;\n        }\n        if (typeof content == \"string\") {\n            e.appendChild(document.createTextNode(content));\n        } else if (content) {\n            for(var i = 0; i < content.length; ++i){\n                e.appendChild(content[i]);\n            }\n        }\n        return e;\n    }\n    // wrapper for elt, which removes the elt from the accessibility tree\n    function eltP(tag, content, className, style) {\n        var e = elt(tag, content, className, style);\n        e.setAttribute(\"role\", \"presentation\");\n        return e;\n    }\n    var range;\n    if (document.createRange) {\n        range = function(node, start, end, endNode) {\n            var r = document.createRange();\n            r.setEnd(endNode || node, end);\n            r.setStart(node, start);\n            return r;\n        };\n    } else {\n        range = function(node, start, end) {\n            var r = document.body.createTextRange();\n            try {\n                r.moveToElementText(node.parentNode);\n            } catch (e) {\n                return r;\n            }\n            r.collapse(true);\n            r.moveEnd(\"character\", end);\n            r.moveStart(\"character\", start);\n            return r;\n        };\n    }\n    function contains(parent, child) {\n        if (child.nodeType == 3) {\n            child = child.parentNode;\n        }\n        if (parent.contains) {\n            return parent.contains(child);\n        }\n        do {\n            if (child.nodeType == 11) {\n                child = child.host;\n            }\n            if (child == parent) {\n                return true;\n            }\n        }while (child = child.parentNode);\n    }\n    function activeElt(rootNode) {\n        // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n        // IE < 10 will throw when accessed while the page is loading or in an iframe.\n        // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n        var doc = rootNode.ownerDocument || rootNode;\n        var activeElement;\n        try {\n            activeElement = rootNode.activeElement;\n        } catch (e) {\n            activeElement = doc.body || null;\n        }\n        while(activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement){\n            activeElement = activeElement.shadowRoot.activeElement;\n        }\n        return activeElement;\n    }\n    function addClass(node, cls) {\n        var current = node.className;\n        if (!classTest(cls).test(current)) {\n            node.className += (current ? \" \" : \"\") + cls;\n        }\n    }\n    function joinClasses(a, b) {\n        var as = a.split(\" \");\n        for(var i = 0; i < as.length; i++){\n            if (as[i] && !classTest(as[i]).test(b)) {\n                b += \" \" + as[i];\n            }\n        }\n        return b;\n    }\n    var selectInput = function(node) {\n        node.select();\n    };\n    if (ios) {\n        selectInput = function(node) {\n            node.selectionStart = 0;\n            node.selectionEnd = node.value.length;\n        };\n    } else if (ie) {\n        selectInput = function(node) {\n            try {\n                node.select();\n            } catch (_e) {}\n        };\n    }\n    function doc(cm) {\n        return cm.display.wrapper.ownerDocument;\n    }\n    function root(cm) {\n        return rootNode(cm.display.wrapper);\n    }\n    function rootNode(element) {\n        // Detect modern browsers (2017+).\n        return element.getRootNode ? element.getRootNode() : element.ownerDocument;\n    }\n    function win(cm) {\n        return doc(cm).defaultView;\n    }\n    function bind(f) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function() {\n            return f.apply(null, args);\n        };\n    }\n    function copyObj(obj, target, overwrite) {\n        if (!target) {\n            target = {};\n        }\n        for(var prop in obj){\n            if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {\n                target[prop] = obj[prop];\n            }\n        }\n        return target;\n    }\n    // Counts the column offset in a string, taking tabs into account.\n    // Used mostly to find indentation.\n    function countColumn(string, end, tabSize, startIndex, startValue) {\n        if (end == null) {\n            end = string.search(/[^\\s\\u00a0]/);\n            if (end == -1) {\n                end = string.length;\n            }\n        }\n        for(var i = startIndex || 0, n = startValue || 0;;){\n            var nextTab = string.indexOf(\"\t\", i);\n            if (nextTab < 0 || nextTab >= end) {\n                return n + (end - i);\n            }\n            n += nextTab - i;\n            n += tabSize - n % tabSize;\n            i = nextTab + 1;\n        }\n    }\n    var Delayed = function() {\n        this.id = null;\n        this.f = null;\n        this.time = 0;\n        this.handler = bind(this.onTimeout, this);\n    };\n    Delayed.prototype.onTimeout = function(self1) {\n        self1.id = 0;\n        if (self1.time <= +new Date) {\n            self1.f();\n        } else {\n            setTimeout(self1.handler, self1.time - +new Date);\n        }\n    };\n    Delayed.prototype.set = function(ms, f) {\n        this.f = f;\n        var time = +new Date + ms;\n        if (!this.id || time < this.time) {\n            clearTimeout(this.id);\n            this.id = setTimeout(this.handler, ms);\n            this.time = time;\n        }\n    };\n    function indexOf(array, elt) {\n        for(var i = 0; i < array.length; ++i){\n            if (array[i] == elt) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    // Number of pixels added to scroller and sizer to hide scrollbar\n    var scrollerGap = 50;\n    // Returned or thrown by various protocols to signal 'I'm not\n    // handling this'.\n    var Pass = {\n        toString: function() {\n            return \"CodeMirror.Pass\";\n        }\n    };\n    // Reused option objects for setSelection & friends\n    var sel_dontScroll = {\n        scroll: false\n    }, sel_mouse = {\n        origin: \"*mouse\"\n    }, sel_move = {\n        origin: \"+move\"\n    };\n    // The inverse of countColumn -- find the offset that corresponds to\n    // a particular column.\n    function findColumn(string, goal, tabSize) {\n        for(var pos = 0, col = 0;;){\n            var nextTab = string.indexOf(\"\t\", pos);\n            if (nextTab == -1) {\n                nextTab = string.length;\n            }\n            var skipped = nextTab - pos;\n            if (nextTab == string.length || col + skipped >= goal) {\n                return pos + Math.min(skipped, goal - col);\n            }\n            col += nextTab - pos;\n            col += tabSize - col % tabSize;\n            pos = nextTab + 1;\n            if (col >= goal) {\n                return pos;\n            }\n        }\n    }\n    var spaceStrs = [\n        \"\"\n    ];\n    function spaceStr(n) {\n        while(spaceStrs.length <= n){\n            spaceStrs.push(lst(spaceStrs) + \" \");\n        }\n        return spaceStrs[n];\n    }\n    function lst(arr) {\n        return arr[arr.length - 1];\n    }\n    function map(array, f) {\n        var out = [];\n        for(var i = 0; i < array.length; i++){\n            out[i] = f(array[i], i);\n        }\n        return out;\n    }\n    function insertSorted(array, value, score) {\n        var pos = 0, priority = score(value);\n        while(pos < array.length && score(array[pos]) <= priority){\n            pos++;\n        }\n        array.splice(pos, 0, value);\n    }\n    function nothing() {}\n    function createObj(base, props) {\n        var inst;\n        if (Object.create) {\n            inst = Object.create(base);\n        } else {\n            nothing.prototype = base;\n            inst = new nothing();\n        }\n        if (props) {\n            copyObj(props, inst);\n        }\n        return inst;\n    }\n    var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n    function isWordCharBasic(ch) {\n        return /\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n    }\n    function isWordChar(ch, helper) {\n        if (!helper) {\n            return isWordCharBasic(ch);\n        }\n        if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) {\n            return true;\n        }\n        return helper.test(ch);\n    }\n    function isEmpty(obj) {\n        for(var n in obj){\n            if (obj.hasOwnProperty(n) && obj[n]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Extending unicode characters. A series of a non-extending char +\n    // any number of extending chars is treated as a single unit as far\n    // as editing and measuring is concerned. This is not fully correct,\n    // since some scripts/fonts/browsers also treat other configurations\n    // of code points as a group.\n    var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n    function isExtendingChar(ch) {\n        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n    }\n    // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n    function skipExtendingChars(str, pos, dir) {\n        while((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))){\n            pos += dir;\n        }\n        return pos;\n    }\n    // Returns the value from the range [`from`; `to`] that satisfies\n    // `pred` and is closest to `from`. Assumes that at least `to`\n    // satisfies `pred`. Supports `from` being greater than `to`.\n    function findFirst(pred, from, to) {\n        // At any point we are certain `to` satisfies `pred`, don't know\n        // whether `from` does.\n        var dir = from > to ? -1 : 1;\n        for(;;){\n            if (from == to) {\n                return from;\n            }\n            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n            if (mid == from) {\n                return pred(mid) ? from : to;\n            }\n            if (pred(mid)) {\n                to = mid;\n            } else {\n                from = mid + dir;\n            }\n        }\n    }\n    // BIDI HELPERS\n    function iterateBidiSections(order, from, to, f) {\n        if (!order) {\n            return f(from, to, \"ltr\", 0);\n        }\n        var found = false;\n        for(var i = 0; i < order.length; ++i){\n            var part = order[i];\n            if (part.from < to && part.to > from || from == to && part.to == from) {\n                f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n                found = true;\n            }\n        }\n        if (!found) {\n            f(from, to, \"ltr\");\n        }\n    }\n    var bidiOther = null;\n    function getBidiPartAt(order, ch, sticky) {\n        var found;\n        bidiOther = null;\n        for(var i = 0; i < order.length; ++i){\n            var cur = order[i];\n            if (cur.from < ch && cur.to > ch) {\n                return i;\n            }\n            if (cur.to == ch) {\n                if (cur.from != cur.to && sticky == \"before\") {\n                    found = i;\n                } else {\n                    bidiOther = i;\n                }\n            }\n            if (cur.from == ch) {\n                if (cur.from != cur.to && sticky != \"before\") {\n                    found = i;\n                } else {\n                    bidiOther = i;\n                }\n            }\n        }\n        return found != null ? found : bidiOther;\n    }\n    // Bidirectional ordering algorithm\n    // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n    // that this (partially) implements.\n    // One-char codes used for character types:\n    // L (L):   Left-to-Right\n    // R (R):   Right-to-Left\n    // r (AL):  Right-to-Left Arabic\n    // 1 (EN):  European Number\n    // + (ES):  European Number Separator\n    // % (ET):  European Number Terminator\n    // n (AN):  Arabic Number\n    // , (CS):  Common Number Separator\n    // m (NSM): Non-Spacing Mark\n    // b (BN):  Boundary Neutral\n    // s (B):   Paragraph Separator\n    // t (S):   Segment Separator\n    // w (WS):  Whitespace\n    // N (ON):  Other Neutrals\n    // Returns null if characters are ordered as they appear\n    // (left-to-right), or an array of sections ({from, to, level}\n    // objects) in the order in which they occur visually.\n    var bidiOrdering = function() {\n        // Character types for codepoints 0 to 0xff\n        var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n        // Character types for codepoints 0x600 to 0x6f9\n        var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n        function charType(code) {\n            if (code <= 0xf7) {\n                return lowTypes.charAt(code);\n            } else if (0x590 <= code && code <= 0x5f4) {\n                return \"R\";\n            } else if (0x600 <= code && code <= 0x6f9) {\n                return arabicTypes.charAt(code - 0x600);\n            } else if (0x6ee <= code && code <= 0x8ac) {\n                return \"r\";\n            } else if (0x2000 <= code && code <= 0x200b) {\n                return \"w\";\n            } else if (code == 0x200c) {\n                return \"b\";\n            } else {\n                return \"L\";\n            }\n        }\n        var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n        function BidiSpan(level, from, to) {\n            this.level = level;\n            this.from = from;\n            this.to = to;\n        }\n        return function(str, direction) {\n            var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n            if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) {\n                return false;\n            }\n            var len = str.length, types = [];\n            for(var i = 0; i < len; ++i){\n                types.push(charType(str.charCodeAt(i)));\n            }\n            // W1. Examine each non-spacing mark (NSM) in the level run, and\n            // change the type of the NSM to the type of the previous\n            // character. If the NSM is at the start of the level run, it will\n            // get the type of sor.\n            for(var i$1 = 0, prev = outerType; i$1 < len; ++i$1){\n                var type = types[i$1];\n                if (type == \"m\") {\n                    types[i$1] = prev;\n                } else {\n                    prev = type;\n                }\n            }\n            // W2. Search backwards from each instance of a European number\n            // until the first strong type (R, L, AL, or sor) is found. If an\n            // AL is found, change the type of the European number to Arabic\n            // number.\n            // W3. Change all ALs to R.\n            for(var i$2 = 0, cur = outerType; i$2 < len; ++i$2){\n                var type$1 = types[i$2];\n                if (type$1 == \"1\" && cur == \"r\") {\n                    types[i$2] = \"n\";\n                } else if (isStrong.test(type$1)) {\n                    cur = type$1;\n                    if (type$1 == \"r\") {\n                        types[i$2] = \"R\";\n                    }\n                }\n            }\n            // W4. A single European separator between two European numbers\n            // changes to a European number. A single common separator between\n            // two numbers of the same type changes to that type.\n            for(var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3){\n                var type$2 = types[i$3];\n                if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3 + 1] == \"1\") {\n                    types[i$3] = \"1\";\n                } else if (type$2 == \",\" && prev$1 == types[i$3 + 1] && (prev$1 == \"1\" || prev$1 == \"n\")) {\n                    types[i$3] = prev$1;\n                }\n                prev$1 = type$2;\n            }\n            // W5. A sequence of European terminators adjacent to European\n            // numbers changes to all European numbers.\n            // W6. Otherwise, separators and terminators change to Other\n            // Neutral.\n            for(var i$4 = 0; i$4 < len; ++i$4){\n                var type$3 = types[i$4];\n                if (type$3 == \",\") {\n                    types[i$4] = \"N\";\n                } else if (type$3 == \"%\") {\n                    var end = void 0;\n                    for(end = i$4 + 1; end < len && types[end] == \"%\"; ++end){}\n                    var replace = i$4 && types[i$4 - 1] == \"!\" || end < len && types[end] == \"1\" ? \"1\" : \"N\";\n                    for(var j = i$4; j < end; ++j){\n                        types[j] = replace;\n                    }\n                    i$4 = end - 1;\n                }\n            }\n            // W7. Search backwards from each instance of a European number\n            // until the first strong type (R, L, or sor) is found. If an L is\n            // found, then change the type of the European number to L.\n            for(var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5){\n                var type$4 = types[i$5];\n                if (cur$1 == \"L\" && type$4 == \"1\") {\n                    types[i$5] = \"L\";\n                } else if (isStrong.test(type$4)) {\n                    cur$1 = type$4;\n                }\n            }\n            // N1. A sequence of neutrals takes the direction of the\n            // surrounding strong text if the text on both sides has the same\n            // direction. European and Arabic numbers act as if they were R in\n            // terms of their influence on neutrals. Start-of-level-run (sor)\n            // and end-of-level-run (eor) are used at level run boundaries.\n            // N2. Any remaining neutrals take the embedding direction.\n            for(var i$6 = 0; i$6 < len; ++i$6){\n                if (isNeutral.test(types[i$6])) {\n                    var end$1 = void 0;\n                    for(end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1){}\n                    var before = (i$6 ? types[i$6 - 1] : outerType) == \"L\";\n                    var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n                    var replace$1 = before == after ? before ? \"L\" : \"R\" : outerType;\n                    for(var j$1 = i$6; j$1 < end$1; ++j$1){\n                        types[j$1] = replace$1;\n                    }\n                    i$6 = end$1 - 1;\n                }\n            }\n            // Here we depart from the documented algorithm, in order to avoid\n            // building up an actual levels array. Since there are only three\n            // levels (0, 1, 2) in an implementation that doesn't take\n            // explicit embedding into account, we can build up the order on\n            // the fly, without following the level-based algorithm.\n            var order = [], m;\n            for(var i$7 = 0; i$7 < len;){\n                if (countsAsLeft.test(types[i$7])) {\n                    var start = i$7;\n                    for(++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7){}\n                    order.push(new BidiSpan(0, start, i$7));\n                } else {\n                    var pos = i$7, at = order.length, isRTL = direction == \"rtl\" ? 1 : 0;\n                    for(++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7){}\n                    for(var j$2 = pos; j$2 < i$7;){\n                        if (countsAsNum.test(types[j$2])) {\n                            if (pos < j$2) {\n                                order.splice(at, 0, new BidiSpan(1, pos, j$2));\n                                at += isRTL;\n                            }\n                            var nstart = j$2;\n                            for(++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2){}\n                            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n                            at += isRTL;\n                            pos = j$2;\n                        } else {\n                            ++j$2;\n                        }\n                    }\n                    if (pos < i$7) {\n                        order.splice(at, 0, new BidiSpan(1, pos, i$7));\n                    }\n                }\n            }\n            if (direction == \"ltr\") {\n                if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n                    order[0].from = m[0].length;\n                    order.unshift(new BidiSpan(0, 0, m[0].length));\n                }\n                if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n                    lst(order).to -= m[0].length;\n                    order.push(new BidiSpan(0, len - m[0].length, len));\n                }\n            }\n            return direction == \"rtl\" ? order.reverse() : order;\n        };\n    }();\n    // Get the bidi ordering for the given line (and cache it). Returns\n    // false for lines that are fully left-to-right, and an array of\n    // BidiSpan objects otherwise.\n    function getOrder(line, direction) {\n        var order = line.order;\n        if (order == null) {\n            order = line.order = bidiOrdering(line.text, direction);\n        }\n        return order;\n    }\n    // EVENT HANDLING\n    // Lightweight event framework. on/off also work on DOM nodes,\n    // registering native DOM handlers.\n    var noHandlers = [];\n    var on = function(emitter, type, f) {\n        if (emitter.addEventListener) {\n            emitter.addEventListener(type, f, false);\n        } else if (emitter.attachEvent) {\n            emitter.attachEvent(\"on\" + type, f);\n        } else {\n            var map = emitter._handlers || (emitter._handlers = {});\n            map[type] = (map[type] || noHandlers).concat(f);\n        }\n    };\n    function getHandlers(emitter, type) {\n        return emitter._handlers && emitter._handlers[type] || noHandlers;\n    }\n    function off(emitter, type, f) {\n        if (emitter.removeEventListener) {\n            emitter.removeEventListener(type, f, false);\n        } else if (emitter.detachEvent) {\n            emitter.detachEvent(\"on\" + type, f);\n        } else {\n            var map = emitter._handlers, arr = map && map[type];\n            if (arr) {\n                var index = indexOf(arr, f);\n                if (index > -1) {\n                    map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n                }\n            }\n        }\n    }\n    function signal(emitter, type /*, values...*/ ) {\n        var handlers = getHandlers(emitter, type);\n        if (!handlers.length) {\n            return;\n        }\n        var args = Array.prototype.slice.call(arguments, 2);\n        for(var i = 0; i < handlers.length; ++i){\n            handlers[i].apply(null, args);\n        }\n    }\n    // The DOM events that CodeMirror handles can be overridden by\n    // registering a (non-DOM) handler on the editor for the event name,\n    // and preventDefault-ing the event in that handler.\n    function signalDOMEvent(cm, e, override) {\n        if (typeof e == \"string\") {\n            e = {\n                type: e,\n                preventDefault: function() {\n                    this.defaultPrevented = true;\n                }\n            };\n        }\n        signal(cm, override || e.type, cm, e);\n        return e_defaultPrevented(e) || e.codemirrorIgnore;\n    }\n    function signalCursorActivity(cm) {\n        var arr = cm._handlers && cm._handlers.cursorActivity;\n        if (!arr) {\n            return;\n        }\n        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n        for(var i = 0; i < arr.length; ++i){\n            if (indexOf(set, arr[i]) == -1) {\n                set.push(arr[i]);\n            }\n        }\n    }\n    function hasHandler(emitter, type) {\n        return getHandlers(emitter, type).length > 0;\n    }\n    // Add on and off methods to a constructor's prototype, to make\n    // registering events on such objects more convenient.\n    function eventMixin(ctor) {\n        ctor.prototype.on = function(type, f) {\n            on(this, type, f);\n        };\n        ctor.prototype.off = function(type, f) {\n            off(this, type, f);\n        };\n    }\n    // Due to the fact that we still support jurassic IE versions, some\n    // compatibility wrappers are needed.\n    function e_preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n        }\n    }\n    function e_stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        } else {\n            e.cancelBubble = true;\n        }\n    }\n    function e_defaultPrevented(e) {\n        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n    }\n    function e_stop(e) {\n        e_preventDefault(e);\n        e_stopPropagation(e);\n    }\n    function e_target(e) {\n        return e.target || e.srcElement;\n    }\n    function e_button(e) {\n        var b = e.which;\n        if (b == null) {\n            if (e.button & 1) {\n                b = 1;\n            } else if (e.button & 2) {\n                b = 3;\n            } else if (e.button & 4) {\n                b = 2;\n            }\n        }\n        if (mac && e.ctrlKey && b == 1) {\n            b = 3;\n        }\n        return b;\n    }\n    // Detect drag-and-drop\n    var dragAndDrop = function() {\n        // There is *some* kind of drag-and-drop support in IE6-8, but I\n        // couldn't get it to work yet.\n        if (ie && ie_version < 9) {\n            return false;\n        }\n        var div = elt(\"div\");\n        return \"draggable\" in div || \"dragDrop\" in div;\n    }();\n    var zwspSupported;\n    function zeroWidthElement(measure) {\n        if (zwspSupported == null) {\n            var test = elt(\"span\", \"\");\n            removeChildrenAndAdd(measure, elt(\"span\", [\n                test,\n                document.createTextNode(\"x\")\n            ]));\n            if (measure.firstChild.offsetHeight != 0) {\n                zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n            }\n        }\n        var node = zwspSupported ? elt(\"span\", \"\") : elt(\"span\", \"\\xa0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n        node.setAttribute(\"cm-text\", \"\");\n        return node;\n    }\n    // Feature-detect IE's crummy client rect reporting for bidi text\n    var badBidiRects;\n    function hasBadBidiRects(measure) {\n        if (badBidiRects != null) {\n            return badBidiRects;\n        }\n        var txt = removeChildrenAndAdd(measure, document.createTextNode(\"AA\"));\n        var r0 = range(txt, 0, 1).getBoundingClientRect();\n        var r1 = range(txt, 1, 2).getBoundingClientRect();\n        removeChildren(measure);\n        if (!r0 || r0.left == r0.right) {\n            return false;\n        } // Safari returns null in some cases (#2780)\n        return badBidiRects = r1.right - r0.right < 3;\n    }\n    // See if \"\".split is the broken IE version, if so, provide an\n    // alternative way to split lines.\n    var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n        var pos = 0, result = [], l = string.length;\n        while(pos <= l){\n            var nl = string.indexOf(\"\\n\", pos);\n            if (nl == -1) {\n                nl = string.length;\n            }\n            var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n            var rt = line.indexOf(\"\\r\");\n            if (rt != -1) {\n                result.push(line.slice(0, rt));\n                pos += rt + 1;\n            } else {\n                result.push(line);\n                pos = nl + 1;\n            }\n        }\n        return result;\n    } : function(string) {\n        return string.split(/\\r\\n?|\\n/);\n    };\n    var hasSelection = window.getSelection ? function(te) {\n        try {\n            return te.selectionStart != te.selectionEnd;\n        } catch (e) {\n            return false;\n        }\n    } : function(te) {\n        var range;\n        try {\n            range = te.ownerDocument.selection.createRange();\n        } catch (e) {}\n        if (!range || range.parentElement() != te) {\n            return false;\n        }\n        return range.compareEndPoints(\"StartToEnd\", range) != 0;\n    };\n    var hasCopyEvent = function() {\n        var e = elt(\"div\");\n        if (\"oncopy\" in e) {\n            return true;\n        }\n        e.setAttribute(\"oncopy\", \"return;\");\n        return typeof e.oncopy == \"function\";\n    }();\n    var badZoomedRects = null;\n    function hasBadZoomedRects(measure) {\n        if (badZoomedRects != null) {\n            return badZoomedRects;\n        }\n        var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n        var normal = node.getBoundingClientRect();\n        var fromRange = range(node, 0, 1).getBoundingClientRect();\n        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n    }\n    // Known modes, by name and by MIME\n    var modes = {}, mimeModes = {};\n    // Extra arguments are stored as the mode's dependencies, which is\n    // used by (legacy) mechanisms like loadmode.js to automatically\n    // load a mode. (Preferred mechanism is the require/define calls.)\n    function defineMode(name, mode) {\n        if (arguments.length > 2) {\n            mode.dependencies = Array.prototype.slice.call(arguments, 2);\n        }\n        modes[name] = mode;\n    }\n    function defineMIME(mime, spec) {\n        mimeModes[mime] = spec;\n    }\n    // Given a MIME type, a {name, ...options} config object, or a name\n    // string, return a mode config object.\n    function resolveMode(spec) {\n        if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n            spec = mimeModes[spec];\n        } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n            var found = mimeModes[spec.name];\n            if (typeof found == \"string\") {\n                found = {\n                    name: found\n                };\n            }\n            spec = createObj(found, spec);\n            spec.name = found.name;\n        } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n            return resolveMode(\"application/xml\");\n        } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n            return resolveMode(\"application/json\");\n        }\n        if (typeof spec == \"string\") {\n            return {\n                name: spec\n            };\n        } else {\n            return spec || {\n                name: \"null\"\n            };\n        }\n    }\n    // Given a mode spec (anything that resolveMode accepts), find and\n    // initialize an actual mode object.\n    function getMode(options, spec) {\n        spec = resolveMode(spec);\n        var mfactory = modes[spec.name];\n        if (!mfactory) {\n            return getMode(options, \"text/plain\");\n        }\n        var modeObj = mfactory(options, spec);\n        if (modeExtensions.hasOwnProperty(spec.name)) {\n            var exts = modeExtensions[spec.name];\n            for(var prop in exts){\n                if (!exts.hasOwnProperty(prop)) {\n                    continue;\n                }\n                if (modeObj.hasOwnProperty(prop)) {\n                    modeObj[\"_\" + prop] = modeObj[prop];\n                }\n                modeObj[prop] = exts[prop];\n            }\n        }\n        modeObj.name = spec.name;\n        if (spec.helperType) {\n            modeObj.helperType = spec.helperType;\n        }\n        if (spec.modeProps) {\n            for(var prop$1 in spec.modeProps){\n                modeObj[prop$1] = spec.modeProps[prop$1];\n            }\n        }\n        return modeObj;\n    }\n    // This can be used to attach properties to mode objects from\n    // outside the actual mode definition.\n    var modeExtensions = {};\n    function extendMode(mode, properties) {\n        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n        copyObj(properties, exts);\n    }\n    function copyState(mode, state) {\n        if (state === true) {\n            return state;\n        }\n        if (mode.copyState) {\n            return mode.copyState(state);\n        }\n        var nstate = {};\n        for(var n in state){\n            var val = state[n];\n            if (val instanceof Array) {\n                val = val.concat([]);\n            }\n            nstate[n] = val;\n        }\n        return nstate;\n    }\n    // Given a mode and a state (for that mode), find the inner mode and\n    // state at the position that the state refers to.\n    function innerMode(mode, state) {\n        var info;\n        while(mode.innerMode){\n            info = mode.innerMode(state);\n            if (!info || info.mode == mode) {\n                break;\n            }\n            state = info.state;\n            mode = info.mode;\n        }\n        return info || {\n            mode: mode,\n            state: state\n        };\n    }\n    function startState(mode, a1, a2) {\n        return mode.startState ? mode.startState(a1, a2) : true;\n    }\n    // STRING STREAM\n    // Fed to the mode parsers, provides helper functions to make\n    // parsers more succinct.\n    var StringStream = function(string, tabSize, lineOracle) {\n        this.pos = this.start = 0;\n        this.string = string;\n        this.tabSize = tabSize || 8;\n        this.lastColumnPos = this.lastColumnValue = 0;\n        this.lineStart = 0;\n        this.lineOracle = lineOracle;\n    };\n    StringStream.prototype.eol = function() {\n        return this.pos >= this.string.length;\n    };\n    StringStream.prototype.sol = function() {\n        return this.pos == this.lineStart;\n    };\n    StringStream.prototype.peek = function() {\n        return this.string.charAt(this.pos) || undefined;\n    };\n    StringStream.prototype.next = function() {\n        if (this.pos < this.string.length) {\n            return this.string.charAt(this.pos++);\n        }\n    };\n    StringStream.prototype.eat = function(match) {\n        var ch = this.string.charAt(this.pos);\n        var ok;\n        if (typeof match == \"string\") {\n            ok = ch == match;\n        } else {\n            ok = ch && (match.test ? match.test(ch) : match(ch));\n        }\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    };\n    StringStream.prototype.eatWhile = function(match) {\n        var start = this.pos;\n        while(this.eat(match)){}\n        return this.pos > start;\n    };\n    StringStream.prototype.eatSpace = function() {\n        var start = this.pos;\n        while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos))){\n            ++this.pos;\n        }\n        return this.pos > start;\n    };\n    StringStream.prototype.skipToEnd = function() {\n        this.pos = this.string.length;\n    };\n    StringStream.prototype.skipTo = function(ch) {\n        var found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    };\n    StringStream.prototype.backUp = function(n) {\n        this.pos -= n;\n    };\n    StringStream.prototype.column = function() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    };\n    StringStream.prototype.indentation = function() {\n        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    };\n    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            var cased = function(str) {\n                return caseInsensitive ? str.toLowerCase() : str;\n            };\n            var substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false) {\n                    this.pos += pattern.length;\n                }\n                return true;\n            }\n        } else {\n            var match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0) {\n                return null;\n            }\n            if (match && consume !== false) {\n                this.pos += match[0].length;\n            }\n            return match;\n        }\n    };\n    StringStream.prototype.current = function() {\n        return this.string.slice(this.start, this.pos);\n    };\n    StringStream.prototype.hideFirstChars = function(n, inner) {\n        this.lineStart += n;\n        try {\n            return inner();\n        } finally{\n            this.lineStart -= n;\n        }\n    };\n    StringStream.prototype.lookAhead = function(n) {\n        var oracle = this.lineOracle;\n        return oracle && oracle.lookAhead(n);\n    };\n    StringStream.prototype.baseToken = function() {\n        var oracle = this.lineOracle;\n        return oracle && oracle.baseToken(this.pos);\n    };\n    // Find the line object corresponding to the given line number.\n    function getLine(doc, n) {\n        n -= doc.first;\n        if (n < 0 || n >= doc.size) {\n            throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n        }\n        var chunk = doc;\n        while(!chunk.lines){\n            for(var i = 0;; ++i){\n                var child = chunk.children[i], sz = child.chunkSize();\n                if (n < sz) {\n                    chunk = child;\n                    break;\n                }\n                n -= sz;\n            }\n        }\n        return chunk.lines[n];\n    }\n    // Get the part of a document between two positions, as an array of\n    // strings.\n    function getBetween(doc, start, end) {\n        var out = [], n = start.line;\n        doc.iter(start.line, end.line + 1, function(line) {\n            var text = line.text;\n            if (n == end.line) {\n                text = text.slice(0, end.ch);\n            }\n            if (n == start.line) {\n                text = text.slice(start.ch);\n            }\n            out.push(text);\n            ++n;\n        });\n        return out;\n    }\n    // Get the lines between from and to, as array of strings.\n    function getLines(doc, from, to) {\n        var out = [];\n        doc.iter(from, to, function(line) {\n            out.push(line.text);\n        }); // iter aborts when callback returns truthy value\n        return out;\n    }\n    // Update the height of a line, propagating the height change\n    // upwards to parent nodes.\n    function updateLineHeight(line, height) {\n        var diff = height - line.height;\n        if (diff) {\n            for(var n = line; n; n = n.parent){\n                n.height += diff;\n            }\n        }\n    }\n    // Given a line object, find its line number by walking up through\n    // its parent links.\n    function lineNo(line) {\n        if (line.parent == null) {\n            return null;\n        }\n        var cur = line.parent, no = indexOf(cur.lines, line);\n        for(var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent){\n            for(var i = 0;; ++i){\n                if (chunk.children[i] == cur) {\n                    break;\n                }\n                no += chunk.children[i].chunkSize();\n            }\n        }\n        return no + cur.first;\n    }\n    // Find the line at the given vertical position, using the height\n    // information in the document tree.\n    function lineAtHeight(chunk, h) {\n        var n = chunk.first;\n        outer: do {\n            for(var i$1 = 0; i$1 < chunk.children.length; ++i$1){\n                var child = chunk.children[i$1], ch = child.height;\n                if (h < ch) {\n                    chunk = child;\n                    continue outer;\n                }\n                h -= ch;\n                n += child.chunkSize();\n            }\n            return n;\n        }while (!chunk.lines);\n        var i = 0;\n        for(; i < chunk.lines.length; ++i){\n            var line = chunk.lines[i], lh = line.height;\n            if (h < lh) {\n                break;\n            }\n            h -= lh;\n        }\n        return n + i;\n    }\n    function isLine(doc, l) {\n        return l >= doc.first && l < doc.first + doc.size;\n    }\n    function lineNumberFor(options, i) {\n        return String(options.lineNumberFormatter(i + options.firstLineNumber));\n    }\n    // A Pos instance represents a position within the text.\n    function Pos(line, ch, sticky) {\n        if (sticky === void 0) sticky = null;\n        if (!(this instanceof Pos)) {\n            return new Pos(line, ch, sticky);\n        }\n        this.line = line;\n        this.ch = ch;\n        this.sticky = sticky;\n    }\n    // Compare two positions, return 0 if they are the same, a negative\n    // number when a is less, and a positive number otherwise.\n    function cmp(a, b) {\n        return a.line - b.line || a.ch - b.ch;\n    }\n    function equalCursorPos(a, b) {\n        return a.sticky == b.sticky && cmp(a, b) == 0;\n    }\n    function copyPos(x) {\n        return Pos(x.line, x.ch);\n    }\n    function maxPos(a, b) {\n        return cmp(a, b) < 0 ? b : a;\n    }\n    function minPos(a, b) {\n        return cmp(a, b) < 0 ? a : b;\n    }\n    // Most of the external API clips given positions to make sure they\n    // actually exist within the document.\n    function clipLine(doc, n) {\n        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));\n    }\n    function clipPos(doc, pos) {\n        if (pos.line < doc.first) {\n            return Pos(doc.first, 0);\n        }\n        var last = doc.first + doc.size - 1;\n        if (pos.line > last) {\n            return Pos(last, getLine(doc, last).text.length);\n        }\n        return clipToLen(pos, getLine(doc, pos.line).text.length);\n    }\n    function clipToLen(pos, linelen) {\n        var ch = pos.ch;\n        if (ch == null || ch > linelen) {\n            return Pos(pos.line, linelen);\n        } else if (ch < 0) {\n            return Pos(pos.line, 0);\n        } else {\n            return pos;\n        }\n    }\n    function clipPosArray(doc, array) {\n        var out = [];\n        for(var i = 0; i < array.length; i++){\n            out[i] = clipPos(doc, array[i]);\n        }\n        return out;\n    }\n    var SavedContext = function(state, lookAhead) {\n        this.state = state;\n        this.lookAhead = lookAhead;\n    };\n    var Context = function(doc, state, line, lookAhead) {\n        this.state = state;\n        this.doc = doc;\n        this.line = line;\n        this.maxLookAhead = lookAhead || 0;\n        this.baseTokens = null;\n        this.baseTokenPos = 1;\n    };\n    Context.prototype.lookAhead = function(n) {\n        var line = this.doc.getLine(this.line + n);\n        if (line != null && n > this.maxLookAhead) {\n            this.maxLookAhead = n;\n        }\n        return line;\n    };\n    Context.prototype.baseToken = function(n) {\n        if (!this.baseTokens) {\n            return null;\n        }\n        while(this.baseTokens[this.baseTokenPos] <= n){\n            this.baseTokenPos += 2;\n        }\n        var type = this.baseTokens[this.baseTokenPos + 1];\n        return {\n            type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n\n        };\n    };\n    Context.prototype.nextLine = function() {\n        this.line++;\n        if (this.maxLookAhead > 0) {\n            this.maxLookAhead--;\n        }\n    };\n    Context.fromSaved = function(doc, saved, line) {\n        if (saved instanceof SavedContext) {\n            return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);\n        } else {\n            return new Context(doc, copyState(doc.mode, saved), line);\n        }\n    };\n    Context.prototype.save = function(copy) {\n        var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n    };\n    // Compute a style array (an array starting with a mode generation\n    // -- for invalidation -- followed by pairs of end positions and\n    // style strings), which is used to highlight the tokens on the\n    // line.\n    function highlightLine(cm, line, context, forceToEnd) {\n        // A styles array always starts with a number identifying the\n        // mode/overlays that it is based on (for easy invalidation).\n        var st = [\n            cm.state.modeGen\n        ], lineClasses = {};\n        // Compute the base array of styles\n        runMode(cm, line.text, cm.doc.mode, context, function(end, style) {\n            return st.push(end, style);\n        }, lineClasses, forceToEnd);\n        var state = context.state;\n        // Run overlays, adjust style array.\n        var loop = function(o) {\n            context.baseTokens = st;\n            var overlay = cm.state.overlays[o], i = 1, at = 0;\n            context.state = true;\n            runMode(cm, line.text, overlay.mode, context, function(end, style) {\n                var start = i;\n                // Ensure there's a token end at the current position, and that i points at it\n                while(at < end){\n                    var i_end = st[i];\n                    if (i_end > end) {\n                        st.splice(i, 1, end, st[i + 1], i_end);\n                    }\n                    i += 2;\n                    at = Math.min(end, i_end);\n                }\n                if (!style) {\n                    return;\n                }\n                if (overlay.opaque) {\n                    st.splice(start, i - start, end, \"overlay \" + style);\n                    i = start + 2;\n                } else {\n                    for(; start < i; start += 2){\n                        var cur = st[start + 1];\n                        st[start + 1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n                    }\n                }\n            }, lineClasses);\n            context.state = state;\n            context.baseTokens = null;\n            context.baseTokenPos = 1;\n        };\n        for(var o = 0; o < cm.state.overlays.length; ++o)loop(o);\n        return {\n            styles: st,\n            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null\n        };\n    }\n    function getLineStyles(cm, line, updateFrontier) {\n        if (!line.styles || line.styles[0] != cm.state.modeGen) {\n            var context = getContextBefore(cm, lineNo(line));\n            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n            var result = highlightLine(cm, line, context);\n            if (resetState) {\n                context.state = resetState;\n            }\n            line.stateAfter = context.save(!resetState);\n            line.styles = result.styles;\n            if (result.classes) {\n                line.styleClasses = result.classes;\n            } else if (line.styleClasses) {\n                line.styleClasses = null;\n            }\n            if (updateFrontier === cm.doc.highlightFrontier) {\n                cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n            }\n        }\n        return line.styles;\n    }\n    function getContextBefore(cm, n, precise) {\n        var doc = cm.doc, display = cm.display;\n        if (!doc.mode.startState) {\n            return new Context(doc, true, n);\n        }\n        var start = findStartLine(cm, n, precise);\n        var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n        var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n        doc.iter(start, n, function(line) {\n            processLine(cm, line.text, context);\n            var pos = context.line;\n            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n            context.nextLine();\n        });\n        if (precise) {\n            doc.modeFrontier = context.line;\n        }\n        return context;\n    }\n    // Lightweight form of highlight -- proceed over this line and\n    // update state, but don't save a style array. Used for lines that\n    // aren't currently visible.\n    function processLine(cm, text, context, startAt) {\n        var mode = cm.doc.mode;\n        var stream = new StringStream(text, cm.options.tabSize, context);\n        stream.start = stream.pos = startAt || 0;\n        if (text == \"\") {\n            callBlankLine(mode, context.state);\n        }\n        while(!stream.eol()){\n            readToken(mode, stream, context.state);\n            stream.start = stream.pos;\n        }\n    }\n    function callBlankLine(mode, state) {\n        if (mode.blankLine) {\n            return mode.blankLine(state);\n        }\n        if (!mode.innerMode) {\n            return;\n        }\n        var inner = innerMode(mode, state);\n        if (inner.mode.blankLine) {\n            return inner.mode.blankLine(inner.state);\n        }\n    }\n    function readToken(mode, stream, state, inner) {\n        for(var i = 0; i < 10; i++){\n            if (inner) {\n                inner[0] = innerMode(mode, state).mode;\n            }\n            var style = mode.token(stream, state);\n            if (stream.pos > stream.start) {\n                return style;\n            }\n        }\n        throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n    }\n    var Token = function(stream, type, state) {\n        this.start = stream.start;\n        this.end = stream.pos;\n        this.string = stream.current();\n        this.type = type || null;\n        this.state = state;\n    };\n    // Utility for getTokenAt and getLineTokens\n    function takeToken(cm, pos, precise, asArray) {\n        var doc = cm.doc, mode = doc.mode, style;\n        pos = clipPos(doc, pos);\n        var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n        var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n        if (asArray) {\n            tokens = [];\n        }\n        while((asArray || stream.pos < pos.ch) && !stream.eol()){\n            stream.start = stream.pos;\n            style = readToken(mode, stream, context.state);\n            if (asArray) {\n                tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));\n            }\n        }\n        return asArray ? tokens : new Token(stream, style, context.state);\n    }\n    function extractLineClasses(type, output) {\n        if (type) {\n            for(;;){\n                var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n                if (!lineClass) {\n                    break;\n                }\n                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n                var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n                if (output[prop] == null) {\n                    output[prop] = lineClass[2];\n                } else if (!new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\").test(output[prop])) {\n                    output[prop] += \" \" + lineClass[2];\n                }\n            }\n        }\n        return type;\n    }\n    // Run the given mode's parser over a line, calling f for each token.\n    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n        var flattenSpans = mode.flattenSpans;\n        if (flattenSpans == null) {\n            flattenSpans = cm.options.flattenSpans;\n        }\n        var curStart = 0, curStyle = null;\n        var stream = new StringStream(text, cm.options.tabSize, context), style;\n        var inner = cm.options.addModeClass && [\n            null\n        ];\n        if (text == \"\") {\n            extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n        }\n        while(!stream.eol()){\n            if (stream.pos > cm.options.maxHighlightLength) {\n                flattenSpans = false;\n                if (forceToEnd) {\n                    processLine(cm, text, context, stream.pos);\n                }\n                stream.pos = text.length;\n                style = null;\n            } else {\n                style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n            }\n            if (inner) {\n                var mName = inner[0].name;\n                if (mName) {\n                    style = \"m-\" + (style ? mName + \" \" + style : mName);\n                }\n            }\n            if (!flattenSpans || curStyle != style) {\n                while(curStart < stream.start){\n                    curStart = Math.min(stream.start, curStart + 5000);\n                    f(curStart, curStyle);\n                }\n                curStyle = style;\n            }\n            stream.start = stream.pos;\n        }\n        while(curStart < stream.pos){\n            // Webkit seems to refuse to render text nodes longer than 57444\n            // characters, and returns inaccurate measurements in nodes\n            // starting around 5000 chars.\n            var pos = Math.min(stream.pos, curStart + 5000);\n            f(pos, curStyle);\n            curStart = pos;\n        }\n    }\n    // Finds the line to start with when starting a parse. Tries to\n    // find a line with a stateAfter, so that it can start with a\n    // valid state. If that fails, it returns the line with the\n    // smallest indentation, which tends to need the least context to\n    // parse correctly.\n    function findStartLine(cm, n, precise) {\n        var minindent, minline, doc = cm.doc;\n        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n        for(var search = n; search > lim; --search){\n            if (search <= doc.first) {\n                return doc.first;\n            }\n            var line = getLine(doc, search - 1), after = line.stateAfter;\n            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {\n                return search;\n            }\n            var indented = countColumn(line.text, null, cm.options.tabSize);\n            if (minline == null || minindent > indented) {\n                minline = search - 1;\n                minindent = indented;\n            }\n        }\n        return minline;\n    }\n    function retreatFrontier(doc, n) {\n        doc.modeFrontier = Math.min(doc.modeFrontier, n);\n        if (doc.highlightFrontier < n - 10) {\n            return;\n        }\n        var start = doc.first;\n        for(var line = n - 1; line > start; line--){\n            var saved = getLine(doc, line).stateAfter;\n            // change is on 3\n            // state on line 1 looked ahead 2 -- so saw 3\n            // test 1 + 2 < 3 should cover this\n            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n                start = line + 1;\n                break;\n            }\n        }\n        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n    }\n    // Optimize some code when these features are not used.\n    var sawReadOnlySpans = false, sawCollapsedSpans = false;\n    function seeReadOnlySpans() {\n        sawReadOnlySpans = true;\n    }\n    function seeCollapsedSpans() {\n        sawCollapsedSpans = true;\n    }\n    // TEXTMARKER SPANS\n    function MarkedSpan(marker, from, to) {\n        this.marker = marker;\n        this.from = from;\n        this.to = to;\n    }\n    // Search an array of spans for a span matching the given marker.\n    function getMarkedSpanFor(spans, marker) {\n        if (spans) {\n            for(var i = 0; i < spans.length; ++i){\n                var span = spans[i];\n                if (span.marker == marker) {\n                    return span;\n                }\n            }\n        }\n    }\n    // Remove a span from an array, returning undefined if no spans are\n    // left (we don't store arrays for lines without spans).\n    function removeMarkedSpan(spans, span) {\n        var r;\n        for(var i = 0; i < spans.length; ++i){\n            if (spans[i] != span) {\n                (r || (r = [])).push(spans[i]);\n            }\n        }\n        return r;\n    }\n    // Add a span to a line.\n    function addMarkedSpan(line, span, op) {\n        var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));\n        if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {\n            line.markedSpans.push(span);\n        } else {\n            line.markedSpans = line.markedSpans ? line.markedSpans.concat([\n                span\n            ]) : [\n                span\n            ];\n            if (inThisOp) {\n                inThisOp.add(line.markedSpans);\n            }\n        }\n        span.marker.attachLine(line);\n    }\n    // Used for the algorithm that adjusts markers for a change in the\n    // document. These functions cut an array of spans at a given\n    // character position, returning an array of remaining chunks (or\n    // undefined if nothing remains).\n    function markedSpansBefore(old, startCh, isInsert) {\n        var nw;\n        if (old) {\n            for(var i = 0; i < old.length; ++i){\n                var span = old[i], marker = span.marker;\n                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n                if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n                    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n                }\n            }\n        }\n        return nw;\n    }\n    function markedSpansAfter(old, endCh, isInsert) {\n        var nw;\n        if (old) {\n            for(var i = 0; i < old.length; ++i){\n                var span = old[i], marker = span.marker;\n                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n                if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n                    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n                }\n            }\n        }\n        return nw;\n    }\n    // Given a change object, compute the new set of marker spans that\n    // cover the line in which the change took place. Removes spans\n    // entirely within the change, reconnects spans belonging to the\n    // same marker that appear on both sides of the change, and cuts off\n    // spans partially within the change. Returns an array of span\n    // arrays with one element for each line in (after) the change.\n    function stretchSpansOverChange(doc, change) {\n        if (change.full) {\n            return null;\n        }\n        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n        if (!oldFirst && !oldLast) {\n            return null;\n        }\n        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n        // Get the spans that 'stick out' on both sides\n        var first = markedSpansBefore(oldFirst, startCh, isInsert);\n        var last = markedSpansAfter(oldLast, endCh, isInsert);\n        // Next, merge those two ends\n        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n        if (first) {\n            // Fix up .to properties of first\n            for(var i = 0; i < first.length; ++i){\n                var span = first[i];\n                if (span.to == null) {\n                    var found = getMarkedSpanFor(last, span.marker);\n                    if (!found) {\n                        span.to = startCh;\n                    } else if (sameLine) {\n                        span.to = found.to == null ? null : found.to + offset;\n                    }\n                }\n            }\n        }\n        if (last) {\n            // Fix up .from in last (or move them into first in case of sameLine)\n            for(var i$1 = 0; i$1 < last.length; ++i$1){\n                var span$1 = last[i$1];\n                if (span$1.to != null) {\n                    span$1.to += offset;\n                }\n                if (span$1.from == null) {\n                    var found$1 = getMarkedSpanFor(first, span$1.marker);\n                    if (!found$1) {\n                        span$1.from = offset;\n                        if (sameLine) {\n                            (first || (first = [])).push(span$1);\n                        }\n                    }\n                } else {\n                    span$1.from += offset;\n                    if (sameLine) {\n                        (first || (first = [])).push(span$1);\n                    }\n                }\n            }\n        }\n        // Make sure we didn't create any zero-length spans\n        if (first) {\n            first = clearEmptySpans(first);\n        }\n        if (last && last != first) {\n            last = clearEmptySpans(last);\n        }\n        var newMarkers = [\n            first\n        ];\n        if (!sameLine) {\n            // Fill gap with whole-line-spans\n            var gap = change.text.length - 2, gapMarkers;\n            if (gap > 0 && first) {\n                for(var i$2 = 0; i$2 < first.length; ++i$2){\n                    if (first[i$2].to == null) {\n                        (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));\n                    }\n                }\n            }\n            for(var i$3 = 0; i$3 < gap; ++i$3){\n                newMarkers.push(gapMarkers);\n            }\n            newMarkers.push(last);\n        }\n        return newMarkers;\n    }\n    // Remove spans that are empty and don't have a clearWhenEmpty\n    // option of false.\n    function clearEmptySpans(spans) {\n        for(var i = 0; i < spans.length; ++i){\n            var span = spans[i];\n            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n                spans.splice(i--, 1);\n            }\n        }\n        if (!spans.length) {\n            return null;\n        }\n        return spans;\n    }\n    // Used to 'clip' out readOnly ranges when making a change.\n    function removeReadOnlyRanges(doc, from, to) {\n        var markers = null;\n        doc.iter(from.line, to.line + 1, function(line) {\n            if (line.markedSpans) {\n                for(var i = 0; i < line.markedSpans.length; ++i){\n                    var mark = line.markedSpans[i].marker;\n                    if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {\n                        (markers || (markers = [])).push(mark);\n                    }\n                }\n            }\n        });\n        if (!markers) {\n            return null;\n        }\n        var parts = [\n            {\n                from: from,\n                to: to\n            }\n        ];\n        for(var i = 0; i < markers.length; ++i){\n            var mk = markers[i], m = mk.find(0);\n            for(var j = 0; j < parts.length; ++j){\n                var p = parts[j];\n                if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {\n                    continue;\n                }\n                var newParts = [\n                    j,\n                    1\n                ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {\n                    newParts.push({\n                        from: p.from,\n                        to: m.from\n                    });\n                }\n                if (dto > 0 || !mk.inclusiveRight && !dto) {\n                    newParts.push({\n                        from: m.to,\n                        to: p.to\n                    });\n                }\n                parts.splice.apply(parts, newParts);\n                j += newParts.length - 3;\n            }\n        }\n        return parts;\n    }\n    // Connect or disconnect spans from a line.\n    function detachMarkedSpans(line) {\n        var spans = line.markedSpans;\n        if (!spans) {\n            return;\n        }\n        for(var i = 0; i < spans.length; ++i){\n            spans[i].marker.detachLine(line);\n        }\n        line.markedSpans = null;\n    }\n    function attachMarkedSpans(line, spans) {\n        if (!spans) {\n            return;\n        }\n        for(var i = 0; i < spans.length; ++i){\n            spans[i].marker.attachLine(line);\n        }\n        line.markedSpans = spans;\n    }\n    // Helpers used when computing which overlapping collapsed span\n    // counts as the larger one.\n    function extraLeft(marker) {\n        return marker.inclusiveLeft ? -1 : 0;\n    }\n    function extraRight(marker) {\n        return marker.inclusiveRight ? 1 : 0;\n    }\n    // Returns a number indicating which of two overlapping collapsed\n    // spans is larger (and thus includes the other). Falls back to\n    // comparing ids when the spans cover exactly the same range.\n    function compareCollapsedMarkers(a, b) {\n        var lenDiff = a.lines.length - b.lines.length;\n        if (lenDiff != 0) {\n            return lenDiff;\n        }\n        var aPos = a.find(), bPos = b.find();\n        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n        if (fromCmp) {\n            return -fromCmp;\n        }\n        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n        if (toCmp) {\n            return toCmp;\n        }\n        return b.id - a.id;\n    }\n    // Find out whether a line ends or starts in a collapsed span. If\n    // so, return the marker for that span.\n    function collapsedSpanAtSide(line, start) {\n        var sps = sawCollapsedSpans && line.markedSpans, found;\n        if (sps) {\n            for(var sp = void 0, i = 0; i < sps.length; ++i){\n                sp = sps[i];\n                if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n                    found = sp.marker;\n                }\n            }\n        }\n        return found;\n    }\n    function collapsedSpanAtStart(line) {\n        return collapsedSpanAtSide(line, true);\n    }\n    function collapsedSpanAtEnd(line) {\n        return collapsedSpanAtSide(line, false);\n    }\n    function collapsedSpanAround(line, ch) {\n        var sps = sawCollapsedSpans && line.markedSpans, found;\n        if (sps) {\n            for(var i = 0; i < sps.length; ++i){\n                var sp = sps[i];\n                if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n                    found = sp.marker;\n                }\n            }\n        }\n        return found;\n    }\n    // Test whether there exists a collapsed span that partially\n    // overlaps (covers the start or end, but not both) of a new span.\n    // Such overlap is not allowed.\n    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n        var line = getLine(doc, lineNo);\n        var sps = sawCollapsedSpans && line.markedSpans;\n        if (sps) {\n            for(var i = 0; i < sps.length; ++i){\n                var sp = sps[i];\n                if (!sp.marker.collapsed) {\n                    continue;\n                }\n                var found = sp.marker.find(0);\n                var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n                var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n                if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n                    continue;\n                }\n                if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {\n                    return true;\n                }\n            }\n        }\n    }\n    // A visual line is a line as drawn on the screen. Folding, for\n    // example, can cause multiple logical lines to appear on the same\n    // visual line. This finds the start of the visual line that the\n    // given line is part of (usually that is the line itself).\n    function visualLine(line) {\n        var merged;\n        while(merged = collapsedSpanAtStart(line)){\n            line = merged.find(-1, true).line;\n        }\n        return line;\n    }\n    function visualLineEnd(line) {\n        var merged;\n        while(merged = collapsedSpanAtEnd(line)){\n            line = merged.find(1, true).line;\n        }\n        return line;\n    }\n    // Returns an array of logical lines that continue the visual line\n    // started by the argument, or undefined if there are no such lines.\n    function visualLineContinued(line) {\n        var merged, lines;\n        while(merged = collapsedSpanAtEnd(line)){\n            line = merged.find(1, true).line;\n            (lines || (lines = [])).push(line);\n        }\n        return lines;\n    }\n    // Get the line number of the start of the visual line that the\n    // given line number is part of.\n    function visualLineNo(doc, lineN) {\n        var line = getLine(doc, lineN), vis = visualLine(line);\n        if (line == vis) {\n            return lineN;\n        }\n        return lineNo(vis);\n    }\n    // Get the line number of the start of the next visual line after\n    // the given line.\n    function visualLineEndNo(doc, lineN) {\n        if (lineN > doc.lastLine()) {\n            return lineN;\n        }\n        var line = getLine(doc, lineN), merged;\n        if (!lineIsHidden(doc, line)) {\n            return lineN;\n        }\n        while(merged = collapsedSpanAtEnd(line)){\n            line = merged.find(1, true).line;\n        }\n        return lineNo(line) + 1;\n    }\n    // Compute whether a line is hidden. Lines count as hidden when they\n    // are part of a visual line that starts with another line, or when\n    // they are entirely covered by collapsed, non-widget span.\n    function lineIsHidden(doc, line) {\n        var sps = sawCollapsedSpans && line.markedSpans;\n        if (sps) {\n            for(var sp = void 0, i = 0; i < sps.length; ++i){\n                sp = sps[i];\n                if (!sp.marker.collapsed) {\n                    continue;\n                }\n                if (sp.from == null) {\n                    return true;\n                }\n                if (sp.marker.widgetNode) {\n                    continue;\n                }\n                if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {\n                    return true;\n                }\n            }\n        }\n    }\n    function lineIsHiddenInner(doc, line, span) {\n        if (span.to == null) {\n            var end = span.marker.find(1, true);\n            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n        }\n        if (span.marker.inclusiveRight && span.to == line.text.length) {\n            return true;\n        }\n        for(var sp = void 0, i = 0; i < line.markedSpans.length; ++i){\n            sp = line.markedSpans[i];\n            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {\n                return true;\n            }\n        }\n    }\n    // Find the height above the given line.\n    function heightAtLine(lineObj) {\n        lineObj = visualLine(lineObj);\n        var h = 0, chunk = lineObj.parent;\n        for(var i = 0; i < chunk.lines.length; ++i){\n            var line = chunk.lines[i];\n            if (line == lineObj) {\n                break;\n            } else {\n                h += line.height;\n            }\n        }\n        for(var p = chunk.parent; p; chunk = p, p = chunk.parent){\n            for(var i$1 = 0; i$1 < p.children.length; ++i$1){\n                var cur = p.children[i$1];\n                if (cur == chunk) {\n                    break;\n                } else {\n                    h += cur.height;\n                }\n            }\n        }\n        return h;\n    }\n    // Compute the character length of a line, taking into account\n    // collapsed ranges (see markText) that might hide parts, and join\n    // other lines onto it.\n    function lineLength(line) {\n        if (line.height == 0) {\n            return 0;\n        }\n        var len = line.text.length, merged, cur = line;\n        while(merged = collapsedSpanAtStart(cur)){\n            var found = merged.find(0, true);\n            cur = found.from.line;\n            len += found.from.ch - found.to.ch;\n        }\n        cur = line;\n        while(merged = collapsedSpanAtEnd(cur)){\n            var found$1 = merged.find(0, true);\n            len -= cur.text.length - found$1.from.ch;\n            cur = found$1.to.line;\n            len += cur.text.length - found$1.to.ch;\n        }\n        return len;\n    }\n    // Find the longest line in the document.\n    function findMaxLine(cm) {\n        var d = cm.display, doc = cm.doc;\n        d.maxLine = getLine(doc, doc.first);\n        d.maxLineLength = lineLength(d.maxLine);\n        d.maxLineChanged = true;\n        doc.iter(function(line) {\n            var len = lineLength(line);\n            if (len > d.maxLineLength) {\n                d.maxLineLength = len;\n                d.maxLine = line;\n            }\n        });\n    }\n    // LINE DATA STRUCTURE\n    // Line objects. These hold state related to a line, including\n    // highlighting info (the styles array).\n    var Line = function(text, markedSpans, estimateHeight) {\n        this.text = text;\n        attachMarkedSpans(this, markedSpans);\n        this.height = estimateHeight ? estimateHeight(this) : 1;\n    };\n    Line.prototype.lineNo = function() {\n        return lineNo(this);\n    };\n    eventMixin(Line);\n    // Change the content (text, markers) of a line. Automatically\n    // invalidates cached information and tries to re-estimate the\n    // line's height.\n    function updateLine(line, text, markedSpans, estimateHeight) {\n        line.text = text;\n        if (line.stateAfter) {\n            line.stateAfter = null;\n        }\n        if (line.styles) {\n            line.styles = null;\n        }\n        if (line.order != null) {\n            line.order = null;\n        }\n        detachMarkedSpans(line);\n        attachMarkedSpans(line, markedSpans);\n        var estHeight = estimateHeight ? estimateHeight(line) : 1;\n        if (estHeight != line.height) {\n            updateLineHeight(line, estHeight);\n        }\n    }\n    // Detach a line from the document tree and its markers.\n    function cleanUpLine(line) {\n        line.parent = null;\n        detachMarkedSpans(line);\n    }\n    // Convert a style as returned by a mode (either null, or a string\n    // containing one or more styles) to a CSS style. This is cached,\n    // and also looks for line-wide styles.\n    var styleToClassCache = {}, styleToClassCacheWithMode = {};\n    function interpretTokenStyle(style, options) {\n        if (!style || /^\\s*$/.test(style)) {\n            return null;\n        }\n        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n        return cache[style] || (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n    }\n    // Render the DOM representation of the text of a line. Also builds\n    // up a 'line map', which points at the DOM nodes that represent\n    // specific stretches of text, and is used by the measuring code.\n    // The returned object contains the DOM node, this map, and\n    // information about line-wide styles that were set by the mode.\n    function buildLineContent(cm, lineView) {\n        // The padding-right forces the element to have a 'border', which\n        // is needed on Webkit to be able to get line-level bounding\n        // rectangles for it (in measureChar).\n        var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n        var builder = {\n            pre: eltP(\"pre\", [\n                content\n            ], \"CodeMirror-line\"),\n            content: content,\n            col: 0,\n            pos: 0,\n            cm: cm,\n            trailingSpace: false,\n            splitSpaces: cm.getOption(\"lineWrapping\")\n        };\n        lineView.measure = {};\n        // Iterate over the logical lines that make up this visual line.\n        for(var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++){\n            var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0;\n            builder.pos = 0;\n            builder.addToken = buildToken;\n            // Optionally wire in some hacks into the token-rendering\n            // algorithm, to deal with browser quirks.\n            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {\n                builder.addToken = buildTokenBadBidi(builder.addToken, order);\n            }\n            builder.map = [];\n            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n            if (line.styleClasses) {\n                if (line.styleClasses.bgClass) {\n                    builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n                }\n                if (line.styleClasses.textClass) {\n                    builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n                }\n            }\n            // Ensure at least a single node is present, for measuring.\n            if (builder.map.length == 0) {\n                builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n            }\n            // Store the map and a cache object for the current logical line\n            if (i == 0) {\n                lineView.measure.map = builder.map;\n                lineView.measure.cache = {};\n            } else {\n                (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n                (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n            }\n        }\n        // See issue #2901\n        if (webkit) {\n            var last = builder.content.lastChild;\n            if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(\".cm-tab\")) {\n                builder.content.className = \"cm-tab-wrap-hack\";\n            }\n        }\n        signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n        if (builder.pre.className) {\n            builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n        }\n        return builder;\n    }\n    function defaultSpecialCharPlaceholder(ch) {\n        var token = elt(\"span\", \"\", \"cm-invalidchar\");\n        token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n        token.setAttribute(\"aria-label\", token.title);\n        return token;\n    }\n    // Build up the DOM representation for a single token, and add it to\n    // the line map. Takes care to render special characters separately.\n    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n        if (!text) {\n            return;\n        }\n        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n        var special = builder.cm.state.specialChars, mustWrap = false;\n        var content;\n        if (!special.test(text)) {\n            builder.col += text.length;\n            content = document.createTextNode(displayText);\n            builder.map.push(builder.pos, builder.pos + text.length, content);\n            if (ie && ie_version < 9) {\n                mustWrap = true;\n            }\n            builder.pos += text.length;\n        } else {\n            content = document.createDocumentFragment();\n            var pos = 0;\n            while(true){\n                special.lastIndex = pos;\n                var m = special.exec(text);\n                var skipped = m ? m.index - pos : text.length - pos;\n                if (skipped) {\n                    var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n                    if (ie && ie_version < 9) {\n                        content.appendChild(elt(\"span\", [\n                            txt\n                        ]));\n                    } else {\n                        content.appendChild(txt);\n                    }\n                    builder.map.push(builder.pos, builder.pos + skipped, txt);\n                    builder.col += skipped;\n                    builder.pos += skipped;\n                }\n                if (!m) {\n                    break;\n                }\n                pos += skipped + 1;\n                var txt$1 = void 0;\n                if (m[0] == \"\t\") {\n                    var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n                    txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n                    txt$1.setAttribute(\"role\", \"presentation\");\n                    txt$1.setAttribute(\"cm-text\", \"\t\");\n                    builder.col += tabWidth;\n                } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n                    txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\" : \"\", \"cm-invalidchar\"));\n                    txt$1.setAttribute(\"cm-text\", m[0]);\n                    builder.col += 1;\n                } else {\n                    txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n                    txt$1.setAttribute(\"cm-text\", m[0]);\n                    if (ie && ie_version < 9) {\n                        content.appendChild(elt(\"span\", [\n                            txt$1\n                        ]));\n                    } else {\n                        content.appendChild(txt$1);\n                    }\n                    builder.col += 1;\n                }\n                builder.map.push(builder.pos, builder.pos + 1, txt$1);\n                builder.pos++;\n            }\n        }\n        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n        if (style || startStyle || endStyle || mustWrap || css || attributes) {\n            var fullStyle = style || \"\";\n            if (startStyle) {\n                fullStyle += startStyle;\n            }\n            if (endStyle) {\n                fullStyle += endStyle;\n            }\n            var token = elt(\"span\", [\n                content\n            ], fullStyle, css);\n            if (attributes) {\n                for(var attr in attributes){\n                    if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\") {\n                        token.setAttribute(attr, attributes[attr]);\n                    }\n                }\n            }\n            return builder.content.appendChild(token);\n        }\n        builder.content.appendChild(content);\n    }\n    // Change some spaces to NBSP to prevent the browser from collapsing\n    // trailing spaces at the end of a line when rendering text (issue #1362).\n    function splitSpaces(text, trailingBefore) {\n        if (text.length > 1 && !/  /.test(text)) {\n            return text;\n        }\n        var spaceBefore = trailingBefore, result = \"\";\n        for(var i = 0; i < text.length; i++){\n            var ch = text.charAt(i);\n            if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {\n                ch = \"\\xa0\";\n            }\n            result += ch;\n            spaceBefore = ch == \" \";\n        }\n        return result;\n    }\n    // Work around nonsense dimensions being reported for stretches of\n    // right-to-left text.\n    function buildTokenBadBidi(inner, order) {\n        return function(builder, text, style, startStyle, endStyle, css, attributes) {\n            style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n            var start = builder.pos, end = start + text.length;\n            for(;;){\n                // Find the part that overlaps with the start of this text\n                var part = void 0;\n                for(var i = 0; i < order.length; i++){\n                    part = order[i];\n                    if (part.to > start && part.from <= start) {\n                        break;\n                    }\n                }\n                if (part.to >= end) {\n                    return inner(builder, text, style, startStyle, endStyle, css, attributes);\n                }\n                inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n                startStyle = null;\n                text = text.slice(part.to - start);\n                start = part.to;\n            }\n        };\n    }\n    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n        var widget = !ignoreWidget && marker.widgetNode;\n        if (widget) {\n            builder.map.push(builder.pos, builder.pos + size, widget);\n        }\n        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n            if (!widget) {\n                widget = builder.content.appendChild(document.createElement(\"span\"));\n            }\n            widget.setAttribute(\"cm-marker\", marker.id);\n        }\n        if (widget) {\n            builder.cm.display.input.setUneditable(widget);\n            builder.content.appendChild(widget);\n        }\n        builder.pos += size;\n        builder.trailingSpace = false;\n    }\n    // Outputs a number of spans to make up a line, taking highlighting\n    // and marked text into account.\n    function insertLineContent(line, builder, styles) {\n        var spans = line.markedSpans, allText = line.text, at = 0;\n        if (!spans) {\n            for(var i$1 = 1; i$1 < styles.length; i$1 += 2){\n                builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));\n            }\n            return;\n        }\n        var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n        for(;;){\n            if (nextChange == pos) {\n                spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n                attributes = null;\n                collapsed = null;\n                nextChange = Infinity;\n                var foundBookmarks = [], endStyles = void 0;\n                for(var j = 0; j < spans.length; ++j){\n                    var sp = spans[j], m = sp.marker;\n                    if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n                        foundBookmarks.push(m);\n                    } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n                        if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n                            nextChange = sp.to;\n                            spanEndStyle = \"\";\n                        }\n                        if (m.className) {\n                            spanStyle += \" \" + m.className;\n                        }\n                        if (m.css) {\n                            css = (css ? css + \";\" : \"\") + m.css;\n                        }\n                        if (m.startStyle && sp.from == pos) {\n                            spanStartStyle += \" \" + m.startStyle;\n                        }\n                        if (m.endStyle && sp.to == nextChange) {\n                            (endStyles || (endStyles = [])).push(m.endStyle, sp.to);\n                        }\n                        // support for the old title property\n                        // https://github.com/codemirror/CodeMirror/pull/5673\n                        if (m.title) {\n                            (attributes || (attributes = {})).title = m.title;\n                        }\n                        if (m.attributes) {\n                            for(var attr in m.attributes){\n                                (attributes || (attributes = {}))[attr] = m.attributes[attr];\n                            }\n                        }\n                        if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {\n                            collapsed = sp;\n                        }\n                    } else if (sp.from > pos && nextChange > sp.from) {\n                        nextChange = sp.from;\n                    }\n                }\n                if (endStyles) {\n                    for(var j$1 = 0; j$1 < endStyles.length; j$1 += 2){\n                        if (endStyles[j$1 + 1] == nextChange) {\n                            spanEndStyle += \" \" + endStyles[j$1];\n                        }\n                    }\n                }\n                if (!collapsed || collapsed.from == pos) {\n                    for(var j$2 = 0; j$2 < foundBookmarks.length; ++j$2){\n                        buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n                    }\n                }\n                if (collapsed && (collapsed.from || 0) == pos) {\n                    buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n                    if (collapsed.to == null) {\n                        return;\n                    }\n                    if (collapsed.to == pos) {\n                        collapsed = false;\n                    }\n                }\n            }\n            if (pos >= len) {\n                break;\n            }\n            var upto = Math.min(len, nextChange);\n            while(true){\n                if (text) {\n                    var end = pos + text.length;\n                    if (!collapsed) {\n                        var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n                    }\n                    if (end >= upto) {\n                        text = text.slice(upto - pos);\n                        pos = upto;\n                        break;\n                    }\n                    pos = end;\n                    spanStartStyle = \"\";\n                }\n                text = allText.slice(at, at = styles[i++]);\n                style = interpretTokenStyle(styles[i++], builder.cm.options);\n            }\n        }\n    }\n    // These objects are used to represent the visible (currently drawn)\n    // part of the document. A LineView may correspond to multiple\n    // logical lines, if those are connected by collapsed ranges.\n    function LineView(doc, line, lineN) {\n        // The starting line\n        this.line = line;\n        // Continuing lines, if any\n        this.rest = visualLineContinued(line);\n        // Number of logical lines in this visual line\n        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n        this.node = this.text = null;\n        this.hidden = lineIsHidden(doc, line);\n    }\n    // Create a range of LineView objects for the given lines.\n    function buildViewArray(cm, from, to) {\n        var array = [], nextPos;\n        for(var pos = from; pos < to; pos = nextPos){\n            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n            nextPos = pos + view.size;\n            array.push(view);\n        }\n        return array;\n    }\n    var operationGroup = null;\n    function pushOperation(op) {\n        if (operationGroup) {\n            operationGroup.ops.push(op);\n        } else {\n            op.ownsGroup = operationGroup = {\n                ops: [\n                    op\n                ],\n                delayedCallbacks: []\n            };\n        }\n    }\n    function fireCallbacksForOps(group) {\n        // Calls delayed callbacks and cursorActivity handlers until no\n        // new ones appear\n        var callbacks = group.delayedCallbacks, i = 0;\n        do {\n            for(; i < callbacks.length; i++){\n                callbacks[i].call(null);\n            }\n            for(var j = 0; j < group.ops.length; j++){\n                var op = group.ops[j];\n                if (op.cursorActivityHandlers) {\n                    while(op.cursorActivityCalled < op.cursorActivityHandlers.length){\n                        op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n                    }\n                }\n            }\n        }while (i < callbacks.length);\n    }\n    function finishOperation(op, endCb) {\n        var group = op.ownsGroup;\n        if (!group) {\n            return;\n        }\n        try {\n            fireCallbacksForOps(group);\n        } finally{\n            operationGroup = null;\n            endCb(group);\n        }\n    }\n    var orphanDelayedCallbacks = null;\n    // Often, we want to signal events at a point where we are in the\n    // middle of some work, but don't want the handler to start calling\n    // other methods on the editor, which might be in an inconsistent\n    // state or simply not expect any other events to happen.\n    // signalLater looks whether there are any handlers, and schedules\n    // them to be executed when the last operation ends, or, if no\n    // operation is active, when a timeout fires.\n    function signalLater(emitter, type /*, values...*/ ) {\n        var arr = getHandlers(emitter, type);\n        if (!arr.length) {\n            return;\n        }\n        var args = Array.prototype.slice.call(arguments, 2), list;\n        if (operationGroup) {\n            list = operationGroup.delayedCallbacks;\n        } else if (orphanDelayedCallbacks) {\n            list = orphanDelayedCallbacks;\n        } else {\n            list = orphanDelayedCallbacks = [];\n            setTimeout(fireOrphanDelayed, 0);\n        }\n        var loop = function(i) {\n            list.push(function() {\n                return arr[i].apply(null, args);\n            });\n        };\n        for(var i = 0; i < arr.length; ++i)loop(i);\n    }\n    function fireOrphanDelayed() {\n        var delayed = orphanDelayedCallbacks;\n        orphanDelayedCallbacks = null;\n        for(var i = 0; i < delayed.length; ++i){\n            delayed[i]();\n        }\n    }\n    // When an aspect of a line changes, a string is added to\n    // lineView.changes. This updates the relevant part of the line's\n    // DOM structure.\n    function updateLineForChanges(cm, lineView, lineN, dims) {\n        for(var j = 0; j < lineView.changes.length; j++){\n            var type = lineView.changes[j];\n            if (type == \"text\") {\n                updateLineText(cm, lineView);\n            } else if (type == \"gutter\") {\n                updateLineGutter(cm, lineView, lineN, dims);\n            } else if (type == \"class\") {\n                updateLineClasses(cm, lineView);\n            } else if (type == \"widget\") {\n                updateLineWidgets(cm, lineView, dims);\n            }\n        }\n        lineView.changes = null;\n    }\n    // Lines with gutter elements, widgets or a background class need to\n    // be wrapped, and have the extra elements added to the wrapper div\n    function ensureLineWrapped(lineView) {\n        if (lineView.node == lineView.text) {\n            lineView.node = elt(\"div\", null, null, \"position: relative\");\n            if (lineView.text.parentNode) {\n                lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n            }\n            lineView.node.appendChild(lineView.text);\n            if (ie && ie_version < 8) {\n                lineView.node.style.zIndex = 2;\n            }\n        }\n        return lineView.node;\n    }\n    function updateLineBackground(cm, lineView) {\n        var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n        if (cls) {\n            cls += \" CodeMirror-linebackground\";\n        }\n        if (lineView.background) {\n            if (cls) {\n                lineView.background.className = cls;\n            } else {\n                lineView.background.parentNode.removeChild(lineView.background);\n                lineView.background = null;\n            }\n        } else if (cls) {\n            var wrap = ensureLineWrapped(lineView);\n            lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n            cm.display.input.setUneditable(lineView.background);\n        }\n    }\n    // Wrapper around buildLineContent which will reuse the structure\n    // in display.externalMeasured when possible.\n    function getLineContent(cm, lineView) {\n        var ext = cm.display.externalMeasured;\n        if (ext && ext.line == lineView.line) {\n            cm.display.externalMeasured = null;\n            lineView.measure = ext.measure;\n            return ext.built;\n        }\n        return buildLineContent(cm, lineView);\n    }\n    // Redraw the line's text. Interacts with the background and text\n    // classes because the mode may output tokens that influence these\n    // classes.\n    function updateLineText(cm, lineView) {\n        var cls = lineView.text.className;\n        var built = getLineContent(cm, lineView);\n        if (lineView.text == lineView.node) {\n            lineView.node = built.pre;\n        }\n        lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n        lineView.text = built.pre;\n        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n            lineView.bgClass = built.bgClass;\n            lineView.textClass = built.textClass;\n            updateLineClasses(cm, lineView);\n        } else if (cls) {\n            lineView.text.className = cls;\n        }\n    }\n    function updateLineClasses(cm, lineView) {\n        updateLineBackground(cm, lineView);\n        if (lineView.line.wrapClass) {\n            ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n        } else if (lineView.node != lineView.text) {\n            lineView.node.className = \"\";\n        }\n        var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n        lineView.text.className = textClass || \"\";\n    }\n    function updateLineGutter(cm, lineView, lineN, dims) {\n        if (lineView.gutter) {\n            lineView.node.removeChild(lineView.gutter);\n            lineView.gutter = null;\n        }\n        if (lineView.gutterBackground) {\n            lineView.node.removeChild(lineView.gutterBackground);\n            lineView.gutterBackground = null;\n        }\n        if (lineView.line.gutterClass) {\n            var wrap = ensureLineWrapped(lineView);\n            lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass, \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + dims.gutterTotalWidth + \"px\");\n            cm.display.input.setUneditable(lineView.gutterBackground);\n            wrap.insertBefore(lineView.gutterBackground, lineView.text);\n        }\n        var markers = lineView.line.gutterMarkers;\n        if (cm.options.lineNumbers || markers) {\n            var wrap$1 = ensureLineWrapped(lineView);\n            var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n            gutterWrap.setAttribute(\"aria-hidden\", \"true\");\n            cm.display.input.setUneditable(gutterWrap);\n            wrap$1.insertBefore(gutterWrap, lineView.text);\n            if (lineView.line.gutterClass) {\n                gutterWrap.className += \" \" + lineView.line.gutterClass;\n            }\n            if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"])) {\n                lineView.lineNumber = gutterWrap.appendChild(elt(\"div\", lineNumberFor(cm.options, lineN), \"CodeMirror-linenumber CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \" + cm.display.lineNumInnerWidth + \"px\"));\n            }\n            if (markers) {\n                for(var k = 0; k < cm.display.gutterSpecs.length; ++k){\n                    var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n                    if (found) {\n                        gutterWrap.appendChild(elt(\"div\", [\n                            found\n                        ], \"CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n                    }\n                }\n            }\n        }\n    }\n    function updateLineWidgets(cm, lineView, dims) {\n        if (lineView.alignable) {\n            lineView.alignable = null;\n        }\n        var isWidget = classTest(\"CodeMirror-linewidget\");\n        for(var node = lineView.node.firstChild, next = void 0; node; node = next){\n            next = node.nextSibling;\n            if (isWidget.test(node.className)) {\n                lineView.node.removeChild(node);\n            }\n        }\n        insertLineWidgets(cm, lineView, dims);\n    }\n    // Build a line's DOM representation from scratch\n    function buildLineElement(cm, lineView, lineN, dims) {\n        var built = getLineContent(cm, lineView);\n        lineView.text = lineView.node = built.pre;\n        if (built.bgClass) {\n            lineView.bgClass = built.bgClass;\n        }\n        if (built.textClass) {\n            lineView.textClass = built.textClass;\n        }\n        updateLineClasses(cm, lineView);\n        updateLineGutter(cm, lineView, lineN, dims);\n        insertLineWidgets(cm, lineView, dims);\n        return lineView.node;\n    }\n    // A lineView may contain multiple logical lines (when merged by\n    // collapsed spans). The widgets for all of them need to be drawn.\n    function insertLineWidgets(cm, lineView, dims) {\n        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n        if (lineView.rest) {\n            for(var i = 0; i < lineView.rest.length; i++){\n                insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n            }\n        }\n    }\n    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n        if (!line.widgets) {\n            return;\n        }\n        var wrap = ensureLineWrapped(lineView);\n        for(var i = 0, ws = line.widgets; i < ws.length; ++i){\n            var widget = ws[i], node = elt(\"div\", [\n                widget.node\n            ], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n            if (!widget.handleMouseEvents) {\n                node.setAttribute(\"cm-ignore-events\", \"true\");\n            }\n            positionLineWidget(widget, node, lineView, dims);\n            cm.display.input.setUneditable(node);\n            if (allowAbove && widget.above) {\n                wrap.insertBefore(node, lineView.gutter || lineView.text);\n            } else {\n                wrap.appendChild(node);\n            }\n            signalLater(widget, \"redraw\");\n        }\n    }\n    function positionLineWidget(widget, node, lineView, dims) {\n        if (widget.noHScroll) {\n            (lineView.alignable || (lineView.alignable = [])).push(node);\n            var width = dims.wrapperWidth;\n            node.style.left = dims.fixedPos + \"px\";\n            if (!widget.coverGutter) {\n                width -= dims.gutterTotalWidth;\n                node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n            }\n            node.style.width = width + \"px\";\n        }\n        if (widget.coverGutter) {\n            node.style.zIndex = 5;\n            node.style.position = \"relative\";\n            if (!widget.noHScroll) {\n                node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n            }\n        }\n    }\n    function widgetHeight(widget) {\n        if (widget.height != null) {\n            return widget.height;\n        }\n        var cm = widget.doc.cm;\n        if (!cm) {\n            return 0;\n        }\n        if (!contains(document.body, widget.node)) {\n            var parentStyle = \"position: relative;\";\n            if (widget.coverGutter) {\n                parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n            }\n            if (widget.noHScroll) {\n                parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n            }\n            removeChildrenAndAdd(cm.display.measure, elt(\"div\", [\n                widget.node\n            ], null, parentStyle));\n        }\n        return widget.height = widget.node.parentNode.offsetHeight;\n    }\n    // Return true when the given mouse event happened in a widget\n    function eventInWidget(display, e) {\n        for(var n = e_target(e); n != display.wrapper; n = n.parentNode){\n            if (!n || n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\" || n.parentNode == display.sizer && n != display.mover) {\n                return true;\n            }\n        }\n    }\n    // POSITION MEASUREMENT\n    function paddingTop(display) {\n        return display.lineSpace.offsetTop;\n    }\n    function paddingVert(display) {\n        return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n    }\n    function paddingH(display) {\n        if (display.cachedPaddingH) {\n            return display.cachedPaddingH;\n        }\n        var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n        var data = {\n            left: parseInt(style.paddingLeft),\n            right: parseInt(style.paddingRight)\n        };\n        if (!isNaN(data.left) && !isNaN(data.right)) {\n            display.cachedPaddingH = data;\n        }\n        return data;\n    }\n    function scrollGap(cm) {\n        return scrollerGap - cm.display.nativeBarWidth;\n    }\n    function displayWidth(cm) {\n        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n    }\n    function displayHeight(cm) {\n        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n    }\n    // Ensure the lineView.wrapping.heights array is populated. This is\n    // an array of bottom offsets for the lines that make up a drawn\n    // line. When lineWrapping is on, there might be more than one\n    // height.\n    function ensureLineHeights(cm, lineView, rect) {\n        var wrapping = cm.options.lineWrapping;\n        var curWidth = wrapping && displayWidth(cm);\n        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n            var heights = lineView.measure.heights = [];\n            if (wrapping) {\n                lineView.measure.width = curWidth;\n                var rects = lineView.text.firstChild.getClientRects();\n                for(var i = 0; i < rects.length - 1; i++){\n                    var cur = rects[i], next = rects[i + 1];\n                    if (Math.abs(cur.bottom - next.bottom) > 2) {\n                        heights.push((cur.bottom + next.top) / 2 - rect.top);\n                    }\n                }\n            }\n            heights.push(rect.bottom - rect.top);\n        }\n    }\n    // Find a line map (mapping character offsets to text nodes) and a\n    // measurement cache for the given line number. (A line view might\n    // contain multiple lines when collapsed ranges are present.)\n    function mapFromLineView(lineView, line, lineN) {\n        if (lineView.line == line) {\n            return {\n                map: lineView.measure.map,\n                cache: lineView.measure.cache\n            };\n        }\n        if (lineView.rest) {\n            for(var i = 0; i < lineView.rest.length; i++){\n                if (lineView.rest[i] == line) {\n                    return {\n                        map: lineView.measure.maps[i],\n                        cache: lineView.measure.caches[i]\n                    };\n                }\n            }\n            for(var i$1 = 0; i$1 < lineView.rest.length; i$1++){\n                if (lineNo(lineView.rest[i$1]) > lineN) {\n                    return {\n                        map: lineView.measure.maps[i$1],\n                        cache: lineView.measure.caches[i$1],\n                        before: true\n                    };\n                }\n            }\n        }\n    }\n    // Render a line into the hidden node display.externalMeasured. Used\n    // when measurement is needed for a line that's not in the viewport.\n    function updateExternalMeasurement(cm, line) {\n        line = visualLine(line);\n        var lineN = lineNo(line);\n        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n        view.lineN = lineN;\n        var built = view.built = buildLineContent(cm, view);\n        view.text = built.pre;\n        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n        return view;\n    }\n    // Get a {top, bottom, left, right} box (in line-local coordinates)\n    // for a given character.\n    function measureChar(cm, line, ch, bias) {\n        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n    }\n    // Find a line view that corresponds to the given line number.\n    function findViewForLine(cm, lineN) {\n        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n            return cm.display.view[findViewIndex(cm, lineN)];\n        }\n        var ext = cm.display.externalMeasured;\n        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n            return ext;\n        }\n    }\n    // Measurement can be split in two steps, the set-up work that\n    // applies to the whole line, and the measurement of the actual\n    // character. Functions like coordsChar, that need to do a lot of\n    // measurements in a row, can thus ensure that the set-up work is\n    // only done once.\n    function prepareMeasureForLine(cm, line) {\n        var lineN = lineNo(line);\n        var view = findViewForLine(cm, lineN);\n        if (view && !view.text) {\n            view = null;\n        } else if (view && view.changes) {\n            updateLineForChanges(cm, view, lineN, getDimensions(cm));\n            cm.curOp.forceUpdate = true;\n        }\n        if (!view) {\n            view = updateExternalMeasurement(cm, line);\n        }\n        var info = mapFromLineView(view, line, lineN);\n        return {\n            line: line,\n            view: view,\n            rect: null,\n            map: info.map,\n            cache: info.cache,\n            before: info.before,\n            hasHeights: false\n        };\n    }\n    // Given a prepared measurement object, measures the position of an\n    // actual character (or fetches it from the cache).\n    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n        if (prepared.before) {\n            ch = -1;\n        }\n        var key = ch + (bias || \"\"), found;\n        if (prepared.cache.hasOwnProperty(key)) {\n            found = prepared.cache[key];\n        } else {\n            if (!prepared.rect) {\n                prepared.rect = prepared.view.text.getBoundingClientRect();\n            }\n            if (!prepared.hasHeights) {\n                ensureLineHeights(cm, prepared.view, prepared.rect);\n                prepared.hasHeights = true;\n            }\n            found = measureCharInner(cm, prepared, ch, bias);\n            if (!found.bogus) {\n                prepared.cache[key] = found;\n            }\n        }\n        return {\n            left: found.left,\n            right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom\n        };\n    }\n    var nullRect = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    function nodeAndOffsetInLineMap(map, ch, bias) {\n        var node, start, end, collapse, mStart, mEnd;\n        // First, search the line map for the text node corresponding to,\n        // or closest to, the target character.\n        for(var i = 0; i < map.length; i += 3){\n            mStart = map[i];\n            mEnd = map[i + 1];\n            if (ch < mStart) {\n                start = 0;\n                end = 1;\n                collapse = \"left\";\n            } else if (ch < mEnd) {\n                start = ch - mStart;\n                end = start + 1;\n            } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n                end = mEnd - mStart;\n                start = end - 1;\n                if (ch >= mEnd) {\n                    collapse = \"right\";\n                }\n            }\n            if (start != null) {\n                node = map[i + 2];\n                if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\")) {\n                    collapse = bias;\n                }\n                if (bias == \"left\" && start == 0) {\n                    while(i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft){\n                        node = map[(i -= 3) + 2];\n                        collapse = \"left\";\n                    }\n                }\n                if (bias == \"right\" && start == mEnd - mStart) {\n                    while(i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft){\n                        node = map[(i += 3) + 2];\n                        collapse = \"right\";\n                    }\n                }\n                break;\n            }\n        }\n        return {\n            node: node,\n            start: start,\n            end: end,\n            collapse: collapse,\n            coverStart: mStart,\n            coverEnd: mEnd\n        };\n    }\n    function getUsefulRect(rects, bias) {\n        var rect = nullRect;\n        if (bias == \"left\") {\n            for(var i = 0; i < rects.length; i++){\n                if ((rect = rects[i]).left != rect.right) {\n                    break;\n                }\n            }\n        } else {\n            for(var i$1 = rects.length - 1; i$1 >= 0; i$1--){\n                if ((rect = rects[i$1]).left != rect.right) {\n                    break;\n                }\n            }\n        }\n        return rect;\n    }\n    function measureCharInner(cm, prepared, ch, bias) {\n        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n        var rect;\n        if (node.nodeType == 3) {\n            for(var i$1 = 0; i$1 < 4; i$1++){\n                while(start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))){\n                    --start;\n                }\n                while(place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))){\n                    ++end;\n                }\n                if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n                    rect = node.parentNode.getBoundingClientRect();\n                } else {\n                    rect = getUsefulRect(range(node, start, end).getClientRects(), bias);\n                }\n                if (rect.left || rect.right || start == 0) {\n                    break;\n                }\n                end = start;\n                start = start - 1;\n                collapse = \"right\";\n            }\n            if (ie && ie_version < 11) {\n                rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n            }\n        } else {\n            if (start > 0) {\n                collapse = bias = \"right\";\n            }\n            var rects;\n            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n                rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n            } else {\n                rect = node.getBoundingClientRect();\n            }\n        }\n        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n            var rSpan = node.parentNode.getClientRects()[0];\n            if (rSpan) {\n                rect = {\n                    left: rSpan.left,\n                    right: rSpan.left + charWidth(cm.display),\n                    top: rSpan.top,\n                    bottom: rSpan.bottom\n                };\n            } else {\n                rect = nullRect;\n            }\n        }\n        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n        var mid = (rtop + rbot) / 2;\n        var heights = prepared.view.measure.heights;\n        var i = 0;\n        for(; i < heights.length - 1; i++){\n            if (mid < heights[i]) {\n                break;\n            }\n        }\n        var top = i ? heights[i - 1] : 0, bot = heights[i];\n        var result = {\n            left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n            right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n            top: top,\n            bottom: bot\n        };\n        if (!rect.left && !rect.right) {\n            result.bogus = true;\n        }\n        if (!cm.options.singleCursorHeightPerLine) {\n            result.rtop = rtop;\n            result.rbottom = rbot;\n        }\n        return result;\n    }\n    // Work around problem with bounding client rects on ranges being\n    // returned incorrectly when zoomed on IE10 and below.\n    function maybeUpdateRectForZooming(measure, rect) {\n        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n            return rect;\n        }\n        var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n        var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n        return {\n            left: rect.left * scaleX,\n            right: rect.right * scaleX,\n            top: rect.top * scaleY,\n            bottom: rect.bottom * scaleY\n        };\n    }\n    function clearLineMeasurementCacheFor(lineView) {\n        if (lineView.measure) {\n            lineView.measure.cache = {};\n            lineView.measure.heights = null;\n            if (lineView.rest) {\n                for(var i = 0; i < lineView.rest.length; i++){\n                    lineView.measure.caches[i] = {};\n                }\n            }\n        }\n    }\n    function clearLineMeasurementCache(cm) {\n        cm.display.externalMeasure = null;\n        removeChildren(cm.display.lineMeasure);\n        for(var i = 0; i < cm.display.view.length; i++){\n            clearLineMeasurementCacheFor(cm.display.view[i]);\n        }\n    }\n    function clearCaches(cm) {\n        clearLineMeasurementCache(cm);\n        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n        if (!cm.options.lineWrapping) {\n            cm.display.maxLineChanged = true;\n        }\n        cm.display.lineNumChars = null;\n    }\n    function pageScrollX(doc) {\n        // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n        // which causes page_Offset and bounding client rects to use\n        // different reference viewports and invalidate our calculations.\n        if (chrome && android) {\n            return -(doc.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc.body).marginLeft));\n        }\n        return doc.defaultView.pageXOffset || (doc.documentElement || doc.body).scrollLeft;\n    }\n    function pageScrollY(doc) {\n        if (chrome && android) {\n            return -(doc.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc.body).marginTop));\n        }\n        return doc.defaultView.pageYOffset || (doc.documentElement || doc.body).scrollTop;\n    }\n    function widgetTopHeight(lineObj) {\n        var ref = visualLine(lineObj);\n        var widgets = ref.widgets;\n        var height = 0;\n        if (widgets) {\n            for(var i = 0; i < widgets.length; ++i){\n                if (widgets[i].above) {\n                    height += widgetHeight(widgets[i]);\n                }\n            }\n        }\n        return height;\n    }\n    // Converts a {top, bottom, left, right} box from line-local\n    // coordinates into another coordinate system. Context may be one of\n    // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n    // or \"page\".\n    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n        if (!includeWidgets) {\n            var height = widgetTopHeight(lineObj);\n            rect.top += height;\n            rect.bottom += height;\n        }\n        if (context == \"line\") {\n            return rect;\n        }\n        if (!context) {\n            context = \"local\";\n        }\n        var yOff = heightAtLine(lineObj);\n        if (context == \"local\") {\n            yOff += paddingTop(cm.display);\n        } else {\n            yOff -= cm.display.viewOffset;\n        }\n        if (context == \"page\" || context == \"window\") {\n            var lOff = cm.display.lineSpace.getBoundingClientRect();\n            yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY(doc(cm)));\n            var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX(doc(cm)));\n            rect.left += xOff;\n            rect.right += xOff;\n        }\n        rect.top += yOff;\n        rect.bottom += yOff;\n        return rect;\n    }\n    // Coverts a box from \"div\" coords to another coordinate system.\n    // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n    function fromCoordSystem(cm, coords, context) {\n        if (context == \"div\") {\n            return coords;\n        }\n        var left = coords.left, top = coords.top;\n        // First move into \"page\" coordinate system\n        if (context == \"page\") {\n            left -= pageScrollX(doc(cm));\n            top -= pageScrollY(doc(cm));\n        } else if (context == \"local\" || !context) {\n            var localBox = cm.display.sizer.getBoundingClientRect();\n            left += localBox.left;\n            top += localBox.top;\n        }\n        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n        return {\n            left: left - lineSpaceBox.left,\n            top: top - lineSpaceBox.top\n        };\n    }\n    function charCoords(cm, pos, context, lineObj, bias) {\n        if (!lineObj) {\n            lineObj = getLine(cm.doc, pos.line);\n        }\n        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n    }\n    // Returns a box for a given cursor position, which may have an\n    // 'other' property containing the position of the secondary cursor\n    // on a bidi boundary.\n    // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n    // and after `char - 1` in writing order of `char - 1`\n    // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n    // and before `char` in writing order of `char`\n    // Examples (upper-case letters are RTL, lower-case are LTR):\n    //     Pos(0, 1, ...)\n    //     before   after\n    // ab     a|b     a|b\n    // aB     a|B     aB|\n    // Ab     |Ab     A|b\n    // AB     B|A     B|A\n    // Every position after the last character on a line is considered to stick\n    // to the last character on the line.\n    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n        lineObj = lineObj || getLine(cm.doc, pos.line);\n        if (!preparedMeasure) {\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        }\n        function get(ch, right) {\n            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n            if (right) {\n                m.left = m.right;\n            } else {\n                m.right = m.left;\n            }\n            return intoCoordSystem(cm, lineObj, m, context);\n        }\n        var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n        if (ch >= lineObj.text.length) {\n            ch = lineObj.text.length;\n            sticky = \"before\";\n        } else if (ch <= 0) {\n            ch = 0;\n            sticky = \"after\";\n        }\n        if (!order) {\n            return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\");\n        }\n        function getBidi(ch, partPos, invert) {\n            var part = order[partPos], right = part.level == 1;\n            return get(invert ? ch - 1 : ch, right != invert);\n        }\n        var partPos = getBidiPartAt(order, ch, sticky);\n        var other = bidiOther;\n        var val = getBidi(ch, partPos, sticky == \"before\");\n        if (other != null) {\n            val.other = getBidi(ch, other, sticky != \"before\");\n        }\n        return val;\n    }\n    // Used to cheaply estimate the coordinates for a position. Used for\n    // intermediate scroll updates.\n    function estimateCoords(cm, pos) {\n        var left = 0;\n        pos = clipPos(cm.doc, pos);\n        if (!cm.options.lineWrapping) {\n            left = charWidth(cm.display) * pos.ch;\n        }\n        var lineObj = getLine(cm.doc, pos.line);\n        var top = heightAtLine(lineObj) + paddingTop(cm.display);\n        return {\n            left: left,\n            right: left,\n            top: top,\n            bottom: top + lineObj.height\n        };\n    }\n    // Positions returned by coordsChar contain some extra information.\n    // xRel is the relative x position of the input coordinates compared\n    // to the found position (so xRel > 0 means the coordinates are to\n    // the right of the character position, for example). When outside\n    // is true, that means the coordinates lie outside the line's\n    // vertical range.\n    function PosWithInfo(line, ch, sticky, outside, xRel) {\n        var pos = Pos(line, ch, sticky);\n        pos.xRel = xRel;\n        if (outside) {\n            pos.outside = outside;\n        }\n        return pos;\n    }\n    // Compute the character position closest to the given coordinates.\n    // Input must be lineSpace-local (\"div\" coordinate system).\n    function coordsChar(cm, x, y) {\n        var doc = cm.doc;\n        y += cm.display.viewOffset;\n        if (y < 0) {\n            return PosWithInfo(doc.first, 0, null, -1, -1);\n        }\n        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n        if (lineN > last) {\n            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);\n        }\n        if (x < 0) {\n            x = 0;\n        }\n        var lineObj = getLine(doc, lineN);\n        for(;;){\n            var found = coordsCharInner(cm, lineObj, lineN, x, y);\n            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n            if (!collapsed) {\n                return found;\n            }\n            var rangeEnd = collapsed.find(1);\n            if (rangeEnd.line == lineN) {\n                return rangeEnd;\n            }\n            lineObj = getLine(doc, lineN = rangeEnd.line);\n        }\n    }\n    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n        y -= widgetTopHeight(lineObj);\n        var end = lineObj.text.length;\n        var begin = findFirst(function(ch) {\n            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;\n        }, end, 0);\n        end = findFirst(function(ch) {\n            return measureCharPrepared(cm, preparedMeasure, ch).top > y;\n        }, begin, end);\n        return {\n            begin: begin,\n            end: end\n        };\n    }\n    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n        if (!preparedMeasure) {\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        }\n        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n    }\n    // Returns true if the given side of a box is after the given\n    // coordinates, in top-to-bottom, left-to-right order.\n    function boxIsAfter(box, x, y, left) {\n        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n    }\n    function coordsCharInner(cm, lineObj, lineNo, x, y) {\n        // Move y into line-local coordinate space\n        y -= heightAtLine(lineObj);\n        var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        // When directly calling `measureCharPrepared`, we have to adjust\n        // for the widgets at this line.\n        var widgetHeight = widgetTopHeight(lineObj);\n        var begin = 0, end = lineObj.text.length, ltr = true;\n        var order = getOrder(lineObj, cm.doc.direction);\n        // If the line isn't plain left-to-right text, first figure out\n        // which bidi section the coordinates fall into.\n        if (order) {\n            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);\n            ltr = part.level != 1;\n            // The awkward -1 offsets are needed because findFirst (called\n            // on these below) will treat its first bound as inclusive,\n            // second as exclusive, but we want to actually address the\n            // characters in the part's range\n            begin = ltr ? part.from : part.to - 1;\n            end = ltr ? part.to : part.from - 1;\n        }\n        // A binary search to find the first character whose bounding box\n        // starts after the coordinates. If we run across any whose box wrap\n        // the coordinates, store that.\n        var chAround = null, boxAround = null;\n        var ch = findFirst(function(ch) {\n            var box = measureCharPrepared(cm, preparedMeasure, ch);\n            box.top += widgetHeight;\n            box.bottom += widgetHeight;\n            if (!boxIsAfter(box, x, y, false)) {\n                return false;\n            }\n            if (box.top <= y && box.left <= x) {\n                chAround = ch;\n                boxAround = box;\n            }\n            return true;\n        }, begin, end);\n        var baseX, sticky, outside = false;\n        // If a box around the coordinates was found, use that\n        if (boxAround) {\n            // Distinguish coordinates nearer to the left or right side of the box\n            var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n            ch = chAround + (atStart ? 0 : 1);\n            sticky = atStart ? \"after\" : \"before\";\n            baseX = atLeft ? boxAround.left : boxAround.right;\n        } else {\n            // (Adjust for extended bound, if necessary.)\n            if (!ltr && (ch == end || ch == begin)) {\n                ch++;\n            }\n            // To determine which side to associate with, get the box to the\n            // left of the character and compare it's vertical position to the\n            // coordinates\n            sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? \"after\" : \"before\";\n            // Now get accurate coordinates for this place, in order to get a\n            // base X position\n            var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n            baseX = coords.left;\n            outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n        }\n        ch = skipExtendingChars(lineObj.text, ch, 1);\n        return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);\n    }\n    function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n        // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n        // situation, we can take this ordering to correspond to the visual\n        // ordering. This finds the first part whose end is after the given\n        // coordinates.\n        var index = findFirst(function(i) {\n            var part = order[i], ltr = part.level != 1;\n            return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"), \"line\", lineObj, preparedMeasure), x, y, true);\n        }, 0, order.length - 1);\n        var part = order[index];\n        // If this isn't the first part, the part's start is also after\n        // the coordinates, and the coordinates aren't on the same line as\n        // that start, move one part back.\n        if (index > 0) {\n            var ltr = part.level != 1;\n            var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"), \"line\", lineObj, preparedMeasure);\n            if (boxIsAfter(start, x, y, true) && start.top > y) {\n                part = order[index - 1];\n            }\n        }\n        return part;\n    }\n    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n        // In a wrapped line, rtl text on wrapping boundaries can do things\n        // that don't correspond to the ordering in our `order` array at\n        // all, so a binary search doesn't work, and we want to return a\n        // part that only spans one line so that the binary search in\n        // coordsCharInner is safe. As such, we first find the extent of the\n        // wrapped line, and then do a flat search in which we discard any\n        // spans that aren't on the line.\n        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n        var begin = ref.begin;\n        var end = ref.end;\n        if (/\\s/.test(lineObj.text.charAt(end - 1))) {\n            end--;\n        }\n        var part = null, closestDist = null;\n        for(var i = 0; i < order.length; i++){\n            var p = order[i];\n            if (p.from >= end || p.to <= begin) {\n                continue;\n            }\n            var ltr = p.level != 1;\n            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n            // Weigh against spans ending before this, so that they are only\n            // picked if nothing ends after\n            var dist = endX < x ? x - endX + 1e9 : endX - x;\n            if (!part || closestDist > dist) {\n                part = p;\n                closestDist = dist;\n            }\n        }\n        if (!part) {\n            part = order[order.length - 1];\n        }\n        // Clip the part to the wrapped line.\n        if (part.from < begin) {\n            part = {\n                from: begin,\n                to: part.to,\n                level: part.level\n            };\n        }\n        if (part.to > end) {\n            part = {\n                from: part.from,\n                to: end,\n                level: part.level\n            };\n        }\n        return part;\n    }\n    var measureText;\n    // Compute the default text height.\n    function textHeight(display) {\n        if (display.cachedTextHeight != null) {\n            return display.cachedTextHeight;\n        }\n        if (measureText == null) {\n            measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n            // Measure a bunch of lines, for browsers that compute\n            // fractional heights.\n            for(var i = 0; i < 49; ++i){\n                measureText.appendChild(document.createTextNode(\"x\"));\n                measureText.appendChild(elt(\"br\"));\n            }\n            measureText.appendChild(document.createTextNode(\"x\"));\n        }\n        removeChildrenAndAdd(display.measure, measureText);\n        var height = measureText.offsetHeight / 50;\n        if (height > 3) {\n            display.cachedTextHeight = height;\n        }\n        removeChildren(display.measure);\n        return height || 1;\n    }\n    // Compute the default character width.\n    function charWidth(display) {\n        if (display.cachedCharWidth != null) {\n            return display.cachedCharWidth;\n        }\n        var anchor = elt(\"span\", \"xxxxxxxxxx\");\n        var pre = elt(\"pre\", [\n            anchor\n        ], \"CodeMirror-line-like\");\n        removeChildrenAndAdd(display.measure, pre);\n        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n        if (width > 2) {\n            display.cachedCharWidth = width;\n        }\n        return width || 10;\n    }\n    // Do a bulk-read of the DOM positions and sizes needed to draw the\n    // view, so that we don't interleave reading and writing to the DOM.\n    function getDimensions(cm) {\n        var d = cm.display, left = {}, width = {};\n        var gutterLeft = d.gutters.clientLeft;\n        for(var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i){\n            var id = cm.display.gutterSpecs[i].className;\n            left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n            width[id] = n.clientWidth;\n        }\n        return {\n            fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth\n        };\n    }\n    // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n    // but using getBoundingClientRect to get a sub-pixel-accurate\n    // result.\n    function compensateForHScroll(display) {\n        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n    }\n    // Returns a function that estimates the height of a line, to use as\n    // first approximation until the line becomes visible (and is thus\n    // properly measurable).\n    function estimateHeight(cm) {\n        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n        return function(line) {\n            if (lineIsHidden(cm.doc, line)) {\n                return 0;\n            }\n            var widgetsHeight = 0;\n            if (line.widgets) {\n                for(var i = 0; i < line.widgets.length; i++){\n                    if (line.widgets[i].height) {\n                        widgetsHeight += line.widgets[i].height;\n                    }\n                }\n            }\n            if (wrapping) {\n                return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n            } else {\n                return widgetsHeight + th;\n            }\n        };\n    }\n    function estimateLineHeights(cm) {\n        var doc = cm.doc, est = estimateHeight(cm);\n        doc.iter(function(line) {\n            var estHeight = est(line);\n            if (estHeight != line.height) {\n                updateLineHeight(line, estHeight);\n            }\n        });\n    }\n    // Given a mouse event, find the corresponding position. If liberal\n    // is false, it checks whether a gutter or scrollbar was clicked,\n    // and returns null if it was. forRect is used by rectangular\n    // selections, and tries to estimate a character position even for\n    // coordinates beyond the right of the text.\n    function posFromMouse(cm, e, liberal, forRect) {\n        var display = cm.display;\n        if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") {\n            return null;\n        }\n        var x, y, space = display.lineSpace.getBoundingClientRect();\n        // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n        try {\n            x = e.clientX - space.left;\n            y = e.clientY - space.top;\n        } catch (e$1) {\n            return null;\n        }\n        var coords = coordsChar(cm, x, y), line;\n        if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n        }\n        return coords;\n    }\n    // Find the view element corresponding to a given line. Return null\n    // when the line isn't visible.\n    function findViewIndex(cm, n) {\n        if (n >= cm.display.viewTo) {\n            return null;\n        }\n        n -= cm.display.viewFrom;\n        if (n < 0) {\n            return null;\n        }\n        var view = cm.display.view;\n        for(var i = 0; i < view.length; i++){\n            n -= view[i].size;\n            if (n < 0) {\n                return i;\n            }\n        }\n    }\n    // Updates the display.view data structure for a given change to the\n    // document. From and to are in pre-change coordinates. Lendiff is\n    // the amount of lines added or subtracted by the change. This is\n    // used for changes that span multiple lines, or change the way\n    // lines are divided into visual lines. regLineChange (below)\n    // registers single-line changes.\n    function regChange(cm, from, to, lendiff) {\n        if (from == null) {\n            from = cm.doc.first;\n        }\n        if (to == null) {\n            to = cm.doc.first + cm.doc.size;\n        }\n        if (!lendiff) {\n            lendiff = 0;\n        }\n        var display = cm.display;\n        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n            display.updateLineNumbers = from;\n        }\n        cm.curOp.viewChanged = true;\n        if (from >= display.viewTo) {\n            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n                resetView(cm);\n            }\n        } else if (to <= display.viewFrom) {\n            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n                resetView(cm);\n            } else {\n                display.viewFrom += lendiff;\n                display.viewTo += lendiff;\n            }\n        } else if (from <= display.viewFrom && to >= display.viewTo) {\n            resetView(cm);\n        } else if (from <= display.viewFrom) {\n            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n            if (cut) {\n                display.view = display.view.slice(cut.index);\n                display.viewFrom = cut.lineN;\n                display.viewTo += lendiff;\n            } else {\n                resetView(cm);\n            }\n        } else if (to >= display.viewTo) {\n            var cut$1 = viewCuttingPoint(cm, from, from, -1);\n            if (cut$1) {\n                display.view = display.view.slice(0, cut$1.index);\n                display.viewTo = cut$1.lineN;\n            } else {\n                resetView(cm);\n            }\n        } else {\n            var cutTop = viewCuttingPoint(cm, from, from, -1);\n            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n            if (cutTop && cutBot) {\n                display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n                display.viewTo += lendiff;\n            } else {\n                resetView(cm);\n            }\n        }\n        var ext = display.externalMeasured;\n        if (ext) {\n            if (to < ext.lineN) {\n                ext.lineN += lendiff;\n            } else if (from < ext.lineN + ext.size) {\n                display.externalMeasured = null;\n            }\n        }\n    }\n    // Register a change to a single line. Type must be one of \"text\",\n    // \"gutter\", \"class\", \"widget\"\n    function regLineChange(cm, line, type) {\n        cm.curOp.viewChanged = true;\n        var display = cm.display, ext = cm.display.externalMeasured;\n        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n            display.externalMeasured = null;\n        }\n        if (line < display.viewFrom || line >= display.viewTo) {\n            return;\n        }\n        var lineView = display.view[findViewIndex(cm, line)];\n        if (lineView.node == null) {\n            return;\n        }\n        var arr = lineView.changes || (lineView.changes = []);\n        if (indexOf(arr, type) == -1) {\n            arr.push(type);\n        }\n    }\n    // Clear the view.\n    function resetView(cm) {\n        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n        cm.display.view = [];\n        cm.display.viewOffset = 0;\n    }\n    function viewCuttingPoint(cm, oldN, newN, dir) {\n        var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n            return {\n                index: index,\n                lineN: newN\n            };\n        }\n        var n = cm.display.viewFrom;\n        for(var i = 0; i < index; i++){\n            n += view[i].size;\n        }\n        if (n != oldN) {\n            if (dir > 0) {\n                if (index == view.length - 1) {\n                    return null;\n                }\n                diff = n + view[index].size - oldN;\n                index++;\n            } else {\n                diff = n - oldN;\n            }\n            oldN += diff;\n            newN += diff;\n        }\n        while(visualLineNo(cm.doc, newN) != newN){\n            if (index == (dir < 0 ? 0 : view.length - 1)) {\n                return null;\n            }\n            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n            index += dir;\n        }\n        return {\n            index: index,\n            lineN: newN\n        };\n    }\n    // Force the view to cover a given range, adding empty view element\n    // or clipping off existing ones as needed.\n    function adjustView(cm, from, to) {\n        var display = cm.display, view = display.view;\n        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n            display.view = buildViewArray(cm, from, to);\n            display.viewFrom = from;\n        } else {\n            if (display.viewFrom > from) {\n                display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n            } else if (display.viewFrom < from) {\n                display.view = display.view.slice(findViewIndex(cm, from));\n            }\n            display.viewFrom = from;\n            if (display.viewTo < to) {\n                display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n            } else if (display.viewTo > to) {\n                display.view = display.view.slice(0, findViewIndex(cm, to));\n            }\n        }\n        display.viewTo = to;\n    }\n    // Count the number of lines in the view whose DOM representation is\n    // out of date (or nonexistent).\n    function countDirtyView(cm) {\n        var view = cm.display.view, dirty = 0;\n        for(var i = 0; i < view.length; i++){\n            var lineView = view[i];\n            if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n                ++dirty;\n            }\n        }\n        return dirty;\n    }\n    function updateSelection(cm) {\n        cm.display.input.showSelection(cm.display.input.prepareSelection());\n    }\n    function prepareSelection(cm, primary) {\n        if (primary === void 0) primary = true;\n        var doc = cm.doc, result = {};\n        var curFragment = result.cursors = document.createDocumentFragment();\n        var selFragment = result.selection = document.createDocumentFragment();\n        var customCursor = cm.options.$customCursor;\n        if (customCursor) {\n            primary = true;\n        }\n        for(var i = 0; i < doc.sel.ranges.length; i++){\n            if (!primary && i == doc.sel.primIndex) {\n                continue;\n            }\n            var range = doc.sel.ranges[i];\n            if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {\n                continue;\n            }\n            var collapsed = range.empty();\n            if (customCursor) {\n                var head = customCursor(cm, range);\n                if (head) {\n                    drawSelectionCursor(cm, head, curFragment);\n                }\n            } else if (collapsed || cm.options.showCursorWhenSelecting) {\n                drawSelectionCursor(cm, range.head, curFragment);\n            }\n            if (!collapsed) {\n                drawSelectionRange(cm, range, selFragment);\n            }\n        }\n        return result;\n    }\n    // Draws a cursor for the given range\n    function drawSelectionCursor(cm, head, output) {\n        var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n        var cursor = output.appendChild(elt(\"div\", \"\\xa0\", \"CodeMirror-cursor\"));\n        cursor.style.left = pos.left + \"px\";\n        cursor.style.top = pos.top + \"px\";\n        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n        if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n            var charPos = charCoords(cm, head, \"div\", null, null);\n            var width = charPos.right - charPos.left;\n            cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + \"px\";\n        }\n        if (pos.other) {\n            // Secondary cursor, shown when on a 'jump' in bi-directional text\n            var otherCursor = output.appendChild(elt(\"div\", \"\\xa0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n            otherCursor.style.display = \"\";\n            otherCursor.style.left = pos.other.left + \"px\";\n            otherCursor.style.top = pos.other.top + \"px\";\n            otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n        }\n    }\n    function cmpCoords(a, b) {\n        return a.top - b.top || a.left - b.left;\n    }\n    // Draws the given range as a highlighted selection\n    function drawSelectionRange(cm, range, output) {\n        var display = cm.display, doc = cm.doc;\n        var fragment = document.createDocumentFragment();\n        var padding = paddingH(cm.display), leftSide = padding.left;\n        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n        var docLTR = doc.direction == \"ltr\";\n        function add(left, top, width, bottom) {\n            if (top < 0) {\n                top = 0;\n            }\n            top = Math.round(top);\n            bottom = Math.round(bottom);\n            fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\"));\n        }\n        function drawForLine(line, fromArg, toArg) {\n            var lineObj = getLine(doc, line);\n            var lineLen = lineObj.text.length;\n            var start, end;\n            function coords(ch, bias) {\n                return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n            }\n            function wrapX(pos, dir, side) {\n                var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n                var prop = dir == \"ltr\" == (side == \"after\") ? \"left\" : \"right\";\n                var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n                return coords(ch, prop)[prop];\n            }\n            var order = getOrder(lineObj, doc.direction);\n            iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i) {\n                var ltr = dir == \"ltr\";\n                var fromPos = coords(from, ltr ? \"left\" : \"right\");\n                var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n                var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n                var first = i == 0, last = !order || i == order.length - 1;\n                if (toPos.top - fromPos.top <= 3) {\n                    var openLeft = (docLTR ? openStart : openEnd) && first;\n                    var openRight = (docLTR ? openEnd : openStart) && last;\n                    var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n                    var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n                    add(left, fromPos.top, right - left, fromPos.bottom);\n                } else {\n                    var topLeft, topRight, botLeft, botRight;\n                    if (ltr) {\n                        topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n                        topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n                        botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n                        botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n                    } else {\n                        topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n                        topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n                        botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n                        botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n                    }\n                    add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n                    if (fromPos.bottom < toPos.top) {\n                        add(leftSide, fromPos.bottom, null, toPos.top);\n                    }\n                    add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n                }\n                if (!start || cmpCoords(fromPos, start) < 0) {\n                    start = fromPos;\n                }\n                if (cmpCoords(toPos, start) < 0) {\n                    start = toPos;\n                }\n                if (!end || cmpCoords(fromPos, end) < 0) {\n                    end = fromPos;\n                }\n                if (cmpCoords(toPos, end) < 0) {\n                    end = toPos;\n                }\n            });\n            return {\n                start: start,\n                end: end\n            };\n        }\n        var sFrom = range.from(), sTo = range.to();\n        if (sFrom.line == sTo.line) {\n            drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n        } else {\n            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n            var singleVLine = visualLine(fromLine) == visualLine(toLine);\n            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n            if (singleVLine) {\n                if (leftEnd.top < rightStart.top - 2) {\n                    add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n                } else {\n                    add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n                }\n            }\n            if (leftEnd.bottom < rightStart.top) {\n                add(leftSide, leftEnd.bottom, null, rightStart.top);\n            }\n        }\n        output.appendChild(fragment);\n    }\n    // Cursor-blinking\n    function restartBlink(cm) {\n        if (!cm.state.focused) {\n            return;\n        }\n        var display = cm.display;\n        clearInterval(display.blinker);\n        var on = true;\n        display.cursorDiv.style.visibility = \"\";\n        if (cm.options.cursorBlinkRate > 0) {\n            display.blinker = setInterval(function() {\n                if (!cm.hasFocus()) {\n                    onBlur(cm);\n                }\n                display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n            }, cm.options.cursorBlinkRate);\n        } else if (cm.options.cursorBlinkRate < 0) {\n            display.cursorDiv.style.visibility = \"hidden\";\n        }\n    }\n    function ensureFocus(cm) {\n        if (!cm.hasFocus()) {\n            cm.display.input.focus();\n            if (!cm.state.focused) {\n                onFocus(cm);\n            }\n        }\n    }\n    function delayBlurEvent(cm) {\n        cm.state.delayingBlurEvent = true;\n        setTimeout(function() {\n            if (cm.state.delayingBlurEvent) {\n                cm.state.delayingBlurEvent = false;\n                if (cm.state.focused) {\n                    onBlur(cm);\n                }\n            }\n        }, 100);\n    }\n    function onFocus(cm, e) {\n        if (cm.state.delayingBlurEvent && !cm.state.draggingText) {\n            cm.state.delayingBlurEvent = false;\n        }\n        if (cm.options.readOnly == \"nocursor\") {\n            return;\n        }\n        if (!cm.state.focused) {\n            signal(cm, \"focus\", cm, e);\n            cm.state.focused = true;\n            addClass(cm.display.wrapper, \"CodeMirror-focused\");\n            // This test prevents this from firing when a context\n            // menu is closed (since the input reset would kill the\n            // select-all detection hack)\n            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n                cm.display.input.reset();\n                if (webkit) {\n                    setTimeout(function() {\n                        return cm.display.input.reset(true);\n                    }, 20);\n                } // Issue #1730\n            }\n            cm.display.input.receivedFocus();\n        }\n        restartBlink(cm);\n    }\n    function onBlur(cm, e) {\n        if (cm.state.delayingBlurEvent) {\n            return;\n        }\n        if (cm.state.focused) {\n            signal(cm, \"blur\", cm, e);\n            cm.state.focused = false;\n            rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n        }\n        clearInterval(cm.display.blinker);\n        setTimeout(function() {\n            if (!cm.state.focused) {\n                cm.display.shift = false;\n            }\n        }, 150);\n    }\n    // Read the actual heights of the rendered lines, and update their\n    // stored heights to match.\n    function updateHeightsInViewport(cm) {\n        var display = cm.display;\n        var prevBottom = display.lineDiv.offsetTop;\n        var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n        var oldHeight = display.lineDiv.getBoundingClientRect().top;\n        var mustScroll = 0;\n        for(var i = 0; i < display.view.length; i++){\n            var cur = display.view[i], wrapping = cm.options.lineWrapping;\n            var height = void 0, width = 0;\n            if (cur.hidden) {\n                continue;\n            }\n            oldHeight += cur.line.height;\n            if (ie && ie_version < 8) {\n                var bot = cur.node.offsetTop + cur.node.offsetHeight;\n                height = bot - prevBottom;\n                prevBottom = bot;\n            } else {\n                var box = cur.node.getBoundingClientRect();\n                height = box.bottom - box.top;\n                // Check that lines don't extend past the right of the current\n                // editor width\n                if (!wrapping && cur.text.firstChild) {\n                    width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n                }\n            }\n            var diff = cur.line.height - height;\n            if (diff > .005 || diff < -.005) {\n                if (oldHeight < viewTop) {\n                    mustScroll -= diff;\n                }\n                updateLineHeight(cur.line, height);\n                updateWidgetHeight(cur.line);\n                if (cur.rest) {\n                    for(var j = 0; j < cur.rest.length; j++){\n                        updateWidgetHeight(cur.rest[j]);\n                    }\n                }\n            }\n            if (width > cm.display.sizerWidth) {\n                var chWidth = Math.ceil(width / charWidth(cm.display));\n                if (chWidth > cm.display.maxLineLength) {\n                    cm.display.maxLineLength = chWidth;\n                    cm.display.maxLine = cur.line;\n                    cm.display.maxLineChanged = true;\n                }\n            }\n        }\n        if (Math.abs(mustScroll) > 2) {\n            display.scroller.scrollTop += mustScroll;\n        }\n    }\n    // Read and store the height of line widgets associated with the\n    // given line.\n    function updateWidgetHeight(line) {\n        if (line.widgets) {\n            for(var i = 0; i < line.widgets.length; ++i){\n                var w = line.widgets[i], parent = w.node.parentNode;\n                if (parent) {\n                    w.height = parent.offsetHeight;\n                }\n            }\n        }\n    }\n    // Compute the lines that are visible in a given viewport (defaults\n    // the current scroll position). viewport may contain top,\n    // height, and ensure (see op.scrollToPos) properties.\n    function visibleLines(display, doc, viewport) {\n        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n        top = Math.floor(top - paddingTop(display));\n        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n        var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n        // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n        // forces those lines into the viewport (if possible).\n        if (viewport && viewport.ensure) {\n            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n            if (ensureFrom < from) {\n                from = ensureFrom;\n                to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n                from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n                to = ensureTo;\n            }\n        }\n        return {\n            from: from,\n            to: Math.max(to, from + 1)\n        };\n    }\n    // SCROLLING THINGS INTO VIEW\n    // If an editor sits on the top or bottom of the window, partially\n    // scrolled out of view, this ensures that the cursor is visible.\n    function maybeScrollWindow(cm, rect) {\n        if (signalDOMEvent(cm, \"scrollCursorIntoView\")) {\n            return;\n        }\n        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n        var doc = display.wrapper.ownerDocument;\n        if (rect.top + box.top < 0) {\n            doScroll = true;\n        } else if (rect.bottom + box.top > (doc.defaultView.innerHeight || doc.documentElement.clientHeight)) {\n            doScroll = false;\n        }\n        if (doScroll != null && !phantom) {\n            var scrollNode = elt(\"div\", \"\", null, \"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + rect.left + \"px; width: \" + Math.max(2, rect.right - rect.left) + \"px;\");\n            cm.display.lineSpace.appendChild(scrollNode);\n            scrollNode.scrollIntoView(doScroll);\n            cm.display.lineSpace.removeChild(scrollNode);\n        }\n    }\n    // Scroll a given position into view (immediately), verifying that\n    // it actually became visible (as line heights are accurately\n    // measured, the position of something may 'drift' during drawing).\n    function scrollPosIntoView(cm, pos, end, margin) {\n        if (margin == null) {\n            margin = 0;\n        }\n        var rect;\n        if (!cm.options.lineWrapping && pos == end) {\n            // Set pos and end to the cursor positions around the character pos sticks to\n            // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n            // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n            end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n            pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n        }\n        for(var limit = 0; limit < 5; limit++){\n            var changed = false;\n            var coords = cursorCoords(cm, pos);\n            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n            rect = {\n                left: Math.min(coords.left, endCoords.left),\n                top: Math.min(coords.top, endCoords.top) - margin,\n                right: Math.max(coords.left, endCoords.left),\n                bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n            };\n            var scrollPos = calculateScrollPos(cm, rect);\n            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n            if (scrollPos.scrollTop != null) {\n                updateScrollTop(cm, scrollPos.scrollTop);\n                if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n                    changed = true;\n                }\n            }\n            if (scrollPos.scrollLeft != null) {\n                setScrollLeft(cm, scrollPos.scrollLeft);\n                if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n                    changed = true;\n                }\n            }\n            if (!changed) {\n                break;\n            }\n        }\n        return rect;\n    }\n    // Scroll a given set of coordinates into view (immediately).\n    function scrollIntoView(cm, rect) {\n        var scrollPos = calculateScrollPos(cm, rect);\n        if (scrollPos.scrollTop != null) {\n            updateScrollTop(cm, scrollPos.scrollTop);\n        }\n        if (scrollPos.scrollLeft != null) {\n            setScrollLeft(cm, scrollPos.scrollLeft);\n        }\n    }\n    // Calculate a new scroll position needed to scroll the given\n    // rectangle into view. Returns an object with scrollTop and\n    // scrollLeft properties. When these are undefined, the\n    // vertical/horizontal position does not need to be adjusted.\n    function calculateScrollPos(cm, rect) {\n        var display = cm.display, snapMargin = textHeight(cm.display);\n        if (rect.top < 0) {\n            rect.top = 0;\n        }\n        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n        var screen1 = displayHeight(cm), result = {};\n        if (rect.bottom - rect.top > screen1) {\n            rect.bottom = rect.top + screen1;\n        }\n        var docBottom = cm.doc.height + paddingVert(display);\n        var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n        if (rect.top < screentop) {\n            result.scrollTop = atTop ? 0 : rect.top;\n        } else if (rect.bottom > screentop + screen1) {\n            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen1);\n            if (newTop != screentop) {\n                result.scrollTop = newTop;\n            }\n        }\n        var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n        var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n        var tooWide = rect.right - rect.left > screenw;\n        if (tooWide) {\n            rect.right = rect.left + screenw;\n        }\n        if (rect.left < 10) {\n            result.scrollLeft = 0;\n        } else if (rect.left < screenleft) {\n            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));\n        } else if (rect.right > screenw + screenleft - 3) {\n            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;\n        }\n        return result;\n    }\n    // Store a relative adjustment to the scroll position in the current\n    // operation (to be applied when the operation finishes).\n    function addToScrollTop(cm, top) {\n        if (top == null) {\n            return;\n        }\n        resolveScrollToPos(cm);\n        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n    }\n    // Make sure that at the end of the operation the current cursor is\n    // shown.\n    function ensureCursorVisible(cm) {\n        resolveScrollToPos(cm);\n        var cur = cm.getCursor();\n        cm.curOp.scrollToPos = {\n            from: cur,\n            to: cur,\n            margin: cm.options.cursorScrollMargin\n        };\n    }\n    function scrollToCoords(cm, x, y) {\n        if (x != null || y != null) {\n            resolveScrollToPos(cm);\n        }\n        if (x != null) {\n            cm.curOp.scrollLeft = x;\n        }\n        if (y != null) {\n            cm.curOp.scrollTop = y;\n        }\n    }\n    function scrollToRange(cm, range) {\n        resolveScrollToPos(cm);\n        cm.curOp.scrollToPos = range;\n    }\n    // When an operation has its scrollToPos property set, and another\n    // scroll action is applied before the end of the operation, this\n    // 'simulates' scrolling that position into view in a cheap way, so\n    // that the effect of intermediate scroll commands is not ignored.\n    function resolveScrollToPos(cm) {\n        var range = cm.curOp.scrollToPos;\n        if (range) {\n            cm.curOp.scrollToPos = null;\n            var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n            scrollToCoordsRange(cm, from, to, range.margin);\n        }\n    }\n    function scrollToCoordsRange(cm, from, to, margin) {\n        var sPos = calculateScrollPos(cm, {\n            left: Math.min(from.left, to.left),\n            top: Math.min(from.top, to.top) - margin,\n            right: Math.max(from.right, to.right),\n            bottom: Math.max(from.bottom, to.bottom) + margin\n        });\n        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n    }\n    // Sync the scrollable area and scrollbars, ensure the viewport\n    // covers the visible area.\n    function updateScrollTop(cm, val) {\n        if (Math.abs(cm.doc.scrollTop - val) < 2) {\n            return;\n        }\n        if (!gecko) {\n            updateDisplaySimple(cm, {\n                top: val\n            });\n        }\n        setScrollTop(cm, val, true);\n        if (gecko) {\n            updateDisplaySimple(cm);\n        }\n        startWorker(cm, 100);\n    }\n    function setScrollTop(cm, val, forceScroll) {\n        val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n        if (cm.display.scroller.scrollTop == val && !forceScroll) {\n            return;\n        }\n        cm.doc.scrollTop = val;\n        cm.display.scrollbars.setScrollTop(val);\n        if (cm.display.scroller.scrollTop != val) {\n            cm.display.scroller.scrollTop = val;\n        }\n    }\n    // Sync scroller and scrollbar, ensure the gutter elements are\n    // aligned.\n    function setScrollLeft(cm, val, isScroller, forceScroll) {\n        val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n            return;\n        }\n        cm.doc.scrollLeft = val;\n        alignHorizontally(cm);\n        if (cm.display.scroller.scrollLeft != val) {\n            cm.display.scroller.scrollLeft = val;\n        }\n        cm.display.scrollbars.setScrollLeft(val);\n    }\n    // SCROLLBARS\n    // Prepare DOM reads needed to update the scrollbars. Done in one\n    // shot to minimize update/measure roundtrips.\n    function measureForScrollbars(cm) {\n        var d = cm.display, gutterW = d.gutters.offsetWidth;\n        var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n        return {\n            clientHeight: d.scroller.clientHeight,\n            viewHeight: d.wrapper.clientHeight,\n            scrollWidth: d.scroller.scrollWidth,\n            clientWidth: d.scroller.clientWidth,\n            viewWidth: d.wrapper.clientWidth,\n            barLeft: cm.options.fixedGutter ? gutterW : 0,\n            docHeight: docH,\n            scrollHeight: docH + scrollGap(cm) + d.barHeight,\n            nativeBarWidth: d.nativeBarWidth,\n            gutterWidth: gutterW\n        };\n    }\n    var NativeScrollbars = function(place, scroll, cm) {\n        this.cm = cm;\n        var vert = this.vert = elt(\"div\", [\n            elt(\"div\", null, null, \"min-width: 1px\")\n        ], \"CodeMirror-vscrollbar\");\n        var horiz = this.horiz = elt(\"div\", [\n            elt(\"div\", null, null, \"height: 100%; min-height: 1px\")\n        ], \"CodeMirror-hscrollbar\");\n        vert.tabIndex = horiz.tabIndex = -1;\n        place(vert);\n        place(horiz);\n        on(vert, \"scroll\", function() {\n            if (vert.clientHeight) {\n                scroll(vert.scrollTop, \"vertical\");\n            }\n        });\n        on(horiz, \"scroll\", function() {\n            if (horiz.clientWidth) {\n                scroll(horiz.scrollLeft, \"horizontal\");\n            }\n        });\n        this.checkedZeroWidth = false;\n        // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n        if (ie && ie_version < 8) {\n            this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n        }\n    };\n    NativeScrollbars.prototype.update = function(measure) {\n        var needsH = measure.scrollWidth > measure.clientWidth + 1;\n        var needsV = measure.scrollHeight > measure.clientHeight + 1;\n        var sWidth = measure.nativeBarWidth;\n        if (needsV) {\n            this.vert.style.display = \"block\";\n            this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n            // A bug in IE8 can cause this value to be negative, so guard it.\n            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n        } else {\n            this.vert.scrollTop = 0;\n            this.vert.style.display = \"\";\n            this.vert.firstChild.style.height = \"0\";\n        }\n        if (needsH) {\n            this.horiz.style.display = \"block\";\n            this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n            this.horiz.style.left = measure.barLeft + \"px\";\n            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n        } else {\n            this.horiz.style.display = \"\";\n            this.horiz.firstChild.style.width = \"0\";\n        }\n        if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n            if (sWidth == 0) {\n                this.zeroWidthHack();\n            }\n            this.checkedZeroWidth = true;\n        }\n        return {\n            right: needsV ? sWidth : 0,\n            bottom: needsH ? sWidth : 0\n        };\n    };\n    NativeScrollbars.prototype.setScrollLeft = function(pos) {\n        if (this.horiz.scrollLeft != pos) {\n            this.horiz.scrollLeft = pos;\n        }\n        if (this.disableHoriz) {\n            this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\");\n        }\n    };\n    NativeScrollbars.prototype.setScrollTop = function(pos) {\n        if (this.vert.scrollTop != pos) {\n            this.vert.scrollTop = pos;\n        }\n        if (this.disableVert) {\n            this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\");\n        }\n    };\n    NativeScrollbars.prototype.zeroWidthHack = function() {\n        var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n        this.horiz.style.height = this.vert.style.width = w;\n        this.horiz.style.visibility = this.vert.style.visibility = \"hidden\";\n        this.disableHoriz = new Delayed;\n        this.disableVert = new Delayed;\n    };\n    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {\n        bar.style.visibility = \"\";\n        function maybeDisable() {\n            // To find out whether the scrollbar is still visible, we\n            // check whether the element under the pixel in the bottom\n            // right corner of the scrollbar box is the scrollbar box\n            // itself (when the bar is still visible) or its filler child\n            // (when the bar is hidden). If it is still visible, we keep\n            // it enabled, if it's hidden, we disable pointer events.\n            var box = bar.getBoundingClientRect();\n            var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n            if (elt != bar) {\n                bar.style.visibility = \"hidden\";\n            } else {\n                delay.set(1000, maybeDisable);\n            }\n        }\n        delay.set(1000, maybeDisable);\n    };\n    NativeScrollbars.prototype.clear = function() {\n        var parent = this.horiz.parentNode;\n        parent.removeChild(this.horiz);\n        parent.removeChild(this.vert);\n    };\n    var NullScrollbars = function() {};\n    NullScrollbars.prototype.update = function() {\n        return {\n            bottom: 0,\n            right: 0\n        };\n    };\n    NullScrollbars.prototype.setScrollLeft = function() {};\n    NullScrollbars.prototype.setScrollTop = function() {};\n    NullScrollbars.prototype.clear = function() {};\n    function updateScrollbars(cm, measure) {\n        if (!measure) {\n            measure = measureForScrollbars(cm);\n        }\n        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n        updateScrollbarsInner(cm, measure);\n        for(var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++){\n            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n                updateHeightsInViewport(cm);\n            }\n            updateScrollbarsInner(cm, measureForScrollbars(cm));\n            startWidth = cm.display.barWidth;\n            startHeight = cm.display.barHeight;\n        }\n    }\n    // Re-synchronize the fake scrollbars with the actual size of the\n    // content.\n    function updateScrollbarsInner(cm, measure) {\n        var d = cm.display;\n        var sizes = d.scrollbars.update(measure);\n        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n        d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n        if (sizes.right && sizes.bottom) {\n            d.scrollbarFiller.style.display = \"block\";\n            d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n            d.scrollbarFiller.style.width = sizes.right + \"px\";\n        } else {\n            d.scrollbarFiller.style.display = \"\";\n        }\n        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n            d.gutterFiller.style.display = \"block\";\n            d.gutterFiller.style.height = sizes.bottom + \"px\";\n            d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n        } else {\n            d.gutterFiller.style.display = \"\";\n        }\n    }\n    var scrollbarModel = {\n        \"native\": NativeScrollbars,\n        \"null\": NullScrollbars\n    };\n    function initScrollbars(cm) {\n        if (cm.display.scrollbars) {\n            cm.display.scrollbars.clear();\n            if (cm.display.scrollbars.addClass) {\n                rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n            }\n        }\n        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {\n            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n            // Prevent clicks in the scrollbars from killing focus\n            on(node, \"mousedown\", function() {\n                if (cm.state.focused) {\n                    setTimeout(function() {\n                        return cm.display.input.focus();\n                    }, 0);\n                }\n            });\n            node.setAttribute(\"cm-not-content\", \"true\");\n        }, function(pos, axis) {\n            if (axis == \"horizontal\") {\n                setScrollLeft(cm, pos);\n            } else {\n                updateScrollTop(cm, pos);\n            }\n        }, cm);\n        if (cm.display.scrollbars.addClass) {\n            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n        }\n    }\n    // Operations are used to wrap a series of changes to the editor\n    // state in such a way that each change won't have to update the\n    // cursor and display (which would be awkward, slow, and\n    // error-prone). Instead, display updates are batched and then all\n    // combined and executed at once.\n    var nextOpId = 0;\n    // Start a new operation.\n    function startOperation(cm) {\n        cm.curOp = {\n            cm: cm,\n            viewChanged: false,\n            startHeight: cm.doc.height,\n            forceUpdate: false,\n            updateInput: 0,\n            typing: false,\n            changeObjs: null,\n            cursorActivityHandlers: null,\n            cursorActivityCalled: 0,\n            selectionChanged: false,\n            updateMaxLine: false,\n            scrollLeft: null,\n            scrollTop: null,\n            scrollToPos: null,\n            focus: false,\n            id: ++nextOpId,\n            markArrays: null // Used by addMarkedSpan\n        };\n        pushOperation(cm.curOp);\n    }\n    // Finish an operation, updating the display and signalling delayed events\n    function endOperation(cm) {\n        var op = cm.curOp;\n        if (op) {\n            finishOperation(op, function(group) {\n                for(var i = 0; i < group.ops.length; i++){\n                    group.ops[i].cm.curOp = null;\n                }\n                endOperations(group);\n            });\n        }\n    }\n    // The DOM updates done when an operation finishes are batched so\n    // that the minimum number of relayouts are required.\n    function endOperations(group) {\n        var ops = group.ops;\n        for(var i = 0; i < ops.length; i++){\n            endOperation_R1(ops[i]);\n        }\n        for(var i$1 = 0; i$1 < ops.length; i$1++){\n            endOperation_W1(ops[i$1]);\n        }\n        for(var i$2 = 0; i$2 < ops.length; i$2++){\n            endOperation_R2(ops[i$2]);\n        }\n        for(var i$3 = 0; i$3 < ops.length; i$3++){\n            endOperation_W2(ops[i$3]);\n        }\n        for(var i$4 = 0; i$4 < ops.length; i$4++){\n            endOperation_finish(ops[i$4]);\n        }\n    }\n    function endOperation_R1(op) {\n        var cm = op.cm, display = cm.display;\n        maybeClipScrollbars(cm);\n        if (op.updateMaxLine) {\n            findMaxLine(cm);\n        }\n        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {\n            top: op.scrollTop,\n            ensure: op.scrollToPos\n        }, op.forceUpdate);\n    }\n    function endOperation_W1(op) {\n        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n    }\n    function endOperation_R2(op) {\n        var cm = op.cm, display = cm.display;\n        if (op.updatedDisplay) {\n            updateHeightsInViewport(cm);\n        }\n        op.barMeasure = measureForScrollbars(cm);\n        // If the max line changed since it was last measured, measure it,\n        // and ensure the document's width matches it.\n        // updateDisplay_W2 will use these properties to do the actual resizing\n        if (display.maxLineChanged && !cm.options.lineWrapping) {\n            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n            cm.display.sizerWidth = op.adjustWidthTo;\n            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n        }\n        if (op.updatedDisplay || op.selectionChanged) {\n            op.preparedSelection = display.input.prepareSelection();\n        }\n    }\n    function endOperation_W2(op) {\n        var cm = op.cm;\n        if (op.adjustWidthTo != null) {\n            cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n            if (op.maxScrollLeft < cm.doc.scrollLeft) {\n                setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n            }\n            cm.display.maxLineChanged = false;\n        }\n        var takeFocus = op.focus && op.focus == activeElt(root(cm));\n        if (op.preparedSelection) {\n            cm.display.input.showSelection(op.preparedSelection, takeFocus);\n        }\n        if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n            updateScrollbars(cm, op.barMeasure);\n        }\n        if (op.updatedDisplay) {\n            setDocumentHeight(cm, op.barMeasure);\n        }\n        if (op.selectionChanged) {\n            restartBlink(cm);\n        }\n        if (cm.state.focused && op.updateInput) {\n            cm.display.input.reset(op.typing);\n        }\n        if (takeFocus) {\n            ensureFocus(op.cm);\n        }\n    }\n    function endOperation_finish(op) {\n        var cm = op.cm, display = cm.display, doc = cm.doc;\n        if (op.updatedDisplay) {\n            postUpdateDisplay(cm, op.update);\n        }\n        // Abort mouse wheel delta measurement, when scrolling explicitly\n        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n            display.wheelStartX = display.wheelStartY = null;\n        }\n        // Propagate the scroll position to the actual DOM scroller\n        if (op.scrollTop != null) {\n            setScrollTop(cm, op.scrollTop, op.forceScroll);\n        }\n        if (op.scrollLeft != null) {\n            setScrollLeft(cm, op.scrollLeft, true, true);\n        }\n        // If we need to scroll a specific position into view, do so.\n        if (op.scrollToPos) {\n            var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n            maybeScrollWindow(cm, rect);\n        }\n        // Fire events for markers that are hidden/unidden by editing or\n        // undoing\n        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n        if (hidden) {\n            for(var i = 0; i < hidden.length; ++i){\n                if (!hidden[i].lines.length) {\n                    signal(hidden[i], \"hide\");\n                }\n            }\n        }\n        if (unhidden) {\n            for(var i$1 = 0; i$1 < unhidden.length; ++i$1){\n                if (unhidden[i$1].lines.length) {\n                    signal(unhidden[i$1], \"unhide\");\n                }\n            }\n        }\n        if (display.wrapper.offsetHeight) {\n            doc.scrollTop = cm.display.scroller.scrollTop;\n        }\n        // Fire change events, and delayed event handlers\n        if (op.changeObjs) {\n            signal(cm, \"changes\", cm, op.changeObjs);\n        }\n        if (op.update) {\n            op.update.finish();\n        }\n    }\n    // Run the given function in an operation\n    function runInOp(cm, f) {\n        if (cm.curOp) {\n            return f();\n        }\n        startOperation(cm);\n        try {\n            return f();\n        } finally{\n            endOperation(cm);\n        }\n    }\n    // Wraps a function in an operation. Returns the wrapped function.\n    function operation(cm, f) {\n        return function() {\n            if (cm.curOp) {\n                return f.apply(cm, arguments);\n            }\n            startOperation(cm);\n            try {\n                return f.apply(cm, arguments);\n            } finally{\n                endOperation(cm);\n            }\n        };\n    }\n    // Used to add methods to editor and doc instances, wrapping them in\n    // operations.\n    function methodOp(f) {\n        return function() {\n            if (this.curOp) {\n                return f.apply(this, arguments);\n            }\n            startOperation(this);\n            try {\n                return f.apply(this, arguments);\n            } finally{\n                endOperation(this);\n            }\n        };\n    }\n    function docMethodOp(f) {\n        return function() {\n            var cm = this.cm;\n            if (!cm || cm.curOp) {\n                return f.apply(this, arguments);\n            }\n            startOperation(cm);\n            try {\n                return f.apply(this, arguments);\n            } finally{\n                endOperation(cm);\n            }\n        };\n    }\n    // HIGHLIGHT WORKER\n    function startWorker(cm, time) {\n        if (cm.doc.highlightFrontier < cm.display.viewTo) {\n            cm.state.highlight.set(time, bind(highlightWorker, cm));\n        }\n    }\n    function highlightWorker(cm) {\n        var doc = cm.doc;\n        if (doc.highlightFrontier >= cm.display.viewTo) {\n            return;\n        }\n        var end = +new Date + cm.options.workTime;\n        var context = getContextBefore(cm, doc.highlightFrontier);\n        var changedLines = [];\n        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n            if (context.line >= cm.display.viewFrom) {\n                var oldStyles = line.styles;\n                var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n                var highlighted = highlightLine(cm, line, context, true);\n                if (resetState) {\n                    context.state = resetState;\n                }\n                line.styles = highlighted.styles;\n                var oldCls = line.styleClasses, newCls = highlighted.classes;\n                if (newCls) {\n                    line.styleClasses = newCls;\n                } else if (oldCls) {\n                    line.styleClasses = null;\n                }\n                var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n                for(var i = 0; !ischange && i < oldStyles.length; ++i){\n                    ischange = oldStyles[i] != line.styles[i];\n                }\n                if (ischange) {\n                    changedLines.push(context.line);\n                }\n                line.stateAfter = context.save();\n                context.nextLine();\n            } else {\n                if (line.text.length <= cm.options.maxHighlightLength) {\n                    processLine(cm, line.text, context);\n                }\n                line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n                context.nextLine();\n            }\n            if (+new Date > end) {\n                startWorker(cm, cm.options.workDelay);\n                return true;\n            }\n        });\n        doc.highlightFrontier = context.line;\n        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n        if (changedLines.length) {\n            runInOp(cm, function() {\n                for(var i = 0; i < changedLines.length; i++){\n                    regLineChange(cm, changedLines[i], \"text\");\n                }\n            });\n        }\n    }\n    // DISPLAY DRAWING\n    var DisplayUpdate = function(cm, viewport, force) {\n        var display = cm.display;\n        this.viewport = viewport;\n        // Store some values that we'll need later (but don't want to force a relayout for)\n        this.visible = visibleLines(display, cm.doc, viewport);\n        this.editorIsHidden = !display.wrapper.offsetWidth;\n        this.wrapperHeight = display.wrapper.clientHeight;\n        this.wrapperWidth = display.wrapper.clientWidth;\n        this.oldDisplayWidth = displayWidth(cm);\n        this.force = force;\n        this.dims = getDimensions(cm);\n        this.events = [];\n    };\n    DisplayUpdate.prototype.signal = function(emitter, type) {\n        if (hasHandler(emitter, type)) {\n            this.events.push(arguments);\n        }\n    };\n    DisplayUpdate.prototype.finish = function() {\n        for(var i = 0; i < this.events.length; i++){\n            signal.apply(null, this.events[i]);\n        }\n    };\n    function maybeClipScrollbars(cm) {\n        var display = cm.display;\n        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n            display.heightForcer.style.height = scrollGap(cm) + \"px\";\n            display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n            display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n            display.scrollbarsClipped = true;\n        }\n    }\n    function selectionSnapshot(cm) {\n        if (cm.hasFocus()) {\n            return null;\n        }\n        var active = activeElt(root(cm));\n        if (!active || !contains(cm.display.lineDiv, active)) {\n            return null;\n        }\n        var result = {\n            activeElt: active\n        };\n        if (window.getSelection) {\n            var sel = win(cm).getSelection();\n            if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n                result.anchorNode = sel.anchorNode;\n                result.anchorOffset = sel.anchorOffset;\n                result.focusNode = sel.focusNode;\n                result.focusOffset = sel.focusOffset;\n            }\n        }\n        return result;\n    }\n    function restoreSelection(snapshot) {\n        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) {\n            return;\n        }\n        snapshot.activeElt.focus();\n        if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n            var doc = snapshot.activeElt.ownerDocument;\n            var sel = doc.defaultView.getSelection(), range = doc.createRange();\n            range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n            range.collapse(false);\n            sel.removeAllRanges();\n            sel.addRange(range);\n            sel.extend(snapshot.focusNode, snapshot.focusOffset);\n        }\n    }\n    // Does the actual updating of the line display. Bails out\n    // (returning false) when there is nothing to be done and forced is\n    // false.\n    function updateDisplayIfNeeded(cm, update) {\n        var display = cm.display, doc = cm.doc;\n        if (update.editorIsHidden) {\n            resetView(cm);\n            return false;\n        }\n        // Bail out if the visible area is already rendered and nothing changed.\n        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n            return false;\n        }\n        if (maybeUpdateLineNumberWidth(cm)) {\n            resetView(cm);\n            update.dims = getDimensions(cm);\n        }\n        // Compute a suitable new viewport (from & to)\n        var end = doc.first + doc.size;\n        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n        if (display.viewFrom < from && from - display.viewFrom < 20) {\n            from = Math.max(doc.first, display.viewFrom);\n        }\n        if (display.viewTo > to && display.viewTo - to < 20) {\n            to = Math.min(end, display.viewTo);\n        }\n        if (sawCollapsedSpans) {\n            from = visualLineNo(cm.doc, from);\n            to = visualLineEndNo(cm.doc, to);\n        }\n        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n        adjustView(cm, from, to);\n        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n        // Position the mover div to align with the current scroll position\n        cm.display.mover.style.top = display.viewOffset + \"px\";\n        var toUpdate = countDirtyView(cm);\n        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n            return false;\n        }\n        // For big changes, we hide the enclosing element during the\n        // update, since that speeds up the operations on most browsers.\n        var selSnapshot = selectionSnapshot(cm);\n        if (toUpdate > 4) {\n            display.lineDiv.style.display = \"none\";\n        }\n        patchDisplay(cm, display.updateLineNumbers, update.dims);\n        if (toUpdate > 4) {\n            display.lineDiv.style.display = \"\";\n        }\n        display.renderedView = display.view;\n        // There might have been a widget with a focused element that got\n        // hidden or updated, if so re-focus it.\n        restoreSelection(selSnapshot);\n        // Prevent selection and cursors from interfering with the scroll\n        // width and height.\n        removeChildren(display.cursorDiv);\n        removeChildren(display.selectionDiv);\n        display.gutters.style.height = display.sizer.style.minHeight = 0;\n        if (different) {\n            display.lastWrapHeight = update.wrapperHeight;\n            display.lastWrapWidth = update.wrapperWidth;\n            startWorker(cm, 400);\n        }\n        display.updateLineNumbers = null;\n        return true;\n    }\n    function postUpdateDisplay(cm, update) {\n        var viewport = update.viewport;\n        for(var first = true;; first = false){\n            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n                // Clip forced viewport to actual scrollable area.\n                if (viewport && viewport.top != null) {\n                    viewport = {\n                        top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)\n                    };\n                }\n                // Updated line heights might result in the drawn area not\n                // actually covering the viewport. Keep looping until it does.\n                update.visible = visibleLines(cm.display, cm.doc, viewport);\n                if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n                    break;\n                }\n            } else if (first) {\n                update.visible = visibleLines(cm.display, cm.doc, viewport);\n            }\n            if (!updateDisplayIfNeeded(cm, update)) {\n                break;\n            }\n            updateHeightsInViewport(cm);\n            var barMeasure = measureForScrollbars(cm);\n            updateSelection(cm);\n            updateScrollbars(cm, barMeasure);\n            setDocumentHeight(cm, barMeasure);\n            update.force = false;\n        }\n        update.signal(cm, \"update\", cm);\n        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n            update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n            cm.display.reportedViewFrom = cm.display.viewFrom;\n            cm.display.reportedViewTo = cm.display.viewTo;\n        }\n    }\n    function updateDisplaySimple(cm, viewport) {\n        var update = new DisplayUpdate(cm, viewport);\n        if (updateDisplayIfNeeded(cm, update)) {\n            updateHeightsInViewport(cm);\n            postUpdateDisplay(cm, update);\n            var barMeasure = measureForScrollbars(cm);\n            updateSelection(cm);\n            updateScrollbars(cm, barMeasure);\n            setDocumentHeight(cm, barMeasure);\n            update.finish();\n        }\n    }\n    // Sync the actual display DOM structure with display.view, removing\n    // nodes for lines that are no longer in view, and creating the ones\n    // that are not there yet, and updating the ones that are out of\n    // date.\n    function patchDisplay(cm, updateNumbersFrom, dims) {\n        var display = cm.display, lineNumbers = cm.options.lineNumbers;\n        var container = display.lineDiv, cur = container.firstChild;\n        function rm(node) {\n            var next = node.nextSibling;\n            // Works around a throw-scroll bug in OS X Webkit\n            if (webkit && mac && cm.display.currentWheelTarget == node) {\n                node.style.display = \"none\";\n            } else {\n                node.parentNode.removeChild(node);\n            }\n            return next;\n        }\n        var view = display.view, lineN = display.viewFrom;\n        // Loop over the elements in the view, syncing cur (the DOM nodes\n        // in display.lineDiv) with the view as we go.\n        for(var i = 0; i < view.length; i++){\n            var lineView = view[i];\n            if (lineView.hidden) ;\n            else if (!lineView.node || lineView.node.parentNode != container) {\n                var node = buildLineElement(cm, lineView, lineN, dims);\n                container.insertBefore(node, cur);\n            } else {\n                while(cur != lineView.node){\n                    cur = rm(cur);\n                }\n                var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n                if (lineView.changes) {\n                    if (indexOf(lineView.changes, \"gutter\") > -1) {\n                        updateNumber = false;\n                    }\n                    updateLineForChanges(cm, lineView, lineN, dims);\n                }\n                if (updateNumber) {\n                    removeChildren(lineView.lineNumber);\n                    lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n                }\n                cur = lineView.node.nextSibling;\n            }\n            lineN += lineView.size;\n        }\n        while(cur){\n            cur = rm(cur);\n        }\n    }\n    function updateGutterSpace(display) {\n        var width = display.gutters.offsetWidth;\n        display.sizer.style.marginLeft = width + \"px\";\n        // Send an event to consumers responding to changes in gutter width.\n        signalLater(display, \"gutterChanged\", display);\n    }\n    function setDocumentHeight(cm, measure) {\n        cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n        cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + \"px\";\n    }\n    // Re-align line numbers and gutter marks to compensate for\n    // horizontal scrolling.\n    function alignHorizontally(cm) {\n        var display = cm.display, view = display.view;\n        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n            return;\n        }\n        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n        var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n        for(var i = 0; i < view.length; i++){\n            if (!view[i].hidden) {\n                if (cm.options.fixedGutter) {\n                    if (view[i].gutter) {\n                        view[i].gutter.style.left = left;\n                    }\n                    if (view[i].gutterBackground) {\n                        view[i].gutterBackground.style.left = left;\n                    }\n                }\n                var align = view[i].alignable;\n                if (align) {\n                    for(var j = 0; j < align.length; j++){\n                        align[j].style.left = left;\n                    }\n                }\n            }\n        }\n        if (cm.options.fixedGutter) {\n            display.gutters.style.left = comp + gutterW + \"px\";\n        }\n    }\n    // Used to ensure that the line number gutter is still the right\n    // size for the current document size. Returns true when an update\n    // is needed.\n    function maybeUpdateLineNumberWidth(cm) {\n        if (!cm.options.lineNumbers) {\n            return false;\n        }\n        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n        if (last.length != display.lineNumChars) {\n            var test = display.measure.appendChild(elt(\"div\", [\n                elt(\"div\", last)\n            ], \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n            display.lineGutter.style.width = \"\";\n            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n            display.lineNumWidth = display.lineNumInnerWidth + padding;\n            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n            display.lineGutter.style.width = display.lineNumWidth + \"px\";\n            updateGutterSpace(cm.display);\n            return true;\n        }\n        return false;\n    }\n    function getGutters(gutters, lineNumbers) {\n        var result = [], sawLineNumbers = false;\n        for(var i = 0; i < gutters.length; i++){\n            var name = gutters[i], style = null;\n            if (typeof name != \"string\") {\n                style = name.style;\n                name = name.className;\n            }\n            if (name == \"CodeMirror-linenumbers\") {\n                if (!lineNumbers) {\n                    continue;\n                } else {\n                    sawLineNumbers = true;\n                }\n            }\n            result.push({\n                className: name,\n                style: style\n            });\n        }\n        if (lineNumbers && !sawLineNumbers) {\n            result.push({\n                className: \"CodeMirror-linenumbers\",\n                style: null\n            });\n        }\n        return result;\n    }\n    // Rebuild the gutter elements, ensure the margin to the left of the\n    // code matches their width.\n    function renderGutters(display) {\n        var gutters = display.gutters, specs = display.gutterSpecs;\n        removeChildren(gutters);\n        display.lineGutter = null;\n        for(var i = 0; i < specs.length; ++i){\n            var ref = specs[i];\n            var className = ref.className;\n            var style = ref.style;\n            var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n            if (style) {\n                gElt.style.cssText = style;\n            }\n            if (className == \"CodeMirror-linenumbers\") {\n                display.lineGutter = gElt;\n                gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n            }\n        }\n        gutters.style.display = specs.length ? \"\" : \"none\";\n        updateGutterSpace(display);\n    }\n    function updateGutters(cm) {\n        renderGutters(cm.display);\n        regChange(cm);\n        alignHorizontally(cm);\n    }\n    // The display handles the DOM integration, both for input reading\n    // and content drawing. It holds references to DOM nodes and\n    // display-related state.\n    function Display(place, doc, input, options) {\n        var d = this;\n        this.input = input;\n        // Covers bottom-right square when both scrollbars are present.\n        d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n        d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n        // Covers bottom of gutter when coverGutterNextToScrollbar is on\n        // and h scrollbar is present.\n        d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n        d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n        // Will contain the actual code, positioned to cover the viewport.\n        d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n        // Elements are added to these to represent selection and cursors.\n        d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n        d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n        // A visibility: hidden element used to find the size of things.\n        d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n        // When lines outside of the viewport are measured, they are drawn in this.\n        d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n        // Wraps everything that needs to exist inside the vertically-padded coordinate system\n        d.lineSpace = eltP(\"div\", [\n            d.measure,\n            d.lineMeasure,\n            d.selectionDiv,\n            d.cursorDiv,\n            d.lineDiv\n        ], null, \"position: relative; outline: none\");\n        var lines = eltP(\"div\", [\n            d.lineSpace\n        ], \"CodeMirror-lines\");\n        // Moved around its parent to cover visible view.\n        d.mover = elt(\"div\", [\n            lines\n        ], null, \"position: relative\");\n        // Set to the height of the document, allowing scrolling.\n        d.sizer = elt(\"div\", [\n            d.mover\n        ], \"CodeMirror-sizer\");\n        d.sizerWidth = null;\n        // Behavior of elts with overflow: auto and padding is\n        // inconsistent across browsers. This is used to ensure the\n        // scrollable area is big enough.\n        d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n        // Will contain the gutters, if any.\n        d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n        d.lineGutter = null;\n        // Actual scrollable element.\n        d.scroller = elt(\"div\", [\n            d.sizer,\n            d.heightForcer,\n            d.gutters\n        ], \"CodeMirror-scroll\");\n        d.scroller.setAttribute(\"tabIndex\", \"-1\");\n        // The element in which the editor lives.\n        d.wrapper = elt(\"div\", [\n            d.scrollbarFiller,\n            d.gutterFiller,\n            d.scroller\n        ], \"CodeMirror\");\n        // See #6982. FIXME remove when this has been fixed for a while in Chrome\n        if (chrome && chrome_version === 105) {\n            d.wrapper.style.clipPath = \"inset(0px)\";\n        }\n        // This attribute is respected by automatic translation systems such as Google Translate,\n        // and may also be respected by tools used by human translators.\n        d.wrapper.setAttribute(\"translate\", \"no\");\n        // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n        if (ie && ie_version < 8) {\n            d.gutters.style.zIndex = -1;\n            d.scroller.style.paddingRight = 0;\n        }\n        if (!webkit && !(gecko && mobile)) {\n            d.scroller.draggable = true;\n        }\n        if (place) {\n            if (place.appendChild) {\n                place.appendChild(d.wrapper);\n            } else {\n                place(d.wrapper);\n            }\n        }\n        // Current rendered range (may be bigger than the view window).\n        d.viewFrom = d.viewTo = doc.first;\n        d.reportedViewFrom = d.reportedViewTo = doc.first;\n        // Information about the rendered lines.\n        d.view = [];\n        d.renderedView = null;\n        // Holds info about a single rendered line when it was rendered\n        // for measurement, while not in view.\n        d.externalMeasured = null;\n        // Empty space (in pixels) above the view\n        d.viewOffset = 0;\n        d.lastWrapHeight = d.lastWrapWidth = 0;\n        d.updateLineNumbers = null;\n        d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n        d.scrollbarsClipped = false;\n        // Used to only resize the line number gutter when necessary (when\n        // the amount of lines crosses a boundary that makes its width change)\n        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n        // Set to true when a non-horizontal-scrolling line widget is\n        // added. As an optimization, line widget aligning is skipped when\n        // this is false.\n        d.alignWidgets = false;\n        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n        // Tracks the maximum line length so that the horizontal scrollbar\n        // can be kept static when scrolling.\n        d.maxLine = null;\n        d.maxLineLength = 0;\n        d.maxLineChanged = false;\n        // Used for measuring wheel scrolling granularity\n        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n        // True when shift is held down.\n        d.shift = false;\n        // Used to track whether anything happened since the context menu\n        // was opened.\n        d.selForContextMenu = null;\n        d.activeTouch = null;\n        d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n        renderGutters(d);\n        input.init(d);\n    }\n    // Since the delta values reported on mouse wheel events are\n    // unstandardized between browsers and even browser versions, and\n    // generally horribly unpredictable, this code starts by measuring\n    // the scroll effect that the first few mouse wheel events have,\n    // and, from that, detects the way it can convert deltas to pixel\n    // offsets afterwards.\n    //\n    // The reason we want to know the amount a wheel event will scroll\n    // is that it gives us a chance to update the display before the\n    // actual scrolling happens, reducing flickering.\n    var wheelSamples = 0, wheelPixelsPerUnit = null;\n    // Fill in a browser-detected starting value on browsers where we\n    // know one. These don't have to be accurate -- the result of them\n    // being wrong would just be a slight flicker on the first wheel\n    // scroll (if it is large enough).\n    if (ie) {\n        wheelPixelsPerUnit = -.53;\n    } else if (gecko) {\n        wheelPixelsPerUnit = 15;\n    } else if (chrome) {\n        wheelPixelsPerUnit = -.7;\n    } else if (safari) {\n        wheelPixelsPerUnit = -1 / 3;\n    }\n    function wheelEventDelta(e) {\n        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n            dx = e.detail;\n        }\n        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n            dy = e.detail;\n        } else if (dy == null) {\n            dy = e.wheelDelta;\n        }\n        return {\n            x: dx,\n            y: dy\n        };\n    }\n    function wheelEventPixels(e) {\n        var delta = wheelEventDelta(e);\n        delta.x *= wheelPixelsPerUnit;\n        delta.y *= wheelPixelsPerUnit;\n        return delta;\n    }\n    function onScrollWheel(cm, e) {\n        // On Chrome 102, viewport updates somehow stop wheel-based\n        // scrolling. Turning off pointer events during the scroll seems\n        // to avoid the issue.\n        if (chrome && chrome_version == 102) {\n            if (cm.display.chromeScrollHack == null) {\n                cm.display.sizer.style.pointerEvents = \"none\";\n            } else {\n                clearTimeout(cm.display.chromeScrollHack);\n            }\n            cm.display.chromeScrollHack = setTimeout(function() {\n                cm.display.chromeScrollHack = null;\n                cm.display.sizer.style.pointerEvents = \"\";\n            }, 100);\n        }\n        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n        var pixelsPerUnit = wheelPixelsPerUnit;\n        if (e.deltaMode === 0) {\n            dx = e.deltaX;\n            dy = e.deltaY;\n            pixelsPerUnit = 1;\n        }\n        var display = cm.display, scroll = display.scroller;\n        // Quit if there's nothing to scroll here\n        var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n        var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n        if (!(dx && canScrollX || dy && canScrollY)) {\n            return;\n        }\n        // Webkit browsers on OS X abort momentum scrolls when the target\n        // of the scroll event is removed from the scrollable element.\n        // This hack (see related code in patchDisplay) makes sure the\n        // element is kept around.\n        if (dy && mac && webkit) {\n            outer: for(var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode){\n                for(var i = 0; i < view.length; i++){\n                    if (view[i].node == cur) {\n                        cm.display.currentWheelTarget = cur;\n                        break outer;\n                    }\n                }\n            }\n        }\n        // On some browsers, horizontal scrolling will cause redraws to\n        // happen before the gutter has been realigned, causing it to\n        // wriggle around in a most unseemly way. When we have an\n        // estimated pixels/delta value, we just handle horizontal\n        // scrolling entirely here. It'll be slightly off from native, but\n        // better than glitching out.\n        if (dx && !gecko && !presto && pixelsPerUnit != null) {\n            if (dy && canScrollY) {\n                updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));\n            }\n            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));\n            // Only prevent default scrolling if vertical scrolling is\n            // actually possible. Otherwise, it causes vertical scroll\n            // jitter on OSX trackpads when deltaX is small and deltaY\n            // is large (issue #3579)\n            if (!dy || dy && canScrollY) {\n                e_preventDefault(e);\n            }\n            display.wheelStartX = null; // Abort measurement, if in progress\n            return;\n        }\n        // 'Project' the visible viewport to cover the area that is being\n        // scrolled into view (if we know enough to estimate it).\n        if (dy && pixelsPerUnit != null) {\n            var pixels = dy * pixelsPerUnit;\n            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n            if (pixels < 0) {\n                top = Math.max(0, top + pixels - 50);\n            } else {\n                bot = Math.min(cm.doc.height, bot + pixels + 50);\n            }\n            updateDisplaySimple(cm, {\n                top: top,\n                bottom: bot\n            });\n        }\n        if (wheelSamples < 20 && e.deltaMode !== 0) {\n            if (display.wheelStartX == null) {\n                display.wheelStartX = scroll.scrollLeft;\n                display.wheelStartY = scroll.scrollTop;\n                display.wheelDX = dx;\n                display.wheelDY = dy;\n                setTimeout(function() {\n                    if (display.wheelStartX == null) {\n                        return;\n                    }\n                    var movedX = scroll.scrollLeft - display.wheelStartX;\n                    var movedY = scroll.scrollTop - display.wheelStartY;\n                    var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n                    display.wheelStartX = display.wheelStartY = null;\n                    if (!sample) {\n                        return;\n                    }\n                    wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n                    ++wheelSamples;\n                }, 200);\n            } else {\n                display.wheelDX += dx;\n                display.wheelDY += dy;\n            }\n        }\n    }\n    // Selection objects are immutable. A new one is created every time\n    // the selection changes. A selection is one or more non-overlapping\n    // (and non-touching) ranges, sorted, and an integer that indicates\n    // which one is the primary selection (the one that's scrolled into\n    // view, that getCursor returns, etc).\n    var Selection = function(ranges, primIndex) {\n        this.ranges = ranges;\n        this.primIndex = primIndex;\n    };\n    Selection.prototype.primary = function() {\n        return this.ranges[this.primIndex];\n    };\n    Selection.prototype.equals = function(other) {\n        if (other == this) {\n            return true;\n        }\n        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n            return false;\n        }\n        for(var i = 0; i < this.ranges.length; i++){\n            var here = this.ranges[i], there = other.ranges[i];\n            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Selection.prototype.deepCopy = function() {\n        var out = [];\n        for(var i = 0; i < this.ranges.length; i++){\n            out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n        }\n        return new Selection(out, this.primIndex);\n    };\n    Selection.prototype.somethingSelected = function() {\n        for(var i = 0; i < this.ranges.length; i++){\n            if (!this.ranges[i].empty()) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Selection.prototype.contains = function(pos, end) {\n        if (!end) {\n            end = pos;\n        }\n        for(var i = 0; i < this.ranges.length; i++){\n            var range = this.ranges[i];\n            if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    var Range = function(anchor, head) {\n        this.anchor = anchor;\n        this.head = head;\n    };\n    Range.prototype.from = function() {\n        return minPos(this.anchor, this.head);\n    };\n    Range.prototype.to = function() {\n        return maxPos(this.anchor, this.head);\n    };\n    Range.prototype.empty = function() {\n        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    };\n    // Take an unsorted, potentially overlapping set of ranges, and\n    // build a selection out of it. 'Consumes' ranges array (modifying\n    // it).\n    function normalizeSelection(cm, ranges, primIndex) {\n        var mayTouch = cm && cm.options.selectionsMayTouch;\n        var prim = ranges[primIndex];\n        ranges.sort(function(a, b) {\n            return cmp(a.from(), b.from());\n        });\n        primIndex = indexOf(ranges, prim);\n        for(var i = 1; i < ranges.length; i++){\n            var cur = ranges[i], prev = ranges[i - 1];\n            var diff = cmp(prev.to(), cur.from());\n            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n                var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n                var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n                if (i <= primIndex) {\n                    --primIndex;\n                }\n                ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n            }\n        }\n        return new Selection(ranges, primIndex);\n    }\n    function simpleSelection(anchor, head) {\n        return new Selection([\n            new Range(anchor, head || anchor)\n        ], 0);\n    }\n    // Compute the position of the end of a change (its 'to' property\n    // refers to the pre-change end).\n    function changeEnd(change) {\n        if (!change.text) {\n            return change.to;\n        }\n        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n    }\n    // Adjust a position to refer to the post-change position of the\n    // same text, or the end of the change if the change covers it.\n    function adjustForChange(pos, change) {\n        if (cmp(pos, change.from) < 0) {\n            return pos;\n        }\n        if (cmp(pos, change.to) <= 0) {\n            return changeEnd(change);\n        }\n        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n        if (pos.line == change.to.line) {\n            ch += changeEnd(change).ch - change.to.ch;\n        }\n        return Pos(line, ch);\n    }\n    function computeSelAfterChange(doc, change) {\n        var out = [];\n        for(var i = 0; i < doc.sel.ranges.length; i++){\n            var range = doc.sel.ranges[i];\n            out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));\n        }\n        return normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    }\n    function offsetPos(pos, old, nw) {\n        if (pos.line == old.line) {\n            return Pos(nw.line, pos.ch - old.ch + nw.ch);\n        } else {\n            return Pos(nw.line + (pos.line - old.line), pos.ch);\n        }\n    }\n    // Used by replaceSelections to allow moving the selection to the\n    // start or around the replaced test. Hint may be \"start\" or \"around\".\n    function computeReplacedSel(doc, changes, hint) {\n        var out = [];\n        var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n        for(var i = 0; i < changes.length; i++){\n            var change = changes[i];\n            var from = offsetPos(change.from, oldPrev, newPrev);\n            var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n            oldPrev = change.to;\n            newPrev = to;\n            if (hint == \"around\") {\n                var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n                out[i] = new Range(inv ? to : from, inv ? from : to);\n            } else {\n                out[i] = new Range(from, from);\n            }\n        }\n        return new Selection(out, doc.sel.primIndex);\n    }\n    // Used to get the editor into a consistent state again when options change.\n    function loadMode(cm) {\n        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n        resetModeState(cm);\n    }\n    function resetModeState(cm) {\n        cm.doc.iter(function(line) {\n            if (line.stateAfter) {\n                line.stateAfter = null;\n            }\n            if (line.styles) {\n                line.styles = null;\n            }\n        });\n        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n        startWorker(cm, 100);\n        cm.state.modeGen++;\n        if (cm.curOp) {\n            regChange(cm);\n        }\n    }\n    // DOCUMENT DATA STRUCTURE\n    // By default, updates that start and end at the beginning of a line\n    // are treated specially, in order to make the association of line\n    // widgets and marker elements with the text behave more intuitive.\n    function isWholeLineUpdate(doc, change) {\n        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n    }\n    // Perform a change on the document data structure.\n    function updateDoc(doc, change, markedSpans, estimateHeight) {\n        function spansFor(n) {\n            return markedSpans ? markedSpans[n] : null;\n        }\n        function update(line, text, spans) {\n            updateLine(line, text, spans, estimateHeight);\n            signalLater(line, \"change\", line, change);\n        }\n        function linesFor(start, end) {\n            var result = [];\n            for(var i = start; i < end; ++i){\n                result.push(new Line(text[i], spansFor(i), estimateHeight));\n            }\n            return result;\n        }\n        var from = change.from, to = change.to, text = change.text;\n        var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n        // Adjust the line structure\n        if (change.full) {\n            doc.insert(0, linesFor(0, text.length));\n            doc.remove(text.length, doc.size - text.length);\n        } else if (isWholeLineUpdate(doc, change)) {\n            // This is a whole-line replace. Treated specially to make\n            // sure line objects move the way they are supposed to.\n            var added = linesFor(0, text.length - 1);\n            update(lastLine, lastLine.text, lastSpans);\n            if (nlines) {\n                doc.remove(from.line, nlines);\n            }\n            if (added.length) {\n                doc.insert(from.line, added);\n            }\n        } else if (firstLine == lastLine) {\n            if (text.length == 1) {\n                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n            } else {\n                var added$1 = linesFor(1, text.length - 1);\n                added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n                doc.insert(from.line + 1, added$1);\n            }\n        } else if (text.length == 1) {\n            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n            doc.remove(from.line + 1, nlines);\n        } else {\n            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n            var added$2 = linesFor(1, text.length - 1);\n            if (nlines > 1) {\n                doc.remove(from.line + 1, nlines - 1);\n            }\n            doc.insert(from.line + 1, added$2);\n        }\n        signalLater(doc, \"change\", doc, change);\n    }\n    // Call f for all linked documents.\n    function linkedDocs(doc, f, sharedHistOnly) {\n        function propagate(doc, skip, sharedHist) {\n            if (doc.linked) {\n                for(var i = 0; i < doc.linked.length; ++i){\n                    var rel = doc.linked[i];\n                    if (rel.doc == skip) {\n                        continue;\n                    }\n                    var shared = sharedHist && rel.sharedHist;\n                    if (sharedHistOnly && !shared) {\n                        continue;\n                    }\n                    f(rel.doc, shared);\n                    propagate(rel.doc, doc, shared);\n                }\n            }\n        }\n        propagate(doc, null, true);\n    }\n    // Attach a document to an editor.\n    function attachDoc(cm, doc) {\n        if (doc.cm) {\n            throw new Error(\"This document is already in use.\");\n        }\n        cm.doc = doc;\n        doc.cm = cm;\n        estimateLineHeights(cm);\n        loadMode(cm);\n        setDirectionClass(cm);\n        cm.options.direction = doc.direction;\n        if (!cm.options.lineWrapping) {\n            findMaxLine(cm);\n        }\n        cm.options.mode = doc.modeOption;\n        regChange(cm);\n    }\n    function setDirectionClass(cm) {\n        (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n    }\n    function directionChanged(cm) {\n        runInOp(cm, function() {\n            setDirectionClass(cm);\n            regChange(cm);\n        });\n    }\n    function History(prev) {\n        // Arrays of change events and selections. Doing something adds an\n        // event to done and clears undo. Undoing moves events from done\n        // to undone, redoing moves them in the other direction.\n        this.done = [];\n        this.undone = [];\n        this.undoDepth = prev ? prev.undoDepth : Infinity;\n        // Used to track when changes can be merged into a single undo\n        // event\n        this.lastModTime = this.lastSelTime = 0;\n        this.lastOp = this.lastSelOp = null;\n        this.lastOrigin = this.lastSelOrigin = null;\n        // Used by the isClean() method\n        this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n    }\n    // Create a history change event from an updateDoc-style change\n    // object.\n    function historyChangeFromChange(doc, change) {\n        var histChange = {\n            from: copyPos(change.from),\n            to: changeEnd(change),\n            text: getBetween(doc, change.from, change.to)\n        };\n        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n        linkedDocs(doc, function(doc) {\n            return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n        }, true);\n        return histChange;\n    }\n    // Pop all selection events off the end of a history array. Stop at\n    // a change event.\n    function clearSelectionEvents(array) {\n        while(array.length){\n            var last = lst(array);\n            if (last.ranges) {\n                array.pop();\n            } else {\n                break;\n            }\n        }\n    }\n    // Find the top change event in the history. Pop off selection\n    // events that are in the way.\n    function lastChangeEvent(hist, force) {\n        if (force) {\n            clearSelectionEvents(hist.done);\n            return lst(hist.done);\n        } else if (hist.done.length && !lst(hist.done).ranges) {\n            return lst(hist.done);\n        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n            hist.done.pop();\n            return lst(hist.done);\n        }\n    }\n    // Register a change in the history. Merges changes that are within\n    // a single operation, or are close together with an origin that\n    // allows merging (starting with \"+\") into a single event.\n    function addChangeToHistory(doc, change, selAfter, opId) {\n        var hist = doc.history;\n        hist.undone.length = 0;\n        var time = +new Date, cur;\n        var last;\n        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == \"*\")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n            // Merge this change into the last event\n            last = lst(cur.changes);\n            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n                // Optimized case for simple insertion -- don't want to add\n                // new changesets for every character typed\n                last.to = changeEnd(change);\n            } else {\n                // Add new sub-event\n                cur.changes.push(historyChangeFromChange(doc, change));\n            }\n        } else {\n            // Can not be merged, start a new event.\n            var before = lst(hist.done);\n            if (!before || !before.ranges) {\n                pushSelectionToHistory(doc.sel, hist.done);\n            }\n            cur = {\n                changes: [\n                    historyChangeFromChange(doc, change)\n                ],\n                generation: hist.generation\n            };\n            hist.done.push(cur);\n            while(hist.done.length > hist.undoDepth){\n                hist.done.shift();\n                if (!hist.done[0].ranges) {\n                    hist.done.shift();\n                }\n            }\n        }\n        hist.done.push(selAfter);\n        hist.generation = ++hist.maxGeneration;\n        hist.lastModTime = hist.lastSelTime = time;\n        hist.lastOp = hist.lastSelOp = opId;\n        hist.lastOrigin = hist.lastSelOrigin = change.origin;\n        if (!last) {\n            signal(doc, \"historyAdded\");\n        }\n    }\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\n        var ch = origin.charAt(0);\n        return ch == \"*\" || ch == \"+\" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n    }\n    // Called whenever the selection changes, sets the new selection as\n    // the pending selection in the history, and pushes the old pending\n    // selection into the 'done' array when it was significantly\n    // different (in number of selected ranges, emptiness, or time).\n    function addSelectionToHistory(doc, sel, opId, options) {\n        var hist = doc.history, origin = options && options.origin;\n        // A new event is started when the previous origin does not match\n        // the current, or the origins don't allow matching. Origins\n        // starting with * are always merged, those starting with + are\n        // merged when similar and close together in time.\n        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {\n            hist.done[hist.done.length - 1] = sel;\n        } else {\n            pushSelectionToHistory(sel, hist.done);\n        }\n        hist.lastSelTime = +new Date;\n        hist.lastSelOrigin = origin;\n        hist.lastSelOp = opId;\n        if (options && options.clearRedo !== false) {\n            clearSelectionEvents(hist.undone);\n        }\n    }\n    function pushSelectionToHistory(sel, dest) {\n        var top = lst(dest);\n        if (!(top && top.ranges && top.equals(sel))) {\n            dest.push(sel);\n        }\n    }\n    // Used to store marked span information in the history.\n    function attachLocalSpans(doc, change, from, to) {\n        var existing = change[\"spans_\" + doc.id], n = 0;\n        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n            if (line.markedSpans) {\n                (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n            }\n            ++n;\n        });\n    }\n    // When un/re-doing restores text containing marked spans, those\n    // that have been explicitly cleared should not be restored.\n    function removeClearedSpans(spans) {\n        if (!spans) {\n            return null;\n        }\n        var out;\n        for(var i = 0; i < spans.length; ++i){\n            if (spans[i].marker.explicitlyCleared) {\n                if (!out) {\n                    out = spans.slice(0, i);\n                }\n            } else if (out) {\n                out.push(spans[i]);\n            }\n        }\n        return !out ? spans : out.length ? out : null;\n    }\n    // Retrieve and filter the old marked spans stored in a change event.\n    function getOldSpans(doc, change) {\n        var found = change[\"spans_\" + doc.id];\n        if (!found) {\n            return null;\n        }\n        var nw = [];\n        for(var i = 0; i < change.text.length; ++i){\n            nw.push(removeClearedSpans(found[i]));\n        }\n        return nw;\n    }\n    // Used for un/re-doing changes from the history. Combines the\n    // result of computing the existing spans with the set of spans that\n    // existed in the history (so that deleting around a span and then\n    // undoing brings back the span).\n    function mergeOldSpans(doc, change) {\n        var old = getOldSpans(doc, change);\n        var stretched = stretchSpansOverChange(doc, change);\n        if (!old) {\n            return stretched;\n        }\n        if (!stretched) {\n            return old;\n        }\n        for(var i = 0; i < old.length; ++i){\n            var oldCur = old[i], stretchCur = stretched[i];\n            if (oldCur && stretchCur) {\n                spans: for(var j = 0; j < stretchCur.length; ++j){\n                    var span = stretchCur[j];\n                    for(var k = 0; k < oldCur.length; ++k){\n                        if (oldCur[k].marker == span.marker) {\n                            continue spans;\n                        }\n                    }\n                    oldCur.push(span);\n                }\n            } else if (stretchCur) {\n                old[i] = stretchCur;\n            }\n        }\n        return old;\n    }\n    // Used both to provide a JSON-safe object in .getHistory, and, when\n    // detaching a document, to split the history in two\n    function copyHistoryArray(events, newGroup, instantiateSel) {\n        var copy = [];\n        for(var i = 0; i < events.length; ++i){\n            var event = events[i];\n            if (event.ranges) {\n                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n                continue;\n            }\n            var changes = event.changes, newChanges = [];\n            copy.push({\n                changes: newChanges\n            });\n            for(var j = 0; j < changes.length; ++j){\n                var change = changes[j], m = void 0;\n                newChanges.push({\n                    from: change.from,\n                    to: change.to,\n                    text: change.text\n                });\n                if (newGroup) {\n                    for(var prop in change){\n                        if (m = prop.match(/^spans_(\\d+)$/)) {\n                            if (indexOf(newGroup, Number(m[1])) > -1) {\n                                lst(newChanges)[prop] = change[prop];\n                                delete change[prop];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return copy;\n    }\n    // The 'scroll' parameter given to many of these indicated whether\n    // the new cursor position should be scrolled into view after\n    // modifying the selection.\n    // If shift is held or the extend flag is set, extends a range to\n    // include a given position (and optionally a second position).\n    // Otherwise, simply returns the range between the given positions.\n    // Used for cursor motion and such.\n    function extendRange(range, head, other, extend) {\n        if (extend) {\n            var anchor = range.anchor;\n            if (other) {\n                var posBefore = cmp(head, anchor) < 0;\n                if (posBefore != cmp(other, anchor) < 0) {\n                    anchor = head;\n                    head = other;\n                } else if (posBefore != cmp(head, other) < 0) {\n                    head = other;\n                }\n            }\n            return new Range(anchor, head);\n        } else {\n            return new Range(other || head, head);\n        }\n    }\n    // Extend the primary selection range, discard the rest.\n    function extendSelection(doc, head, other, options, extend) {\n        if (extend == null) {\n            extend = doc.cm && (doc.cm.display.shift || doc.extend);\n        }\n        setSelection(doc, new Selection([\n            extendRange(doc.sel.primary(), head, other, extend)\n        ], 0), options);\n    }\n    // Extend all selections (pos is an array of selections with length\n    // equal the number of selections)\n    function extendSelections(doc, heads, options) {\n        var out = [];\n        var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n        for(var i = 0; i < doc.sel.ranges.length; i++){\n            out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);\n        }\n        var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n        setSelection(doc, newSel, options);\n    }\n    // Updates a single range in the selection.\n    function replaceOneSelection(doc, i, range, options) {\n        var ranges = doc.sel.ranges.slice(0);\n        ranges[i] = range;\n        setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n    }\n    // Reset the selection to a single range.\n    function setSimpleSelection(doc, anchor, head, options) {\n        setSelection(doc, simpleSelection(anchor, head), options);\n    }\n    // Give beforeSelectionChange handlers a change to influence a\n    // selection update.\n    function filterSelectionChange(doc, sel, options) {\n        var obj = {\n            ranges: sel.ranges,\n            update: function(ranges) {\n                this.ranges = [];\n                for(var i = 0; i < ranges.length; i++){\n                    this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));\n                }\n            },\n            origin: options && options.origin\n        };\n        signal(doc, \"beforeSelectionChange\", doc, obj);\n        if (doc.cm) {\n            signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n        }\n        if (obj.ranges != sel.ranges) {\n            return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);\n        } else {\n            return sel;\n        }\n    }\n    function setSelectionReplaceHistory(doc, sel, options) {\n        var done = doc.history.done, last = lst(done);\n        if (last && last.ranges) {\n            done[done.length - 1] = sel;\n            setSelectionNoUndo(doc, sel, options);\n        } else {\n            setSelection(doc, sel, options);\n        }\n    }\n    // Set a new selection.\n    function setSelection(doc, sel, options) {\n        setSelectionNoUndo(doc, sel, options);\n        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n    }\n    function setSelectionNoUndo(doc, sel, options) {\n        if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n            sel = filterSelectionChange(doc, sel, options);\n        }\n        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n        if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\") {\n            ensureCursorVisible(doc.cm);\n        }\n    }\n    function setSelectionInner(doc, sel) {\n        if (sel.equals(doc.sel)) {\n            return;\n        }\n        doc.sel = sel;\n        if (doc.cm) {\n            doc.cm.curOp.updateInput = 1;\n            doc.cm.curOp.selectionChanged = true;\n            signalCursorActivity(doc.cm);\n        }\n        signalLater(doc, \"cursorActivity\", doc);\n    }\n    // Verify that the selection does not partially select any atomic\n    // marked ranges.\n    function reCheckSelection(doc) {\n        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n    }\n    // Return a selection that does not partially select any atomic\n    // ranges.\n    function skipAtomicInSelection(doc, sel, bias, mayClear) {\n        var out;\n        for(var i = 0; i < sel.ranges.length; i++){\n            var range = sel.ranges[i];\n            var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n            var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n            var newHead = range.head == range.anchor ? newAnchor : skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n            if (out || newAnchor != range.anchor || newHead != range.head) {\n                if (!out) {\n                    out = sel.ranges.slice(0, i);\n                }\n                out[i] = new Range(newAnchor, newHead);\n            }\n        }\n        return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;\n    }\n    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n        var line = getLine(doc, pos.line);\n        if (line.markedSpans) {\n            for(var i = 0; i < line.markedSpans.length; ++i){\n                var sp = line.markedSpans[i], m = sp.marker;\n                // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n                // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n                // is with selectLeft/Right\n                var preventCursorLeft = \"selectLeft\" in m ? !m.selectLeft : m.inclusiveLeft;\n                var preventCursorRight = \"selectRight\" in m ? !m.selectRight : m.inclusiveRight;\n                if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n                    if (mayClear) {\n                        signal(m, \"beforeCursorEnter\");\n                        if (m.explicitlyCleared) {\n                            if (!line.markedSpans) {\n                                break;\n                            } else {\n                                --i;\n                                continue;\n                            }\n                        }\n                    }\n                    if (!m.atomic) {\n                        continue;\n                    }\n                    if (oldPos) {\n                        var near = m.find(dir < 0 ? 1 : -1), diff = void 0;\n                        if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n                            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n                        }\n                        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {\n                            return skipAtomicInner(doc, near, pos, dir, mayClear);\n                        }\n                    }\n                    var far = m.find(dir < 0 ? -1 : 1);\n                    if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n                        far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n                    }\n                    return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n                }\n            }\n        }\n        return pos;\n    }\n    // Ensure a given position is not inside an atomic range.\n    function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n        var dir = bias || 1;\n        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);\n        if (!found) {\n            doc.cantEdit = true;\n            return Pos(doc.first, 0);\n        }\n        return found;\n    }\n    function movePos(doc, pos, dir, line) {\n        if (dir < 0 && pos.ch == 0) {\n            if (pos.line > doc.first) {\n                return clipPos(doc, Pos(pos.line - 1));\n            } else {\n                return null;\n            }\n        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n            if (pos.line < doc.first + doc.size - 1) {\n                return Pos(pos.line + 1, 0);\n            } else {\n                return null;\n            }\n        } else {\n            return new Pos(pos.line, pos.ch + dir);\n        }\n    }\n    function selectAll(cm) {\n        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n    }\n    // UPDATING\n    // Allow \"beforeChange\" event handlers to influence a change\n    function filterChange(doc, change, update) {\n        var obj = {\n            canceled: false,\n            from: change.from,\n            to: change.to,\n            text: change.text,\n            origin: change.origin,\n            cancel: function() {\n                return obj.canceled = true;\n            }\n        };\n        if (update) {\n            obj.update = function(from, to, text, origin) {\n                if (from) {\n                    obj.from = clipPos(doc, from);\n                }\n                if (to) {\n                    obj.to = clipPos(doc, to);\n                }\n                if (text) {\n                    obj.text = text;\n                }\n                if (origin !== undefined) {\n                    obj.origin = origin;\n                }\n            };\n        }\n        signal(doc, \"beforeChange\", doc, obj);\n        if (doc.cm) {\n            signal(doc.cm, \"beforeChange\", doc.cm, obj);\n        }\n        if (obj.canceled) {\n            if (doc.cm) {\n                doc.cm.curOp.updateInput = 2;\n            }\n            return null;\n        }\n        return {\n            from: obj.from,\n            to: obj.to,\n            text: obj.text,\n            origin: obj.origin\n        };\n    }\n    // Apply a change to a document, and add it to the document's\n    // history, and propagating it to all linked documents.\n    function makeChange(doc, change, ignoreReadOnly) {\n        if (doc.cm) {\n            if (!doc.cm.curOp) {\n                return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n            }\n            if (doc.cm.state.suppressEdits) {\n                return;\n            }\n        }\n        if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n            change = filterChange(doc, change, true);\n            if (!change) {\n                return;\n            }\n        }\n        // Possibly split or suppress the update based on the presence\n        // of read-only spans in its range.\n        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n        if (split) {\n            for(var i = split.length - 1; i >= 0; --i){\n                makeChangeInner(doc, {\n                    from: split[i].from,\n                    to: split[i].to,\n                    text: i ? [\n                        \"\"\n                    ] : change.text,\n                    origin: change.origin\n                });\n            }\n        } else {\n            makeChangeInner(doc, change);\n        }\n    }\n    function makeChangeInner(doc, change) {\n        if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) {\n            return;\n        }\n        var selAfter = computeSelAfterChange(doc, change);\n        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n        var rebased = [];\n        linkedDocs(doc, function(doc, sharedHist) {\n            if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n                rebaseHist(doc.history, change);\n                rebased.push(doc.history);\n            }\n            makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n        });\n    }\n    // Revert a change stored in a document's history.\n    function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n        var suppress = doc.cm && doc.cm.state.suppressEdits;\n        if (suppress && !allowSelectionOnly) {\n            return;\n        }\n        var hist = doc.history, event, selAfter = doc.sel;\n        var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n        // Verify that there is a useable event (so that ctrl-z won't\n        // needlessly clear selection events)\n        var i = 0;\n        for(; i < source.length; i++){\n            event = source[i];\n            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {\n                break;\n            }\n        }\n        if (i == source.length) {\n            return;\n        }\n        hist.lastOrigin = hist.lastSelOrigin = null;\n        for(;;){\n            event = source.pop();\n            if (event.ranges) {\n                pushSelectionToHistory(event, dest);\n                if (allowSelectionOnly && !event.equals(doc.sel)) {\n                    setSelection(doc, event, {\n                        clearRedo: false\n                    });\n                    return;\n                }\n                selAfter = event;\n            } else if (suppress) {\n                source.push(event);\n                return;\n            } else {\n                break;\n            }\n        }\n        // Build up a reverse change object to add to the opposite history\n        // stack (redo when undoing, and vice versa).\n        var antiChanges = [];\n        pushSelectionToHistory(selAfter, dest);\n        dest.push({\n            changes: antiChanges,\n            generation: hist.generation\n        });\n        hist.generation = event.generation || ++hist.maxGeneration;\n        var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n        var loop = function(i) {\n            var change = event.changes[i];\n            change.origin = type;\n            if (filter && !filterChange(doc, change, false)) {\n                source.length = 0;\n                return {};\n            }\n            antiChanges.push(historyChangeFromChange(doc, change));\n            var after = i ? computeSelAfterChange(doc, change) : lst(source);\n            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n            if (!i && doc.cm) {\n                doc.cm.scrollIntoView({\n                    from: change.from,\n                    to: changeEnd(change)\n                });\n            }\n            var rebased = [];\n            // Propagate to the linked documents\n            linkedDocs(doc, function(doc, sharedHist) {\n                if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n                    rebaseHist(doc.history, change);\n                    rebased.push(doc.history);\n                }\n                makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n            });\n        };\n        for(var i$1 = event.changes.length - 1; i$1 >= 0; --i$1){\n            var returned = loop(i$1);\n            if (returned) return returned.v;\n        }\n    }\n    // Sub-views need their line numbers shifted when text is added\n    // above or below them in the parent document.\n    function shiftDoc(doc, distance) {\n        if (distance == 0) {\n            return;\n        }\n        doc.first += distance;\n        doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n            return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));\n        }), doc.sel.primIndex);\n        if (doc.cm) {\n            regChange(doc.cm, doc.first, doc.first - distance, distance);\n            for(var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++){\n                regLineChange(doc.cm, l, \"gutter\");\n            }\n        }\n    }\n    // More lower-level change function, handling only a single document\n    // (not linked ones).\n    function makeChangeSingleDoc(doc, change, selAfter, spans) {\n        if (doc.cm && !doc.cm.curOp) {\n            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n        }\n        if (change.to.line < doc.first) {\n            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n            return;\n        }\n        if (change.from.line > doc.lastLine()) {\n            return;\n        }\n        // Clip the change to the size of this doc\n        if (change.from.line < doc.first) {\n            var shift = change.text.length - 1 - (doc.first - change.from.line);\n            shiftDoc(doc, shift);\n            change = {\n                from: Pos(doc.first, 0),\n                to: Pos(change.to.line + shift, change.to.ch),\n                text: [\n                    lst(change.text)\n                ],\n                origin: change.origin\n            };\n        }\n        var last = doc.lastLine();\n        if (change.to.line > last) {\n            change = {\n                from: change.from,\n                to: Pos(last, getLine(doc, last).text.length),\n                text: [\n                    change.text[0]\n                ],\n                origin: change.origin\n            };\n        }\n        change.removed = getBetween(doc, change.from, change.to);\n        if (!selAfter) {\n            selAfter = computeSelAfterChange(doc, change);\n        }\n        if (doc.cm) {\n            makeChangeSingleDocInEditor(doc.cm, change, spans);\n        } else {\n            updateDoc(doc, change, spans);\n        }\n        setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n        if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {\n            doc.cantEdit = false;\n        }\n    }\n    // Handle the interaction of a change to a document with the editor\n    // that this document is part of.\n    function makeChangeSingleDocInEditor(cm, change, spans) {\n        var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n        var recomputeMaxLength = false, checkWidthStart = from.line;\n        if (!cm.options.lineWrapping) {\n            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n            doc.iter(checkWidthStart, to.line + 1, function(line) {\n                if (line == display.maxLine) {\n                    recomputeMaxLength = true;\n                    return true;\n                }\n            });\n        }\n        if (doc.sel.contains(change.from, change.to) > -1) {\n            signalCursorActivity(cm);\n        }\n        updateDoc(doc, change, spans, estimateHeight(cm));\n        if (!cm.options.lineWrapping) {\n            doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n                var len = lineLength(line);\n                if (len > display.maxLineLength) {\n                    display.maxLine = line;\n                    display.maxLineLength = len;\n                    display.maxLineChanged = true;\n                    recomputeMaxLength = false;\n                }\n            });\n            if (recomputeMaxLength) {\n                cm.curOp.updateMaxLine = true;\n            }\n        }\n        retreatFrontier(doc, from.line);\n        startWorker(cm, 400);\n        var lendiff = change.text.length - (to.line - from.line) - 1;\n        // Remember that these lines changed, for updating the display\n        if (change.full) {\n            regChange(cm);\n        } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n            regLineChange(cm, from.line, \"text\");\n        } else {\n            regChange(cm, from.line, to.line + 1, lendiff);\n        }\n        var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n        if (changeHandler || changesHandler) {\n            var obj = {\n                from: from,\n                to: to,\n                text: change.text,\n                removed: change.removed,\n                origin: change.origin\n            };\n            if (changeHandler) {\n                signalLater(cm, \"change\", cm, obj);\n            }\n            if (changesHandler) {\n                (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n            }\n        }\n        cm.display.selForContextMenu = null;\n    }\n    function replaceRange(doc, code, from, to, origin) {\n        var assign;\n        if (!to) {\n            to = from;\n        }\n        if (cmp(to, from) < 0) {\n            assign = [\n                to,\n                from\n            ], from = assign[0], to = assign[1];\n        }\n        if (typeof code == \"string\") {\n            code = doc.splitLines(code);\n        }\n        makeChange(doc, {\n            from: from,\n            to: to,\n            text: code,\n            origin: origin\n        });\n    }\n    // Rebasing/resetting history to deal with externally-sourced changes\n    function rebaseHistSelSingle(pos, from, to, diff) {\n        if (to < pos.line) {\n            pos.line += diff;\n        } else if (from < pos.line) {\n            pos.line = from;\n            pos.ch = 0;\n        }\n    }\n    // Tries to rebase an array of history events given a change in the\n    // document. If the change touches the same lines as the event, the\n    // event, and everything 'behind' it, is discarded. If the change is\n    // before the event, the event's positions are updated. Uses a\n    // copy-on-write scheme for the positions, to avoid having to\n    // reallocate them all on every rebase, but also avoid problems with\n    // shared position objects being unsafely updated.\n    function rebaseHistArray(array, from, to, diff) {\n        for(var i = 0; i < array.length; ++i){\n            var sub = array[i], ok = true;\n            if (sub.ranges) {\n                if (!sub.copied) {\n                    sub = array[i] = sub.deepCopy();\n                    sub.copied = true;\n                }\n                for(var j = 0; j < sub.ranges.length; j++){\n                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n                }\n                continue;\n            }\n            for(var j$1 = 0; j$1 < sub.changes.length; ++j$1){\n                var cur = sub.changes[j$1];\n                if (to < cur.from.line) {\n                    cur.from = Pos(cur.from.line + diff, cur.from.ch);\n                    cur.to = Pos(cur.to.line + diff, cur.to.ch);\n                } else if (from <= cur.to.line) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) {\n                array.splice(0, i + 1);\n                i = 0;\n            }\n        }\n    }\n    function rebaseHist(hist, change) {\n        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n        rebaseHistArray(hist.done, from, to, diff);\n        rebaseHistArray(hist.undone, from, to, diff);\n    }\n    // Utility for applying a change to a line by handle or number,\n    // returning the number and optionally registering the line as\n    // changed.\n    function changeLine(doc, handle, changeType, op) {\n        var no = handle, line = handle;\n        if (typeof handle == \"number\") {\n            line = getLine(doc, clipLine(doc, handle));\n        } else {\n            no = lineNo(handle);\n        }\n        if (no == null) {\n            return null;\n        }\n        if (op(line, no) && doc.cm) {\n            regLineChange(doc.cm, no, changeType);\n        }\n        return line;\n    }\n    // The document is represented as a BTree consisting of leaves, with\n    // chunk of lines in them, and branches, with up to ten leaves or\n    // other branch nodes below them. The top node is always a branch\n    // node, and is the document object itself (meaning it has\n    // additional methods and properties).\n    //\n    // All nodes have parent links. The tree is used both to go from\n    // line numbers to line objects, and to go from objects to numbers.\n    // It also indexes by height, and is used to convert between height\n    // and line object, and to find the total height of the document.\n    //\n    // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n    function LeafChunk(lines) {\n        this.lines = lines;\n        this.parent = null;\n        var height = 0;\n        for(var i = 0; i < lines.length; ++i){\n            lines[i].parent = this;\n            height += lines[i].height;\n        }\n        this.height = height;\n    }\n    LeafChunk.prototype = {\n        chunkSize: function() {\n            return this.lines.length;\n        },\n        // Remove the n lines at offset 'at'.\n        removeInner: function(at, n) {\n            for(var i = at, e = at + n; i < e; ++i){\n                var line = this.lines[i];\n                this.height -= line.height;\n                cleanUpLine(line);\n                signalLater(line, \"delete\");\n            }\n            this.lines.splice(at, n);\n        },\n        // Helper used to collapse a small branch into a single leaf.\n        collapse: function(lines) {\n            lines.push.apply(lines, this.lines);\n        },\n        // Insert the given array of lines at offset 'at', count them as\n        // having the given height.\n        insertInner: function(at, lines, height) {\n            this.height += height;\n            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n            for(var i = 0; i < lines.length; ++i){\n                lines[i].parent = this;\n            }\n        },\n        // Used to iterate over a part of the tree.\n        iterN: function(at, n, op) {\n            for(var e = at + n; at < e; ++at){\n                if (op(this.lines[at])) {\n                    return true;\n                }\n            }\n        }\n    };\n    function BranchChunk(children) {\n        this.children = children;\n        var size = 0, height = 0;\n        for(var i = 0; i < children.length; ++i){\n            var ch = children[i];\n            size += ch.chunkSize();\n            height += ch.height;\n            ch.parent = this;\n        }\n        this.size = size;\n        this.height = height;\n        this.parent = null;\n    }\n    BranchChunk.prototype = {\n        chunkSize: function() {\n            return this.size;\n        },\n        removeInner: function(at, n) {\n            this.size -= n;\n            for(var i = 0; i < this.children.length; ++i){\n                var child = this.children[i], sz = child.chunkSize();\n                if (at < sz) {\n                    var rm = Math.min(n, sz - at), oldHeight = child.height;\n                    child.removeInner(at, rm);\n                    this.height -= oldHeight - child.height;\n                    if (sz == rm) {\n                        this.children.splice(i--, 1);\n                        child.parent = null;\n                    }\n                    if ((n -= rm) == 0) {\n                        break;\n                    }\n                    at = 0;\n                } else {\n                    at -= sz;\n                }\n            }\n            // If the result is smaller than 25 lines, ensure that it is a\n            // single leaf node.\n            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n                var lines = [];\n                this.collapse(lines);\n                this.children = [\n                    new LeafChunk(lines)\n                ];\n                this.children[0].parent = this;\n            }\n        },\n        collapse: function(lines) {\n            for(var i = 0; i < this.children.length; ++i){\n                this.children[i].collapse(lines);\n            }\n        },\n        insertInner: function(at, lines, height) {\n            this.size += lines.length;\n            this.height += height;\n            for(var i = 0; i < this.children.length; ++i){\n                var child = this.children[i], sz = child.chunkSize();\n                if (at <= sz) {\n                    child.insertInner(at, lines, height);\n                    if (child.lines && child.lines.length > 50) {\n                        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n                        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n                        var remaining = child.lines.length % 25 + 25;\n                        for(var pos = remaining; pos < child.lines.length;){\n                            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n                            child.height -= leaf.height;\n                            this.children.splice(++i, 0, leaf);\n                            leaf.parent = this;\n                        }\n                        child.lines = child.lines.slice(0, remaining);\n                        this.maybeSpill();\n                    }\n                    break;\n                }\n                at -= sz;\n            }\n        },\n        // When a node has grown, check whether it should be split.\n        maybeSpill: function() {\n            if (this.children.length <= 10) {\n                return;\n            }\n            var me = this;\n            do {\n                var spilled = me.children.splice(me.children.length - 5, 5);\n                var sibling = new BranchChunk(spilled);\n                if (!me.parent) {\n                    var copy = new BranchChunk(me.children);\n                    copy.parent = me;\n                    me.children = [\n                        copy,\n                        sibling\n                    ];\n                    me = copy;\n                } else {\n                    me.size -= sibling.size;\n                    me.height -= sibling.height;\n                    var myIndex = indexOf(me.parent.children, me);\n                    me.parent.children.splice(myIndex + 1, 0, sibling);\n                }\n                sibling.parent = me.parent;\n            }while (me.children.length > 10);\n            me.parent.maybeSpill();\n        },\n        iterN: function(at, n, op) {\n            for(var i = 0; i < this.children.length; ++i){\n                var child = this.children[i], sz = child.chunkSize();\n                if (at < sz) {\n                    var used = Math.min(n, sz - at);\n                    if (child.iterN(at, used, op)) {\n                        return true;\n                    }\n                    if ((n -= used) == 0) {\n                        break;\n                    }\n                    at = 0;\n                } else {\n                    at -= sz;\n                }\n            }\n        }\n    };\n    // Line widgets are block elements displayed above or below a line.\n    var LineWidget = function(doc, node, options) {\n        if (options) {\n            for(var opt in options){\n                if (options.hasOwnProperty(opt)) {\n                    this[opt] = options[opt];\n                }\n            }\n        }\n        this.doc = doc;\n        this.node = node;\n    };\n    LineWidget.prototype.clear = function() {\n        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n        if (no == null || !ws) {\n            return;\n        }\n        for(var i = 0; i < ws.length; ++i){\n            if (ws[i] == this) {\n                ws.splice(i--, 1);\n            }\n        }\n        if (!ws.length) {\n            line.widgets = null;\n        }\n        var height = widgetHeight(this);\n        updateLineHeight(line, Math.max(0, line.height - height));\n        if (cm) {\n            runInOp(cm, function() {\n                adjustScrollWhenAboveVisible(cm, line, -height);\n                regLineChange(cm, no, \"widget\");\n            });\n            signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n        }\n    };\n    LineWidget.prototype.changed = function() {\n        var this$1 = this;\n        var oldH = this.height, cm = this.doc.cm, line = this.line;\n        this.height = null;\n        var diff = widgetHeight(this) - oldH;\n        if (!diff) {\n            return;\n        }\n        if (!lineIsHidden(this.doc, line)) {\n            updateLineHeight(line, line.height + diff);\n        }\n        if (cm) {\n            runInOp(cm, function() {\n                cm.curOp.forceUpdate = true;\n                adjustScrollWhenAboveVisible(cm, line, diff);\n                signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n            });\n        }\n    };\n    eventMixin(LineWidget);\n    function adjustScrollWhenAboveVisible(cm, line, diff) {\n        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n            addToScrollTop(cm, diff);\n        }\n    }\n    function addLineWidget(doc, handle, node, options) {\n        var widget = new LineWidget(doc, node, options);\n        var cm = doc.cm;\n        if (cm && widget.noHScroll) {\n            cm.display.alignWidgets = true;\n        }\n        changeLine(doc, handle, \"widget\", function(line) {\n            var widgets = line.widgets || (line.widgets = []);\n            if (widget.insertAt == null) {\n                widgets.push(widget);\n            } else {\n                widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);\n            }\n            widget.line = line;\n            if (cm && !lineIsHidden(doc, line)) {\n                var aboveVisible = heightAtLine(line) < doc.scrollTop;\n                updateLineHeight(line, line.height + widgetHeight(widget));\n                if (aboveVisible) {\n                    addToScrollTop(cm, widget.height);\n                }\n                cm.curOp.forceUpdate = true;\n            }\n            return true;\n        });\n        if (cm) {\n            signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n        }\n        return widget;\n    }\n    // TEXTMARKERS\n    // Created with markText and setBookmark methods. A TextMarker is a\n    // handle that can be used to clear or find a marked position in the\n    // document. Line objects hold arrays (markedSpans) containing\n    // {from, to, marker} object pointing to such marker objects, and\n    // indicating that such a marker is present on that line. Multiple\n    // lines may point to the same marker when it spans across lines.\n    // The spans will have null for their from/to properties when the\n    // marker continues beyond the start/end of the line. Markers have\n    // links back to the lines they currently touch.\n    // Collapsed markers have unique ids, in order to be able to order\n    // them, which is needed for uniquely determining an outer marker\n    // when they overlap (they may nest, but not partially overlap).\n    var nextMarkerId = 0;\n    var TextMarker = function(doc, type) {\n        this.lines = [];\n        this.type = type;\n        this.doc = doc;\n        this.id = ++nextMarkerId;\n    };\n    // Clear the marker.\n    TextMarker.prototype.clear = function() {\n        if (this.explicitlyCleared) {\n            return;\n        }\n        var cm = this.doc.cm, withOp = cm && !cm.curOp;\n        if (withOp) {\n            startOperation(cm);\n        }\n        if (hasHandler(this, \"clear\")) {\n            var found = this.find();\n            if (found) {\n                signalLater(this, \"clear\", found.from, found.to);\n            }\n        }\n        var min = null, max = null;\n        for(var i = 0; i < this.lines.length; ++i){\n            var line = this.lines[i];\n            var span = getMarkedSpanFor(line.markedSpans, this);\n            if (cm && !this.collapsed) {\n                regLineChange(cm, lineNo(line), \"text\");\n            } else if (cm) {\n                if (span.to != null) {\n                    max = lineNo(line);\n                }\n                if (span.from != null) {\n                    min = lineNo(line);\n                }\n            }\n            line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {\n                updateLineHeight(line, textHeight(cm.display));\n            }\n        }\n        if (cm && this.collapsed && !cm.options.lineWrapping) {\n            for(var i$1 = 0; i$1 < this.lines.length; ++i$1){\n                var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n                if (len > cm.display.maxLineLength) {\n                    cm.display.maxLine = visual;\n                    cm.display.maxLineLength = len;\n                    cm.display.maxLineChanged = true;\n                }\n            }\n        }\n        if (min != null && cm && this.collapsed) {\n            regChange(cm, min, max + 1);\n        }\n        this.lines.length = 0;\n        this.explicitlyCleared = true;\n        if (this.atomic && this.doc.cantEdit) {\n            this.doc.cantEdit = false;\n            if (cm) {\n                reCheckSelection(cm.doc);\n            }\n        }\n        if (cm) {\n            signalLater(cm, \"markerCleared\", cm, this, min, max);\n        }\n        if (withOp) {\n            endOperation(cm);\n        }\n        if (this.parent) {\n            this.parent.clear();\n        }\n    };\n    // Find the position of the marker in the document. Returns a {from,\n    // to} object by default. Side can be passed to get a specific side\n    // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n    // Pos objects returned contain a line object, rather than a line\n    // number (used to prevent looking up the same line twice).\n    TextMarker.prototype.find = function(side, lineObj) {\n        if (side == null && this.type == \"bookmark\") {\n            side = 1;\n        }\n        var from, to;\n        for(var i = 0; i < this.lines.length; ++i){\n            var line = this.lines[i];\n            var span = getMarkedSpanFor(line.markedSpans, this);\n            if (span.from != null) {\n                from = Pos(lineObj ? line : lineNo(line), span.from);\n                if (side == -1) {\n                    return from;\n                }\n            }\n            if (span.to != null) {\n                to = Pos(lineObj ? line : lineNo(line), span.to);\n                if (side == 1) {\n                    return to;\n                }\n            }\n        }\n        return from && {\n            from: from,\n            to: to\n        };\n    };\n    // Signals that the marker's widget changed, and surrounding layout\n    // should be recomputed.\n    TextMarker.prototype.changed = function() {\n        var this$1 = this;\n        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n        if (!pos || !cm) {\n            return;\n        }\n        runInOp(cm, function() {\n            var line = pos.line, lineN = lineNo(pos.line);\n            var view = findViewForLine(cm, lineN);\n            if (view) {\n                clearLineMeasurementCacheFor(view);\n                cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n            }\n            cm.curOp.updateMaxLine = true;\n            if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n                var oldHeight = widget.height;\n                widget.height = null;\n                var dHeight = widgetHeight(widget) - oldHeight;\n                if (dHeight) {\n                    updateLineHeight(line, line.height + dHeight);\n                }\n            }\n            signalLater(cm, \"markerChanged\", cm, this$1);\n        });\n    };\n    TextMarker.prototype.attachLine = function(line) {\n        if (!this.lines.length && this.doc.cm) {\n            var op = this.doc.cm.curOp;\n            if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {\n                (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n            }\n        }\n        this.lines.push(line);\n    };\n    TextMarker.prototype.detachLine = function(line) {\n        this.lines.splice(indexOf(this.lines, line), 1);\n        if (!this.lines.length && this.doc.cm) {\n            var op = this.doc.cm.curOp;\n            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n        }\n    };\n    eventMixin(TextMarker);\n    // Create a marker, wire it up to the right lines, and\n    function markText(doc, from, to, options, type) {\n        // Shared markers (across linked documents) are handled separately\n        // (markTextShared will call out to this again, once per\n        // document).\n        if (options && options.shared) {\n            return markTextShared(doc, from, to, options, type);\n        }\n        // Ensure we are in an operation.\n        if (doc.cm && !doc.cm.curOp) {\n            return operation(doc.cm, markText)(doc, from, to, options, type);\n        }\n        var marker = new TextMarker(doc, type), diff = cmp(from, to);\n        if (options) {\n            copyObj(options, marker, false);\n        }\n        // Don't connect empty markers unless clearWhenEmpty is false\n        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {\n            return marker;\n        }\n        if (marker.replacedWith) {\n            // Showing up as a widget implies collapsed (widget replaces text)\n            marker.collapsed = true;\n            marker.widgetNode = eltP(\"span\", [\n                marker.replacedWith\n            ], \"CodeMirror-widget\");\n            if (!options.handleMouseEvents) {\n                marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n            }\n            if (options.insertLeft) {\n                marker.widgetNode.insertLeft = true;\n            }\n        }\n        if (marker.collapsed) {\n            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {\n                throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n            }\n            seeCollapsedSpans();\n        }\n        if (marker.addToHistory) {\n            addChangeToHistory(doc, {\n                from: from,\n                to: to,\n                origin: \"markText\"\n            }, doc.sel, NaN);\n        }\n        var curLine = from.line, cm = doc.cm, updateMaxLine;\n        doc.iter(curLine, to.line + 1, function(line) {\n            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n                updateMaxLine = true;\n            }\n            if (marker.collapsed && curLine != from.line) {\n                updateLineHeight(line, 0);\n            }\n            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n            ++curLine;\n        });\n        // lineIsHidden depends on the presence of the spans, so needs a second pass\n        if (marker.collapsed) {\n            doc.iter(from.line, to.line + 1, function(line) {\n                if (lineIsHidden(doc, line)) {\n                    updateLineHeight(line, 0);\n                }\n            });\n        }\n        if (marker.clearOnEnter) {\n            on(marker, \"beforeCursorEnter\", function() {\n                return marker.clear();\n            });\n        }\n        if (marker.readOnly) {\n            seeReadOnlySpans();\n            if (doc.history.done.length || doc.history.undone.length) {\n                doc.clearHistory();\n            }\n        }\n        if (marker.collapsed) {\n            marker.id = ++nextMarkerId;\n            marker.atomic = true;\n        }\n        if (cm) {\n            // Sync editor state\n            if (updateMaxLine) {\n                cm.curOp.updateMaxLine = true;\n            }\n            if (marker.collapsed) {\n                regChange(cm, from.line, to.line + 1);\n            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {\n                for(var i = from.line; i <= to.line; i++){\n                    regLineChange(cm, i, \"text\");\n                }\n            }\n            if (marker.atomic) {\n                reCheckSelection(cm.doc);\n            }\n            signalLater(cm, \"markerAdded\", cm, marker);\n        }\n        return marker;\n    }\n    // SHARED TEXTMARKERS\n    // A shared marker spans multiple linked documents. It is\n    // implemented as a meta-marker-object controlling multiple normal\n    // markers.\n    var SharedTextMarker = function(markers, primary) {\n        this.markers = markers;\n        this.primary = primary;\n        for(var i = 0; i < markers.length; ++i){\n            markers[i].parent = this;\n        }\n    };\n    SharedTextMarker.prototype.clear = function() {\n        if (this.explicitlyCleared) {\n            return;\n        }\n        this.explicitlyCleared = true;\n        for(var i = 0; i < this.markers.length; ++i){\n            this.markers[i].clear();\n        }\n        signalLater(this, \"clear\");\n    };\n    SharedTextMarker.prototype.find = function(side, lineObj) {\n        return this.primary.find(side, lineObj);\n    };\n    eventMixin(SharedTextMarker);\n    function markTextShared(doc, from, to, options, type) {\n        options = copyObj(options);\n        options.shared = false;\n        var markers = [\n            markText(doc, from, to, options, type)\n        ], primary = markers[0];\n        var widget = options.widgetNode;\n        linkedDocs(doc, function(doc) {\n            if (widget) {\n                options.widgetNode = widget.cloneNode(true);\n            }\n            markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n            for(var i = 0; i < doc.linked.length; ++i){\n                if (doc.linked[i].isParent) {\n                    return;\n                }\n            }\n            primary = lst(markers);\n        });\n        return new SharedTextMarker(markers, primary);\n    }\n    function findSharedMarkers(doc) {\n        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {\n            return m.parent;\n        });\n    }\n    function copySharedMarkers(doc, markers) {\n        for(var i = 0; i < markers.length; i++){\n            var marker = markers[i], pos = marker.find();\n            var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n            if (cmp(mFrom, mTo)) {\n                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n                marker.markers.push(subMark);\n                subMark.parent = marker;\n            }\n        }\n    }\n    function detachSharedMarkers(markers) {\n        var loop = function(i) {\n            var marker = markers[i], linked = [\n                marker.primary.doc\n            ];\n            linkedDocs(marker.primary.doc, function(d) {\n                return linked.push(d);\n            });\n            for(var j = 0; j < marker.markers.length; j++){\n                var subMarker = marker.markers[j];\n                if (indexOf(linked, subMarker.doc) == -1) {\n                    subMarker.parent = null;\n                    marker.markers.splice(j--, 1);\n                }\n            }\n        };\n        for(var i = 0; i < markers.length; i++)loop(i);\n    }\n    var nextDocId = 0;\n    var Doc = function(text, mode, firstLine, lineSep, direction) {\n        if (!(this instanceof Doc)) {\n            return new Doc(text, mode, firstLine, lineSep, direction);\n        }\n        if (firstLine == null) {\n            firstLine = 0;\n        }\n        BranchChunk.call(this, [\n            new LeafChunk([\n                new Line(\"\", null)\n            ])\n        ]);\n        this.first = firstLine;\n        this.scrollTop = this.scrollLeft = 0;\n        this.cantEdit = false;\n        this.cleanGeneration = 1;\n        this.modeFrontier = this.highlightFrontier = firstLine;\n        var start = Pos(firstLine, 0);\n        this.sel = simpleSelection(start);\n        this.history = new History(null);\n        this.id = ++nextDocId;\n        this.modeOption = mode;\n        this.lineSep = lineSep;\n        this.direction = direction == \"rtl\" ? \"rtl\" : \"ltr\";\n        this.extend = false;\n        if (typeof text == \"string\") {\n            text = this.splitLines(text);\n        }\n        updateDoc(this, {\n            from: start,\n            to: start,\n            text: text\n        });\n        setSelection(this, simpleSelection(start), sel_dontScroll);\n    };\n    Doc.prototype = createObj(BranchChunk.prototype, {\n        constructor: Doc,\n        // Iterate over the document. Supports two forms -- with only one\n        // argument, it calls that for each line in the document. With\n        // three, it iterates over the range given by the first two (with\n        // the second being non-inclusive).\n        iter: function(from, to, op) {\n            if (op) {\n                this.iterN(from - this.first, to - from, op);\n            } else {\n                this.iterN(this.first, this.first + this.size, from);\n            }\n        },\n        // Non-public interface for adding and removing lines.\n        insert: function(at, lines) {\n            var height = 0;\n            for(var i = 0; i < lines.length; ++i){\n                height += lines[i].height;\n            }\n            this.insertInner(at - this.first, lines, height);\n        },\n        remove: function(at, n) {\n            this.removeInner(at - this.first, n);\n        },\n        // From here, the methods are part of the public interface. Most\n        // are also available from CodeMirror (editor) instances.\n        getValue: function(lineSep) {\n            var lines = getLines(this, this.first, this.first + this.size);\n            if (lineSep === false) {\n                return lines;\n            }\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        setValue: docMethodOp(function(code) {\n            var top = Pos(this.first, 0), last = this.first + this.size - 1;\n            makeChange(this, {\n                from: top,\n                to: Pos(last, getLine(this, last).text.length),\n                text: this.splitLines(code),\n                origin: \"setValue\",\n                full: true\n            }, true);\n            if (this.cm) {\n                scrollToCoords(this.cm, 0, 0);\n            }\n            setSelection(this, simpleSelection(top), sel_dontScroll);\n        }),\n        replaceRange: function(code, from, to, origin) {\n            from = clipPos(this, from);\n            to = to ? clipPos(this, to) : from;\n            replaceRange(this, code, from, to, origin);\n        },\n        getRange: function(from, to, lineSep) {\n            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n            if (lineSep === false) {\n                return lines;\n            }\n            if (lineSep === \"\") {\n                return lines.join(\"\");\n            }\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        getLine: function(line) {\n            var l = this.getLineHandle(line);\n            return l && l.text;\n        },\n        getLineHandle: function(line) {\n            if (isLine(this, line)) {\n                return getLine(this, line);\n            }\n        },\n        getLineNumber: function(line) {\n            return lineNo(line);\n        },\n        getLineHandleVisualStart: function(line) {\n            if (typeof line == \"number\") {\n                line = getLine(this, line);\n            }\n            return visualLine(line);\n        },\n        lineCount: function() {\n            return this.size;\n        },\n        firstLine: function() {\n            return this.first;\n        },\n        lastLine: function() {\n            return this.first + this.size - 1;\n        },\n        clipPos: function(pos) {\n            return clipPos(this, pos);\n        },\n        getCursor: function(start) {\n            var range = this.sel.primary(), pos;\n            if (start == null || start == \"head\") {\n                pos = range.head;\n            } else if (start == \"anchor\") {\n                pos = range.anchor;\n            } else if (start == \"end\" || start == \"to\" || start === false) {\n                pos = range.to();\n            } else {\n                pos = range.from();\n            }\n            return pos;\n        },\n        listSelections: function() {\n            return this.sel.ranges;\n        },\n        somethingSelected: function() {\n            return this.sel.somethingSelected();\n        },\n        setCursor: docMethodOp(function(line, ch, options) {\n            setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n        }),\n        setSelection: docMethodOp(function(anchor, head, options) {\n            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n        }),\n        extendSelection: docMethodOp(function(head, other, options) {\n            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n        }),\n        extendSelections: docMethodOp(function(heads, options) {\n            extendSelections(this, clipPosArray(this, heads), options);\n        }),\n        extendSelectionsBy: docMethodOp(function(f, options) {\n            var heads = map(this.sel.ranges, f);\n            extendSelections(this, clipPosArray(this, heads), options);\n        }),\n        setSelections: docMethodOp(function(ranges, primary, options) {\n            if (!ranges.length) {\n                return;\n            }\n            var out = [];\n            for(var i = 0; i < ranges.length; i++){\n                out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head || ranges[i].anchor));\n            }\n            if (primary == null) {\n                primary = Math.min(ranges.length - 1, this.sel.primIndex);\n            }\n            setSelection(this, normalizeSelection(this.cm, out, primary), options);\n        }),\n        addSelection: docMethodOp(function(anchor, head, options) {\n            var ranges = this.sel.ranges.slice(0);\n            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n        }),\n        getSelection: function(lineSep) {\n            var ranges = this.sel.ranges, lines;\n            for(var i = 0; i < ranges.length; i++){\n                var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n                lines = lines ? lines.concat(sel) : sel;\n            }\n            if (lineSep === false) {\n                return lines;\n            } else {\n                return lines.join(lineSep || this.lineSeparator());\n            }\n        },\n        getSelections: function(lineSep) {\n            var parts = [], ranges = this.sel.ranges;\n            for(var i = 0; i < ranges.length; i++){\n                var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n                if (lineSep !== false) {\n                    sel = sel.join(lineSep || this.lineSeparator());\n                }\n                parts[i] = sel;\n            }\n            return parts;\n        },\n        replaceSelection: function(code, collapse, origin) {\n            var dup = [];\n            for(var i = 0; i < this.sel.ranges.length; i++){\n                dup[i] = code;\n            }\n            this.replaceSelections(dup, collapse, origin || \"+input\");\n        },\n        replaceSelections: docMethodOp(function(code, collapse, origin) {\n            var changes = [], sel = this.sel;\n            for(var i = 0; i < sel.ranges.length; i++){\n                var range = sel.ranges[i];\n                changes[i] = {\n                    from: range.from(),\n                    to: range.to(),\n                    text: this.splitLines(code[i]),\n                    origin: origin\n                };\n            }\n            var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n            for(var i$1 = changes.length - 1; i$1 >= 0; i$1--){\n                makeChange(this, changes[i$1]);\n            }\n            if (newSel) {\n                setSelectionReplaceHistory(this, newSel);\n            } else if (this.cm) {\n                ensureCursorVisible(this.cm);\n            }\n        }),\n        undo: docMethodOp(function() {\n            makeChangeFromHistory(this, \"undo\");\n        }),\n        redo: docMethodOp(function() {\n            makeChangeFromHistory(this, \"redo\");\n        }),\n        undoSelection: docMethodOp(function() {\n            makeChangeFromHistory(this, \"undo\", true);\n        }),\n        redoSelection: docMethodOp(function() {\n            makeChangeFromHistory(this, \"redo\", true);\n        }),\n        setExtending: function(val) {\n            this.extend = val;\n        },\n        getExtending: function() {\n            return this.extend;\n        },\n        historySize: function() {\n            var hist = this.history, done = 0, undone = 0;\n            for(var i = 0; i < hist.done.length; i++){\n                if (!hist.done[i].ranges) {\n                    ++done;\n                }\n            }\n            for(var i$1 = 0; i$1 < hist.undone.length; i$1++){\n                if (!hist.undone[i$1].ranges) {\n                    ++undone;\n                }\n            }\n            return {\n                undo: done,\n                redo: undone\n            };\n        },\n        clearHistory: function() {\n            var this$1 = this;\n            this.history = new History(this.history);\n            linkedDocs(this, function(doc) {\n                return doc.history = this$1.history;\n            }, true);\n        },\n        markClean: function() {\n            this.cleanGeneration = this.changeGeneration(true);\n        },\n        changeGeneration: function(forceSplit) {\n            if (forceSplit) {\n                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n            }\n            return this.history.generation;\n        },\n        isClean: function(gen) {\n            return this.history.generation == (gen || this.cleanGeneration);\n        },\n        getHistory: function() {\n            return {\n                done: copyHistoryArray(this.history.done),\n                undone: copyHistoryArray(this.history.undone)\n            };\n        },\n        setHistory: function(histData) {\n            var hist = this.history = new History(this.history);\n            hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n        },\n        setGutterMarker: docMethodOp(function(line, gutterID, value) {\n            return changeLine(this, line, \"gutter\", function(line) {\n                var markers = line.gutterMarkers || (line.gutterMarkers = {});\n                markers[gutterID] = value;\n                if (!value && isEmpty(markers)) {\n                    line.gutterMarkers = null;\n                }\n                return true;\n            });\n        }),\n        clearGutter: docMethodOp(function(gutterID) {\n            var this$1 = this;\n            this.iter(function(line) {\n                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n                    changeLine(this$1, line, \"gutter\", function() {\n                        line.gutterMarkers[gutterID] = null;\n                        if (isEmpty(line.gutterMarkers)) {\n                            line.gutterMarkers = null;\n                        }\n                        return true;\n                    });\n                }\n            });\n        }),\n        lineInfo: function(line) {\n            var n;\n            if (typeof line == \"number\") {\n                if (!isLine(this, line)) {\n                    return null;\n                }\n                n = line;\n                line = getLine(this, line);\n                if (!line) {\n                    return null;\n                }\n            } else {\n                n = lineNo(line);\n                if (n == null) {\n                    return null;\n                }\n            }\n            return {\n                line: n,\n                handle: line,\n                text: line.text,\n                gutterMarkers: line.gutterMarkers,\n                textClass: line.textClass,\n                bgClass: line.bgClass,\n                wrapClass: line.wrapClass,\n                widgets: line.widgets\n            };\n        },\n        addLineClass: docMethodOp(function(handle, where, cls) {\n            return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n                var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n                if (!line[prop]) {\n                    line[prop] = cls;\n                } else if (classTest(cls).test(line[prop])) {\n                    return false;\n                } else {\n                    line[prop] += \" \" + cls;\n                }\n                return true;\n            });\n        }),\n        removeLineClass: docMethodOp(function(handle, where, cls) {\n            return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n                var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n                var cur = line[prop];\n                if (!cur) {\n                    return false;\n                } else if (cls == null) {\n                    line[prop] = null;\n                } else {\n                    var found = cur.match(classTest(cls));\n                    if (!found) {\n                        return false;\n                    }\n                    var end = found.index + found[0].length;\n                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n                }\n                return true;\n            });\n        }),\n        addLineWidget: docMethodOp(function(handle, node, options) {\n            return addLineWidget(this, handle, node, options);\n        }),\n        removeLineWidget: function(widget) {\n            widget.clear();\n        },\n        markText: function(from, to, options) {\n            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n        },\n        setBookmark: function(pos, options) {\n            var realOpts = {\n                replacedWith: options && (options.nodeType == null ? options.widget : options),\n                insertLeft: options && options.insertLeft,\n                clearWhenEmpty: false,\n                shared: options && options.shared,\n                handleMouseEvents: options && options.handleMouseEvents\n            };\n            pos = clipPos(this, pos);\n            return markText(this, pos, pos, realOpts, \"bookmark\");\n        },\n        findMarksAt: function(pos) {\n            pos = clipPos(this, pos);\n            var markers = [], spans = getLine(this, pos.line).markedSpans;\n            if (spans) {\n                for(var i = 0; i < spans.length; ++i){\n                    var span = spans[i];\n                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n                        markers.push(span.marker.parent || span.marker);\n                    }\n                }\n            }\n            return markers;\n        },\n        findMarks: function(from, to, filter) {\n            from = clipPos(this, from);\n            to = clipPos(this, to);\n            var found = [], lineNo = from.line;\n            this.iter(from.line, to.line + 1, function(line) {\n                var spans = line.markedSpans;\n                if (spans) {\n                    for(var i = 0; i < spans.length; i++){\n                        var span = spans[i];\n                        if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {\n                            found.push(span.marker.parent || span.marker);\n                        }\n                    }\n                }\n                ++lineNo;\n            });\n            return found;\n        },\n        getAllMarks: function() {\n            var markers = [];\n            this.iter(function(line) {\n                var sps = line.markedSpans;\n                if (sps) {\n                    for(var i = 0; i < sps.length; ++i){\n                        if (sps[i].from != null) {\n                            markers.push(sps[i].marker);\n                        }\n                    }\n                }\n            });\n            return markers;\n        },\n        posFromIndex: function(off) {\n            var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n            this.iter(function(line) {\n                var sz = line.text.length + sepSize;\n                if (sz > off) {\n                    ch = off;\n                    return true;\n                }\n                off -= sz;\n                ++lineNo;\n            });\n            return clipPos(this, Pos(lineNo, ch));\n        },\n        indexFromPos: function(coords) {\n            coords = clipPos(this, coords);\n            var index = coords.ch;\n            if (coords.line < this.first || coords.ch < 0) {\n                return 0;\n            }\n            var sepSize = this.lineSeparator().length;\n            this.iter(this.first, coords.line, function(line) {\n                index += line.text.length + sepSize;\n            });\n            return index;\n        },\n        copy: function(copyHistory) {\n            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n            doc.scrollTop = this.scrollTop;\n            doc.scrollLeft = this.scrollLeft;\n            doc.sel = this.sel;\n            doc.extend = false;\n            if (copyHistory) {\n                doc.history.undoDepth = this.history.undoDepth;\n                doc.setHistory(this.getHistory());\n            }\n            return doc;\n        },\n        linkedDoc: function(options) {\n            if (!options) {\n                options = {};\n            }\n            var from = this.first, to = this.first + this.size;\n            if (options.from != null && options.from > from) {\n                from = options.from;\n            }\n            if (options.to != null && options.to < to) {\n                to = options.to;\n            }\n            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n            if (options.sharedHist) {\n                copy.history = this.history;\n            }\n            (this.linked || (this.linked = [])).push({\n                doc: copy,\n                sharedHist: options.sharedHist\n            });\n            copy.linked = [\n                {\n                    doc: this,\n                    isParent: true,\n                    sharedHist: options.sharedHist\n                }\n            ];\n            copySharedMarkers(copy, findSharedMarkers(this));\n            return copy;\n        },\n        unlinkDoc: function(other) {\n            if (other instanceof CodeMirror) {\n                other = other.doc;\n            }\n            if (this.linked) {\n                for(var i = 0; i < this.linked.length; ++i){\n                    var link = this.linked[i];\n                    if (link.doc != other) {\n                        continue;\n                    }\n                    this.linked.splice(i, 1);\n                    other.unlinkDoc(this);\n                    detachSharedMarkers(findSharedMarkers(this));\n                    break;\n                }\n            }\n            // If the histories were shared, split them again\n            if (other.history == this.history) {\n                var splitIds = [\n                    other.id\n                ];\n                linkedDocs(other, function(doc) {\n                    return splitIds.push(doc.id);\n                }, true);\n                other.history = new History(null);\n                other.history.done = copyHistoryArray(this.history.done, splitIds);\n                other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n            }\n        },\n        iterLinkedDocs: function(f) {\n            linkedDocs(this, f);\n        },\n        getMode: function() {\n            return this.mode;\n        },\n        getEditor: function() {\n            return this.cm;\n        },\n        splitLines: function(str) {\n            if (this.lineSep) {\n                return str.split(this.lineSep);\n            }\n            return splitLinesAuto(str);\n        },\n        lineSeparator: function() {\n            return this.lineSep || \"\\n\";\n        },\n        setDirection: docMethodOp(function(dir) {\n            if (dir != \"rtl\") {\n                dir = \"ltr\";\n            }\n            if (dir == this.direction) {\n                return;\n            }\n            this.direction = dir;\n            this.iter(function(line) {\n                return line.order = null;\n            });\n            if (this.cm) {\n                directionChanged(this.cm);\n            }\n        })\n    });\n    // Public alias.\n    Doc.prototype.eachLine = Doc.prototype.iter;\n    // Kludge to work around strange IE behavior where it'll sometimes\n    // re-fire a series of drag-related events right after the drop (#1551)\n    var lastDrop = 0;\n    function onDrop(e) {\n        var cm = this;\n        clearDragCursor(cm);\n        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n            return;\n        }\n        e_preventDefault(e);\n        if (ie) {\n            lastDrop = +new Date;\n        }\n        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n        if (!pos || cm.isReadOnly()) {\n            return;\n        }\n        // Might be a file drop, in which case we simply extract the text\n        // and insert it.\n        if (files && files.length && window.FileReader && window.File) {\n            var n = files.length, text = Array(n), read = 0;\n            var markAsReadAndPasteIfAllFilesAreRead = function() {\n                if (++read == n) {\n                    operation(cm, function() {\n                        pos = clipPos(cm.doc, pos);\n                        var change = {\n                            from: pos,\n                            to: pos,\n                            text: cm.doc.splitLines(text.filter(function(t) {\n                                return t != null;\n                            }).join(cm.doc.lineSeparator())),\n                            origin: \"paste\"\n                        };\n                        makeChange(cm.doc, change);\n                        setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n                    })();\n                }\n            };\n            var readTextFromFile = function(file, i) {\n                if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n                    markAsReadAndPasteIfAllFilesAreRead();\n                    return;\n                }\n                var reader = new FileReader;\n                reader.onerror = function() {\n                    return markAsReadAndPasteIfAllFilesAreRead();\n                };\n                reader.onload = function() {\n                    var content = reader.result;\n                    if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n                        markAsReadAndPasteIfAllFilesAreRead();\n                        return;\n                    }\n                    text[i] = content;\n                    markAsReadAndPasteIfAllFilesAreRead();\n                };\n                reader.readAsText(file);\n            };\n            for(var i = 0; i < files.length; i++){\n                readTextFromFile(files[i], i);\n            }\n        } else {\n            // Don't do a replace if the drop happened inside of the selected text.\n            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n                cm.state.draggingText(e);\n                // Ensure the editor is re-focused\n                setTimeout(function() {\n                    return cm.display.input.focus();\n                }, 20);\n                return;\n            }\n            try {\n                var text$1 = e.dataTransfer.getData(\"Text\");\n                if (text$1) {\n                    var selected;\n                    if (cm.state.draggingText && !cm.state.draggingText.copy) {\n                        selected = cm.listSelections();\n                    }\n                    setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n                    if (selected) {\n                        for(var i$1 = 0; i$1 < selected.length; ++i$1){\n                            replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\");\n                        }\n                    }\n                    cm.replaceSelection(text$1, \"around\", \"paste\");\n                    cm.display.input.focus();\n                }\n            } catch (e$1) {}\n        }\n    }\n    function onDragStart(cm, e) {\n        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) {\n            e_stop(e);\n            return;\n        }\n        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n            return;\n        }\n        e.dataTransfer.setData(\"Text\", cm.getSelection());\n        e.dataTransfer.effectAllowed = \"copyMove\";\n        // Use dummy image instead of default browsers image.\n        // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n        if (e.dataTransfer.setDragImage && !safari) {\n            var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n            img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n            if (presto) {\n                img.width = img.height = 1;\n                cm.display.wrapper.appendChild(img);\n                // Force a relayout, or Opera won't use our image for some obscure reason\n                img._top = img.offsetTop;\n            }\n            e.dataTransfer.setDragImage(img, 0, 0);\n            if (presto) {\n                img.parentNode.removeChild(img);\n            }\n        }\n    }\n    function onDragOver(cm, e) {\n        var pos = posFromMouse(cm, e);\n        if (!pos) {\n            return;\n        }\n        var frag = document.createDocumentFragment();\n        drawSelectionCursor(cm, pos, frag);\n        if (!cm.display.dragCursor) {\n            cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n        }\n        removeChildrenAndAdd(cm.display.dragCursor, frag);\n    }\n    function clearDragCursor(cm) {\n        if (cm.display.dragCursor) {\n            cm.display.lineSpace.removeChild(cm.display.dragCursor);\n            cm.display.dragCursor = null;\n        }\n    }\n    // These must be handled carefully, because naively registering a\n    // handler for each editor will cause the editors to never be\n    // garbage collected.\n    function forEachCodeMirror(f) {\n        if (!document.getElementsByClassName) {\n            return;\n        }\n        var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n        for(var i = 0; i < byClass.length; i++){\n            var cm = byClass[i].CodeMirror;\n            if (cm) {\n                editors.push(cm);\n            }\n        }\n        if (editors.length) {\n            editors[0].operation(function() {\n                for(var i = 0; i < editors.length; i++){\n                    f(editors[i]);\n                }\n            });\n        }\n    }\n    var globalsRegistered = false;\n    function ensureGlobalHandlers() {\n        if (globalsRegistered) {\n            return;\n        }\n        registerGlobalHandlers();\n        globalsRegistered = true;\n    }\n    function registerGlobalHandlers() {\n        // When the window resizes, we need to refresh active editors.\n        var resizeTimer;\n        on(window, \"resize\", function() {\n            if (resizeTimer == null) {\n                resizeTimer = setTimeout(function() {\n                    resizeTimer = null;\n                    forEachCodeMirror(onResize);\n                }, 100);\n            }\n        });\n        // When the window loses focus, we want to show the editor as blurred\n        on(window, \"blur\", function() {\n            return forEachCodeMirror(onBlur);\n        });\n    }\n    // Called when the window resizes\n    function onResize(cm) {\n        var d = cm.display;\n        // Might be a text scaling operation, clear size caches.\n        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n        d.scrollbarsClipped = false;\n        cm.setSize();\n    }\n    var keyNames = {\n        3: \"Pause\",\n        8: \"Backspace\",\n        9: \"Tab\",\n        13: \"Enter\",\n        16: \"Shift\",\n        17: \"Ctrl\",\n        18: \"Alt\",\n        19: \"Pause\",\n        20: \"CapsLock\",\n        27: \"Esc\",\n        32: \"Space\",\n        33: \"PageUp\",\n        34: \"PageDown\",\n        35: \"End\",\n        36: \"Home\",\n        37: \"Left\",\n        38: \"Up\",\n        39: \"Right\",\n        40: \"Down\",\n        44: \"PrintScrn\",\n        45: \"Insert\",\n        46: \"Delete\",\n        59: \";\",\n        61: \"=\",\n        91: \"Mod\",\n        92: \"Mod\",\n        93: \"Mod\",\n        106: \"*\",\n        107: \"=\",\n        109: \"-\",\n        110: \".\",\n        111: \"/\",\n        145: \"ScrollLock\",\n        173: \"-\",\n        186: \";\",\n        187: \"=\",\n        188: \",\",\n        189: \"-\",\n        190: \".\",\n        191: \"/\",\n        192: \"`\",\n        219: \"[\",\n        220: \"\\\\\",\n        221: \"]\",\n        222: \"'\",\n        224: \"Mod\",\n        63232: \"Up\",\n        63233: \"Down\",\n        63234: \"Left\",\n        63235: \"Right\",\n        63272: \"Delete\",\n        63273: \"Home\",\n        63275: \"End\",\n        63276: \"PageUp\",\n        63277: \"PageDown\",\n        63302: \"Insert\"\n    };\n    // Number keys\n    for(var i = 0; i < 10; i++){\n        keyNames[i + 48] = keyNames[i + 96] = String(i);\n    }\n    // Alphabetic keys\n    for(var i$1 = 65; i$1 <= 90; i$1++){\n        keyNames[i$1] = String.fromCharCode(i$1);\n    }\n    // Function keys\n    for(var i$2 = 1; i$2 <= 12; i$2++){\n        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2;\n    }\n    var keyMap = {};\n    keyMap.basic = {\n        \"Left\": \"goCharLeft\",\n        \"Right\": \"goCharRight\",\n        \"Up\": \"goLineUp\",\n        \"Down\": \"goLineDown\",\n        \"End\": \"goLineEnd\",\n        \"Home\": \"goLineStartSmart\",\n        \"PageUp\": \"goPageUp\",\n        \"PageDown\": \"goPageDown\",\n        \"Delete\": \"delCharAfter\",\n        \"Backspace\": \"delCharBefore\",\n        \"Shift-Backspace\": \"delCharBefore\",\n        \"Tab\": \"defaultTab\",\n        \"Shift-Tab\": \"indentAuto\",\n        \"Enter\": \"newlineAndIndent\",\n        \"Insert\": \"toggleOverwrite\",\n        \"Esc\": \"singleSelection\"\n    };\n    // Note that the save and find-related commands aren't defined by\n    // default. User code or addons can define them. Unknown commands\n    // are simply ignored.\n    keyMap.pcDefault = {\n        \"Ctrl-A\": \"selectAll\",\n        \"Ctrl-D\": \"deleteLine\",\n        \"Ctrl-Z\": \"undo\",\n        \"Shift-Ctrl-Z\": \"redo\",\n        \"Ctrl-Y\": \"redo\",\n        \"Ctrl-Home\": \"goDocStart\",\n        \"Ctrl-End\": \"goDocEnd\",\n        \"Ctrl-Up\": \"goLineUp\",\n        \"Ctrl-Down\": \"goLineDown\",\n        \"Ctrl-Left\": \"goGroupLeft\",\n        \"Ctrl-Right\": \"goGroupRight\",\n        \"Alt-Left\": \"goLineStart\",\n        \"Alt-Right\": \"goLineEnd\",\n        \"Ctrl-Backspace\": \"delGroupBefore\",\n        \"Ctrl-Delete\": \"delGroupAfter\",\n        \"Ctrl-S\": \"save\",\n        \"Ctrl-F\": \"find\",\n        \"Ctrl-G\": \"findNext\",\n        \"Shift-Ctrl-G\": \"findPrev\",\n        \"Shift-Ctrl-F\": \"replace\",\n        \"Shift-Ctrl-R\": \"replaceAll\",\n        \"Ctrl-[\": \"indentLess\",\n        \"Ctrl-]\": \"indentMore\",\n        \"Ctrl-U\": \"undoSelection\",\n        \"Shift-Ctrl-U\": \"redoSelection\",\n        \"Alt-U\": \"redoSelection\",\n        \"fallthrough\": \"basic\"\n    };\n    // Very basic readline/emacs-style bindings, which are standard on Mac.\n    keyMap.emacsy = {\n        \"Ctrl-F\": \"goCharRight\",\n        \"Ctrl-B\": \"goCharLeft\",\n        \"Ctrl-P\": \"goLineUp\",\n        \"Ctrl-N\": \"goLineDown\",\n        \"Ctrl-A\": \"goLineStart\",\n        \"Ctrl-E\": \"goLineEnd\",\n        \"Ctrl-V\": \"goPageDown\",\n        \"Shift-Ctrl-V\": \"goPageUp\",\n        \"Ctrl-D\": \"delCharAfter\",\n        \"Ctrl-H\": \"delCharBefore\",\n        \"Alt-Backspace\": \"delWordBefore\",\n        \"Ctrl-K\": \"killLine\",\n        \"Ctrl-T\": \"transposeChars\",\n        \"Ctrl-O\": \"openLine\"\n    };\n    keyMap.macDefault = {\n        \"Cmd-A\": \"selectAll\",\n        \"Cmd-D\": \"deleteLine\",\n        \"Cmd-Z\": \"undo\",\n        \"Shift-Cmd-Z\": \"redo\",\n        \"Cmd-Y\": \"redo\",\n        \"Cmd-Home\": \"goDocStart\",\n        \"Cmd-Up\": \"goDocStart\",\n        \"Cmd-End\": \"goDocEnd\",\n        \"Cmd-Down\": \"goDocEnd\",\n        \"Alt-Left\": \"goGroupLeft\",\n        \"Alt-Right\": \"goGroupRight\",\n        \"Cmd-Left\": \"goLineLeft\",\n        \"Cmd-Right\": \"goLineRight\",\n        \"Alt-Backspace\": \"delGroupBefore\",\n        \"Ctrl-Alt-Backspace\": \"delGroupAfter\",\n        \"Alt-Delete\": \"delGroupAfter\",\n        \"Cmd-S\": \"save\",\n        \"Cmd-F\": \"find\",\n        \"Cmd-G\": \"findNext\",\n        \"Shift-Cmd-G\": \"findPrev\",\n        \"Cmd-Alt-F\": \"replace\",\n        \"Shift-Cmd-Alt-F\": \"replaceAll\",\n        \"Cmd-[\": \"indentLess\",\n        \"Cmd-]\": \"indentMore\",\n        \"Cmd-Backspace\": \"delWrappedLineLeft\",\n        \"Cmd-Delete\": \"delWrappedLineRight\",\n        \"Cmd-U\": \"undoSelection\",\n        \"Shift-Cmd-U\": \"redoSelection\",\n        \"Ctrl-Up\": \"goDocStart\",\n        \"Ctrl-Down\": \"goDocEnd\",\n        \"fallthrough\": [\n            \"basic\",\n            \"emacsy\"\n        ]\n    };\n    keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n    // KEYMAP DISPATCH\n    function normalizeKeyName(name) {\n        var parts = name.split(/-(?!$)/);\n        name = parts[parts.length - 1];\n        var alt, ctrl, shift, cmd;\n        for(var i = 0; i < parts.length - 1; i++){\n            var mod = parts[i];\n            if (/^(cmd|meta|m)$/i.test(mod)) {\n                cmd = true;\n            } else if (/^a(lt)?$/i.test(mod)) {\n                alt = true;\n            } else if (/^(c|ctrl|control)$/i.test(mod)) {\n                ctrl = true;\n            } else if (/^s(hift)?$/i.test(mod)) {\n                shift = true;\n            } else {\n                throw new Error(\"Unrecognized modifier name: \" + mod);\n            }\n        }\n        if (alt) {\n            name = \"Alt-\" + name;\n        }\n        if (ctrl) {\n            name = \"Ctrl-\" + name;\n        }\n        if (cmd) {\n            name = \"Cmd-\" + name;\n        }\n        if (shift) {\n            name = \"Shift-\" + name;\n        }\n        return name;\n    }\n    // This is a kludge to keep keymaps mostly working as raw objects\n    // (backwards compatibility) while at the same time support features\n    // like normalization and multi-stroke key bindings. It compiles a\n    // new normalized keymap, and then updates the old object to reflect\n    // this.\n    function normalizeKeyMap(keymap) {\n        var copy = {};\n        for(var keyname in keymap){\n            if (keymap.hasOwnProperty(keyname)) {\n                var value = keymap[keyname];\n                if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n                    continue;\n                }\n                if (value == \"...\") {\n                    delete keymap[keyname];\n                    continue;\n                }\n                var keys = map(keyname.split(\" \"), normalizeKeyName);\n                for(var i = 0; i < keys.length; i++){\n                    var val = void 0, name = void 0;\n                    if (i == keys.length - 1) {\n                        name = keys.join(\" \");\n                        val = value;\n                    } else {\n                        name = keys.slice(0, i + 1).join(\" \");\n                        val = \"...\";\n                    }\n                    var prev = copy[name];\n                    if (!prev) {\n                        copy[name] = val;\n                    } else if (prev != val) {\n                        throw new Error(\"Inconsistent bindings for \" + name);\n                    }\n                }\n                delete keymap[keyname];\n            }\n        }\n        for(var prop in copy){\n            keymap[prop] = copy[prop];\n        }\n        return keymap;\n    }\n    function lookupKey(key, map, handle, context) {\n        map = getKeyMap(map);\n        var found = map.call ? map.call(key, context) : map[key];\n        if (found === false) {\n            return \"nothing\";\n        }\n        if (found === \"...\") {\n            return \"multi\";\n        }\n        if (found != null && handle(found)) {\n            return \"handled\";\n        }\n        if (map.fallthrough) {\n            if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\") {\n                return lookupKey(key, map.fallthrough, handle, context);\n            }\n            for(var i = 0; i < map.fallthrough.length; i++){\n                var result = lookupKey(key, map.fallthrough[i], handle, context);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n    // Modifier key presses don't count as 'real' key presses for the\n    // purpose of keymap fallthrough.\n    function isModifierKey(value) {\n        var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n        return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n    }\n    function addModifierNames(name, event, noShift) {\n        var base = name;\n        if (event.altKey && base != \"Alt\") {\n            name = \"Alt-\" + name;\n        }\n        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") {\n            name = \"Ctrl-\" + name;\n        }\n        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") {\n            name = \"Cmd-\" + name;\n        }\n        if (!noShift && event.shiftKey && base != \"Shift\") {\n            name = \"Shift-\" + name;\n        }\n        return name;\n    }\n    // Look up the name of a key as indicated by an event object.\n    function keyName(event, noShift) {\n        if (presto && event.keyCode == 34 && event[\"char\"]) {\n            return false;\n        }\n        var name = keyNames[event.keyCode];\n        if (name == null || event.altGraphKey) {\n            return false;\n        }\n        // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n        // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n        if (event.keyCode == 3 && event.code) {\n            name = event.code;\n        }\n        return addModifierNames(name, event, noShift);\n    }\n    function getKeyMap(val) {\n        return typeof val == \"string\" ? keyMap[val] : val;\n    }\n    // Helper for deleting text near the selection(s), used to implement\n    // backspace, delete, and similar functionality.\n    function deleteNearSelection(cm, compute) {\n        var ranges = cm.doc.sel.ranges, kill = [];\n        // Build up a set of ranges to kill first, merging overlapping\n        // ranges.\n        for(var i = 0; i < ranges.length; i++){\n            var toKill = compute(ranges[i]);\n            while(kill.length && cmp(toKill.from, lst(kill).to) <= 0){\n                var replaced = kill.pop();\n                if (cmp(replaced.from, toKill.from) < 0) {\n                    toKill.from = replaced.from;\n                    break;\n                }\n            }\n            kill.push(toKill);\n        }\n        // Next, remove those actual ranges.\n        runInOp(cm, function() {\n            for(var i = kill.length - 1; i >= 0; i--){\n                replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n            }\n            ensureCursorVisible(cm);\n        });\n    }\n    function moveCharLogically(line, ch, dir) {\n        var target = skipExtendingChars(line.text, ch + dir, dir);\n        return target < 0 || target > line.text.length ? null : target;\n    }\n    function moveLogically(line, start, dir) {\n        var ch = moveCharLogically(line, start.ch, dir);\n        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\");\n    }\n    function endOfLine(visually, cm, lineObj, lineNo, dir) {\n        if (visually) {\n            if (cm.doc.direction == \"rtl\") {\n                dir = -dir;\n            }\n            var order = getOrder(lineObj, cm.doc.direction);\n            if (order) {\n                var part = dir < 0 ? lst(order) : order[0];\n                var moveInStorageOrder = dir < 0 == (part.level == 1);\n                var sticky = moveInStorageOrder ? \"after\" : \"before\";\n                var ch;\n                // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n                // it could be that the last bidi part is not on the last visual line,\n                // since visual lines contain content order-consecutive chunks.\n                // Thus, in rtl, we are looking for the first (content-order) character\n                // in the rtl chunk that is on the last line (that is, the same line\n                // as the last (content-order) character).\n                if (part.level > 0 || cm.doc.direction == \"rtl\") {\n                    var prep = prepareMeasureForLine(cm, lineObj);\n                    ch = dir < 0 ? lineObj.text.length - 1 : 0;\n                    var targetTop = measureCharPrepared(cm, prep, ch).top;\n                    ch = findFirst(function(ch) {\n                        return measureCharPrepared(cm, prep, ch).top == targetTop;\n                    }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n                    if (sticky == \"before\") {\n                        ch = moveCharLogically(lineObj, ch, 1);\n                    }\n                } else {\n                    ch = dir < 0 ? part.to : part.from;\n                }\n                return new Pos(lineNo, ch, sticky);\n            }\n        }\n        return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\");\n    }\n    function moveVisually(cm, line, start, dir) {\n        var bidi = getOrder(line, cm.doc.direction);\n        if (!bidi) {\n            return moveLogically(line, start, dir);\n        }\n        if (start.ch >= line.text.length) {\n            start.ch = line.text.length;\n            start.sticky = \"before\";\n        } else if (start.ch <= 0) {\n            start.ch = 0;\n            start.sticky = \"after\";\n        }\n        var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n        if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n            // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n            // nothing interesting happens.\n            return moveLogically(line, start, dir);\n        }\n        var mv = function(pos, dir) {\n            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);\n        };\n        var prep;\n        var getWrappedLineExtent = function(ch) {\n            if (!cm.options.lineWrapping) {\n                return {\n                    begin: 0,\n                    end: line.text.length\n                };\n            }\n            prep = prep || prepareMeasureForLine(cm, line);\n            return wrappedLineExtentChar(cm, line, prep, ch);\n        };\n        var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n        if (cm.doc.direction == \"rtl\" || part.level == 1) {\n            var moveInStorageOrder = part.level == 1 == dir < 0;\n            var ch = mv(start, moveInStorageOrder ? 1 : -1);\n            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n                // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n                var sticky = moveInStorageOrder ? \"before\" : \"after\";\n                return new Pos(start.line, ch, sticky);\n            }\n        }\n        // Case 3: Could not move within this bidi part in this visual line, so leave\n        // the current bidi part\n        var searchInVisualLine = function(partPos, dir, wrappedLineExtent) {\n            var getRes = function(ch, moveInStorageOrder) {\n                return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), \"before\") : new Pos(start.line, ch, \"after\");\n            };\n            for(; partPos >= 0 && partPos < bidi.length; partPos += dir){\n                var part = bidi[partPos];\n                var moveInStorageOrder = dir > 0 == (part.level != 1);\n                var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n                if (part.from <= ch && ch < part.to) {\n                    return getRes(ch, moveInStorageOrder);\n                }\n                ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n                if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {\n                    return getRes(ch, moveInStorageOrder);\n                }\n            }\n        };\n        // Case 3a: Look for other bidi parts on the same visual line\n        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n        if (res) {\n            return res;\n        }\n        // Case 3b: Look for other bidi parts on the next visual line\n        var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n            if (res) {\n                return res;\n            }\n        }\n        // Case 4: Nowhere to move\n        return null;\n    }\n    // Commands are parameter-less actions that can be performed on an\n    // editor, mostly used for keybindings.\n    var commands = {\n        selectAll: selectAll,\n        singleSelection: function(cm) {\n            return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n        },\n        killLine: function(cm) {\n            return deleteNearSelection(cm, function(range) {\n                if (range.empty()) {\n                    var len = getLine(cm.doc, range.head.line).text.length;\n                    if (range.head.ch == len && range.head.line < cm.lastLine()) {\n                        return {\n                            from: range.head,\n                            to: Pos(range.head.line + 1, 0)\n                        };\n                    } else {\n                        return {\n                            from: range.head,\n                            to: Pos(range.head.line, len)\n                        };\n                    }\n                } else {\n                    return {\n                        from: range.from(),\n                        to: range.to()\n                    };\n                }\n            });\n        },\n        deleteLine: function(cm) {\n            return deleteNearSelection(cm, function(range) {\n                return {\n                    from: Pos(range.from().line, 0),\n                    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n                };\n            });\n        },\n        delLineLeft: function(cm) {\n            return deleteNearSelection(cm, function(range) {\n                return {\n                    from: Pos(range.from().line, 0),\n                    to: range.from()\n                };\n            });\n        },\n        delWrappedLineLeft: function(cm) {\n            return deleteNearSelection(cm, function(range) {\n                var top = cm.charCoords(range.head, \"div\").top + 5;\n                var leftPos = cm.coordsChar({\n                    left: 0,\n                    top: top\n                }, \"div\");\n                return {\n                    from: leftPos,\n                    to: range.from()\n                };\n            });\n        },\n        delWrappedLineRight: function(cm) {\n            return deleteNearSelection(cm, function(range) {\n                var top = cm.charCoords(range.head, \"div\").top + 5;\n                var rightPos = cm.coordsChar({\n                    left: cm.display.lineDiv.offsetWidth + 100,\n                    top: top\n                }, \"div\");\n                return {\n                    from: range.from(),\n                    to: rightPos\n                };\n            });\n        },\n        undo: function(cm) {\n            return cm.undo();\n        },\n        redo: function(cm) {\n            return cm.redo();\n        },\n        undoSelection: function(cm) {\n            return cm.undoSelection();\n        },\n        redoSelection: function(cm) {\n            return cm.redoSelection();\n        },\n        goDocStart: function(cm) {\n            return cm.extendSelection(Pos(cm.firstLine(), 0));\n        },\n        goDocEnd: function(cm) {\n            return cm.extendSelection(Pos(cm.lastLine()));\n        },\n        goLineStart: function(cm) {\n            return cm.extendSelectionsBy(function(range) {\n                return lineStart(cm, range.head.line);\n            }, {\n                origin: \"+move\",\n                bias: 1\n            });\n        },\n        goLineStartSmart: function(cm) {\n            return cm.extendSelectionsBy(function(range) {\n                return lineStartSmart(cm, range.head);\n            }, {\n                origin: \"+move\",\n                bias: 1\n            });\n        },\n        goLineEnd: function(cm) {\n            return cm.extendSelectionsBy(function(range) {\n                return lineEnd(cm, range.head.line);\n            }, {\n                origin: \"+move\",\n                bias: -1\n            });\n        },\n        goLineRight: function(cm) {\n            return cm.extendSelectionsBy(function(range) {\n                var top = cm.cursorCoords(range.head, \"div\").top + 5;\n                return cm.coordsChar({\n                    left: cm.display.lineDiv.offsetWidth + 100,\n                    top: top\n                }, \"div\");\n            }, sel_move);\n        },\n        goLineLeft: function(cm) {\n            return cm.extendSelectionsBy(function(range) {\n                var top = cm.cursorCoords(range.head, \"div\").top + 5;\n                return cm.coordsChar({\n                    left: 0,\n                    top: top\n                }, \"div\");\n            }, sel_move);\n        },\n        goLineLeftSmart: function(cm) {\n            return cm.extendSelectionsBy(function(range) {\n                var top = cm.cursorCoords(range.head, \"div\").top + 5;\n                var pos = cm.coordsChar({\n                    left: 0,\n                    top: top\n                }, \"div\");\n                if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n                    return lineStartSmart(cm, range.head);\n                }\n                return pos;\n            }, sel_move);\n        },\n        goLineUp: function(cm) {\n            return cm.moveV(-1, \"line\");\n        },\n        goLineDown: function(cm) {\n            return cm.moveV(1, \"line\");\n        },\n        goPageUp: function(cm) {\n            return cm.moveV(-1, \"page\");\n        },\n        goPageDown: function(cm) {\n            return cm.moveV(1, \"page\");\n        },\n        goCharLeft: function(cm) {\n            return cm.moveH(-1, \"char\");\n        },\n        goCharRight: function(cm) {\n            return cm.moveH(1, \"char\");\n        },\n        goColumnLeft: function(cm) {\n            return cm.moveH(-1, \"column\");\n        },\n        goColumnRight: function(cm) {\n            return cm.moveH(1, \"column\");\n        },\n        goWordLeft: function(cm) {\n            return cm.moveH(-1, \"word\");\n        },\n        goGroupRight: function(cm) {\n            return cm.moveH(1, \"group\");\n        },\n        goGroupLeft: function(cm) {\n            return cm.moveH(-1, \"group\");\n        },\n        goWordRight: function(cm) {\n            return cm.moveH(1, \"word\");\n        },\n        delCharBefore: function(cm) {\n            return cm.deleteH(-1, \"codepoint\");\n        },\n        delCharAfter: function(cm) {\n            return cm.deleteH(1, \"char\");\n        },\n        delWordBefore: function(cm) {\n            return cm.deleteH(-1, \"word\");\n        },\n        delWordAfter: function(cm) {\n            return cm.deleteH(1, \"word\");\n        },\n        delGroupBefore: function(cm) {\n            return cm.deleteH(-1, \"group\");\n        },\n        delGroupAfter: function(cm) {\n            return cm.deleteH(1, \"group\");\n        },\n        indentAuto: function(cm) {\n            return cm.indentSelection(\"smart\");\n        },\n        indentMore: function(cm) {\n            return cm.indentSelection(\"add\");\n        },\n        indentLess: function(cm) {\n            return cm.indentSelection(\"subtract\");\n        },\n        insertTab: function(cm) {\n            return cm.replaceSelection(\"\t\");\n        },\n        insertSoftTab: function(cm) {\n            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n            for(var i = 0; i < ranges.length; i++){\n                var pos = ranges[i].from();\n                var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n                spaces.push(spaceStr(tabSize - col % tabSize));\n            }\n            cm.replaceSelections(spaces);\n        },\n        defaultTab: function(cm) {\n            if (cm.somethingSelected()) {\n                cm.indentSelection(\"add\");\n            } else {\n                cm.execCommand(\"insertTab\");\n            }\n        },\n        // Swap the two chars left and right of each selection's head.\n        // Move cursor behind the two swapped characters afterwards.\n        //\n        // Doesn't consider line feeds a character.\n        // Doesn't scan more than one line above to find a character.\n        // Doesn't do anything on an empty line.\n        // Doesn't do anything with non-empty selections.\n        transposeChars: function(cm) {\n            return runInOp(cm, function() {\n                var ranges = cm.listSelections(), newSel = [];\n                for(var i = 0; i < ranges.length; i++){\n                    if (!ranges[i].empty()) {\n                        continue;\n                    }\n                    var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n                    if (line) {\n                        if (cur.ch == line.length) {\n                            cur = new Pos(cur.line, cur.ch - 1);\n                        }\n                        if (cur.ch > 0) {\n                            cur = new Pos(cur.line, cur.ch + 1);\n                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n                        } else if (cur.line > cm.doc.first) {\n                            var prev = getLine(cm.doc, cur.line - 1).text;\n                            if (prev) {\n                                cur = new Pos(cur.line, 1);\n                                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n                            }\n                        }\n                    }\n                    newSel.push(new Range(cur, cur));\n                }\n                cm.setSelections(newSel);\n            });\n        },\n        newlineAndIndent: function(cm) {\n            return runInOp(cm, function() {\n                var sels = cm.listSelections();\n                for(var i = sels.length - 1; i >= 0; i--){\n                    cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\");\n                }\n                sels = cm.listSelections();\n                for(var i$1 = 0; i$1 < sels.length; i$1++){\n                    cm.indentLine(sels[i$1].from().line, null, true);\n                }\n                ensureCursorVisible(cm);\n            });\n        },\n        openLine: function(cm) {\n            return cm.replaceSelection(\"\\n\", \"start\");\n        },\n        toggleOverwrite: function(cm) {\n            return cm.toggleOverwrite();\n        }\n    };\n    function lineStart(cm, lineN) {\n        var line = getLine(cm.doc, lineN);\n        var visual = visualLine(line);\n        if (visual != line) {\n            lineN = lineNo(visual);\n        }\n        return endOfLine(true, cm, visual, lineN, 1);\n    }\n    function lineEnd(cm, lineN) {\n        var line = getLine(cm.doc, lineN);\n        var visual = visualLineEnd(line);\n        if (visual != line) {\n            lineN = lineNo(visual);\n        }\n        return endOfLine(true, cm, line, lineN, -1);\n    }\n    function lineStartSmart(cm, pos) {\n        var start = lineStart(cm, pos.line);\n        var line = getLine(cm.doc, start.line);\n        var order = getOrder(line, cm.doc.direction);\n        if (!order || order[0].level == 0) {\n            var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n            return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);\n        }\n        return start;\n    }\n    // Run a handler that was bound to a key.\n    function doHandleBinding(cm, bound, dropShift) {\n        if (typeof bound == \"string\") {\n            bound = commands[bound];\n            if (!bound) {\n                return false;\n            }\n        }\n        // Ensure previous input has been read, so that the handler sees a\n        // consistent view of the document\n        cm.display.input.ensurePolled();\n        var prevShift = cm.display.shift, done = false;\n        try {\n            if (cm.isReadOnly()) {\n                cm.state.suppressEdits = true;\n            }\n            if (dropShift) {\n                cm.display.shift = false;\n            }\n            done = bound(cm) != Pass;\n        } finally{\n            cm.display.shift = prevShift;\n            cm.state.suppressEdits = false;\n        }\n        return done;\n    }\n    function lookupKeyForEditor(cm, name, handle) {\n        for(var i = 0; i < cm.state.keyMaps.length; i++){\n            var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n            if (result) {\n                return result;\n            }\n        }\n        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);\n    }\n    // Note that, despite the name, this function is also used to check\n    // for bound mouse clicks.\n    var stopSeq = new Delayed;\n    function dispatchKey(cm, name, e, handle) {\n        var seq = cm.state.keySeq;\n        if (seq) {\n            if (isModifierKey(name)) {\n                return \"handled\";\n            }\n            if (/\\'$/.test(name)) {\n                cm.state.keySeq = null;\n            } else {\n                stopSeq.set(50, function() {\n                    if (cm.state.keySeq == seq) {\n                        cm.state.keySeq = null;\n                        cm.display.input.reset();\n                    }\n                });\n            }\n            if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) {\n                return true;\n            }\n        }\n        return dispatchKeyInner(cm, name, e, handle);\n    }\n    function dispatchKeyInner(cm, name, e, handle) {\n        var result = lookupKeyForEditor(cm, name, handle);\n        if (result == \"multi\") {\n            cm.state.keySeq = name;\n        }\n        if (result == \"handled\") {\n            signalLater(cm, \"keyHandled\", cm, name, e);\n        }\n        if (result == \"handled\" || result == \"multi\") {\n            e_preventDefault(e);\n            restartBlink(cm);\n        }\n        return !!result;\n    }\n    // Handle a key from the keydown event.\n    function handleKeyBinding(cm, e) {\n        var name = keyName(e, true);\n        if (!name) {\n            return false;\n        }\n        if (e.shiftKey && !cm.state.keySeq) {\n            // First try to resolve full name (including 'Shift-'). Failing\n            // that, see if there is a cursor-motion command (starting with\n            // 'go') bound to the keyname without 'Shift-'.\n            return dispatchKey(cm, \"Shift-\" + name, e, function(b) {\n                return doHandleBinding(cm, b, true);\n            }) || dispatchKey(cm, name, e, function(b) {\n                if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion) {\n                    return doHandleBinding(cm, b);\n                }\n            });\n        } else {\n            return dispatchKey(cm, name, e, function(b) {\n                return doHandleBinding(cm, b);\n            });\n        }\n    }\n    // Handle a key from the keypress event\n    function handleCharBinding(cm, e, ch) {\n        return dispatchKey(cm, \"'\" + ch + \"'\", e, function(b) {\n            return doHandleBinding(cm, b, true);\n        });\n    }\n    var lastStoppedKey = null;\n    function onKeyDown(e) {\n        var cm = this;\n        if (e.target && e.target != cm.display.input.getField()) {\n            return;\n        }\n        cm.curOp.focus = activeElt(root(cm));\n        if (signalDOMEvent(cm, e)) {\n            return;\n        }\n        // IE does strange things with escape.\n        if (ie && ie_version < 11 && e.keyCode == 27) {\n            e.returnValue = false;\n        }\n        var code = e.keyCode;\n        cm.display.shift = code == 16 || e.shiftKey;\n        var handled = handleKeyBinding(cm, e);\n        if (presto) {\n            lastStoppedKey = handled ? code : null;\n            // Opera has no cut event... we try to at least catch the key combo\n            if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n                cm.replaceSelection(\"\", null, \"cut\");\n            }\n        }\n        if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {\n            document.execCommand(\"cut\");\n        }\n        // Turn mouse into crosshair when Alt is held on Mac.\n        if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n            showCrossHair(cm);\n        }\n    }\n    function showCrossHair(cm) {\n        var lineDiv = cm.display.lineDiv;\n        addClass(lineDiv, \"CodeMirror-crosshair\");\n        function up(e) {\n            if (e.keyCode == 18 || !e.altKey) {\n                rmClass(lineDiv, \"CodeMirror-crosshair\");\n                off(document, \"keyup\", up);\n                off(document, \"mouseover\", up);\n            }\n        }\n        on(document, \"keyup\", up);\n        on(document, \"mouseover\", up);\n    }\n    function onKeyUp(e) {\n        if (e.keyCode == 16) {\n            this.doc.sel.shift = false;\n        }\n        signalDOMEvent(this, e);\n    }\n    function onKeyPress(e) {\n        var cm = this;\n        if (e.target && e.target != cm.display.input.getField()) {\n            return;\n        }\n        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n            return;\n        }\n        var keyCode = e.keyCode, charCode = e.charCode;\n        if (presto && keyCode == lastStoppedKey) {\n            lastStoppedKey = null;\n            e_preventDefault(e);\n            return;\n        }\n        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n            return;\n        }\n        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n        // Some browsers fire keypress events for backspace\n        if (ch == \"\\b\") {\n            return;\n        }\n        if (handleCharBinding(cm, e, ch)) {\n            return;\n        }\n        cm.display.input.onKeyPress(e);\n    }\n    var DOUBLECLICK_DELAY = 400;\n    var PastClick = function(time, pos, button) {\n        this.time = time;\n        this.pos = pos;\n        this.button = button;\n    };\n    PastClick.prototype.compare = function(time, pos, button) {\n        return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;\n    };\n    var lastClick, lastDoubleClick;\n    function clickRepeat(pos, button) {\n        var now = +new Date;\n        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n            lastClick = lastDoubleClick = null;\n            return \"triple\";\n        } else if (lastClick && lastClick.compare(now, pos, button)) {\n            lastDoubleClick = new PastClick(now, pos, button);\n            lastClick = null;\n            return \"double\";\n        } else {\n            lastClick = new PastClick(now, pos, button);\n            lastDoubleClick = null;\n            return \"single\";\n        }\n    }\n    // A mouse down can be a single click, double click, triple click,\n    // start of selection drag, start of text drag, new cursor\n    // (ctrl-click), rectangle drag (alt-drag), or xwin\n    // middle-click-paste. Or it might be a click on something we should\n    // not interfere with, such as a scrollbar or widget.\n    function onMouseDown(e) {\n        var cm = this, display = cm.display;\n        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n            return;\n        }\n        display.input.ensurePolled();\n        display.shift = e.shiftKey;\n        if (eventInWidget(display, e)) {\n            if (!webkit) {\n                // Briefly turn off draggability, to allow widgets to do\n                // normal dragging things.\n                display.scroller.draggable = false;\n                setTimeout(function() {\n                    return display.scroller.draggable = true;\n                }, 100);\n            }\n            return;\n        }\n        if (clickInGutter(cm, e)) {\n            return;\n        }\n        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n        win(cm).focus();\n        // #3261: make sure, that we're not starting a second selection\n        if (button == 1 && cm.state.selectingText) {\n            cm.state.selectingText(e);\n        }\n        if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n            return;\n        }\n        if (button == 1) {\n            if (pos) {\n                leftButtonDown(cm, pos, repeat, e);\n            } else if (e_target(e) == display.scroller) {\n                e_preventDefault(e);\n            }\n        } else if (button == 2) {\n            if (pos) {\n                extendSelection(cm.doc, pos);\n            }\n            setTimeout(function() {\n                return display.input.focus();\n            }, 20);\n        } else if (button == 3) {\n            if (captureRightClick) {\n                cm.display.input.onContextMenu(e);\n            } else {\n                delayBlurEvent(cm);\n            }\n        }\n    }\n    function handleMappedButton(cm, button, pos, repeat, event) {\n        var name = \"Click\";\n        if (repeat == \"double\") {\n            name = \"Double\" + name;\n        } else if (repeat == \"triple\") {\n            name = \"Triple\" + name;\n        }\n        name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n        return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {\n            if (typeof bound == \"string\") {\n                bound = commands[bound];\n            }\n            if (!bound) {\n                return false;\n            }\n            var done = false;\n            try {\n                if (cm.isReadOnly()) {\n                    cm.state.suppressEdits = true;\n                }\n                done = bound(cm, pos) != Pass;\n            } finally{\n                cm.state.suppressEdits = false;\n            }\n            return done;\n        });\n    }\n    function configureMouse(cm, repeat, event) {\n        var option = cm.getOption(\"configureMouse\");\n        var value = option ? option(cm, repeat, event) : {};\n        if (value.unit == null) {\n            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n            value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n        }\n        if (value.extend == null || cm.doc.extend) {\n            value.extend = cm.doc.extend || event.shiftKey;\n        }\n        if (value.addNew == null) {\n            value.addNew = mac ? event.metaKey : event.ctrlKey;\n        }\n        if (value.moveOnDrag == null) {\n            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n        }\n        return value;\n    }\n    function leftButtonDown(cm, pos, repeat, event) {\n        if (ie) {\n            setTimeout(bind(ensureFocus, cm), 0);\n        } else {\n            cm.curOp.focus = activeElt(root(cm));\n        }\n        var behavior = configureMouse(cm, repeat, event);\n        var sel = cm.doc.sel, contained;\n        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == \"single\" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {\n            leftButtonStartDrag(cm, event, pos, behavior);\n        } else {\n            leftButtonSelect(cm, event, pos, behavior);\n        }\n    }\n    // Start a text drag. When it ends, see if any dragging actually\n    // happen, and treat as a click if it didn't.\n    function leftButtonStartDrag(cm, event, pos, behavior) {\n        var display = cm.display, moved = false;\n        var dragEnd = operation(cm, function(e) {\n            if (webkit) {\n                display.scroller.draggable = false;\n            }\n            cm.state.draggingText = false;\n            if (cm.state.delayingBlurEvent) {\n                if (cm.hasFocus()) {\n                    cm.state.delayingBlurEvent = false;\n                } else {\n                    delayBlurEvent(cm);\n                }\n            }\n            off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n            off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n            off(display.scroller, \"dragstart\", dragStart);\n            off(display.scroller, \"drop\", dragEnd);\n            if (!moved) {\n                e_preventDefault(e);\n                if (!behavior.addNew) {\n                    extendSelection(cm.doc, pos, null, null, behavior.extend);\n                }\n                // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n                if (webkit && !safari || ie && ie_version == 9) {\n                    setTimeout(function() {\n                        display.wrapper.ownerDocument.body.focus({\n                            preventScroll: true\n                        });\n                        display.input.focus();\n                    }, 20);\n                } else {\n                    display.input.focus();\n                }\n            }\n        });\n        var mouseMove = function(e2) {\n            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n        };\n        var dragStart = function() {\n            return moved = true;\n        };\n        // Let the drag handler handle this.\n        if (webkit) {\n            display.scroller.draggable = true;\n        }\n        cm.state.draggingText = dragEnd;\n        dragEnd.copy = !behavior.moveOnDrag;\n        on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n        on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n        on(display.scroller, \"dragstart\", dragStart);\n        on(display.scroller, \"drop\", dragEnd);\n        cm.state.delayingBlurEvent = true;\n        setTimeout(function() {\n            return display.input.focus();\n        }, 20);\n        // IE's approach to draggable\n        if (display.scroller.dragDrop) {\n            display.scroller.dragDrop();\n        }\n    }\n    function rangeForUnit(cm, pos, unit) {\n        if (unit == \"char\") {\n            return new Range(pos, pos);\n        }\n        if (unit == \"word\") {\n            return cm.findWordAt(pos);\n        }\n        if (unit == \"line\") {\n            return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n        }\n        var result = unit(cm, pos);\n        return new Range(result.from, result.to);\n    }\n    // Normal selection, as opposed to text dragging.\n    function leftButtonSelect(cm, event, start, behavior) {\n        if (ie) {\n            delayBlurEvent(cm);\n        }\n        var display = cm.display, doc = cm.doc;\n        e_preventDefault(event);\n        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n        if (behavior.addNew && !behavior.extend) {\n            ourIndex = doc.sel.contains(start);\n            if (ourIndex > -1) {\n                ourRange = ranges[ourIndex];\n            } else {\n                ourRange = new Range(start, start);\n            }\n        } else {\n            ourRange = doc.sel.primary();\n            ourIndex = doc.sel.primIndex;\n        }\n        if (behavior.unit == \"rectangle\") {\n            if (!behavior.addNew) {\n                ourRange = new Range(start, start);\n            }\n            start = posFromMouse(cm, event, true, true);\n            ourIndex = -1;\n        } else {\n            var range = rangeForUnit(cm, start, behavior.unit);\n            if (behavior.extend) {\n                ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);\n            } else {\n                ourRange = range;\n            }\n        }\n        if (!behavior.addNew) {\n            ourIndex = 0;\n            setSelection(doc, new Selection([\n                ourRange\n            ], 0), sel_mouse);\n            startSel = doc.sel;\n        } else if (ourIndex == -1) {\n            ourIndex = ranges.length;\n            setSelection(doc, normalizeSelection(cm, ranges.concat([\n                ourRange\n            ]), ourIndex), {\n                scroll: false,\n                origin: \"*mouse\"\n            });\n        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n            setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {\n                scroll: false,\n                origin: \"*mouse\"\n            });\n            startSel = doc.sel;\n        } else {\n            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n        }\n        var lastPos = start;\n        function extendTo(pos) {\n            if (cmp(lastPos, pos) == 0) {\n                return;\n            }\n            lastPos = pos;\n            if (behavior.unit == \"rectangle\") {\n                var ranges = [], tabSize = cm.options.tabSize;\n                var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n                var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n                var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n                for(var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++){\n                    var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n                    if (left == right) {\n                        ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n                    } else if (text.length > leftPos) {\n                        ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n                    }\n                }\n                if (!ranges.length) {\n                    ranges.push(new Range(start, start));\n                }\n                setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {\n                    origin: \"*mouse\",\n                    scroll: false\n                });\n                cm.scrollIntoView(pos);\n            } else {\n                var oldRange = ourRange;\n                var range = rangeForUnit(cm, pos, behavior.unit);\n                var anchor = oldRange.anchor, head;\n                if (cmp(range.anchor, anchor) > 0) {\n                    head = range.head;\n                    anchor = minPos(oldRange.from(), range.anchor);\n                } else {\n                    head = range.anchor;\n                    anchor = maxPos(oldRange.to(), range.head);\n                }\n                var ranges$1 = startSel.ranges.slice(0);\n                ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n                setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n            }\n        }\n        var editorSize = display.wrapper.getBoundingClientRect();\n        // Used to ensure timeout re-tries don't fire when another extend\n        // happened in the meantime (clearTimeout isn't reliable -- at\n        // least on Chrome, the timeouts still happen even when cleared,\n        // if the clear happens after their scheduled firing time).\n        var counter = 0;\n        function extend(e) {\n            var curCount = ++counter;\n            var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n            if (!cur) {\n                return;\n            }\n            if (cmp(cur, lastPos) != 0) {\n                cm.curOp.focus = activeElt(root(cm));\n                extendTo(cur);\n                var visible = visibleLines(display, doc);\n                if (cur.line >= visible.to || cur.line < visible.from) {\n                    setTimeout(operation(cm, function() {\n                        if (counter == curCount) {\n                            extend(e);\n                        }\n                    }), 150);\n                }\n            } else {\n                var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n                if (outside) {\n                    setTimeout(operation(cm, function() {\n                        if (counter != curCount) {\n                            return;\n                        }\n                        display.scroller.scrollTop += outside;\n                        extend(e);\n                    }), 50);\n                }\n            }\n        }\n        function done(e) {\n            cm.state.selectingText = false;\n            counter = Infinity;\n            // If e is null or undefined we interpret this as someone trying\n            // to explicitly cancel the selection rather than the user\n            // letting go of the mouse button.\n            if (e) {\n                e_preventDefault(e);\n                display.input.focus();\n            }\n            off(display.wrapper.ownerDocument, \"mousemove\", move);\n            off(display.wrapper.ownerDocument, \"mouseup\", up);\n            doc.history.lastSelOrigin = null;\n        }\n        var move = operation(cm, function(e) {\n            if (e.buttons === 0 || !e_button(e)) {\n                done(e);\n            } else {\n                extend(e);\n            }\n        });\n        var up = operation(cm, done);\n        cm.state.selectingText = up;\n        on(display.wrapper.ownerDocument, \"mousemove\", move);\n        on(display.wrapper.ownerDocument, \"mouseup\", up);\n    }\n    // Used when mouse-selecting to adjust the anchor to the proper side\n    // of a bidi jump depending on the visual position of the head.\n    function bidiSimplify(cm, range) {\n        var anchor = range.anchor;\n        var head = range.head;\n        var anchorLine = getLine(cm.doc, anchor.line);\n        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {\n            return range;\n        }\n        var order = getOrder(anchorLine);\n        if (!order) {\n            return range;\n        }\n        var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n        if (part.from != anchor.ch && part.to != anchor.ch) {\n            return range;\n        }\n        var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);\n        if (boundary == 0 || boundary == order.length) {\n            return range;\n        }\n        // Compute the relative visual position of the head compared to the\n        // anchor (<0 is to the left, >0 to the right)\n        var leftSide;\n        if (head.line != anchor.line) {\n            leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n        } else {\n            var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n            if (headIndex == boundary - 1 || headIndex == boundary) {\n                leftSide = dir < 0;\n            } else {\n                leftSide = dir > 0;\n            }\n        }\n        var usePart = order[boundary + (leftSide ? -1 : 0)];\n        var from = leftSide == (usePart.level == 1);\n        var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n        return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);\n    }\n    // Determines whether an event happened in the gutter, and fires the\n    // handlers for the corresponding event.\n    function gutterEvent(cm, e, type, prevent) {\n        var mX, mY;\n        if (e.touches) {\n            mX = e.touches[0].clientX;\n            mY = e.touches[0].clientY;\n        } else {\n            try {\n                mX = e.clientX;\n                mY = e.clientY;\n            } catch (e$1) {\n                return false;\n            }\n        }\n        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n            return false;\n        }\n        if (prevent) {\n            e_preventDefault(e);\n        }\n        var display = cm.display;\n        var lineBox = display.lineDiv.getBoundingClientRect();\n        if (mY > lineBox.bottom || !hasHandler(cm, type)) {\n            return e_defaultPrevented(e);\n        }\n        mY -= lineBox.top - display.viewOffset;\n        for(var i = 0; i < cm.display.gutterSpecs.length; ++i){\n            var g = display.gutters.childNodes[i];\n            if (g && g.getBoundingClientRect().right >= mX) {\n                var line = lineAtHeight(cm.doc, mY);\n                var gutter = cm.display.gutterSpecs[i];\n                signal(cm, type, cm, line, gutter.className, e);\n                return e_defaultPrevented(e);\n            }\n        }\n    }\n    function clickInGutter(cm, e) {\n        return gutterEvent(cm, e, \"gutterClick\", true);\n    }\n    // CONTEXT MENU HANDLING\n    // To make the context menu work, we need to briefly unhide the\n    // textarea (making it as unobtrusive as possible) to let the\n    // right-click take effect on it.\n    function onContextMenu(cm, e) {\n        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n            return;\n        }\n        if (signalDOMEvent(cm, e, \"contextmenu\")) {\n            return;\n        }\n        if (!captureRightClick) {\n            cm.display.input.onContextMenu(e);\n        }\n    }\n    function contextMenuInGutter(cm, e) {\n        if (!hasHandler(cm, \"gutterContextMenu\")) {\n            return false;\n        }\n        return gutterEvent(cm, e, \"gutterContextMenu\", false);\n    }\n    function themeChanged(cm) {\n        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") + cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n        clearCaches(cm);\n    }\n    var Init = {\n        toString: function() {\n            return \"CodeMirror.Init\";\n        }\n    };\n    var defaults = {};\n    var optionHandlers = {};\n    function defineOptions(CodeMirror) {\n        var optionHandlers = CodeMirror.optionHandlers;\n        function option(name, deflt, handle, notOnInit) {\n            CodeMirror.defaults[name] = deflt;\n            if (handle) {\n                optionHandlers[name] = notOnInit ? function(cm, val, old) {\n                    if (old != Init) {\n                        handle(cm, val, old);\n                    }\n                } : handle;\n            }\n        }\n        CodeMirror.defineOption = option;\n        // Passed to option handlers when there is no old value.\n        CodeMirror.Init = Init;\n        // These two are, on init, called from the constructor because they\n        // have to be initialized before the editor can start at all.\n        option(\"value\", \"\", function(cm, val) {\n            return cm.setValue(val);\n        }, true);\n        option(\"mode\", null, function(cm, val) {\n            cm.doc.modeOption = val;\n            loadMode(cm);\n        }, true);\n        option(\"indentUnit\", 2, loadMode, true);\n        option(\"indentWithTabs\", false);\n        option(\"smartIndent\", true);\n        option(\"tabSize\", 4, function(cm) {\n            resetModeState(cm);\n            clearCaches(cm);\n            regChange(cm);\n        }, true);\n        option(\"lineSeparator\", null, function(cm, val) {\n            cm.doc.lineSep = val;\n            if (!val) {\n                return;\n            }\n            var newBreaks = [], lineNo = cm.doc.first;\n            cm.doc.iter(function(line) {\n                for(var pos = 0;;){\n                    var found = line.text.indexOf(val, pos);\n                    if (found == -1) {\n                        break;\n                    }\n                    pos = found + val.length;\n                    newBreaks.push(Pos(lineNo, found));\n                }\n                lineNo++;\n            });\n            for(var i = newBreaks.length - 1; i >= 0; i--){\n                replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));\n            }\n        });\n        option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]/g, function(cm, val, old) {\n            cm.state.specialChars = new RegExp(val.source + (val.test(\"\t\") ? \"\" : \"|\t\"), \"g\");\n            if (old != Init) {\n                cm.refresh();\n            }\n        });\n        option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {\n            return cm.refresh();\n        }, true);\n        option(\"electricChars\", true);\n        option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n            throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n            ;\n        }, true);\n        option(\"spellcheck\", false, function(cm, val) {\n            return cm.getInputField().spellcheck = val;\n        }, true);\n        option(\"autocorrect\", false, function(cm, val) {\n            return cm.getInputField().autocorrect = val;\n        }, true);\n        option(\"autocapitalize\", false, function(cm, val) {\n            return cm.getInputField().autocapitalize = val;\n        }, true);\n        option(\"rtlMoveVisually\", !windows);\n        option(\"wholeLineUpdateBefore\", true);\n        option(\"theme\", \"default\", function(cm) {\n            themeChanged(cm);\n            updateGutters(cm);\n        }, true);\n        option(\"keyMap\", \"default\", function(cm, val, old) {\n            var next = getKeyMap(val);\n            var prev = old != Init && getKeyMap(old);\n            if (prev && prev.detach) {\n                prev.detach(cm, next);\n            }\n            if (next.attach) {\n                next.attach(cm, prev || null);\n            }\n        });\n        option(\"extraKeys\", null);\n        option(\"configureMouse\", null);\n        option(\"lineWrapping\", false, wrappingChanged, true);\n        option(\"gutters\", [], function(cm, val) {\n            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n            updateGutters(cm);\n        }, true);\n        option(\"fixedGutter\", true, function(cm, val) {\n            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n            cm.refresh();\n        }, true);\n        option(\"coverGutterNextToScrollbar\", false, function(cm) {\n            return updateScrollbars(cm);\n        }, true);\n        option(\"scrollbarStyle\", \"native\", function(cm) {\n            initScrollbars(cm);\n            updateScrollbars(cm);\n            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n        }, true);\n        option(\"lineNumbers\", false, function(cm, val) {\n            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n            updateGutters(cm);\n        }, true);\n        option(\"firstLineNumber\", 1, updateGutters, true);\n        option(\"lineNumberFormatter\", function(integer) {\n            return integer;\n        }, updateGutters, true);\n        option(\"showCursorWhenSelecting\", false, updateSelection, true);\n        option(\"resetSelectionOnContextMenu\", true);\n        option(\"lineWiseCopyCut\", true);\n        option(\"pasteLinesPerSelection\", true);\n        option(\"selectionsMayTouch\", false);\n        option(\"readOnly\", false, function(cm, val) {\n            if (val == \"nocursor\") {\n                onBlur(cm);\n                cm.display.input.blur();\n            }\n            cm.display.input.readOnlyChanged(val);\n        });\n        option(\"screenReaderLabel\", null, function(cm, val) {\n            val = val === \"\" ? null : val;\n            cm.display.input.screenReaderLabelChanged(val);\n        });\n        option(\"disableInput\", false, function(cm, val) {\n            if (!val) {\n                cm.display.input.reset();\n            }\n        }, true);\n        option(\"dragDrop\", true, dragDropChanged);\n        option(\"allowDropFileTypes\", null);\n        option(\"cursorBlinkRate\", 530);\n        option(\"cursorScrollMargin\", 0);\n        option(\"cursorHeight\", 1, updateSelection, true);\n        option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n        option(\"workTime\", 100);\n        option(\"workDelay\", 100);\n        option(\"flattenSpans\", true, resetModeState, true);\n        option(\"addModeClass\", false, resetModeState, true);\n        option(\"pollInterval\", 100);\n        option(\"undoDepth\", 200, function(cm, val) {\n            return cm.doc.history.undoDepth = val;\n        });\n        option(\"historyEventDelay\", 1250);\n        option(\"viewportMargin\", 10, function(cm) {\n            return cm.refresh();\n        }, true);\n        option(\"maxHighlightLength\", 10000, resetModeState, true);\n        option(\"moveInputWithCursor\", true, function(cm, val) {\n            if (!val) {\n                cm.display.input.resetPosition();\n            }\n        });\n        option(\"tabindex\", null, function(cm, val) {\n            return cm.display.input.getField().tabIndex = val || \"\";\n        });\n        option(\"autofocus\", null);\n        option(\"direction\", \"ltr\", function(cm, val) {\n            return cm.doc.setDirection(val);\n        }, true);\n        option(\"phrases\", null);\n    }\n    function dragDropChanged(cm, value, old) {\n        var wasOn = old && old != Init;\n        if (!value != !wasOn) {\n            var funcs = cm.display.dragFunctions;\n            var toggle = value ? on : off;\n            toggle(cm.display.scroller, \"dragstart\", funcs.start);\n            toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n            toggle(cm.display.scroller, \"dragover\", funcs.over);\n            toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n            toggle(cm.display.scroller, \"drop\", funcs.drop);\n        }\n    }\n    function wrappingChanged(cm) {\n        if (cm.options.lineWrapping) {\n            addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n            cm.display.sizer.style.minWidth = \"\";\n            cm.display.sizerWidth = null;\n        } else {\n            rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n            findMaxLine(cm);\n        }\n        estimateLineHeights(cm);\n        regChange(cm);\n        clearCaches(cm);\n        setTimeout(function() {\n            return updateScrollbars(cm);\n        }, 100);\n    }\n    // A CodeMirror instance represents an editor. This is the object\n    // that user code is usually dealing with.\n    function CodeMirror(place, options) {\n        var this$1 = this;\n        if (!(this instanceof CodeMirror)) {\n            return new CodeMirror(place, options);\n        }\n        this.options = options = options ? copyObj(options) : {};\n        // Determine effective options based on given values and defaults.\n        copyObj(defaults, options, false);\n        var doc = options.value;\n        if (typeof doc == \"string\") {\n            doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);\n        } else if (options.mode) {\n            doc.modeOption = options.mode;\n        }\n        this.doc = doc;\n        var input = new CodeMirror.inputStyles[options.inputStyle](this);\n        var display = this.display = new Display(place, doc, input, options);\n        display.wrapper.CodeMirror = this;\n        themeChanged(this);\n        if (options.lineWrapping) {\n            this.display.wrapper.className += \" CodeMirror-wrap\";\n        }\n        initScrollbars(this);\n        this.state = {\n            keyMaps: [],\n            overlays: [],\n            modeGen: 0,\n            overwrite: false,\n            delayingBlurEvent: false,\n            focused: false,\n            suppressEdits: false,\n            pasteIncoming: -1,\n            cutIncoming: -1,\n            selectingText: false,\n            draggingText: false,\n            highlight: new Delayed(),\n            keySeq: null,\n            specialChars: null\n        };\n        if (options.autofocus && !mobile) {\n            display.input.focus();\n        }\n        // Override magic textarea content restore that IE sometimes does\n        // on our hidden textarea on reload\n        if (ie && ie_version < 11) {\n            setTimeout(function() {\n                return this$1.display.input.reset(true);\n            }, 20);\n        }\n        registerEventHandlers(this);\n        ensureGlobalHandlers();\n        startOperation(this);\n        this.curOp.forceUpdate = true;\n        attachDoc(this, doc);\n        if (options.autofocus && !mobile || this.hasFocus()) {\n            setTimeout(function() {\n                if (this$1.hasFocus() && !this$1.state.focused) {\n                    onFocus(this$1);\n                }\n            }, 20);\n        } else {\n            onBlur(this);\n        }\n        for(var opt in optionHandlers){\n            if (optionHandlers.hasOwnProperty(opt)) {\n                optionHandlers[opt](this, options[opt], Init);\n            }\n        }\n        maybeUpdateLineNumberWidth(this);\n        if (options.finishInit) {\n            options.finishInit(this);\n        }\n        for(var i = 0; i < initHooks.length; ++i){\n            initHooks[i](this);\n        }\n        endOperation(this);\n        // Suppress optimizelegibility in Webkit, since it breaks text\n        // measuring on line wrapping boundaries.\n        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\") {\n            display.lineDiv.style.textRendering = \"auto\";\n        }\n    }\n    // The default configuration options.\n    CodeMirror.defaults = defaults;\n    // Functions to run when options are changed.\n    CodeMirror.optionHandlers = optionHandlers;\n    // Attach the necessary event handlers when initializing the editor\n    function registerEventHandlers(cm) {\n        var d = cm.display;\n        on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n        // Older IE's will not fire a second mousedown for a double click\n        if (ie && ie_version < 11) {\n            on(d.scroller, \"dblclick\", operation(cm, function(e) {\n                if (signalDOMEvent(cm, e)) {\n                    return;\n                }\n                var pos = posFromMouse(cm, e);\n                if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n                    return;\n                }\n                e_preventDefault(e);\n                var word = cm.findWordAt(pos);\n                extendSelection(cm.doc, word.anchor, word.head);\n            }));\n        } else {\n            on(d.scroller, \"dblclick\", function(e) {\n                return signalDOMEvent(cm, e) || e_preventDefault(e);\n            });\n        }\n        // Some browsers fire contextmenu *after* opening the menu, at\n        // which point we can't mess with it anymore. Context menu is\n        // handled in onMouseDown for these browsers.\n        on(d.scroller, \"contextmenu\", function(e) {\n            return onContextMenu(cm, e);\n        });\n        on(d.input.getField(), \"contextmenu\", function(e) {\n            if (!d.scroller.contains(e.target)) {\n                onContextMenu(cm, e);\n            }\n        });\n        // Used to suppress mouse event handling when a touch happens\n        var touchFinished, prevTouch = {\n            end: 0\n        };\n        function finishTouch() {\n            if (d.activeTouch) {\n                touchFinished = setTimeout(function() {\n                    return d.activeTouch = null;\n                }, 1000);\n                prevTouch = d.activeTouch;\n                prevTouch.end = +new Date;\n            }\n        }\n        function isMouseLikeTouchEvent(e) {\n            if (e.touches.length != 1) {\n                return false;\n            }\n            var touch = e.touches[0];\n            return touch.radiusX <= 1 && touch.radiusY <= 1;\n        }\n        function farAway(touch, other) {\n            if (other.left == null) {\n                return true;\n            }\n            var dx = other.left - touch.left, dy = other.top - touch.top;\n            return dx * dx + dy * dy > 20 * 20;\n        }\n        on(d.scroller, \"touchstart\", function(e) {\n            if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n                d.input.ensurePolled();\n                clearTimeout(touchFinished);\n                var now = +new Date;\n                d.activeTouch = {\n                    start: now,\n                    moved: false,\n                    prev: now - prevTouch.end <= 300 ? prevTouch : null\n                };\n                if (e.touches.length == 1) {\n                    d.activeTouch.left = e.touches[0].pageX;\n                    d.activeTouch.top = e.touches[0].pageY;\n                }\n            }\n        });\n        on(d.scroller, \"touchmove\", function() {\n            if (d.activeTouch) {\n                d.activeTouch.moved = true;\n            }\n        });\n        on(d.scroller, \"touchend\", function(e) {\n            var touch = d.activeTouch;\n            if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date - touch.start < 300) {\n                var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n                if (!touch.prev || farAway(touch, touch.prev)) {\n                    range = new Range(pos, pos);\n                } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {\n                    range = cm.findWordAt(pos);\n                } else {\n                    range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n                }\n                cm.setSelection(range.anchor, range.head);\n                cm.focus();\n                e_preventDefault(e);\n            }\n            finishTouch();\n        });\n        on(d.scroller, \"touchcancel\", finishTouch);\n        // Sync scrolling between fake scrollbars and real scrollable\n        // area, ensure viewport is updated when scrolling.\n        on(d.scroller, \"scroll\", function() {\n            if (d.scroller.clientHeight) {\n                updateScrollTop(cm, d.scroller.scrollTop);\n                setScrollLeft(cm, d.scroller.scrollLeft, true);\n                signal(cm, \"scroll\", cm);\n            }\n        });\n        // Listen to wheel events in order to try and update the viewport on time.\n        on(d.scroller, \"mousewheel\", function(e) {\n            return onScrollWheel(cm, e);\n        });\n        on(d.scroller, \"DOMMouseScroll\", function(e) {\n            return onScrollWheel(cm, e);\n        });\n        // Prevent wrapper from ever scrolling\n        on(d.wrapper, \"scroll\", function() {\n            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n        });\n        d.dragFunctions = {\n            enter: function(e) {\n                if (!signalDOMEvent(cm, e)) {\n                    e_stop(e);\n                }\n            },\n            over: function(e) {\n                if (!signalDOMEvent(cm, e)) {\n                    onDragOver(cm, e);\n                    e_stop(e);\n                }\n            },\n            start: function(e) {\n                return onDragStart(cm, e);\n            },\n            drop: operation(cm, onDrop),\n            leave: function(e) {\n                if (!signalDOMEvent(cm, e)) {\n                    clearDragCursor(cm);\n                }\n            }\n        };\n        var inp = d.input.getField();\n        on(inp, \"keyup\", function(e) {\n            return onKeyUp.call(cm, e);\n        });\n        on(inp, \"keydown\", operation(cm, onKeyDown));\n        on(inp, \"keypress\", operation(cm, onKeyPress));\n        on(inp, \"focus\", function(e) {\n            return onFocus(cm, e);\n        });\n        on(inp, \"blur\", function(e) {\n            return onBlur(cm, e);\n        });\n    }\n    var initHooks = [];\n    CodeMirror.defineInitHook = function(f) {\n        return initHooks.push(f);\n    };\n    // Indent the given line. The how parameter can be \"smart\",\n    // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n    // (typically set to true for forced single-line indents), empty\n    // lines are not indented, and places where the mode returns Pass\n    // are left alone.\n    function indentLine(cm, n, how, aggressive) {\n        var doc = cm.doc, state;\n        if (how == null) {\n            how = \"add\";\n        }\n        if (how == \"smart\") {\n            // Fall back to \"prev\" when the mode doesn't have an indentation\n            // method.\n            if (!doc.mode.indent) {\n                how = \"prev\";\n            } else {\n                state = getContextBefore(cm, n).state;\n            }\n        }\n        var tabSize = cm.options.tabSize;\n        var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n        if (line.stateAfter) {\n            line.stateAfter = null;\n        }\n        var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n        if (!aggressive && !/\\S/.test(line.text)) {\n            indentation = 0;\n            how = \"not\";\n        } else if (how == \"smart\") {\n            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n            if (indentation == Pass || indentation > 150) {\n                if (!aggressive) {\n                    return;\n                }\n                how = \"prev\";\n            }\n        }\n        if (how == \"prev\") {\n            if (n > doc.first) {\n                indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);\n            } else {\n                indentation = 0;\n            }\n        } else if (how == \"add\") {\n            indentation = curSpace + cm.options.indentUnit;\n        } else if (how == \"subtract\") {\n            indentation = curSpace - cm.options.indentUnit;\n        } else if (typeof how == \"number\") {\n            indentation = curSpace + how;\n        }\n        indentation = Math.max(0, indentation);\n        var indentString = \"\", pos = 0;\n        if (cm.options.indentWithTabs) {\n            for(var i = Math.floor(indentation / tabSize); i; --i){\n                pos += tabSize;\n                indentString += \"\t\";\n            }\n        }\n        if (pos < indentation) {\n            indentString += spaceStr(indentation - pos);\n        }\n        if (indentString != curSpaceString) {\n            replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n            line.stateAfter = null;\n            return true;\n        } else {\n            // Ensure that, if the cursor was in the whitespace at the start\n            // of the line, it is moved to the end of that space.\n            for(var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++){\n                var range = doc.sel.ranges[i$1];\n                if (range.head.line == n && range.head.ch < curSpaceString.length) {\n                    var pos$1 = Pos(n, curSpaceString.length);\n                    replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n                    break;\n                }\n            }\n        }\n    }\n    // This will be set to a {lineWise: bool, text: [string]} object, so\n    // that, when pasting, we know what kind of selections the copied\n    // text was made out of.\n    var lastCopied = null;\n    function setLastCopied(newLastCopied) {\n        lastCopied = newLastCopied;\n    }\n    function applyTextInput(cm, inserted, deleted, sel, origin) {\n        var doc = cm.doc;\n        cm.display.shift = false;\n        if (!sel) {\n            sel = doc.sel;\n        }\n        var recent = +new Date - 200;\n        var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n        var textLines = splitLinesAuto(inserted), multiPaste = null;\n        // When pasting N lines into N selections, insert one line per selection\n        if (paste && sel.ranges.length > 1) {\n            if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n                if (sel.ranges.length % lastCopied.text.length == 0) {\n                    multiPaste = [];\n                    for(var i = 0; i < lastCopied.text.length; i++){\n                        multiPaste.push(doc.splitLines(lastCopied.text[i]));\n                    }\n                }\n            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n                multiPaste = map(textLines, function(l) {\n                    return [\n                        l\n                    ];\n                });\n            }\n        }\n        var updateInput = cm.curOp.updateInput;\n        // Normal behavior is to insert the new text into every selection\n        for(var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--){\n            var range = sel.ranges[i$1];\n            var from = range.from(), to = range.to();\n            if (range.empty()) {\n                if (deleted && deleted > 0) {\n                    from = Pos(from.line, from.ch - deleted);\n                } else if (cm.state.overwrite && !paste) {\n                    to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n                } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\")) {\n                    from = to = Pos(from.line, 0);\n                }\n            }\n            var changeEvent = {\n                from: from,\n                to: to,\n                text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")\n            };\n            makeChange(cm.doc, changeEvent);\n            signalLater(cm, \"inputRead\", cm, changeEvent);\n        }\n        if (inserted && !paste) {\n            triggerElectric(cm, inserted);\n        }\n        ensureCursorVisible(cm);\n        if (cm.curOp.updateInput < 2) {\n            cm.curOp.updateInput = updateInput;\n        }\n        cm.curOp.typing = true;\n        cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n    }\n    function handlePaste(e, cm) {\n        var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n        if (pasted) {\n            e.preventDefault();\n            if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {\n                runInOp(cm, function() {\n                    return applyTextInput(cm, pasted, 0, null, \"paste\");\n                });\n            }\n            return true;\n        }\n    }\n    function triggerElectric(cm, inserted) {\n        // When an 'electric' character is inserted, immediately trigger a reindent\n        if (!cm.options.electricChars || !cm.options.smartIndent) {\n            return;\n        }\n        var sel = cm.doc.sel;\n        for(var i = sel.ranges.length - 1; i >= 0; i--){\n            var range = sel.ranges[i];\n            if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {\n                continue;\n            }\n            var mode = cm.getModeAt(range.head);\n            var indented = false;\n            if (mode.electricChars) {\n                for(var j = 0; j < mode.electricChars.length; j++){\n                    if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n                        indented = indentLine(cm, range.head.line, \"smart\");\n                        break;\n                    }\n                }\n            } else if (mode.electricInput) {\n                if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {\n                    indented = indentLine(cm, range.head.line, \"smart\");\n                }\n            }\n            if (indented) {\n                signalLater(cm, \"electricInput\", cm, range.head.line);\n            }\n        }\n    }\n    function copyableRanges(cm) {\n        var text = [], ranges = [];\n        for(var i = 0; i < cm.doc.sel.ranges.length; i++){\n            var line = cm.doc.sel.ranges[i].head.line;\n            var lineRange = {\n                anchor: Pos(line, 0),\n                head: Pos(line + 1, 0)\n            };\n            ranges.push(lineRange);\n            text.push(cm.getRange(lineRange.anchor, lineRange.head));\n        }\n        return {\n            text: text,\n            ranges: ranges\n        };\n    }\n    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n        field.setAttribute(\"autocorrect\", autocorrect ? \"on\" : \"off\");\n        field.setAttribute(\"autocapitalize\", autocapitalize ? \"on\" : \"off\");\n        field.setAttribute(\"spellcheck\", !!spellcheck);\n    }\n    function hiddenTextarea() {\n        var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none\");\n        var div = elt(\"div\", [\n            te\n        ], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n        // The textarea is kept positioned near the cursor to prevent the\n        // fact that it'll be scrolled into view on input from scrolling\n        // our fake cursor out of view. On webkit, when wrap=off, paste is\n        // very slow. So make the area wide instead.\n        if (webkit) {\n            te.style.width = \"1000px\";\n        } else {\n            te.setAttribute(\"wrap\", \"off\");\n        }\n        // If border: 0; -- iOS fails to open keyboard (issue #1287)\n        if (ios) {\n            te.style.border = \"1px solid black\";\n        }\n        return div;\n    }\n    // The publicly visible API. Note that methodOp(f) means\n    // 'wrap f in an operation, performed on its `this` parameter'.\n    // This is not the complete set of editor methods. Most of the\n    // methods defined on the Doc type are also injected into\n    // CodeMirror.prototype, for backwards compatibility and\n    // convenience.\n    function addEditorMethods(CodeMirror) {\n        var optionHandlers = CodeMirror.optionHandlers;\n        var helpers = CodeMirror.helpers = {};\n        CodeMirror.prototype = {\n            constructor: CodeMirror,\n            focus: function() {\n                win(this).focus();\n                this.display.input.focus();\n            },\n            setOption: function(option, value) {\n                var options = this.options, old = options[option];\n                if (options[option] == value && option != \"mode\") {\n                    return;\n                }\n                options[option] = value;\n                if (optionHandlers.hasOwnProperty(option)) {\n                    operation(this, optionHandlers[option])(this, value, old);\n                }\n                signal(this, \"optionChange\", this, option);\n            },\n            getOption: function(option) {\n                return this.options[option];\n            },\n            getDoc: function() {\n                return this.doc;\n            },\n            addKeyMap: function(map, bottom) {\n                this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n            },\n            removeKeyMap: function(map) {\n                var maps = this.state.keyMaps;\n                for(var i = 0; i < maps.length; ++i){\n                    if (maps[i] == map || maps[i].name == map) {\n                        maps.splice(i, 1);\n                        return true;\n                    }\n                }\n            },\n            addOverlay: methodOp(function(spec, options) {\n                var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n                if (mode.startState) {\n                    throw new Error(\"Overlays may not be stateful.\");\n                }\n                insertSorted(this.state.overlays, {\n                    mode: mode,\n                    modeSpec: spec,\n                    opaque: options && options.opaque,\n                    priority: options && options.priority || 0\n                }, function(overlay) {\n                    return overlay.priority;\n                });\n                this.state.modeGen++;\n                regChange(this);\n            }),\n            removeOverlay: methodOp(function(spec) {\n                var overlays = this.state.overlays;\n                for(var i = 0; i < overlays.length; ++i){\n                    var cur = overlays[i].modeSpec;\n                    if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n                        overlays.splice(i, 1);\n                        this.state.modeGen++;\n                        regChange(this);\n                        return;\n                    }\n                }\n            }),\n            indentLine: methodOp(function(n, dir, aggressive) {\n                if (typeof dir != \"string\" && typeof dir != \"number\") {\n                    if (dir == null) {\n                        dir = this.options.smartIndent ? \"smart\" : \"prev\";\n                    } else {\n                        dir = dir ? \"add\" : \"subtract\";\n                    }\n                }\n                if (isLine(this.doc, n)) {\n                    indentLine(this, n, dir, aggressive);\n                }\n            }),\n            indentSelection: methodOp(function(how) {\n                var ranges = this.doc.sel.ranges, end = -1;\n                for(var i = 0; i < ranges.length; i++){\n                    var range = ranges[i];\n                    if (!range.empty()) {\n                        var from = range.from(), to = range.to();\n                        var start = Math.max(end, from.line);\n                        end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n                        for(var j = start; j < end; ++j){\n                            indentLine(this, j, how);\n                        }\n                        var newRanges = this.doc.sel.ranges;\n                        if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {\n                            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n                        }\n                    } else if (range.head.line > end) {\n                        indentLine(this, range.head.line, how, true);\n                        end = range.head.line;\n                        if (i == this.doc.sel.primIndex) {\n                            ensureCursorVisible(this);\n                        }\n                    }\n                }\n            }),\n            // Fetch the parser token for a given character. Useful for hacks\n            // that want to inspect the mode state (say, for completion).\n            getTokenAt: function(pos, precise) {\n                return takeToken(this, pos, precise);\n            },\n            getLineTokens: function(line, precise) {\n                return takeToken(this, Pos(line), precise, true);\n            },\n            getTokenTypeAt: function(pos) {\n                pos = clipPos(this.doc, pos);\n                var styles = getLineStyles(this, getLine(this.doc, pos.line));\n                var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n                var type;\n                if (ch == 0) {\n                    type = styles[2];\n                } else {\n                    for(;;){\n                        var mid = before + after >> 1;\n                        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {\n                            after = mid;\n                        } else if (styles[mid * 2 + 1] < ch) {\n                            before = mid + 1;\n                        } else {\n                            type = styles[mid * 2 + 2];\n                            break;\n                        }\n                    }\n                }\n                var cut = type ? type.indexOf(\"overlay \") : -1;\n                return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n            },\n            getModeAt: function(pos) {\n                var mode = this.doc.mode;\n                if (!mode.innerMode) {\n                    return mode;\n                }\n                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n            },\n            getHelper: function(pos, type) {\n                return this.getHelpers(pos, type)[0];\n            },\n            getHelpers: function(pos, type) {\n                var found = [];\n                if (!helpers.hasOwnProperty(type)) {\n                    return found;\n                }\n                var help = helpers[type], mode = this.getModeAt(pos);\n                if (typeof mode[type] == \"string\") {\n                    if (help[mode[type]]) {\n                        found.push(help[mode[type]]);\n                    }\n                } else if (mode[type]) {\n                    for(var i = 0; i < mode[type].length; i++){\n                        var val = help[mode[type][i]];\n                        if (val) {\n                            found.push(val);\n                        }\n                    }\n                } else if (mode.helperType && help[mode.helperType]) {\n                    found.push(help[mode.helperType]);\n                } else if (help[mode.name]) {\n                    found.push(help[mode.name]);\n                }\n                for(var i$1 = 0; i$1 < help._global.length; i$1++){\n                    var cur = help._global[i$1];\n                    if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {\n                        found.push(cur.val);\n                    }\n                }\n                return found;\n            },\n            getStateAfter: function(line, precise) {\n                var doc = this.doc;\n                line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n                return getContextBefore(this, line + 1, precise).state;\n            },\n            cursorCoords: function(start, mode) {\n                var pos, range = this.doc.sel.primary();\n                if (start == null) {\n                    pos = range.head;\n                } else if (typeof start == \"object\") {\n                    pos = clipPos(this.doc, start);\n                } else {\n                    pos = start ? range.from() : range.to();\n                }\n                return cursorCoords(this, pos, mode || \"page\");\n            },\n            charCoords: function(pos, mode) {\n                return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n            },\n            coordsChar: function(coords, mode) {\n                coords = fromCoordSystem(this, coords, mode || \"page\");\n                return coordsChar(this, coords.left, coords.top);\n            },\n            lineAtHeight: function(height, mode) {\n                height = fromCoordSystem(this, {\n                    top: height,\n                    left: 0\n                }, mode || \"page\").top;\n                return lineAtHeight(this.doc, height + this.display.viewOffset);\n            },\n            heightAtLine: function(line, mode, includeWidgets) {\n                var end = false, lineObj;\n                if (typeof line == \"number\") {\n                    var last = this.doc.first + this.doc.size - 1;\n                    if (line < this.doc.first) {\n                        line = this.doc.first;\n                    } else if (line > last) {\n                        line = last;\n                        end = true;\n                    }\n                    lineObj = getLine(this.doc, line);\n                } else {\n                    lineObj = line;\n                }\n                return intoCoordSystem(this, lineObj, {\n                    top: 0,\n                    left: 0\n                }, mode || \"page\", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);\n            },\n            defaultTextHeight: function() {\n                return textHeight(this.display);\n            },\n            defaultCharWidth: function() {\n                return charWidth(this.display);\n            },\n            getViewport: function() {\n                return {\n                    from: this.display.viewFrom,\n                    to: this.display.viewTo\n                };\n            },\n            addWidget: function(pos, node, scroll, vert, horiz) {\n                var display = this.display;\n                pos = cursorCoords(this, clipPos(this.doc, pos));\n                var top = pos.bottom, left = pos.left;\n                node.style.position = \"absolute\";\n                node.setAttribute(\"cm-ignore-events\", \"true\");\n                this.display.input.setUneditable(node);\n                display.sizer.appendChild(node);\n                if (vert == \"over\") {\n                    top = pos.top;\n                } else if (vert == \"above\" || vert == \"near\") {\n                    var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n                    // Default to positioning above (if specified and possible); otherwise default to positioning below\n                    if ((vert == \"above\" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n                        top = pos.top - node.offsetHeight;\n                    } else if (pos.bottom + node.offsetHeight <= vspace) {\n                        top = pos.bottom;\n                    }\n                    if (left + node.offsetWidth > hspace) {\n                        left = hspace - node.offsetWidth;\n                    }\n                }\n                node.style.top = top + \"px\";\n                node.style.left = node.style.right = \"\";\n                if (horiz == \"right\") {\n                    left = display.sizer.clientWidth - node.offsetWidth;\n                    node.style.right = \"0px\";\n                } else {\n                    if (horiz == \"left\") {\n                        left = 0;\n                    } else if (horiz == \"middle\") {\n                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n                    }\n                    node.style.left = left + \"px\";\n                }\n                if (scroll) {\n                    scrollIntoView(this, {\n                        left: left,\n                        top: top,\n                        right: left + node.offsetWidth,\n                        bottom: top + node.offsetHeight\n                    });\n                }\n            },\n            triggerOnKeyDown: methodOp(onKeyDown),\n            triggerOnKeyPress: methodOp(onKeyPress),\n            triggerOnKeyUp: onKeyUp,\n            triggerOnMouseDown: methodOp(onMouseDown),\n            execCommand: function(cmd) {\n                if (commands.hasOwnProperty(cmd)) {\n                    return commands[cmd].call(null, this);\n                }\n            },\n            triggerElectric: methodOp(function(text) {\n                triggerElectric(this, text);\n            }),\n            findPosH: function(from, amount, unit, visually) {\n                var dir = 1;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                var cur = clipPos(this.doc, from);\n                for(var i = 0; i < amount; ++i){\n                    cur = findPosH(this.doc, cur, dir, unit, visually);\n                    if (cur.hitSide) {\n                        break;\n                    }\n                }\n                return cur;\n            },\n            moveH: methodOp(function(dir, unit) {\n                var this$1 = this;\n                this.extendSelectionsBy(function(range) {\n                    if (this$1.display.shift || this$1.doc.extend || range.empty()) {\n                        return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);\n                    } else {\n                        return dir < 0 ? range.from() : range.to();\n                    }\n                }, sel_move);\n            }),\n            deleteH: methodOp(function(dir, unit) {\n                var sel = this.doc.sel, doc = this.doc;\n                if (sel.somethingSelected()) {\n                    doc.replaceSelection(\"\", null, \"+delete\");\n                } else {\n                    deleteNearSelection(this, function(range) {\n                        var other = findPosH(doc, range.head, dir, unit, false);\n                        return dir < 0 ? {\n                            from: other,\n                            to: range.head\n                        } : {\n                            from: range.head,\n                            to: other\n                        };\n                    });\n                }\n            }),\n            findPosV: function(from, amount, unit, goalColumn) {\n                var dir = 1, x = goalColumn;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                var cur = clipPos(this.doc, from);\n                for(var i = 0; i < amount; ++i){\n                    var coords = cursorCoords(this, cur, \"div\");\n                    if (x == null) {\n                        x = coords.left;\n                    } else {\n                        coords.left = x;\n                    }\n                    cur = findPosV(this, coords, dir, unit);\n                    if (cur.hitSide) {\n                        break;\n                    }\n                }\n                return cur;\n            },\n            moveV: methodOp(function(dir, unit) {\n                var this$1 = this;\n                var doc = this.doc, goals = [];\n                var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n                doc.extendSelectionsBy(function(range) {\n                    if (collapse) {\n                        return dir < 0 ? range.from() : range.to();\n                    }\n                    var headPos = cursorCoords(this$1, range.head, \"div\");\n                    if (range.goalColumn != null) {\n                        headPos.left = range.goalColumn;\n                    }\n                    goals.push(headPos.left);\n                    var pos = findPosV(this$1, headPos, dir, unit);\n                    if (unit == \"page\" && range == doc.sel.primary()) {\n                        addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top);\n                    }\n                    return pos;\n                }, sel_move);\n                if (goals.length) {\n                    for(var i = 0; i < doc.sel.ranges.length; i++){\n                        doc.sel.ranges[i].goalColumn = goals[i];\n                    }\n                }\n            }),\n            // Find the word at the given position (as returned by coordsChar).\n            findWordAt: function(pos) {\n                var doc = this.doc, line = getLine(doc, pos.line).text;\n                var start = pos.ch, end = pos.ch;\n                if (line) {\n                    var helper = this.getHelper(pos, \"wordChars\");\n                    if ((pos.sticky == \"before\" || end == line.length) && start) {\n                        --start;\n                    } else {\n                        ++end;\n                    }\n                    var startChar = line.charAt(start);\n                    var check = isWordChar(startChar, helper) ? function(ch) {\n                        return isWordChar(ch, helper);\n                    } : /\\s/.test(startChar) ? function(ch) {\n                        return /\\s/.test(ch);\n                    } : function(ch) {\n                        return !/\\s/.test(ch) && !isWordChar(ch);\n                    };\n                    while(start > 0 && check(line.charAt(start - 1))){\n                        --start;\n                    }\n                    while(end < line.length && check(line.charAt(end))){\n                        ++end;\n                    }\n                }\n                return new Range(Pos(pos.line, start), Pos(pos.line, end));\n            },\n            toggleOverwrite: function(value) {\n                if (value != null && value == this.state.overwrite) {\n                    return;\n                }\n                if (this.state.overwrite = !this.state.overwrite) {\n                    addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n                } else {\n                    rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n                }\n                signal(this, \"overwriteToggle\", this, this.state.overwrite);\n            },\n            hasFocus: function() {\n                return this.display.input.getField() == activeElt(root(this));\n            },\n            isReadOnly: function() {\n                return !!(this.options.readOnly || this.doc.cantEdit);\n            },\n            scrollTo: methodOp(function(x, y) {\n                scrollToCoords(this, x, y);\n            }),\n            getScrollInfo: function() {\n                var scroller = this.display.scroller;\n                return {\n                    left: scroller.scrollLeft,\n                    top: scroller.scrollTop,\n                    height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                    width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                    clientHeight: displayHeight(this),\n                    clientWidth: displayWidth(this)\n                };\n            },\n            scrollIntoView: methodOp(function(range, margin) {\n                if (range == null) {\n                    range = {\n                        from: this.doc.sel.primary().head,\n                        to: null\n                    };\n                    if (margin == null) {\n                        margin = this.options.cursorScrollMargin;\n                    }\n                } else if (typeof range == \"number\") {\n                    range = {\n                        from: Pos(range, 0),\n                        to: null\n                    };\n                } else if (range.from == null) {\n                    range = {\n                        from: range,\n                        to: null\n                    };\n                }\n                if (!range.to) {\n                    range.to = range.from;\n                }\n                range.margin = margin || 0;\n                if (range.from.line != null) {\n                    scrollToRange(this, range);\n                } else {\n                    scrollToCoordsRange(this, range.from, range.to, range.margin);\n                }\n            }),\n            setSize: methodOp(function(width, height) {\n                var this$1 = this;\n                var interpret = function(val) {\n                    return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n                };\n                if (width != null) {\n                    this.display.wrapper.style.width = interpret(width);\n                }\n                if (height != null) {\n                    this.display.wrapper.style.height = interpret(height);\n                }\n                if (this.options.lineWrapping) {\n                    clearLineMeasurementCache(this);\n                }\n                var lineNo = this.display.viewFrom;\n                this.doc.iter(lineNo, this.display.viewTo, function(line) {\n                    if (line.widgets) {\n                        for(var i = 0; i < line.widgets.length; i++){\n                            if (line.widgets[i].noHScroll) {\n                                regLineChange(this$1, lineNo, \"widget\");\n                                break;\n                            }\n                        }\n                    }\n                    ++lineNo;\n                });\n                this.curOp.forceUpdate = true;\n                signal(this, \"refresh\", this);\n            }),\n            operation: function(f) {\n                return runInOp(this, f);\n            },\n            startOperation: function() {\n                return startOperation(this);\n            },\n            endOperation: function() {\n                return endOperation(this);\n            },\n            refresh: methodOp(function() {\n                var oldHeight = this.display.cachedTextHeight;\n                regChange(this);\n                this.curOp.forceUpdate = true;\n                clearCaches(this);\n                scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n                updateGutterSpace(this.display);\n                if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping) {\n                    estimateLineHeights(this);\n                }\n                signal(this, \"refresh\", this);\n            }),\n            swapDoc: methodOp(function(doc) {\n                var old = this.doc;\n                old.cm = null;\n                // Cancel the current text selection if any (#5821)\n                if (this.state.selectingText) {\n                    this.state.selectingText();\n                }\n                attachDoc(this, doc);\n                clearCaches(this);\n                this.display.input.reset();\n                scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n                this.curOp.forceScroll = true;\n                signalLater(this, \"swapDoc\", this, old);\n                return old;\n            }),\n            phrase: function(phraseText) {\n                var phrases = this.options.phrases;\n                return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n            },\n            getInputField: function() {\n                return this.display.input.getField();\n            },\n            getWrapperElement: function() {\n                return this.display.wrapper;\n            },\n            getScrollerElement: function() {\n                return this.display.scroller;\n            },\n            getGutterElement: function() {\n                return this.display.gutters;\n            }\n        };\n        eventMixin(CodeMirror);\n        CodeMirror.registerHelper = function(type, name, value) {\n            if (!helpers.hasOwnProperty(type)) {\n                helpers[type] = CodeMirror[type] = {\n                    _global: []\n                };\n            }\n            helpers[type][name] = value;\n        };\n        CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n            CodeMirror.registerHelper(type, name, value);\n            helpers[type]._global.push({\n                pred: predicate,\n                val: value\n            });\n        };\n    }\n    // Used for horizontal relative motion. Dir is -1 or 1 (left or\n    // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n    // doesn't cross line boundaries), \"word\" (across next word), or\n    // \"group\" (to the start of next group of word or\n    // non-word-non-whitespace chars). The visually param controls\n    // whether, in right-to-left text, direction 1 means to move towards\n    // the next index in the string, or towards the character to the right\n    // of the current position. The resulting position will have a\n    // hitSide=true property if it reached the end of the document.\n    function findPosH(doc, pos, dir, unit, visually) {\n        var oldPos = pos;\n        var origDir = dir;\n        var lineObj = getLine(doc, pos.line);\n        var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n        function findNextLine() {\n            var l = pos.line + lineDir;\n            if (l < doc.first || l >= doc.first + doc.size) {\n                return false;\n            }\n            pos = new Pos(l, pos.ch, pos.sticky);\n            return lineObj = getLine(doc, l);\n        }\n        function moveOnce(boundToLine) {\n            var next;\n            if (unit == \"codepoint\") {\n                var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n                if (isNaN(ch)) {\n                    next = null;\n                } else {\n                    var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n                    next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n                }\n            } else if (visually) {\n                next = moveVisually(doc.cm, lineObj, pos, dir);\n            } else {\n                next = moveLogically(lineObj, pos, dir);\n            }\n            if (next == null) {\n                if (!boundToLine && findNextLine()) {\n                    pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);\n                } else {\n                    return false;\n                }\n            } else {\n                pos = next;\n            }\n            return true;\n        }\n        if (unit == \"char\" || unit == \"codepoint\") {\n            moveOnce();\n        } else if (unit == \"column\") {\n            moveOnce(true);\n        } else if (unit == \"word\" || unit == \"group\") {\n            var sawType = null, group = unit == \"group\";\n            var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n            for(var first = true;; first = false){\n                if (dir < 0 && !moveOnce(!first)) {\n                    break;\n                }\n                var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n                var type = isWordChar(cur, helper) ? \"w\" : group && cur == \"\\n\" ? \"n\" : !group || /\\s/.test(cur) ? null : \"p\";\n                if (group && !first && !type) {\n                    type = \"s\";\n                }\n                if (sawType && sawType != type) {\n                    if (dir < 0) {\n                        dir = 1;\n                        moveOnce();\n                        pos.sticky = \"after\";\n                    }\n                    break;\n                }\n                if (type) {\n                    sawType = type;\n                }\n                if (dir > 0 && !moveOnce(!first)) {\n                    break;\n                }\n            }\n        }\n        var result = skipAtomic(doc, pos, oldPos, origDir, true);\n        if (equalCursorPos(oldPos, result)) {\n            result.hitSide = true;\n        }\n        return result;\n    }\n    // For relative vertical movement. Dir may be -1 or 1. Unit can be\n    // \"page\" or \"line\". The resulting position will have a hitSide=true\n    // property if it reached the end of the document.\n    function findPosV(cm, pos, dir, unit) {\n        var doc = cm.doc, x = pos.left, y;\n        if (unit == \"page\") {\n            var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc(cm).documentElement.clientHeight);\n            var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n        } else if (unit == \"line\") {\n            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n        }\n        var target;\n        for(;;){\n            target = coordsChar(cm, x, y);\n            if (!target.outside) {\n                break;\n            }\n            if (dir < 0 ? y <= 0 : y >= doc.height) {\n                target.hitSide = true;\n                break;\n            }\n            y += dir * 5;\n        }\n        return target;\n    }\n    // CONTENTEDITABLE INPUT STYLE\n    var ContentEditableInput = function(cm) {\n        this.cm = cm;\n        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n        this.polling = new Delayed();\n        this.composing = null;\n        this.gracePeriod = false;\n        this.readDOMTimeout = null;\n    };\n    ContentEditableInput.prototype.init = function(display) {\n        var this$1 = this;\n        var input = this, cm = input.cm;\n        var div = input.div = display.lineDiv;\n        div.contentEditable = true;\n        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n        function belongsToInput(e) {\n            for(var t = e.target; t; t = t.parentNode){\n                if (t == div) {\n                    return true;\n                }\n                if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {\n                    break;\n                }\n            }\n            return false;\n        }\n        on(div, \"paste\", function(e) {\n            if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n                return;\n            }\n            // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n            if (ie_version <= 11) {\n                setTimeout(operation(cm, function() {\n                    return this$1.updateFromDOM();\n                }), 20);\n            }\n        });\n        on(div, \"compositionstart\", function(e) {\n            this$1.composing = {\n                data: e.data,\n                done: false\n            };\n        });\n        on(div, \"compositionupdate\", function(e) {\n            if (!this$1.composing) {\n                this$1.composing = {\n                    data: e.data,\n                    done: false\n                };\n            }\n        });\n        on(div, \"compositionend\", function(e) {\n            if (this$1.composing) {\n                if (e.data != this$1.composing.data) {\n                    this$1.readFromDOMSoon();\n                }\n                this$1.composing.done = true;\n            }\n        });\n        on(div, \"touchstart\", function() {\n            return input.forceCompositionEnd();\n        });\n        on(div, \"input\", function() {\n            if (!this$1.composing) {\n                this$1.readFromDOMSoon();\n            }\n        });\n        function onCopyCut(e) {\n            if (!belongsToInput(e) || signalDOMEvent(cm, e)) {\n                return;\n            }\n            if (cm.somethingSelected()) {\n                setLastCopied({\n                    lineWise: false,\n                    text: cm.getSelections()\n                });\n                if (e.type == \"cut\") {\n                    cm.replaceSelection(\"\", null, \"cut\");\n                }\n            } else if (!cm.options.lineWiseCopyCut) {\n                return;\n            } else {\n                var ranges = copyableRanges(cm);\n                setLastCopied({\n                    lineWise: true,\n                    text: ranges.text\n                });\n                if (e.type == \"cut\") {\n                    cm.operation(function() {\n                        cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n                        cm.replaceSelection(\"\", null, \"cut\");\n                    });\n                }\n            }\n            if (e.clipboardData) {\n                e.clipboardData.clearData();\n                var content = lastCopied.text.join(\"\\n\");\n                // iOS exposes the clipboard API, but seems to discard content inserted into it\n                e.clipboardData.setData(\"Text\", content);\n                if (e.clipboardData.getData(\"Text\") == content) {\n                    e.preventDefault();\n                    return;\n                }\n            }\n            // Old-fashioned briefly-focus-a-textarea hack\n            var kludge = hiddenTextarea(), te = kludge.firstChild;\n            disableBrowserMagic(te);\n            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n            te.value = lastCopied.text.join(\"\\n\");\n            var hadFocus = activeElt(rootNode(div));\n            selectInput(te);\n            setTimeout(function() {\n                cm.display.lineSpace.removeChild(kludge);\n                hadFocus.focus();\n                if (hadFocus == div) {\n                    input.showPrimarySelection();\n                }\n            }, 50);\n        }\n        on(div, \"copy\", onCopyCut);\n        on(div, \"cut\", onCopyCut);\n    };\n    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {\n        // Label for screenreaders, accessibility\n        if (label) {\n            this.div.setAttribute(\"aria-label\", label);\n        } else {\n            this.div.removeAttribute(\"aria-label\");\n        }\n    };\n    ContentEditableInput.prototype.prepareSelection = function() {\n        var result = prepareSelection(this.cm, false);\n        result.focus = activeElt(rootNode(this.div)) == this.div;\n        return result;\n    };\n    ContentEditableInput.prototype.showSelection = function(info, takeFocus) {\n        if (!info || !this.cm.display.view.length) {\n            return;\n        }\n        if (info.focus || takeFocus) {\n            this.showPrimarySelection();\n        }\n        this.showMultipleSelections(info);\n    };\n    ContentEditableInput.prototype.getSelection = function() {\n        return this.cm.display.wrapper.ownerDocument.getSelection();\n    };\n    ContentEditableInput.prototype.showPrimarySelection = function() {\n        var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n        var from = prim.from(), to = prim.to();\n        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n            sel.removeAllRanges();\n            return;\n        }\n        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {\n            return;\n        }\n        var view = cm.display.view;\n        var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n            node: view[0].measure.map[2],\n            offset: 0\n        };\n        var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n        if (!end) {\n            var measure = view[view.length - 1].measure;\n            var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n            end = {\n                node: map[map.length - 1],\n                offset: map[map.length - 2] - map[map.length - 3]\n            };\n        }\n        if (!start || !end) {\n            sel.removeAllRanges();\n            return;\n        }\n        var old = sel.rangeCount && sel.getRangeAt(0), rng;\n        try {\n            rng = range(start.node, start.offset, end.offset, end.node);\n        } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n        if (rng) {\n            if (!gecko && cm.state.focused) {\n                sel.collapse(start.node, start.offset);\n                if (!rng.collapsed) {\n                    sel.removeAllRanges();\n                    sel.addRange(rng);\n                }\n            } else {\n                sel.removeAllRanges();\n                sel.addRange(rng);\n            }\n            if (old && sel.anchorNode == null) {\n                sel.addRange(old);\n            } else if (gecko) {\n                this.startGracePeriod();\n            }\n        }\n        this.rememberSelection();\n    };\n    ContentEditableInput.prototype.startGracePeriod = function() {\n        var this$1 = this;\n        clearTimeout(this.gracePeriod);\n        this.gracePeriod = setTimeout(function() {\n            this$1.gracePeriod = false;\n            if (this$1.selectionChanged()) {\n                this$1.cm.operation(function() {\n                    return this$1.cm.curOp.selectionChanged = true;\n                });\n            }\n        }, 20);\n    };\n    ContentEditableInput.prototype.showMultipleSelections = function(info) {\n        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    };\n    ContentEditableInput.prototype.rememberSelection = function() {\n        var sel = this.getSelection();\n        this.lastAnchorNode = sel.anchorNode;\n        this.lastAnchorOffset = sel.anchorOffset;\n        this.lastFocusNode = sel.focusNode;\n        this.lastFocusOffset = sel.focusOffset;\n    };\n    ContentEditableInput.prototype.selectionInEditor = function() {\n        var sel = this.getSelection();\n        if (!sel.rangeCount) {\n            return false;\n        }\n        var node = sel.getRangeAt(0).commonAncestorContainer;\n        return contains(this.div, node);\n    };\n    ContentEditableInput.prototype.focus = function() {\n        if (this.cm.options.readOnly != \"nocursor\") {\n            if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div) {\n                this.showSelection(this.prepareSelection(), true);\n            }\n            this.div.focus();\n        }\n    };\n    ContentEditableInput.prototype.blur = function() {\n        this.div.blur();\n    };\n    ContentEditableInput.prototype.getField = function() {\n        return this.div;\n    };\n    ContentEditableInput.prototype.supportsTouch = function() {\n        return true;\n    };\n    ContentEditableInput.prototype.receivedFocus = function() {\n        var this$1 = this;\n        var input = this;\n        if (this.selectionInEditor()) {\n            setTimeout(function() {\n                return this$1.pollSelection();\n            }, 20);\n        } else {\n            runInOp(this.cm, function() {\n                return input.cm.curOp.selectionChanged = true;\n            });\n        }\n        function poll() {\n            if (input.cm.state.focused) {\n                input.pollSelection();\n                input.polling.set(input.cm.options.pollInterval, poll);\n            }\n        }\n        this.polling.set(this.cm.options.pollInterval, poll);\n    };\n    ContentEditableInput.prototype.selectionChanged = function() {\n        var sel = this.getSelection();\n        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    };\n    ContentEditableInput.prototype.pollSelection = function() {\n        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n            return;\n        }\n        var sel = this.getSelection(), cm = this.cm;\n        // On Android Chrome (version 56, at least), backspacing into an\n        // uneditable block element will put the cursor in that element,\n        // and then, because it's not editable, hide the virtual keyboard.\n        // Because Android doesn't allow us to actually detect backspace\n        // presses in a sane way, this code checks for when that happens\n        // and simulates a backspace press in this case.\n        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n            this.cm.triggerOnKeyDown({\n                type: \"keydown\",\n                keyCode: 8,\n                preventDefault: Math.abs\n            });\n            this.blur();\n            this.focus();\n            return;\n        }\n        if (this.composing) {\n            return;\n        }\n        this.rememberSelection();\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (anchor && head) {\n            runInOp(cm, function() {\n                setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n                if (anchor.bad || head.bad) {\n                    cm.curOp.selectionChanged = true;\n                }\n            });\n        }\n    };\n    ContentEditableInput.prototype.pollContent = function() {\n        if (this.readDOMTimeout != null) {\n            clearTimeout(this.readDOMTimeout);\n            this.readDOMTimeout = null;\n        }\n        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n        var from = sel.from(), to = sel.to();\n        if (from.ch == 0 && from.line > cm.firstLine()) {\n            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);\n        }\n        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n            to = Pos(to.line + 1, 0);\n        }\n        if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n            return false;\n        }\n        var fromIndex, fromLine, fromNode;\n        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n            fromLine = lineNo(display.view[0].line);\n            fromNode = display.view[0].node;\n        } else {\n            fromLine = lineNo(display.view[fromIndex].line);\n            fromNode = display.view[fromIndex - 1].node.nextSibling;\n        }\n        var toIndex = findViewIndex(cm, to.line);\n        var toLine, toNode;\n        if (toIndex == display.view.length - 1) {\n            toLine = display.viewTo - 1;\n            toNode = display.lineDiv.lastChild;\n        } else {\n            toLine = lineNo(display.view[toIndex + 1].line) - 1;\n            toNode = display.view[toIndex + 1].node.previousSibling;\n        }\n        if (!fromNode) {\n            return false;\n        }\n        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n        while(newText.length > 1 && oldText.length > 1){\n            if (lst(newText) == lst(oldText)) {\n                newText.pop();\n                oldText.pop();\n                toLine--;\n            } else if (newText[0] == oldText[0]) {\n                newText.shift();\n                oldText.shift();\n                fromLine++;\n            } else {\n                break;\n            }\n        }\n        var cutFront = 0, cutEnd = 0;\n        var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n        while(cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)){\n            ++cutFront;\n        }\n        var newBot = lst(newText), oldBot = lst(oldText);\n        var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n        while(cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)){\n            ++cutEnd;\n        }\n        // Try to move start of change to start of selection if ambiguous\n        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n            while(cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)){\n                cutFront--;\n                cutEnd++;\n            }\n        }\n        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n        newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n        var chFrom = Pos(fromLine, cutFront);\n        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n            replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n            return true;\n        }\n    };\n    ContentEditableInput.prototype.ensurePolled = function() {\n        this.forceCompositionEnd();\n    };\n    ContentEditableInput.prototype.reset = function() {\n        this.forceCompositionEnd();\n    };\n    ContentEditableInput.prototype.forceCompositionEnd = function() {\n        if (!this.composing) {\n            return;\n        }\n        clearTimeout(this.readDOMTimeout);\n        this.composing = null;\n        this.updateFromDOM();\n        this.div.blur();\n        this.div.focus();\n    };\n    ContentEditableInput.prototype.readFromDOMSoon = function() {\n        var this$1 = this;\n        if (this.readDOMTimeout != null) {\n            return;\n        }\n        this.readDOMTimeout = setTimeout(function() {\n            this$1.readDOMTimeout = null;\n            if (this$1.composing) {\n                if (this$1.composing.done) {\n                    this$1.composing = null;\n                } else {\n                    return;\n                }\n            }\n            this$1.updateFromDOM();\n        }, 80);\n    };\n    ContentEditableInput.prototype.updateFromDOM = function() {\n        var this$1 = this;\n        if (this.cm.isReadOnly() || !this.pollContent()) {\n            runInOp(this.cm, function() {\n                return regChange(this$1.cm);\n            });\n        }\n    };\n    ContentEditableInput.prototype.setUneditable = function(node) {\n        node.contentEditable = \"false\";\n    };\n    ContentEditableInput.prototype.onKeyPress = function(e) {\n        if (e.charCode == 0 || this.composing) {\n            return;\n        }\n        e.preventDefault();\n        if (!this.cm.isReadOnly()) {\n            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n        }\n    };\n    ContentEditableInput.prototype.readOnlyChanged = function(val) {\n        this.div.contentEditable = String(val != \"nocursor\");\n    };\n    ContentEditableInput.prototype.onContextMenu = function() {};\n    ContentEditableInput.prototype.resetPosition = function() {};\n    ContentEditableInput.prototype.needsContentAttribute = true;\n    function posToDOM(cm, pos) {\n        var view = findViewForLine(cm, pos.line);\n        if (!view || view.hidden) {\n            return null;\n        }\n        var line = getLine(cm.doc, pos.line);\n        var info = mapFromLineView(view, line, pos.line);\n        var order = getOrder(line, cm.doc.direction), side = \"left\";\n        if (order) {\n            var partPos = getBidiPartAt(order, pos.ch);\n            side = partPos % 2 ? \"right\" : \"left\";\n        }\n        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n        result.offset = result.collapse == \"right\" ? result.end : result.start;\n        return result;\n    }\n    function isInGutter(node) {\n        for(var scan = node; scan; scan = scan.parentNode){\n            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function badPos(pos, bad) {\n        if (bad) {\n            pos.bad = true;\n        }\n        return pos;\n    }\n    function domTextBetween(cm, from, to, fromLine, toLine) {\n        var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n        function recognizeMarker(id) {\n            return function(marker) {\n                return marker.id == id;\n            };\n        }\n        function close() {\n            if (closing) {\n                text += lineSep;\n                if (extraLinebreak) {\n                    text += lineSep;\n                }\n                closing = extraLinebreak = false;\n            }\n        }\n        function addText(str) {\n            if (str) {\n                close();\n                text += str;\n            }\n        }\n        function walk(node) {\n            if (node.nodeType == 1) {\n                var cmText = node.getAttribute(\"cm-text\");\n                if (cmText) {\n                    addText(cmText);\n                    return;\n                }\n                var markerID = node.getAttribute(\"cm-marker\"), range;\n                if (markerID) {\n                    var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n                    if (found.length && (range = found[0].find(0))) {\n                        addText(getBetween(cm.doc, range.from, range.to).join(lineSep));\n                    }\n                    return;\n                }\n                if (node.getAttribute(\"contenteditable\") == \"false\") {\n                    return;\n                }\n                var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n                if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n                    return;\n                }\n                if (isBlock) {\n                    close();\n                }\n                for(var i = 0; i < node.childNodes.length; i++){\n                    walk(node.childNodes[i]);\n                }\n                if (/^(pre|p)$/i.test(node.nodeName)) {\n                    extraLinebreak = true;\n                }\n                if (isBlock) {\n                    closing = true;\n                }\n            } else if (node.nodeType == 3) {\n                addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n            }\n        }\n        for(;;){\n            walk(from);\n            if (from == to) {\n                break;\n            }\n            from = from.nextSibling;\n            extraLinebreak = false;\n        }\n        return text;\n    }\n    function domToPos(cm, node, offset) {\n        var lineNode;\n        if (node == cm.display.lineDiv) {\n            lineNode = cm.display.lineDiv.childNodes[offset];\n            if (!lineNode) {\n                return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n            }\n            node = null;\n            offset = 0;\n        } else {\n            for(lineNode = node;; lineNode = lineNode.parentNode){\n                if (!lineNode || lineNode == cm.display.lineDiv) {\n                    return null;\n                }\n                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n                    break;\n                }\n            }\n        }\n        for(var i = 0; i < cm.display.view.length; i++){\n            var lineView = cm.display.view[i];\n            if (lineView.node == lineNode) {\n                return locateNodeInLineView(lineView, node, offset);\n            }\n        }\n    }\n    function locateNodeInLineView(lineView, node, offset) {\n        var wrapper = lineView.text.firstChild, bad = false;\n        if (!node || !contains(wrapper, node)) {\n            return badPos(Pos(lineNo(lineView.line), 0), true);\n        }\n        if (node == wrapper) {\n            bad = true;\n            node = wrapper.childNodes[offset];\n            offset = 0;\n            if (!node) {\n                var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n                return badPos(Pos(lineNo(line), line.text.length), bad);\n            }\n        }\n        var textNode = node.nodeType == 3 ? node : null, topNode = node;\n        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n            textNode = node.firstChild;\n            if (offset) {\n                offset = textNode.nodeValue.length;\n            }\n        }\n        while(topNode.parentNode != wrapper){\n            topNode = topNode.parentNode;\n        }\n        var measure = lineView.measure, maps = measure.maps;\n        function find(textNode, topNode, offset) {\n            for(var i = -1; i < (maps ? maps.length : 0); i++){\n                var map = i < 0 ? measure.map : maps[i];\n                for(var j = 0; j < map.length; j += 3){\n                    var curNode = map[j + 2];\n                    if (curNode == textNode || curNode == topNode) {\n                        var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n                        var ch = map[j] + offset;\n                        if (offset < 0 || curNode != textNode) {\n                            ch = map[j + (offset ? 1 : 0)];\n                        }\n                        return Pos(line, ch);\n                    }\n                }\n            }\n        }\n        var found = find(textNode, topNode, offset);\n        if (found) {\n            return badPos(found, bad);\n        }\n        // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n        for(var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling){\n            found = find(after, after.firstChild, 0);\n            if (found) {\n                return badPos(Pos(found.line, found.ch - dist), bad);\n            } else {\n                dist += after.textContent.length;\n            }\n        }\n        for(var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling){\n            found = find(before, before.firstChild, -1);\n            if (found) {\n                return badPos(Pos(found.line, found.ch + dist$1), bad);\n            } else {\n                dist$1 += before.textContent.length;\n            }\n        }\n    }\n    // TEXTAREA INPUT STYLE\n    var TextareaInput = function(cm) {\n        this.cm = cm;\n        // See input.poll and input.reset\n        this.prevInput = \"\";\n        // Flag that indicates whether we expect input to appear real soon\n        // now (after some event like 'keypress' or 'input') and are\n        // polling intensively.\n        this.pollingFast = false;\n        // Self-resetting timeout for the poller\n        this.polling = new Delayed();\n        // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n        this.hasSelection = false;\n        this.composing = null;\n        this.resetting = false;\n    };\n    TextareaInput.prototype.init = function(display) {\n        var this$1 = this;\n        var input = this, cm = this.cm;\n        this.createField(display);\n        var te = this.textarea;\n        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n        // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n        if (ios) {\n            te.style.width = \"0px\";\n        }\n        on(te, \"input\", function() {\n            if (ie && ie_version >= 9 && this$1.hasSelection) {\n                this$1.hasSelection = null;\n            }\n            input.poll();\n        });\n        on(te, \"paste\", function(e) {\n            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n                return;\n            }\n            cm.state.pasteIncoming = +new Date;\n            input.fastPoll();\n        });\n        function prepareCopyCut(e) {\n            if (signalDOMEvent(cm, e)) {\n                return;\n            }\n            if (cm.somethingSelected()) {\n                setLastCopied({\n                    lineWise: false,\n                    text: cm.getSelections()\n                });\n            } else if (!cm.options.lineWiseCopyCut) {\n                return;\n            } else {\n                var ranges = copyableRanges(cm);\n                setLastCopied({\n                    lineWise: true,\n                    text: ranges.text\n                });\n                if (e.type == \"cut\") {\n                    cm.setSelections(ranges.ranges, null, sel_dontScroll);\n                } else {\n                    input.prevInput = \"\";\n                    te.value = ranges.text.join(\"\\n\");\n                    selectInput(te);\n                }\n            }\n            if (e.type == \"cut\") {\n                cm.state.cutIncoming = +new Date;\n            }\n        }\n        on(te, \"cut\", prepareCopyCut);\n        on(te, \"copy\", prepareCopyCut);\n        on(display.scroller, \"paste\", function(e) {\n            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n                return;\n            }\n            if (!te.dispatchEvent) {\n                cm.state.pasteIncoming = +new Date;\n                input.focus();\n                return;\n            }\n            // Pass the `paste` event to the textarea so it's handled by its event listener.\n            var event = new Event(\"paste\");\n            event.clipboardData = e.clipboardData;\n            te.dispatchEvent(event);\n        });\n        // Prevent normal selection in the editor (we handle our own)\n        on(display.lineSpace, \"selectstart\", function(e) {\n            if (!eventInWidget(display, e)) {\n                e_preventDefault(e);\n            }\n        });\n        on(te, \"compositionstart\", function() {\n            var start = cm.getCursor(\"from\");\n            if (input.composing) {\n                input.composing.range.clear();\n            }\n            input.composing = {\n                start: start,\n                range: cm.markText(start, cm.getCursor(\"to\"), {\n                    className: \"CodeMirror-composing\"\n                })\n            };\n        });\n        on(te, \"compositionend\", function() {\n            if (input.composing) {\n                input.poll();\n                input.composing.range.clear();\n                input.composing = null;\n            }\n        });\n    };\n    TextareaInput.prototype.createField = function(_display) {\n        // Wraps and hides input textarea\n        this.wrapper = hiddenTextarea();\n        // The semihidden textarea that is focused when the editor is\n        // focused, and receives input.\n        this.textarea = this.wrapper.firstChild;\n        var opts = this.cm.options;\n        disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);\n    };\n    TextareaInput.prototype.screenReaderLabelChanged = function(label) {\n        // Label for screenreaders, accessibility\n        if (label) {\n            this.textarea.setAttribute(\"aria-label\", label);\n        } else {\n            this.textarea.removeAttribute(\"aria-label\");\n        }\n    };\n    TextareaInput.prototype.prepareSelection = function() {\n        // Redraw the selection and/or cursor\n        var cm = this.cm, display = cm.display, doc = cm.doc;\n        var result = prepareSelection(cm);\n        // Move the hidden textarea near the cursor to prevent scrolling artifacts\n        if (cm.options.moveInputWithCursor) {\n            var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));\n            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));\n        }\n        return result;\n    };\n    TextareaInput.prototype.showSelection = function(drawn) {\n        var cm = this.cm, display = cm.display;\n        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n        removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n        if (drawn.teTop != null) {\n            this.wrapper.style.top = drawn.teTop + \"px\";\n            this.wrapper.style.left = drawn.teLeft + \"px\";\n        }\n    };\n    // Reset the input to correspond to the selection (or to be empty,\n    // when not typing and nothing is selected)\n    TextareaInput.prototype.reset = function(typing) {\n        if (this.contextMenuPending || this.composing && typing) {\n            return;\n        }\n        var cm = this.cm;\n        this.resetting = true;\n        if (cm.somethingSelected()) {\n            this.prevInput = \"\";\n            var content = cm.getSelection();\n            this.textarea.value = content;\n            if (cm.state.focused) {\n                selectInput(this.textarea);\n            }\n            if (ie && ie_version >= 9) {\n                this.hasSelection = content;\n            }\n        } else if (!typing) {\n            this.prevInput = this.textarea.value = \"\";\n            if (ie && ie_version >= 9) {\n                this.hasSelection = null;\n            }\n        }\n        this.resetting = false;\n    };\n    TextareaInput.prototype.getField = function() {\n        return this.textarea;\n    };\n    TextareaInput.prototype.supportsTouch = function() {\n        return false;\n    };\n    TextareaInput.prototype.focus = function() {\n        if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {\n            try {\n                this.textarea.focus();\n            } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n        }\n    };\n    TextareaInput.prototype.blur = function() {\n        this.textarea.blur();\n    };\n    TextareaInput.prototype.resetPosition = function() {\n        this.wrapper.style.top = this.wrapper.style.left = 0;\n    };\n    TextareaInput.prototype.receivedFocus = function() {\n        this.slowPoll();\n    };\n    // Poll for input changes, using the normal rate of polling. This\n    // runs as long as the editor is focused.\n    TextareaInput.prototype.slowPoll = function() {\n        var this$1 = this;\n        if (this.pollingFast) {\n            return;\n        }\n        this.polling.set(this.cm.options.pollInterval, function() {\n            this$1.poll();\n            if (this$1.cm.state.focused) {\n                this$1.slowPoll();\n            }\n        });\n    };\n    // When an event has just come in that is likely to add or change\n    // something in the input textarea, we poll faster, to ensure that\n    // the change appears on the screen quickly.\n    TextareaInput.prototype.fastPoll = function() {\n        var missed = false, input = this;\n        input.pollingFast = true;\n        function p() {\n            var changed = input.poll();\n            if (!changed && !missed) {\n                missed = true;\n                input.polling.set(60, p);\n            } else {\n                input.pollingFast = false;\n                input.slowPoll();\n            }\n        }\n        input.polling.set(20, p);\n    };\n    // Read input from the textarea, and update the document to match.\n    // When something is selected, it is present in the textarea, and\n    // selected (unless it is huge, in which case a placeholder is\n    // used). When nothing is selected, the cursor sits after previously\n    // seen text (can be empty), which is stored in prevInput (we must\n    // not reset the textarea when typing, because that breaks IME).\n    TextareaInput.prototype.poll = function() {\n        var this$1 = this;\n        var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n        // Since this is called a *lot*, try to bail out as cheaply as\n        // possible when it is clear that nothing happened. hasSelection\n        // will be the case when there is a lot of text in the textarea,\n        // in which case reading its value would be expensive.\n        if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n            return false;\n        }\n        var text = input.value;\n        // If nothing changed, bail.\n        if (text == prevInput && !cm.somethingSelected()) {\n            return false;\n        }\n        // Work around nonsensical selection resetting in IE9/10, and\n        // inexplicable appearance of private area unicode characters on\n        // some key combos in Mac (#2689).\n        if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {\n            cm.display.input.reset();\n            return false;\n        }\n        if (cm.doc.sel == cm.display.selForContextMenu) {\n            var first = text.charCodeAt(0);\n            if (first == 0x200b && !prevInput) {\n                prevInput = \"\";\n            }\n            if (first == 0x21da) {\n                this.reset();\n                return this.cm.execCommand(\"undo\");\n            }\n        }\n        // Find the part of the input that is actually new\n        var same = 0, l = Math.min(prevInput.length, text.length);\n        while(same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)){\n            ++same;\n        }\n        runInOp(cm, function() {\n            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? \"*compose\" : null);\n            // Don't leave long text in the textarea, since it makes further polling slow\n            if (text.length > 1000 || text.indexOf(\"\\n\") > -1) {\n                input.value = this$1.prevInput = \"\";\n            } else {\n                this$1.prevInput = text;\n            }\n            if (this$1.composing) {\n                this$1.composing.range.clear();\n                this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"), {\n                    className: \"CodeMirror-composing\"\n                });\n            }\n        });\n        return true;\n    };\n    TextareaInput.prototype.ensurePolled = function() {\n        if (this.pollingFast && this.poll()) {\n            this.pollingFast = false;\n        }\n    };\n    TextareaInput.prototype.onKeyPress = function() {\n        if (ie && ie_version >= 9) {\n            this.hasSelection = null;\n        }\n        this.fastPoll();\n    };\n    TextareaInput.prototype.onContextMenu = function(e) {\n        var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n        if (input.contextMenuPending) {\n            input.contextMenuPending();\n        }\n        var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n        if (!pos || presto) {\n            return;\n        } // Opera is difficult.\n        // Reset the current text selection only if the click is done outside of the selection\n        // and 'resetSelectionOnContextMenu' option is true.\n        var reset = cm.options.resetSelectionOnContextMenu;\n        if (reset && cm.doc.sel.contains(pos) == -1) {\n            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n        }\n        var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n        input.wrapper.style.cssText = \"position: static\";\n        te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n        var oldScrollY;\n        if (webkit) {\n            oldScrollY = te.ownerDocument.defaultView.scrollY;\n        } // Work around Chrome issue (#2712)\n        display.input.focus();\n        if (webkit) {\n            te.ownerDocument.defaultView.scrollTo(null, oldScrollY);\n        }\n        display.input.reset();\n        // Adds \"Select all\" to context menu in FF\n        if (!cm.somethingSelected()) {\n            te.value = input.prevInput = \" \";\n        }\n        input.contextMenuPending = rehide;\n        display.selForContextMenu = cm.doc.sel;\n        clearTimeout(display.detectingSelectAll);\n        // Select-all will be greyed out if there's nothing to select, so\n        // this adds a zero-width space so that we can later check whether\n        // it got selected.\n        function prepareSelectAllHack() {\n            if (te.selectionStart != null) {\n                var selected = cm.somethingSelected();\n                var extval = \"\" + (selected ? te.value : \"\");\n                te.value = \"\"; // Used to catch context-menu undo\n                te.value = extval;\n                input.prevInput = selected ? \"\" : \"\";\n                te.selectionStart = 1;\n                te.selectionEnd = extval.length;\n                // Re-set this, in case some other handler touched the\n                // selection in the meantime.\n                display.selForContextMenu = cm.doc.sel;\n            }\n        }\n        function rehide() {\n            if (input.contextMenuPending != rehide) {\n                return;\n            }\n            input.contextMenuPending = false;\n            input.wrapper.style.cssText = oldWrapperCSS;\n            te.style.cssText = oldCSS;\n            if (ie && ie_version < 9) {\n                display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n            }\n            // Try to detect the user choosing select-all\n            if (te.selectionStart != null) {\n                if (!ie || ie && ie_version < 9) {\n                    prepareSelectAllHack();\n                }\n                var i = 0, poll = function() {\n                    if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == \"\") {\n                        operation(cm, selectAll)(cm);\n                    } else if (i++ < 10) {\n                        display.detectingSelectAll = setTimeout(poll, 500);\n                    } else {\n                        display.selForContextMenu = null;\n                        display.input.reset();\n                    }\n                };\n                display.detectingSelectAll = setTimeout(poll, 200);\n            }\n        }\n        if (ie && ie_version >= 9) {\n            prepareSelectAllHack();\n        }\n        if (captureRightClick) {\n            e_stop(e);\n            var mouseup = function() {\n                off(window, \"mouseup\", mouseup);\n                setTimeout(rehide, 20);\n            };\n            on(window, \"mouseup\", mouseup);\n        } else {\n            setTimeout(rehide, 50);\n        }\n    };\n    TextareaInput.prototype.readOnlyChanged = function(val) {\n        if (!val) {\n            this.reset();\n        }\n        this.textarea.disabled = val == \"nocursor\";\n        this.textarea.readOnly = !!val;\n    };\n    TextareaInput.prototype.setUneditable = function() {};\n    TextareaInput.prototype.needsContentAttribute = false;\n    function fromTextArea(textarea, options) {\n        options = options ? copyObj(options) : {};\n        options.value = textarea.value;\n        if (!options.tabindex && textarea.tabIndex) {\n            options.tabindex = textarea.tabIndex;\n        }\n        if (!options.placeholder && textarea.placeholder) {\n            options.placeholder = textarea.placeholder;\n        }\n        // Set autofocus to true if this textarea is focused, or if it has\n        // autofocus and no other element is focused.\n        if (options.autofocus == null) {\n            var hasFocus = activeElt(rootNode(textarea));\n            options.autofocus = hasFocus == textarea || textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n        }\n        function save() {\n            textarea.value = cm.getValue();\n        }\n        var realSubmit;\n        if (textarea.form) {\n            on(textarea.form, \"submit\", save);\n            // Deplorable hack to make the submit method do the right thing.\n            if (!options.leaveSubmitMethodAlone) {\n                var form = textarea.form;\n                realSubmit = form.submit;\n                try {\n                    var wrappedSubmit = form.submit = function() {\n                        save();\n                        form.submit = realSubmit;\n                        form.submit();\n                        form.submit = wrappedSubmit;\n                    };\n                } catch (e) {}\n            }\n        }\n        options.finishInit = function(cm) {\n            cm.save = save;\n            cm.getTextArea = function() {\n                return textarea;\n            };\n            cm.toTextArea = function() {\n                cm.toTextArea = isNaN; // Prevent this from being ran twice\n                save();\n                textarea.parentNode.removeChild(cm.getWrapperElement());\n                textarea.style.display = \"\";\n                if (textarea.form) {\n                    off(textarea.form, \"submit\", save);\n                    if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\") {\n                        textarea.form.submit = realSubmit;\n                    }\n                }\n            };\n        };\n        textarea.style.display = \"none\";\n        var cm = CodeMirror(function(node) {\n            return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n        }, options);\n        return cm;\n    }\n    function addLegacyProps(CodeMirror) {\n        CodeMirror.off = off;\n        CodeMirror.on = on;\n        CodeMirror.wheelEventPixels = wheelEventPixels;\n        CodeMirror.Doc = Doc;\n        CodeMirror.splitLines = splitLinesAuto;\n        CodeMirror.countColumn = countColumn;\n        CodeMirror.findColumn = findColumn;\n        CodeMirror.isWordChar = isWordCharBasic;\n        CodeMirror.Pass = Pass;\n        CodeMirror.signal = signal;\n        CodeMirror.Line = Line;\n        CodeMirror.changeEnd = changeEnd;\n        CodeMirror.scrollbarModel = scrollbarModel;\n        CodeMirror.Pos = Pos;\n        CodeMirror.cmpPos = cmp;\n        CodeMirror.modes = modes;\n        CodeMirror.mimeModes = mimeModes;\n        CodeMirror.resolveMode = resolveMode;\n        CodeMirror.getMode = getMode;\n        CodeMirror.modeExtensions = modeExtensions;\n        CodeMirror.extendMode = extendMode;\n        CodeMirror.copyState = copyState;\n        CodeMirror.startState = startState;\n        CodeMirror.innerMode = innerMode;\n        CodeMirror.commands = commands;\n        CodeMirror.keyMap = keyMap;\n        CodeMirror.keyName = keyName;\n        CodeMirror.isModifierKey = isModifierKey;\n        CodeMirror.lookupKey = lookupKey;\n        CodeMirror.normalizeKeyMap = normalizeKeyMap;\n        CodeMirror.StringStream = StringStream;\n        CodeMirror.SharedTextMarker = SharedTextMarker;\n        CodeMirror.TextMarker = TextMarker;\n        CodeMirror.LineWidget = LineWidget;\n        CodeMirror.e_preventDefault = e_preventDefault;\n        CodeMirror.e_stopPropagation = e_stopPropagation;\n        CodeMirror.e_stop = e_stop;\n        CodeMirror.addClass = addClass;\n        CodeMirror.contains = contains;\n        CodeMirror.rmClass = rmClass;\n        CodeMirror.keyNames = keyNames;\n    }\n    // EDITOR CONSTRUCTOR\n    defineOptions(CodeMirror);\n    addEditorMethods(CodeMirror);\n    // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n    var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n    for(var prop in Doc.prototype){\n        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {\n            CodeMirror.prototype[prop] = function(method) {\n                return function() {\n                    return method.apply(this.doc, arguments);\n                };\n            }(Doc.prototype[prop]);\n        }\n    }\n    eventMixin(Doc);\n    CodeMirror.inputStyles = {\n        \"textarea\": TextareaInput,\n        \"contenteditable\": ContentEditableInput\n    };\n    // Extra arguments are stored as the mode's dependencies, which is\n    // used by (legacy) mechanisms like loadmode.js to automatically\n    // load a mode. (Preferred mechanism is the require/define calls.)\n    CodeMirror.defineMode = function(name /*, mode, */ ) {\n        if (!CodeMirror.defaults.mode && name != \"null\") {\n            CodeMirror.defaults.mode = name;\n        }\n        defineMode.apply(this, arguments);\n    };\n    CodeMirror.defineMIME = defineMIME;\n    // Minimal default mode.\n    CodeMirror.defineMode(\"null\", function() {\n        return {\n            token: function(stream) {\n                return stream.skipToEnd();\n            }\n        };\n    });\n    CodeMirror.defineMIME(\"text/plain\", \"null\");\n    // EXTENSIONS\n    CodeMirror.defineExtension = function(name, func) {\n        CodeMirror.prototype[name] = func;\n    };\n    CodeMirror.defineDocExtension = function(name, func) {\n        Doc.prototype[name] = func;\n    };\n    CodeMirror.fromTextArea = fromTextArea;\n    addLegacyProps(CodeMirror);\n    CodeMirror.version = \"5.65.20\";\n    return CodeMirror;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBRXJFLCtEQUErRDtBQUMvRCx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSxvREFBb0Q7QUFFbkQsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3hCLEtBQWlELEdBQWNFLE9BQU9ELE9BQU8sR0FBR0QsWUFDaEYsQ0FDdUQ7QUFDekQsR0FBRSxRQUFPO0lBQWM7SUFFckIsa0VBQWtFO0lBQ2xFLHdEQUF3RDtJQUN4RCxJQUFJTyxZQUFZQyxVQUFVRCxTQUFTO0lBQ25DLElBQUlFLFdBQVdELFVBQVVDLFFBQVE7SUFFakMsSUFBSUMsUUFBUSxhQUFhQyxJQUFJLENBQUNKO0lBQzlCLElBQUlLLFlBQVksVUFBVUQsSUFBSSxDQUFDSjtJQUMvQixJQUFJTSxVQUFVLHdDQUF3Q0MsSUFBSSxDQUFDUDtJQUMzRCxJQUFJUSxPQUFPLGNBQWNELElBQUksQ0FBQ1A7SUFDOUIsSUFBSVMsS0FBS0osYUFBYUMsV0FBV0U7SUFDakMsSUFBSUUsYUFBYUQsTUFBT0osQ0FBQUEsWUFBWU0sU0FBU0MsWUFBWSxJQUFJLElBQUksQ0FBQyxDQUFDSixRQUFRRixPQUFNLENBQUUsQ0FBQyxFQUFFO0lBQ3RGLElBQUlPLFNBQVMsQ0FBQ0wsUUFBUSxXQUFXSixJQUFJLENBQUNKO0lBQ3RDLElBQUljLFdBQVdELFVBQVUsZUFBZVQsSUFBSSxDQUFDSjtJQUM3QyxJQUFJZSxTQUFTLENBQUNQLFFBQVEsZ0JBQWdCRCxJQUFJLENBQUNQO0lBQzNDLElBQUlnQixpQkFBaUJELFVBQVUsQ0FBQ0EsTUFBTSxDQUFDLEVBQUU7SUFDekMsSUFBSUUsU0FBUyxVQUFVYixJQUFJLENBQUNKO0lBQzVCLElBQUlrQixTQUFTLGlCQUFpQmQsSUFBSSxDQUFDSCxVQUFVa0IsTUFBTTtJQUNuRCxJQUFJ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Q2xFenpELFdBQVcyVSxVQUFVLEdBQUcsU0FBU0MsS0FBSSxXQUFXLEdBQVg7UUFDbkMsSUFBSSxDQUFDNVUsV0FBV3VxRCxRQUFRLENBQUMxMUMsSUFBSSxJQUFJRCxRQUFRLFFBQVE7WUFBRTVVLFdBQVd1cUQsUUFBUSxDQUFDMTFDLElBQUksR0FBR0Q7UUFBTTtRQUNwRkQsV0FBV3ROLEtBQUssQ0FBQyxJQUFJLEVBQUVEO0lBQ3pCO0lBRUFwSCxXQUFXK1UsVUFBVSxHQUFHQTtJQUV4Qix3QkFBd0I7SUFDeEIvVSxXQUFXMlUsVUFBVSxDQUFDLFFBQVE7UUFBYyxPQUFRO1lBQUM4SSxPQUFPLFNBQVVKLE1BQU07Z0JBQUksT0FBT0EsT0FBT2hHLFNBQVM7WUFBSTtRQUFDO0lBQUk7SUFDaEhyWCxXQUFXK1UsVUFBVSxDQUFDLGNBQWM7SUFFcEMsYUFBYTtJQUViL1UsV0FBV3M3RCxlQUFlLEdBQUcsU0FBVTFtRCxJQUFJLEVBQUUybUQsSUFBSTtRQUMvQ3Y3RCxXQUFXa0gsU0FBUyxDQUFDME4sS0FBSyxHQUFHMm1EO0lBQy9CO0lBQ0F2N0QsV0FBV3c3RCxrQkFBa0IsR0FBRyxTQUFVNW1ELElBQUksRUFBRTJtRCxJQUFJO1FBQ2xEdGpCLElBQUkvd0MsU0FBUyxDQUFDME4sS0FBSyxHQUFHMm1EO0lBQ3hCO0lBRUF2N0QsV0FBV3c2RCxZQUFZLEdBQUdBO0lBRTFCVSxlQUFlbDdEO0lBRWZBLFdBQVd5N0QsT0FBTyxHQUFHO0lBRXJCLE9BQU96N0Q7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz8wZWRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC81L0xJQ0VOU0VcblxuLy8gVGhpcyBpcyBDb2RlTWlycm9yIChodHRwczovL2NvZGVtaXJyb3IubmV0LzUpLCBhIGNvZGUgZWRpdG9yXG4vLyBpbXBsZW1lbnRlZCBpbiBKYXZhU2NyaXB0IG9uIHRvcCBvZiB0aGUgYnJvd3NlcidzIERPTS5cbi8vXG4vLyBZb3UgY2FuIGZpbmQgc29tZSB0ZWNobmljYWwgYmFja2dyb3VuZCBmb3Igc29tZSBvZiB0aGUgY29kZSBiZWxvd1xuLy8gYXQgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9ibG9nLyNjbS1pbnRlcm5hbHMgLlxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkNvZGVNaXJyb3IgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gS2x1ZGdlcyBmb3IgYnVncyBhbmQgYmVoYXZpb3IgZGlmZmVyZW5jZXMgdGhhdCBjYW4ndCBiZSBmZWF0dXJlXG4gIC8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXG4gIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB2YXIgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm07XG5cbiAgdmFyIGdlY2tvID0gL2dlY2tvXFwvXFxkL2kudGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgaWVfdXB0bzEwID0gL01TSUUgXFxkLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBpZV8xMXVwID0gL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKHVzZXJBZ2VudCk7XG4gIHZhciBlZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWModXNlckFnZW50KTtcbiAgdmFyIGllID0gaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgZWRnZTtcbiAgdmFyIGllX3ZlcnNpb24gPSBpZSAmJiAoaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDYgOiArKGVkZ2UgfHwgaWVfMTF1cClbMV0pO1xuICB2YXIgd2Via2l0ID0gIWVkZ2UgJiYgL1dlYktpdFxcLy8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgcXR3ZWJraXQgPSB3ZWJraXQgJiYgL1F0XFwvXFxkK1xcLlxcZCsvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIGNocm9tZSA9ICFlZGdlICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWModXNlckFnZW50KTtcbiAgdmFyIGNocm9tZV92ZXJzaW9uID0gY2hyb21lICYmICtjaHJvbWVbMV07XG4gIHZhciBwcmVzdG8gPSAvT3BlcmFcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHNhZmFyaSA9IC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbiAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHBoYW50b20gPSAvUGhhbnRvbUpTLy50ZXN0KHVzZXJBZ2VudCk7XG5cbiAgdmFyIGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QodXNlckFnZW50KSB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAyKTtcbiAgdmFyIGFuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpO1xuICAvLyBUaGlzIGlzIHdvZWZ1bGx5IGluY29tcGxldGUuIFN1Z2dlc3Rpb25zIGZvciBhbHRlcm5hdGl2ZSBtZXRob2RzIHdlbGNvbWUuXG4gIHZhciBtb2JpbGUgPSBpb3MgfHwgYW5kcm9pZCB8fCAvd2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBtYWMgPSBpb3MgfHwgL01hYy8udGVzdChwbGF0Zm9ybSk7XG4gIHZhciBjaHJvbWVPUyA9IC9cXGJDck9TXFxiLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciB3aW5kb3dzID0gL3dpbi9pLnRlc3QocGxhdGZvcm0pO1xuXG4gIHZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKlxcLlxcZCopLyk7XG4gIGlmIChwcmVzdG9fdmVyc2lvbikgeyBwcmVzdG9fdmVyc2lvbiA9IE51bWJlcihwcmVzdG9fdmVyc2lvblsxXSk7IH1cbiAgaWYgKHByZXN0b192ZXJzaW9uICYmIHByZXN0b192ZXJzaW9uID49IDE1KSB7IHByZXN0byA9IGZhbHNlOyB3ZWJraXQgPSB0cnVlOyB9XG4gIC8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXG4gIHZhciBmbGlwQ3RybENtZCA9IG1hYyAmJiAocXR3ZWJraXQgfHwgcHJlc3RvICYmIChwcmVzdG9fdmVyc2lvbiA9PSBudWxsIHx8IHByZXN0b192ZXJzaW9uIDwgMTIuMTEpKTtcbiAgdmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSk7XG5cbiAgZnVuY3Rpb24gY2xhc3NUZXN0KGNscykgeyByZXR1cm4gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xzICsgXCIoPzokfFxcXFxzKVxcXFxzKlwiKSB9XG5cbiAgdmFyIHJtQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbHMpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xuICAgIHZhciBtYXRjaCA9IGNsYXNzVGVzdChjbHMpLmV4ZWMoY3VycmVudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBjdXJyZW50LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3VycmVudC5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAoYWZ0ZXIgPyBtYXRjaFsxXSArIGFmdGVyIDogXCJcIik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpIHtcbiAgICBmb3IgKHZhciBjb3VudCA9IGUuY2hpbGROb2Rlcy5sZW5ndGg7IGNvdW50ID4gMDsgLS1jb3VudClcbiAgICAgIHsgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpOyB9XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xuICAgIHJldHVybiByZW1vdmVDaGlsZHJlbihwYXJlbnQpLmFwcGVuZENoaWxkKGUpXG4gIH1cblxuICBmdW5jdGlvbiBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNsYXNzTmFtZSkgeyBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxuICAgIGlmIChzdHlsZSkgeyBlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTsgfVxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKSB7IGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpOyB9XG4gICAgZWxzZSBpZiAoY29udGVudCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyArK2kpIHsgZS5hcHBlbmRDaGlsZChjb250ZW50W2ldKTsgfSB9XG4gICAgcmV0dXJuIGVcbiAgfVxuICAvLyB3cmFwcGVyIGZvciBlbHQsIHdoaWNoIHJlbW92ZXMgdGhlIGVsdCBmcm9tIHRoZSBhY2Nlc3NpYmlsaXR5IHRyZWVcbiAgZnVuY3Rpb24gZWx0UCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgICB2YXIgZSA9IGVsdCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpO1xuICAgIGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgdmFyIHJhbmdlO1xuICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kLCBlbmROb2RlKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHIuc2V0RW5kKGVuZE5vZGUgfHwgbm9kZSwgZW5kKTtcbiAgICByLnNldFN0YXJ0KG5vZGUsIHN0YXJ0KTtcbiAgICByZXR1cm4gclxuICB9OyB9XG4gIGVsc2UgeyByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgdHJ5IHsgci5tb3ZlVG9FbGVtZW50VGV4dChub2RlLnBhcmVudE5vZGUpOyB9XG4gICAgY2F0Y2goZSkgeyByZXR1cm4gciB9XG4gICAgci5jb2xsYXBzZSh0cnVlKTtcbiAgICByLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICByLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7XG4gICAgcmV0dXJuIHJcbiAgfTsgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMykgLy8gQW5kcm9pZCBicm93c2VyIGFsd2F5cyByZXR1cm5zIGZhbHNlIHdoZW4gY2hpbGQgaXMgYSB0ZXh0bm9kZVxuICAgICAgeyBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7IH1cbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKVxuICAgICAgeyByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGNoaWxkKSB9XG4gICAgZG8ge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSB7IGNoaWxkID0gY2hpbGQuaG9zdDsgfVxuICAgICAgaWYgKGNoaWxkID09IHBhcmVudCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZlRWx0KHJvb3ROb2RlKSB7XG4gICAgLy8gSUUgYW5kIEVkZ2UgbWF5IHRocm93IGFuIFwiVW5zcGVjaWZpZWQgRXJyb3JcIiB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50LlxuICAgIC8vIElFIDwgMTAgd2lsbCB0aHJvdyB3aGVuIGFjY2Vzc2VkIHdoaWxlIHRoZSBwYWdlIGlzIGxvYWRpbmcgb3IgaW4gYW4gaWZyYW1lLlxuICAgIC8vIElFID4gOSBhbmQgRWRnZSB3aWxsIHRocm93IHdoZW4gYWNjZXNzZWQgaW4gYW4gaWZyYW1lIGlmIGRvY3VtZW50LmJvZHkgaXMgdW5hdmFpbGFibGUuXG4gICAgdmFyIGRvYyA9IHJvb3ROb2RlLm93bmVyRG9jdW1lbnQgfHwgcm9vdE5vZGU7XG4gICAgdmFyIGFjdGl2ZUVsZW1lbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290Tm9kZS5hY3RpdmVFbGVtZW50O1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgYWN0aXZlRWxlbWVudCA9IGRvYy5ib2R5IHx8IG51bGw7XG4gICAgfVxuICAgIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudClcbiAgICAgIHsgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50OyB9XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNscykge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWU7XG4gICAgaWYgKCFjbGFzc1Rlc3QoY2xzKS50ZXN0KGN1cnJlbnQpKSB7IG5vZGUuY2xhc3NOYW1lICs9IChjdXJyZW50ID8gXCIgXCIgOiBcIlwiKSArIGNsczsgfVxuICB9XG4gIGZ1bmN0aW9uIGpvaW5DbGFzc2VzKGEsIGIpIHtcbiAgICB2YXIgYXMgPSBhLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAoYXNbaV0gJiYgIWNsYXNzVGVzdChhc1tpXSkudGVzdChiKSkgeyBiICs9IFwiIFwiICsgYXNbaV07IH0gfVxuICAgIHJldHVybiBiXG4gIH1cblxuICB2YXIgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0KCk7IH07XG4gIGlmIChpb3MpIC8vIE1vYmlsZSBTYWZhcmkgYXBwYXJlbnRseSBoYXMgYSBidWcgd2hlcmUgc2VsZWN0KCkgaXMgYnJva2VuLlxuICAgIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0aW9uU3RhcnQgPSAwOyBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoOyB9OyB9XG4gIGVsc2UgaWYgKGllKSAvLyBTdXBwcmVzcyBteXN0ZXJpb3VzIElFMTAgZXJyb3JzXG4gICAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKTsgfSBjYXRjaChfZSkge30gfTsgfVxuXG4gIGZ1bmN0aW9uIGRvYyhjbSkgeyByZXR1cm4gY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQgfVxuXG4gIGZ1bmN0aW9uIHJvb3QoY20pIHtcbiAgICByZXR1cm4gcm9vdE5vZGUoY20uZGlzcGxheS53cmFwcGVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcm9vdE5vZGUoZWxlbWVudCkge1xuICAgIC8vIERldGVjdCBtb2Rlcm4gYnJvd3NlcnMgKDIwMTcrKS5cbiAgICByZXR1cm4gZWxlbWVudC5nZXRSb290Tm9kZSA/IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKSA6IGVsZW1lbnQub3duZXJEb2N1bWVudFxuICB9XG5cbiAgZnVuY3Rpb24gd2luKGNtKSB7IHJldHVybiBkb2MoY20pLmRlZmF1bHRWaWV3IH1cblxuICBmdW5jdGlvbiBiaW5kKGYpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyl9XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcbiAgICBpZiAoIXRhcmdldCkgeyB0YXJnZXQgPSB7fTsgfVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgeyBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcCkpKVxuICAgICAgICB7IHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTsgfSB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4gIC8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG4gIGZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICBpZiAoZW5kID09IC0xKSB7IGVuZCA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbiA9IHN0YXJ0VmFsdWUgfHwgMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIGkpO1xuICAgICAgaWYgKG5leHRUYWIgPCAwIHx8IG5leHRUYWIgPj0gZW5kKVxuICAgICAgICB7IHJldHVybiBuICsgKGVuZCAtIGkpIH1cbiAgICAgIG4gKz0gbmV4dFRhYiAtIGk7XG4gICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgaSA9IG5leHRUYWIgKyAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pZCA9IG51bGw7XG4gICAgdGhpcy5mID0gbnVsbDtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuaGFuZGxlciA9IGJpbmQodGhpcy5vblRpbWVvdXQsIHRoaXMpO1xuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5vblRpbWVvdXQgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgIHNlbGYuaWQgPSAwO1xuICAgIGlmIChzZWxmLnRpbWUgPD0gK25ldyBEYXRlKSB7XG4gICAgICBzZWxmLmYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChzZWxmLmhhbmRsZXIsIHNlbGYudGltZSAtICtuZXcgRGF0ZSk7XG4gICAgfVxuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobXMsIGYpIHtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHZhciB0aW1lID0gK25ldyBEYXRlICsgbXM7XG4gICAgaWYgKCF0aGlzLmlkIHx8IHRpbWUgPCB0aGlzLnRpbWUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICAgIHRoaXMuaWQgPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlciwgbXMpO1xuICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWx0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgIHsgaWYgKGFycmF5W2ldID09IGVsdCkgeyByZXR1cm4gaSB9IH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE51bWJlciBvZiBwaXhlbHMgYWRkZWQgdG8gc2Nyb2xsZXIgYW5kIHNpemVyIHRvIGhpZGUgc2Nyb2xsYmFyXG4gIHZhciBzY3JvbGxlckdhcCA9IDUwO1xuXG4gIC8vIFJldHVybmVkIG9yIHRocm93biBieSB2YXJpb3VzIHByb3RvY29scyB0byBzaWduYWwgJ0knbSBub3RcbiAgLy8gaGFuZGxpbmcgdGhpcycuXG4gIHZhciBQYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcIkNvZGVNaXJyb3IuUGFzc1wifX07XG5cbiAgLy8gUmV1c2VkIG9wdGlvbiBvYmplY3RzIGZvciBzZXRTZWxlY3Rpb24gJiBmcmllbmRzXG4gIHZhciBzZWxfZG9udFNjcm9sbCA9IHtzY3JvbGw6IGZhbHNlfSwgc2VsX21vdXNlID0ge29yaWdpbjogXCIqbW91c2VcIn0sIHNlbF9tb3ZlID0ge29yaWdpbjogXCIrbW92ZVwifTtcblxuICAvLyBUaGUgaW52ZXJzZSBvZiBjb3VudENvbHVtbiAtLSBmaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAvLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxuICBmdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xuICAgIGZvciAodmFyIHBvcyA9IDAsIGNvbCA9IDA7Oykge1xuICAgICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcIlxcdFwiLCBwb3MpO1xuICAgICAgaWYgKG5leHRUYWIgPT0gLTEpIHsgbmV4dFRhYiA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICAgIHZhciBza2lwcGVkID0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGlmIChuZXh0VGFiID09IHN0cmluZy5sZW5ndGggfHwgY29sICsgc2tpcHBlZCA+PSBnb2FsKVxuICAgICAgICB7IHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKSB9XG4gICAgICBjb2wgKz0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGNvbCArPSB0YWJTaXplIC0gKGNvbCAlIHRhYlNpemUpO1xuICAgICAgcG9zID0gbmV4dFRhYiArIDE7XG4gICAgICBpZiAoY29sID49IGdvYWwpIHsgcmV0dXJuIHBvcyB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHNwYWNlU3RycyA9IFtcIlwiXTtcbiAgZnVuY3Rpb24gc3BhY2VTdHIobikge1xuICAgIHdoaWxlIChzcGFjZVN0cnMubGVuZ3RoIDw9IG4pXG4gICAgICB7IHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXCIgXCIpOyB9XG4gICAgcmV0dXJuIHNwYWNlU3Ryc1tuXVxuICB9XG5cbiAgZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV0gfVxuXG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IG91dFtpXSA9IGYoYXJyYXlbaV0sIGkpOyB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGFycmF5LCB2YWx1ZSwgc2NvcmUpIHtcbiAgICB2YXIgcG9zID0gMCwgcHJpb3JpdHkgPSBzY29yZSh2YWx1ZSk7XG4gICAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgeyBwb3MrKzsgfVxuICAgIGFycmF5LnNwbGljZShwb3MsIDAsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7fVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xuICAgIHZhciBpbnN0O1xuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgICBpbnN0ID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aGluZy5wcm90b3R5cGUgPSBiYXNlO1xuICAgICAgaW5zdCA9IG5ldyBub3RoaW5nKCk7XG4gICAgfVxuICAgIGlmIChwcm9wcykgeyBjb3B5T2JqKHByb3BzLCBpbnN0KTsgfVxuICAgIHJldHVybiBpbnN0XG4gIH1cblxuICB2YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG4gIGZ1bmN0aW9uIGlzV29yZENoYXJCYXNpYyhjaCkge1xuICAgIHJldHVybiAvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJlxuICAgICAgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSlcbiAgfVxuICBmdW5jdGlvbiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpIHtcbiAgICBpZiAoIWhlbHBlcikgeyByZXR1cm4gaXNXb3JkQ2hhckJhc2ljKGNoKSB9XG4gICAgaWYgKGhlbHBlci5zb3VyY2UuaW5kZXhPZihcIlxcXFx3XCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGhlbHBlci50ZXN0KGNoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciBuIGluIG9iaikgeyBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEV4dGVuZGluZyB1bmljb2RlIGNoYXJhY3RlcnMuIEEgc2VyaWVzIG9mIGEgbm9uLWV4dGVuZGluZyBjaGFyICtcbiAgLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxuICAvLyBhcyBlZGl0aW5nIGFuZCBtZWFzdXJpbmcgaXMgY29uY2VybmVkLiBUaGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0LFxuICAvLyBzaW5jZSBzb21lIHNjcmlwdHMvZm9udHMvYnJvd3NlcnMgYWxzbyB0cmVhdCBvdGhlciBjb25maWd1cmF0aW9uc1xuICAvLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxuICB2YXIgZXh0ZW5kaW5nQ2hhcnMgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY1ZVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRlLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2ViLVxcdTA3ZjNcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwOTAwLVxcdTA5MDJcXHUwOTNjXFx1MDk0MS1cXHUwOTQ4XFx1MDk0ZFxcdTA5NTEtXFx1MDk1NVxcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5YmNcXHUwOWJlXFx1MDljMS1cXHUwOWM0XFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTBhMDFcXHUwYTAyXFx1MGEzY1xcdTBhNDFcXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE3MFxcdTBhNzFcXHUwYTc1XFx1MGE4MVxcdTBhODJcXHUwYWJjXFx1MGFjMS1cXHUwYWM1XFx1MGFjN1xcdTBhYzhcXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYjAxXFx1MGIzY1xcdTBiM2VcXHUwYjNmXFx1MGI0MS1cXHUwYjQ0XFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjgyXFx1MGJiZVxcdTBiYzBcXHUwYmNkXFx1MGJkN1xcdTBjM2UtXFx1MGM0MFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwY2JjXFx1MGNiZlxcdTBjYzJcXHUwY2M2XFx1MGNjY1xcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGQzZVxcdTBkNDEtXFx1MGQ0NFxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZGNhXFx1MGRjZlxcdTBkZDItXFx1MGRkNFxcdTBkZDZcXHUwZGRmXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBmMThcXHUwZjE5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY3MS1cXHUwZjdlXFx1MGY4MC1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjkwLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyZC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM2FcXHUxMDNkXFx1MTAzZVxcdTEwNThcXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4ZFxcdTEwOWRcXHUxMzVmXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjctXFx1MTdiZFxcdTE3YzZcXHUxN2M5LVxcdTE3ZDNcXHUxN2RkXFx1MTgwYi1cXHUxODBkXFx1MThhOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzYlxcdTFhMTdcXHUxYTE4XFx1MWE1NlxcdTFhNTgtXFx1MWE1ZVxcdTFhNjBcXHUxYTYyXFx1MWE2NS1cXHUxYTZjXFx1MWE3My1cXHUxYTdjXFx1MWE3ZlxcdTFiMDAtXFx1MWIwM1xcdTFiMzRcXHUxYjM2LVxcdTFiM2FcXHUxYjNjXFx1MWI0MlxcdTFiNmItXFx1MWI3M1xcdTFiODBcXHUxYjgxXFx1MWJhMi1cXHUxYmE1XFx1MWJhOFxcdTFiYTlcXHUxYzJjLVxcdTFjMzNcXHUxYzM2XFx1MWMzN1xcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlMFxcdTFjZTItXFx1MWNlOFxcdTFjZWRcXHUxZGMwLVxcdTFkZTZcXHUxZGZkLVxcdTFkZmZcXHUyMDBjXFx1MjAwZFxcdTIwZDAtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTY2Zi1cXHVhNjcyXFx1YTY3Y1xcdWE2N2RcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjVcXHVhODI2XFx1YThjNFxcdWE4ZTAtXFx1YThmMVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1MVxcdWE5ODAtXFx1YTk4MlxcdWE5YjNcXHVhOWI2LVxcdWE5YjlcXHVhOWJjXFx1YWEyOS1cXHVhYTJlXFx1YWEzMVxcdWFhMzJcXHVhYTM1XFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWJlNVxcdWFiZThcXHVhYmVkXFx1ZGMwMC1cXHVkZmZmXFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZmOWVcXHVmZjlmXS87XG4gIGZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCkgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgZnJvbSB0aGUgcmFuZ2UgW2AwYDsgYHN0ci5sZW5ndGhgXSB1bmxlc3MgYHBvc2AgaXMgb3V0c2lkZSB0aGF0IHJhbmdlLlxuICBmdW5jdGlvbiBza2lwRXh0ZW5kaW5nQ2hhcnMoc3RyLCBwb3MsIGRpcikge1xuICAgIHdoaWxlICgoZGlyIDwgMCA/IHBvcyA+IDAgOiBwb3MgPCBzdHIubGVuZ3RoKSAmJiBpc0V4dGVuZGluZ0NoYXIoc3RyLmNoYXJBdChwb3MpKSkgeyBwb3MgKz0gZGlyOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgcmFuZ2UgW2Bmcm9tYDsgYHRvYF0gdGhhdCBzYXRpc2ZpZXNcbiAgLy8gYHByZWRgIGFuZCBpcyBjbG9zZXN0IHRvIGBmcm9tYC4gQXNzdW1lcyB0aGF0IGF0IGxlYXN0IGB0b2BcbiAgLy8gc2F0aXNmaWVzIGBwcmVkYC4gU3VwcG9ydHMgYGZyb21gIGJlaW5nIGdyZWF0ZXIgdGhhbiBgdG9gLlxuICBmdW5jdGlvbiBmaW5kRmlyc3QocHJlZCwgZnJvbSwgdG8pIHtcbiAgICAvLyBBdCBhbnkgcG9pbnQgd2UgYXJlIGNlcnRhaW4gYHRvYCBzYXRpc2ZpZXMgYHByZWRgLCBkb24ndCBrbm93XG4gICAgLy8gd2hldGhlciBgZnJvbWAgZG9lcy5cbiAgICB2YXIgZGlyID0gZnJvbSA+IHRvID8gLTEgOiAxO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChmcm9tID09IHRvKSB7IHJldHVybiBmcm9tIH1cbiAgICAgIHZhciBtaWRGID0gKGZyb20gKyB0bykgLyAyLCBtaWQgPSBkaXIgPCAwID8gTWF0aC5jZWlsKG1pZEYpIDogTWF0aC5mbG9vcihtaWRGKTtcbiAgICAgIGlmIChtaWQgPT0gZnJvbSkgeyByZXR1cm4gcHJlZChtaWQpID8gZnJvbSA6IHRvIH1cbiAgICAgIGlmIChwcmVkKG1pZCkpIHsgdG8gPSBtaWQ7IH1cbiAgICAgIGVsc2UgeyBmcm9tID0gbWlkICsgZGlyOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQklESSBIRUxQRVJTXG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbSwgdG8sIGYpIHtcbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiBmKGZyb20sIHRvLCBcImx0clwiLCAwKSB9XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltpXTtcbiAgICAgIGlmIChwYXJ0LmZyb20gPCB0byAmJiBwYXJ0LnRvID4gZnJvbSB8fCBmcm9tID09IHRvICYmIHBhcnQudG8gPT0gZnJvbSkge1xuICAgICAgICBmKE1hdGgubWF4KHBhcnQuZnJvbSwgZnJvbSksIE1hdGgubWluKHBhcnQudG8sIHRvKSwgcGFydC5sZXZlbCA9PSAxID8gXCJydGxcIiA6IFwibHRyXCIsIGkpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIHsgZihmcm9tLCB0bywgXCJsdHJcIik7IH1cbiAgfVxuXG4gIHZhciBiaWRpT3RoZXIgPSBudWxsO1xuICBmdW5jdGlvbiBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGJpZGlPdGhlciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGN1ciA9IG9yZGVyW2ldO1xuICAgICAgaWYgKGN1ci5mcm9tIDwgY2ggJiYgY3VyLnRvID4gY2gpIHsgcmV0dXJuIGkgfVxuICAgICAgaWYgKGN1ci50byA9PSBjaCkge1xuICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSA9PSBcImJlZm9yZVwiKSB7IGZvdW5kID0gaTsgfVxuICAgICAgICBlbHNlIHsgYmlkaU90aGVyID0gaTsgfVxuICAgICAgfVxuICAgICAgaWYgKGN1ci5mcm9tID09IGNoKSB7XG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ICE9IFwiYmVmb3JlXCIpIHsgZm91bmQgPSBpOyB9XG4gICAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZCAhPSBudWxsID8gZm91bmQgOiBiaWRpT3RoZXJcbiAgfVxuXG4gIC8vIEJpZGlyZWN0aW9uYWwgb3JkZXJpbmcgYWxnb3JpdGhtXG4gIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvdHI5LTEzLmh0bWwgZm9yIHRoZSBhbGdvcml0aG1cbiAgLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXG5cbiAgLy8gT25lLWNoYXIgY29kZXMgdXNlZCBmb3IgY2hhcmFjdGVyIHR5cGVzOlxuICAvLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XG4gIC8vIFIgKFIpOiAgIFJpZ2h0LXRvLUxlZnRcbiAgLy8gciAoQUwpOiAgUmlnaHQtdG8tTGVmdCBBcmFiaWNcbiAgLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXG4gIC8vICsgKEVTKTogIEV1cm9wZWFuIE51bWJlciBTZXBhcmF0b3JcbiAgLy8gJSAoRVQpOiAgRXVyb3BlYW4gTnVtYmVyIFRlcm1pbmF0b3JcbiAgLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxuICAvLyAsIChDUyk6ICBDb21tb24gTnVtYmVyIFNlcGFyYXRvclxuICAvLyBtIChOU00pOiBOb24tU3BhY2luZyBNYXJrXG4gIC8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcbiAgLy8gcyAoQik6ICAgUGFyYWdyYXBoIFNlcGFyYXRvclxuICAvLyB0IChTKTogICBTZWdtZW50IFNlcGFyYXRvclxuICAvLyB3IChXUyk6ICBXaGl0ZXNwYWNlXG4gIC8vIE4gKE9OKTogIE90aGVyIE5ldXRyYWxzXG5cbiAgLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcbiAgLy8gKGxlZnQtdG8tcmlnaHQpLCBvciBhbiBhcnJheSBvZiBzZWN0aW9ucyAoe2Zyb20sIHRvLCBsZXZlbH1cbiAgLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXG4gIHZhciBiaWRpT3JkZXJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmZlxuICAgIHZhciBsb3dUeXBlcyA9IFwiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cIjtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbiAgICB2YXIgYXJhYmljVHlwZXMgPSBcIm5ubm5ubk5OciUlcixyTk5tbW1tbW1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1tbW5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbk5tbW1tbW1ycm1tTm1tbW1ycjExMTExMTExMTFcIjtcbiAgICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA8PSAweGY3KSB7IHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSkgfVxuICAgICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSB7IHJldHVybiBcIlJcIiB9XG4gICAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZjkpIHsgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApIH1cbiAgICAgIGVsc2UgaWYgKDB4NmVlIDw9IGNvZGUgJiYgY29kZSA8PSAweDhhYykgeyByZXR1cm4gXCJyXCIgfVxuICAgICAgZWxzZSBpZiAoMHgyMDAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDIwMGIpIHsgcmV0dXJuIFwid1wiIH1cbiAgICAgIGVsc2UgaWYgKGNvZGUgPT0gMHgyMDBjKSB7IHJldHVybiBcImJcIiB9XG4gICAgICBlbHNlIHsgcmV0dXJuIFwiTFwiIH1cbiAgICB9XG5cbiAgICB2YXIgYmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbiAgICB2YXIgaXNOZXV0cmFsID0gL1tzdHdOXS8sIGlzU3Ryb25nID0gL1tMUnJdLywgY291bnRzQXNMZWZ0ID0gL1tMYjFuXS8sIGNvdW50c0FzTnVtID0gL1sxbl0vO1xuXG4gICAgZnVuY3Rpb24gQmlkaVNwYW4obGV2ZWwsIGZyb20sIHRvKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgb3V0ZXJUeXBlID0gZGlyZWN0aW9uID09IFwibHRyXCIgPyBcIkxcIiA6IFwiUlwiO1xuXG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGRpcmVjdGlvbiA9PSBcImx0clwiICYmICFiaWRpUkUudGVzdChzdHIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aCwgdHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIHsgdHlwZXMucHVzaChjaGFyVHlwZShzdHIuY2hhckNvZGVBdChpKSkpOyB9XG5cbiAgICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSQxIDwgbGVuOyArK2kkMSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2kkMV07XG4gICAgICAgIGlmICh0eXBlID09IFwibVwiKSB7IHR5cGVzW2kkMV0gPSBwcmV2OyB9XG4gICAgICAgIGVsc2UgeyBwcmV2ID0gdHlwZTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAvLyBudW1iZXIuXG4gICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgIGZvciAodmFyIGkkMiA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSQyIDwgbGVuOyArK2kkMikge1xuICAgICAgICB2YXIgdHlwZSQxID0gdHlwZXNbaSQyXTtcbiAgICAgICAgaWYgKHR5cGUkMSA9PSBcIjFcIiAmJiBjdXIgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiblwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQxKSkgeyBjdXIgPSB0eXBlJDE7IGlmICh0eXBlJDEgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiUlwiOyB9IH1cbiAgICAgIH1cblxuICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzXG4gICAgICAvLyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb24gc2VwYXJhdG9yIGJldHdlZW5cbiAgICAgIC8vIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXG4gICAgICBmb3IgKHZhciBpJDMgPSAxLCBwcmV2JDEgPSB0eXBlc1swXTsgaSQzIDwgbGVuIC0gMTsgKytpJDMpIHtcbiAgICAgICAgdmFyIHR5cGUkMiA9IHR5cGVzW2kkM107XG4gICAgICAgIGlmICh0eXBlJDIgPT0gXCIrXCIgJiYgcHJldiQxID09IFwiMVwiICYmIHR5cGVzW2kkMysxXSA9PSBcIjFcIikgeyB0eXBlc1tpJDNdID0gXCIxXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQyID09IFwiLFwiICYmIHByZXYkMSA9PSB0eXBlc1tpJDMrMV0gJiZcbiAgICAgICAgICAgICAgICAgKHByZXYkMSA9PSBcIjFcIiB8fCBwcmV2JDEgPT0gXCJuXCIpKSB7IHR5cGVzW2kkM10gPSBwcmV2JDE7IH1cbiAgICAgICAgcHJldiQxID0gdHlwZSQyO1xuICAgICAgfVxuXG4gICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXG4gICAgICAvLyBOZXV0cmFsLlxuICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbGVuOyArK2kkNCkge1xuICAgICAgICB2YXIgdHlwZSQzID0gdHlwZXNbaSQ0XTtcbiAgICAgICAgaWYgKHR5cGUkMyA9PSBcIixcIikgeyB0eXBlc1tpJDRdID0gXCJOXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQzID09IFwiJVwiKSB7XG4gICAgICAgICAgdmFyIGVuZCA9ICh2b2lkIDApO1xuICAgICAgICAgIGZvciAoZW5kID0gaSQ0ICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXCIlXCI7ICsrZW5kKSB7fVxuICAgICAgICAgIHZhciByZXBsYWNlID0gKGkkNCAmJiB0eXBlc1tpJDQtMV0gPT0gXCIhXCIpIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIjFcIikgPyBcIjFcIiA6IFwiTlwiO1xuICAgICAgICAgIGZvciAodmFyIGogPSBpJDQ7IGogPCBlbmQ7ICsraikgeyB0eXBlc1tqXSA9IHJlcGxhY2U7IH1cbiAgICAgICAgICBpJDQgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgZm9yICh2YXIgaSQ1ID0gMCwgY3VyJDEgPSBvdXRlclR5cGU7IGkkNSA8IGxlbjsgKytpJDUpIHtcbiAgICAgICAgdmFyIHR5cGUkNCA9IHR5cGVzW2kkNV07XG4gICAgICAgIGlmIChjdXIkMSA9PSBcIkxcIiAmJiB0eXBlJDQgPT0gXCIxXCIpIHsgdHlwZXNbaSQ1XSA9IFwiTFwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQ0KSkgeyBjdXIkMSA9IHR5cGUkNDsgfVxuICAgICAgfVxuXG4gICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGxlbjsgKytpJDYpIHtcbiAgICAgICAgaWYgKGlzTmV1dHJhbC50ZXN0KHR5cGVzW2kkNl0pKSB7XG4gICAgICAgICAgdmFyIGVuZCQxID0gKHZvaWQgMCk7XG4gICAgICAgICAgZm9yIChlbmQkMSA9IGkkNiArIDE7IGVuZCQxIDwgbGVuICYmIGlzTmV1dHJhbC50ZXN0KHR5cGVzW2VuZCQxXSk7ICsrZW5kJDEpIHt9XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IChpJDYgPyB0eXBlc1tpJDYtMV0gOiBvdXRlclR5cGUpID09IFwiTFwiO1xuICAgICAgICAgIHZhciBhZnRlciA9IChlbmQkMSA8IGxlbiA/IHR5cGVzW2VuZCQxXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIHJlcGxhY2UkMSA9IGJlZm9yZSA9PSBhZnRlciA/IChiZWZvcmUgPyBcIkxcIiA6IFwiUlwiKSA6IG91dGVyVHlwZTtcbiAgICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDY7IGokMSA8IGVuZCQxOyArK2okMSkgeyB0eXBlc1tqJDFdID0gcmVwbGFjZSQxOyB9XG4gICAgICAgICAgaSQ2ID0gZW5kJDEgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgICAgLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcbiAgICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAgIC8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXG4gICAgICB2YXIgb3JkZXIgPSBbXSwgbTtcbiAgICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IGxlbjspIHtcbiAgICAgICAgaWYgKGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaSQ3O1xuICAgICAgICAgIGZvciAoKytpJDc7IGkkNyA8IGxlbiAmJiBjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpJDddKTsgKytpJDcpIHt9XG4gICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgc3RhcnQsIGkkNykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MgPSBpJDcsIGF0ID0gb3JkZXIubGVuZ3RoLCBpc1JUTCA9IGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gMSA6IDA7XG4gICAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIHR5cGVzW2kkN10gIT0gXCJMXCI7ICsraSQ3KSB7fVxuICAgICAgICAgIGZvciAodmFyIGokMiA9IHBvczsgaiQyIDwgaSQ3Oykge1xuICAgICAgICAgICAgaWYgKGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSkpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA8IGokMikgeyBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGokMikpOyBhdCArPSBpc1JUTDsgfVxuICAgICAgICAgICAgICB2YXIgbnN0YXJ0ID0gaiQyO1xuICAgICAgICAgICAgICBmb3IgKCsraiQyOyBqJDIgPCBpJDcgJiYgY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKTsgKytqJDIpIHt9XG4gICAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDIsIG5zdGFydCwgaiQyKSk7XG4gICAgICAgICAgICAgIGF0ICs9IGlzUlRMO1xuICAgICAgICAgICAgICBwb3MgPSBqJDI7XG4gICAgICAgICAgICB9IGVsc2UgeyArK2okMjsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zIDwgaSQ3KSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaSQ3KSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImx0clwiKSB7XG4gICAgICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxzKy8pKSkge1xuICAgICAgICAgIG9yZGVyWzBdLmZyb20gPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLCAwLCBtWzBdLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsc3Qob3JkZXIpLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL1xccyskLykpKSB7XG4gICAgICAgICAgbHN0KG9yZGVyKS50byAtPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gb3JkZXIucmV2ZXJzZSgpIDogb3JkZXJcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gR2V0IHRoZSBiaWRpIG9yZGVyaW5nIGZvciB0aGUgZ2l2ZW4gbGluZSAoYW5kIGNhY2hlIGl0KS4gUmV0dXJuc1xuICAvLyBmYWxzZSBmb3IgbGluZXMgdGhhdCBhcmUgZnVsbHkgbGVmdC10by1yaWdodCwgYW5kIGFuIGFycmF5IG9mXG4gIC8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBnZXRPcmRlcihsaW5lLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyO1xuICAgIGlmIChvcmRlciA9PSBudWxsKSB7IG9yZGVyID0gbGluZS5vcmRlciA9IGJpZGlPcmRlcmluZyhsaW5lLnRleHQsIGRpcmVjdGlvbik7IH1cbiAgICByZXR1cm4gb3JkZXJcbiAgfVxuXG4gIC8vIEVWRU5UIEhBTkRMSU5HXG5cbiAgLy8gTGlnaHR3ZWlnaHQgZXZlbnQgZnJhbWV3b3JrLiBvbi9vZmYgYWxzbyB3b3JrIG9uIERPTSBub2RlcyxcbiAgLy8gcmVnaXN0ZXJpbmcgbmF0aXZlIERPTSBoYW5kbGVycy5cblxuICB2YXIgbm9IYW5kbGVycyA9IFtdO1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZW1pdHRlci5hdHRhY2hFdmVudCkge1xuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzIHx8IChlbWl0dGVyLl9oYW5kbGVycyA9IHt9KTtcbiAgICAgIG1hcFt0eXBlXSA9IChtYXBbdHlwZV0gfHwgbm9IYW5kbGVycykuY29uY2F0KGYpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdIHx8IG5vSGFuZGxlcnNcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZihlbWl0dGVyLCB0eXBlLCBmKSB7XG4gICAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVtaXR0ZXIuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycywgYXJyID0gbWFwICYmIG1hcFt0eXBlXTtcbiAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnIsIGYpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICB7IG1hcFt0eXBlXSA9IGFyci5zbGljZSgwLCBpbmRleCkuY29uY2F0KGFyci5zbGljZShpbmRleCArIDEpKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBoYW5kbGVycyA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xuICAgIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7IHJldHVybiB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHsgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7IH1cbiAgfVxuXG4gIC8vIFRoZSBET00gZXZlbnRzIHRoYXQgQ29kZU1pcnJvciBoYW5kbGVzIGNhbiBiZSBvdmVycmlkZGVuIGJ5XG4gIC8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXG4gIC8vIGFuZCBwcmV2ZW50RGVmYXVsdC1pbmcgdGhlIGV2ZW50IGluIHRoYXQgaGFuZGxlci5cbiAgZnVuY3Rpb24gc2lnbmFsRE9NRXZlbnQoY20sIGUsIG92ZXJyaWRlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICB7IGUgPSB7dHlwZTogZSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9fTsgfVxuICAgIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSk7XG4gICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmNvZGVtaXJyb3JJZ25vcmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XG4gICAgdmFyIGFyciA9IGNtLl9oYW5kbGVycyAmJiBjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHk7XG4gICAgaWYgKCFhcnIpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgeyBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXG4gICAgICB7IHNldC5wdXNoKGFycltpXSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIEFkZCBvbiBhbmQgb2ZmIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSwgdG8gbWFrZVxuICAvLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cbiAgZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XG4gICAgY3Rvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBmKSB7b24odGhpcywgdHlwZSwgZik7fTtcbiAgICBjdG9yLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmKSB7b2ZmKHRoaXMsIHR5cGUsIGYpO307XG4gIH1cblxuICAvLyBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBzdGlsbCBzdXBwb3J0IGp1cmFzc2ljIElFIHZlcnNpb25zLCBzb21lXG4gIC8vIGNvbXBhdGliaWxpdHkgd3JhcHBlcnMgYXJlIG5lZWRlZC5cblxuICBmdW5jdGlvbiBlX3ByZXZlbnREZWZhdWx0KGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICBlbHNlIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XG4gIH1cbiAgZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSkge1xuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9XG4gICAgZWxzZSB7IGUuY2FuY2VsQnViYmxlID0gdHJ1ZTsgfVxuICB9XG4gIGZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XG4gICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gZS5kZWZhdWx0UHJldmVudGVkIDogZS5yZXR1cm5WYWx1ZSA9PSBmYWxzZVxuICB9XG4gIGZ1bmN0aW9uIGVfc3RvcChlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSk7fVxuXG4gIGZ1bmN0aW9uIGVfdGFyZ2V0KGUpIHtyZXR1cm4gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50fVxuICBmdW5jdGlvbiBlX2J1dHRvbihlKSB7XG4gICAgdmFyIGIgPSBlLndoaWNoO1xuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgIGlmIChlLmJ1dHRvbiAmIDEpIHsgYiA9IDE7IH1cbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgMikgeyBiID0gMzsgfVxuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiA0KSB7IGIgPSAyOyB9XG4gICAgfVxuICAgIGlmIChtYWMgJiYgZS5jdHJsS2V5ICYmIGIgPT0gMSkgeyBiID0gMzsgfVxuICAgIHJldHVybiBiXG4gIH1cblxuICAvLyBEZXRlY3QgZHJhZy1hbmQtZHJvcFxuICB2YXIgZHJhZ0FuZERyb3AgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXG4gICAgLy8gY291bGRuJ3QgZ2V0IGl0IHRvIHdvcmsgeWV0LlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBkaXYgPSBlbHQoJ2RpdicpO1xuICAgIHJldHVybiBcImRyYWdnYWJsZVwiIGluIGRpdiB8fCBcImRyYWdEcm9wXCIgaW4gZGl2XG4gIH0oKTtcblxuICB2YXIgendzcFN1cHBvcnRlZDtcbiAgZnVuY3Rpb24gemVyb1dpZHRoRWxlbWVudChtZWFzdXJlKSB7XG4gICAgaWYgKHp3c3BTdXBwb3J0ZWQgPT0gbnVsbCkge1xuICAgICAgdmFyIHRlc3QgPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKTtcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKTtcbiAgICAgIGlmIChtZWFzdXJlLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0ICE9IDApXG4gICAgICAgIHsgendzcFN1cHBvcnRlZCA9IHRlc3Qub2Zmc2V0V2lkdGggPD0gMSAmJiB0ZXN0Lm9mZnNldEhlaWdodCA+IDIgJiYgIShpZSAmJiBpZV92ZXJzaW9uIDwgOCk7IH1cbiAgICB9XG4gICAgdmFyIG5vZGUgPSB6d3NwU3VwcG9ydGVkID8gZWx0KFwic3BhblwiLCBcIlxcdTIwMGJcIikgOlxuICAgICAgZWx0KFwic3BhblwiLCBcIlxcdTAwYTBcIiwgbnVsbCwgXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxcHg7IG1hcmdpbi1yaWdodDogLTFweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcIik7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIC8vIEZlYXR1cmUtZGV0ZWN0IElFJ3MgY3J1bW15IGNsaWVudCByZWN0IHJlcG9ydGluZyBmb3IgYmlkaSB0ZXh0XG4gIHZhciBiYWRCaWRpUmVjdHM7XG4gIGZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZEJpZGlSZWN0cyAhPSBudWxsKSB7IHJldHVybiBiYWRCaWRpUmVjdHMgfVxuICAgIHZhciB0eHQgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSk7XG4gICAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlbW92ZUNoaWxkcmVuKG1lYXN1cmUpO1xuICAgIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkgeyByZXR1cm4gZmFsc2UgfSAvLyBTYWZhcmkgcmV0dXJucyBudWxsIGluIHNvbWUgY2FzZXMgKCMyNzgwKVxuICAgIHJldHVybiBiYWRCaWRpUmVjdHMgPSAocjEucmlnaHQgLSByMC5yaWdodCA8IDMpXG4gIH1cblxuICAvLyBTZWUgaWYgXCJcIi5zcGxpdCBpcyB0aGUgYnJva2VuIElFIHZlcnNpb24sIGlmIHNvLCBwcm92aWRlIGFuXG4gIC8vIGFsdGVybmF0aXZlIHdheSB0byBzcGxpdCBsaW5lcy5cbiAgdmFyIHNwbGl0TGluZXNBdXRvID0gXCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGg7XG4gICAgd2hpbGUgKHBvcyA8PSBsKSB7XG4gICAgICB2YXIgbmwgPSBzdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgaWYgKG5sID09IC0xKSB7IG5sID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgICAgdmFyIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zLCBzdHJpbmcuY2hhckF0KG5sIC0gMSkgPT0gXCJcXHJcIiA/IG5sIC0gMSA6IG5sKTtcbiAgICAgIHZhciBydCA9IGxpbmUuaW5kZXhPZihcIlxcclwiKTtcbiAgICAgIGlmIChydCAhPSAtMSkge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIHJ0KSk7XG4gICAgICAgIHBvcyArPSBydCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgcG9zID0gbmwgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcuc3BsaXQoL1xcclxcbj98XFxuLyk7IH07XG5cbiAgdmFyIGhhc1NlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyBmdW5jdGlvbiAodGUpIHtcbiAgICB0cnkgeyByZXR1cm4gdGUuc2VsZWN0aW9uU3RhcnQgIT0gdGUuc2VsZWN0aW9uRW5kIH1cbiAgICBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9XG4gIH0gOiBmdW5jdGlvbiAodGUpIHtcbiAgICB2YXIgcmFuZ2U7XG4gICAgdHJ5IHtyYW5nZSA9IHRlLm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7fVxuICAgIGNhdGNoKGUpIHt9XG4gICAgaWYgKCFyYW5nZSB8fCByYW5nZS5wYXJlbnRFbGVtZW50KCkgIT0gdGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gcmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgcmFuZ2UpICE9IDBcbiAgfTtcblxuICB2YXIgaGFzQ29weUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IGVsdChcImRpdlwiKTtcbiAgICBpZiAoXCJvbmNvcHlcIiBpbiBlKSB7IHJldHVybiB0cnVlIH1cbiAgICBlLnNldEF0dHJpYnV0ZShcIm9uY29weVwiLCBcInJldHVybjtcIik7XG4gICAgcmV0dXJuIHR5cGVvZiBlLm9uY29weSA9PSBcImZ1bmN0aW9uXCJcbiAgfSkoKTtcblxuICB2YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsO1xuICBmdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZFpvb21lZFJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZFpvb21lZFJlY3RzIH1cbiAgICB2YXIgbm9kZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgXCJ4XCIpKTtcbiAgICB2YXIgbm9ybWFsID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgZnJvbVJhbmdlID0gcmFuZ2Uobm9kZSwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxXG4gIH1cblxuICAvLyBLbm93biBtb2RlcywgYnkgbmFtZSBhbmQgYnkgTUlNRVxuICB2YXIgbW9kZXMgPSB7fSwgbWltZU1vZGVzID0ge307XG5cbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcbiAgLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXG4gIGZ1bmN0aW9uIGRlZmluZU1vZGUobmFtZSwgbW9kZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcbiAgICAgIHsgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpOyB9XG4gICAgbW9kZXNbbmFtZV0gPSBtb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lTUlNRShtaW1lLCBzcGVjKSB7XG4gICAgbWltZU1vZGVzW21pbWVdID0gc3BlYztcbiAgfVxuXG4gIC8vIEdpdmVuIGEgTUlNRSB0eXBlLCBhIHtuYW1lLCAuLi5vcHRpb25zfSBjb25maWcgb2JqZWN0LCBvciBhIG5hbWVcbiAgLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXG4gIGZ1bmN0aW9uIHJlc29sdmVNb2RlKHNwZWMpIHtcbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpIHtcbiAgICAgIHNwZWMgPSBtaW1lTW9kZXNbc3BlY107XG4gICAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV07XG4gICAgICBpZiAodHlwZW9mIGZvdW5kID09IFwic3RyaW5nXCIpIHsgZm91bmQgPSB7bmFtZTogZm91bmR9OyB9XG4gICAgICBzcGVjID0gY3JlYXRlT2JqKGZvdW5kLCBzcGVjKTtcbiAgICAgIHNwZWMubmFtZSA9IGZvdW5kLm5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24veG1sXCIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwranNvbiQvLnRlc3Qoc3BlYykpIHtcbiAgICAgIHJldHVybiByZXNvbHZlTW9kZShcImFwcGxpY2F0aW9uL2pzb25cIilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIpIHsgcmV0dXJuIHtuYW1lOiBzcGVjfSB9XG4gICAgZWxzZSB7IHJldHVybiBzcGVjIHx8IHtuYW1lOiBcIm51bGxcIn0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIHNwZWMgKGFueXRoaW5nIHRoYXQgcmVzb2x2ZU1vZGUgYWNjZXB0cyksIGZpbmQgYW5kXG4gIC8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxuICBmdW5jdGlvbiBnZXRNb2RlKG9wdGlvbnMsIHNwZWMpIHtcbiAgICBzcGVjID0gcmVzb2x2ZU1vZGUoc3BlYyk7XG4gICAgdmFyIG1mYWN0b3J5ID0gbW9kZXNbc3BlYy5uYW1lXTtcbiAgICBpZiAoIW1mYWN0b3J5KSB7IHJldHVybiBnZXRNb2RlKG9wdGlvbnMsIFwidGV4dC9wbGFpblwiKSB9XG4gICAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKTtcbiAgICBpZiAobW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRzKSB7XG4gICAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmIChtb2RlT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7IG1vZGVPYmpbXCJfXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF07IH1cbiAgICAgICAgbW9kZU9ialtwcm9wXSA9IGV4dHNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIG1vZGVPYmoubmFtZSA9IHNwZWMubmFtZTtcbiAgICBpZiAoc3BlYy5oZWxwZXJUeXBlKSB7IG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTsgfVxuICAgIGlmIChzcGVjLm1vZGVQcm9wcykgeyBmb3IgKHZhciBwcm9wJDEgaW4gc3BlYy5tb2RlUHJvcHMpXG4gICAgICB7IG1vZGVPYmpbcHJvcCQxXSA9IHNwZWMubW9kZVByb3BzW3Byb3AkMV07IH0gfVxuXG4gICAgcmV0dXJuIG1vZGVPYmpcbiAgfVxuXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cbiAgLy8gb3V0c2lkZSB0aGUgYWN0dWFsIG1vZGUgZGVmaW5pdGlvbi5cbiAgdmFyIG1vZGVFeHRlbnNpb25zID0ge307XG4gIGZ1bmN0aW9uIGV4dGVuZE1vZGUobW9kZSwgcHJvcGVydGllcykge1xuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KTtcbiAgICBjb3B5T2JqKHByb3BlcnRpZXMsIGV4dHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weVN0YXRlKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB0cnVlKSB7IHJldHVybiBzdGF0ZSB9XG4gICAgaWYgKG1vZGUuY29weVN0YXRlKSB7IHJldHVybiBtb2RlLmNvcHlTdGF0ZShzdGF0ZSkgfVxuICAgIHZhciBuc3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XG4gICAgICB2YXIgdmFsID0gc3RhdGVbbl07XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgdmFsID0gdmFsLmNvbmNhdChbXSk7IH1cbiAgICAgIG5zdGF0ZVtuXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIG5zdGF0ZVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIGFuZCBhIHN0YXRlIChmb3IgdGhhdCBtb2RlKSwgZmluZCB0aGUgaW5uZXIgbW9kZSBhbmRcbiAgLy8gc3RhdGUgYXQgdGhlIHBvc2l0aW9uIHRoYXQgdGhlIHN0YXRlIHJlZmVycyB0by5cbiAgZnVuY3Rpb24gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKSB7XG4gICAgdmFyIGluZm87XG4gICAgd2hpbGUgKG1vZGUuaW5uZXJNb2RlKSB7XG4gICAgICBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpO1xuICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSB7IGJyZWFrIH1cbiAgICAgIHN0YXRlID0gaW5mby5zdGF0ZTtcbiAgICAgIG1vZGUgPSBpbmZvLm1vZGU7XG4gICAgfVxuICAgIHJldHVybiBpbmZvIHx8IHttb2RlOiBtb2RlLCBzdGF0ZTogc3RhdGV9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xuICAgIHJldHVybiBtb2RlLnN0YXJ0U3RhdGUgPyBtb2RlLnN0YXJ0U3RhdGUoYTEsIGEyKSA6IHRydWVcbiAgfVxuXG4gIC8vIFNUUklORyBTVFJFQU1cblxuICAvLyBGZWQgdG8gdGhlIG1vZGUgcGFyc2VycywgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byBtYWtlXG4gIC8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cblxuICB2YXIgU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplLCBsaW5lT3JhY2xlKSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplIHx8IDg7XG4gICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmxpbmVPcmFjbGUgPSBsaW5lT3JhY2xlO1xuICB9O1xuXG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZW9sID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGh9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNvbCA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5saW5lU3RhcnR9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKSB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICB2YXIgb2s7XG4gICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKSB7IG9rID0gY2ggPT0gbWF0Y2g7IH1cbiAgICBlbHNlIHsgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTsgfVxuICAgIGlmIChvaykgeysrdGhpcy5wb3M7IHJldHVybiBjaH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRXaGlsZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpe31cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKSB7ICsrdGhpcy5wb3M7IH1cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUb0VuZCA9IGZ1bmN0aW9uICgpIHt0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUbyA9IGZ1bmN0aW9uIChjaCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhY2tVcCA9IGZ1bmN0aW9uIChuKSB7dGhpcy5wb3MgLT0gbjt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZSAtICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpIC1cbiAgICAgICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyOyB9O1xuICAgICAgdmFyIHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApIHsgcmV0dXJuIG51bGwgfVxuICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDsgfVxuICAgICAgcmV0dXJuIG1hdGNoXG4gICAgfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5oaWRlRmlyc3RDaGFycyA9IGZ1bmN0aW9uIChuLCBpbm5lcikge1xuICAgIHRoaXMubGluZVN0YXJ0ICs9IG47XG4gICAgdHJ5IHsgcmV0dXJuIGlubmVyKCkgfVxuICAgIGZpbmFsbHkgeyB0aGlzLmxpbmVTdGFydCAtPSBuOyB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubG9va0FoZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmxvb2tBaGVhZChuKVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmJhc2VUb2tlbih0aGlzLnBvcylcbiAgfTtcblxuICAvLyBGaW5kIHRoZSBsaW5lIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcbiAgICBuIC09IGRvYy5maXJzdDtcbiAgICBpZiAobiA8IDAgfHwgbiA+PSBkb2Muc2l6ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBsaW5lIFwiICsgKG4gKyBkb2MuZmlyc3QpICsgXCIgaW4gdGhlIGRvY3VtZW50LlwiKSB9XG4gICAgdmFyIGNodW5rID0gZG9jO1xuICAgIHdoaWxlICghY2h1bmsubGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAobiA8IHN6KSB7IGNodW5rID0gY2hpbGQ7IGJyZWFrIH1cbiAgICAgICAgbiAtPSBzejtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rLmxpbmVzW25dXG4gIH1cblxuICAvLyBHZXQgdGhlIHBhcnQgb2YgYSBkb2N1bWVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMsIGFzIGFuIGFycmF5IG9mXG4gIC8vIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG91dCA9IFtdLCBuID0gc3RhcnQubGluZTtcbiAgICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgdGV4dCA9IGxpbmUudGV4dDtcbiAgICAgIGlmIChuID09IGVuZC5saW5lKSB7IHRleHQgPSB0ZXh0LnNsaWNlKDAsIGVuZC5jaCk7IH1cbiAgICAgIGlmIChuID09IHN0YXJ0LmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2Uoc3RhcnQuY2gpOyB9XG4gICAgICBvdXQucHVzaCh0ZXh0KTtcbiAgICAgICsrbjtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgLy8gR2V0IHRoZSBsaW5lcyBiZXR3ZWVuIGZyb20gYW5kIHRvLCBhcyBhcnJheSBvZiBzdHJpbmdzLlxuICBmdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGRvYy5pdGVyKGZyb20sIHRvLCBmdW5jdGlvbiAobGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpOyB9KTsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIHRydXRoeSB2YWx1ZVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgcHJvcGFnYXRpbmcgdGhlIGhlaWdodCBjaGFuZ2VcbiAgLy8gdXB3YXJkcyB0byBwYXJlbnQgbm9kZXMuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgaGVpZ2h0KSB7XG4gICAgdmFyIGRpZmYgPSBoZWlnaHQgLSBsaW5lLmhlaWdodDtcbiAgICBpZiAoZGlmZikgeyBmb3IgKHZhciBuID0gbGluZTsgbjsgbiA9IG4ucGFyZW50KSB7IG4uaGVpZ2h0ICs9IGRpZmY7IH0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBsaW5lIG9iamVjdCwgZmluZCBpdHMgbGluZSBudW1iZXIgYnkgd2Fsa2luZyB1cCB0aHJvdWdoXG4gIC8vIGl0cyBwYXJlbnQgbGlua3MuXG4gIGZ1bmN0aW9uIGxpbmVObyhsaW5lKSB7XG4gICAgaWYgKGxpbmUucGFyZW50ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XG4gICAgZm9yICh2YXIgY2h1bmsgPSBjdXIucGFyZW50OyBjaHVuazsgY3VyID0gY2h1bmssIGNodW5rID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xuICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSB7IGJyZWFrIH1cbiAgICAgICAgbm8gKz0gY2h1bmsuY2hpbGRyZW5baV0uY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBubyArIGN1ci5maXJzdFxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcbiAgLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXG4gIGZ1bmN0aW9uIGxpbmVBdEhlaWdodChjaHVuaywgaCkge1xuICAgIHZhciBuID0gY2h1bmsuZmlyc3Q7XG4gICAgb3V0ZXI6IGRvIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baSQxXSwgY2ggPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgIGlmIChoIDwgY2gpIHsgY2h1bmsgPSBjaGlsZDsgY29udGludWUgb3V0ZXIgfVxuICAgICAgICBoIC09IGNoO1xuICAgICAgICBuICs9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5cbiAgICB9IHdoaWxlICghY2h1bmsubGluZXMpXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV0sIGxoID0gbGluZS5oZWlnaHQ7XG4gICAgICBpZiAoaCA8IGxoKSB7IGJyZWFrIH1cbiAgICAgIGggLT0gbGg7XG4gICAgfVxuICAgIHJldHVybiBuICsgaVxuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lKGRvYywgbCkge3JldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemV9XG5cbiAgZnVuY3Rpb24gbGluZU51bWJlckZvcihvcHRpb25zLCBpKSB7XG4gICAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSlcbiAgfVxuXG4gIC8vIEEgUG9zIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRleHQuXG4gIGZ1bmN0aW9uIFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB7XG4gICAgaWYgKCBzdGlja3kgPT09IHZvaWQgMCApIHN0aWNreSA9IG51bGw7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zKSkgeyByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB9XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNoID0gY2g7XG4gICAgdGhpcy5zdGlja3kgPSBzdGlja3k7XG4gIH1cblxuICAvLyBDb21wYXJlIHR3byBwb3NpdGlvbnMsIHJldHVybiAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBhIG5lZ2F0aXZlXG4gIC8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZSB8fCBhLmNoIC0gYi5jaCB9XG5cbiAgZnVuY3Rpb24gZXF1YWxDdXJzb3JQb3MoYSwgYikgeyByZXR1cm4gYS5zdGlja3kgPT0gYi5zdGlja3kgJiYgY21wKGEsIGIpID09IDAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlQb3MoeCkge3JldHVybiBQb3MoeC5saW5lLCB4LmNoKX1cbiAgZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYSB9XG4gIGZ1bmN0aW9uIG1pblBvcyhhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGIgfVxuXG4gIC8vIE1vc3Qgb2YgdGhlIGV4dGVybmFsIEFQSSBjbGlwcyBnaXZlbiBwb3NpdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXlcbiAgLy8gYWN0dWFsbHkgZXhpc3Qgd2l0aGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoZG9jLCBuKSB7cmV0dXJuIE1hdGgubWF4KGRvYy5maXJzdCwgTWF0aC5taW4obiwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSl9XG4gIGZ1bmN0aW9uIGNsaXBQb3MoZG9jLCBwb3MpIHtcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHsgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApIH1cbiAgICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAocG9zLmxpbmUgPiBsYXN0KSB7IHJldHVybiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKSB9XG4gICAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpXG4gIH1cbiAgZnVuY3Rpb24gY2xpcFRvTGVuKHBvcywgbGluZWxlbikge1xuICAgIHZhciBjaCA9IHBvcy5jaDtcbiAgICBpZiAoY2ggPT0gbnVsbCB8fCBjaCA+IGxpbmVsZW4pIHsgcmV0dXJuIFBvcyhwb3MubGluZSwgbGluZWxlbikgfVxuICAgIGVsc2UgaWYgKGNoIDwgMCkgeyByZXR1cm4gUG9zKHBvcy5saW5lLCAwKSB9XG4gICAgZWxzZSB7IHJldHVybiBwb3MgfVxuICB9XG4gIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gY2xpcFBvcyhkb2MsIGFycmF5W2ldKTsgfVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIHZhciBTYXZlZENvbnRleHQgPSBmdW5jdGlvbihzdGF0ZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICB9O1xuXG4gIHZhciBDb250ZXh0ID0gZnVuY3Rpb24oZG9jLCBzdGF0ZSwgbGluZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5tYXhMb29rQWhlYWQgPSBsb29rQWhlYWQgfHwgMDtcbiAgICB0aGlzLmJhc2VUb2tlbnMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRva2VuUG9zID0gMTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZSh0aGlzLmxpbmUgKyBuKTtcbiAgICBpZiAobGluZSAhPSBudWxsICYmIG4gPiB0aGlzLm1heExvb2tBaGVhZCkgeyB0aGlzLm1heExvb2tBaGVhZCA9IG47IH1cbiAgICByZXR1cm4gbGluZVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKCF0aGlzLmJhc2VUb2tlbnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHdoaWxlICh0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3NdIDw9IG4pXG4gICAgICB7IHRoaXMuYmFzZVRva2VuUG9zICs9IDI7IH1cbiAgICB2YXIgdHlwZSA9IHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvcyArIDFdO1xuICAgIHJldHVybiB7dHlwZTogdHlwZSAmJiB0eXBlLnJlcGxhY2UoLyggfF4pb3ZlcmxheSAuKi8sIFwiXCIpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zXSAtIG59XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUubmV4dExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saW5lKys7XG4gICAgaWYgKHRoaXMubWF4TG9va0FoZWFkID4gMCkgeyB0aGlzLm1heExvb2tBaGVhZC0tOyB9XG4gIH07XG5cbiAgQ29udGV4dC5mcm9tU2F2ZWQgPSBmdW5jdGlvbiAoZG9jLCBzYXZlZCwgbGluZSkge1xuICAgIGlmIChzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dClcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZC5zdGF0ZSksIGxpbmUsIHNhdmVkLmxvb2tBaGVhZCkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZCksIGxpbmUpIH1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGNvcHkpIHtcbiAgICB2YXIgc3RhdGUgPSBjb3B5ICE9PSBmYWxzZSA/IGNvcHlTdGF0ZSh0aGlzLmRvYy5tb2RlLCB0aGlzLnN0YXRlKSA6IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIHRoaXMubWF4TG9va0FoZWFkID4gMCA/IG5ldyBTYXZlZENvbnRleHQoc3RhdGUsIHRoaXMubWF4TG9va0FoZWFkKSA6IHN0YXRlXG4gIH07XG5cblxuICAvLyBDb21wdXRlIGEgc3R5bGUgYXJyYXkgKGFuIGFycmF5IHN0YXJ0aW5nIHdpdGggYSBtb2RlIGdlbmVyYXRpb25cbiAgLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxuICAvLyBzdHlsZSBzdHJpbmdzKSwgd2hpY2ggaXMgdXNlZCB0byBoaWdobGlnaHQgdGhlIHRva2VucyBvbiB0aGVcbiAgLy8gbGluZS5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCwgZm9yY2VUb0VuZCkge1xuICAgIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcbiAgICAvLyBtb2RlL292ZXJsYXlzIHRoYXQgaXQgaXMgYmFzZWQgb24gKGZvciBlYXN5IGludmFsaWRhdGlvbikuXG4gICAgdmFyIHN0ID0gW2NtLnN0YXRlLm1vZGVHZW5dLCBsaW5lQ2xhc3NlcyA9IHt9O1xuICAgIC8vIENvbXB1dGUgdGhlIGJhc2UgYXJyYXkgb2Ygc3R5bGVzXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHsgcmV0dXJuIHN0LnB1c2goZW5kLCBzdHlsZSk7IH0sXG4gICAgICAgICAgICBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCk7XG4gICAgdmFyIHN0YXRlID0gY29udGV4dC5zdGF0ZTtcblxuICAgIC8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBvICkge1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5zID0gc3Q7XG4gICAgICB2YXIgb3ZlcmxheSA9IGNtLnN0YXRlLm92ZXJsYXlzW29dLCBpID0gMSwgYXQgPSAwO1xuICAgICAgY29udGV4dC5zdGF0ZSA9IHRydWU7XG4gICAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIG92ZXJsYXkubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYSB0b2tlbiBlbmQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGF0IGkgcG9pbnRzIGF0IGl0XG4gICAgICAgIHdoaWxlIChhdCA8IGVuZCkge1xuICAgICAgICAgIHZhciBpX2VuZCA9IHN0W2ldO1xuICAgICAgICAgIGlmIChpX2VuZCA+IGVuZClcbiAgICAgICAgICAgIHsgc3Quc3BsaWNlKGksIDEsIGVuZCwgc3RbaSsxXSwgaV9lbmQpOyB9XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHlsZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcbiAgICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkgLSBzdGFydCwgZW5kLCBcIm92ZXJsYXkgXCIgKyBzdHlsZSk7XG4gICAgICAgICAgaSA9IHN0YXJ0ICsgMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKDsgc3RhcnQgPCBpOyBzdGFydCArPSAyKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gc3Rbc3RhcnQrMV07XG4gICAgICAgICAgICBzdFtzdGFydCsxXSA9IChjdXIgPyBjdXIgKyBcIiBcIiA6IFwiXCIpICsgXCJvdmVybGF5IFwiICsgc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBsaW5lQ2xhc3Nlcyk7XG4gICAgICBjb250ZXh0LnN0YXRlID0gc3RhdGU7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBudWxsO1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5Qb3MgPSAxO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKSBsb29wKCBvICk7XG5cbiAgICByZXR1cm4ge3N0eWxlczogc3QsIGNsYXNzZXM6IGxpbmVDbGFzc2VzLmJnQ2xhc3MgfHwgbGluZUNsYXNzZXMudGV4dENsYXNzID8gbGluZUNsYXNzZXMgOiBudWxsfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgdXBkYXRlRnJvbnRpZXIpIHtcbiAgICBpZiAoIWxpbmUuc3R5bGVzIHx8IGxpbmUuc3R5bGVzWzBdICE9IGNtLnN0YXRlLm1vZGVHZW4pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIHZhciByZXNldFN0YXRlID0gbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoICYmIGNvcHlTdGF0ZShjbS5kb2MubW9kZSwgY29udGV4dC5zdGF0ZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCk7XG4gICAgICBpZiAocmVzZXRTdGF0ZSkgeyBjb250ZXh0LnN0YXRlID0gcmVzZXRTdGF0ZTsgfVxuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gY29udGV4dC5zYXZlKCFyZXNldFN0YXRlKTtcbiAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcbiAgICAgIGlmIChyZXN1bHQuY2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzOyB9XG4gICAgICBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7IH1cbiAgICAgIGlmICh1cGRhdGVGcm9udGllciA9PT0gY20uZG9jLmhpZ2hsaWdodEZyb250aWVyKVxuICAgICAgICB7IGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1heChjbS5kb2MubW9kZUZyb250aWVyLCArK2NtLmRvYy5oaWdobGlnaHRGcm9udGllcik7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmUuc3R5bGVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0QmVmb3JlKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSB7IHJldHVybiBuZXcgQ29udGV4dChkb2MsIHRydWUsIG4pIH1cbiAgICB2YXIgc3RhcnQgPSBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKTtcbiAgICB2YXIgc2F2ZWQgPSBzdGFydCA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgc3RhcnQgLSAxKS5zdGF0ZUFmdGVyO1xuICAgIHZhciBjb250ZXh0ID0gc2F2ZWQgPyBDb250ZXh0LmZyb21TYXZlZChkb2MsIHNhdmVkLCBzdGFydCkgOiBuZXcgQ29udGV4dChkb2MsIHN0YXJ0U3RhdGUoZG9jLm1vZGUpLCBzdGFydCk7XG5cbiAgICBkb2MuaXRlcihzdGFydCwgbiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpO1xuICAgICAgdmFyIHBvcyA9IGNvbnRleHQubGluZTtcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHBvcyA9PSBuIC0gMSB8fCBwb3MgJSA1ID09IDAgfHwgcG9zID49IGRpc3BsYXkudmlld0Zyb20gJiYgcG9zIDwgZGlzcGxheS52aWV3VG8gPyBjb250ZXh0LnNhdmUoKSA6IG51bGw7XG4gICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgfSk7XG4gICAgaWYgKHByZWNpc2UpIHsgZG9jLm1vZGVGcm9udGllciA9IGNvbnRleHQubGluZTsgfVxuICAgIHJldHVybiBjb250ZXh0XG4gIH1cblxuICAvLyBMaWdodHdlaWdodCBmb3JtIG9mIGhpZ2hsaWdodCAtLSBwcm9jZWVkIG92ZXIgdGhpcyBsaW5lIGFuZFxuICAvLyB1cGRhdGUgc3RhdGUsIGJ1dCBkb24ndCBzYXZlIGEgc3R5bGUgYXJyYXkuIFVzZWQgZm9yIGxpbmVzIHRoYXRcbiAgLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxuICBmdW5jdGlvbiBwcm9jZXNzTGluZShjbSwgdGV4dCwgY29udGV4dCwgc3RhcnRBdCkge1xuICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KTtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zID0gc3RhcnRBdCB8fCAwO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIHsgY2FsbEJsYW5rTGluZShtb2RlLCBjb250ZXh0LnN0YXRlKTsgfVxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xuICAgIGlmIChtb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gbW9kZS5ibGFua0xpbmUoc3RhdGUpIH1cbiAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiB9XG4gICAgdmFyIGlubmVyID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKTtcbiAgICBpZiAoaW5uZXIubW9kZS5ibGFua0xpbmUpIHsgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKSB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGlmIChpbm5lcikgeyBpbm5lclswXSA9IGlubmVyTW9kZShtb2RlLCBzdGF0ZSkubW9kZTsgfVxuICAgICAgdmFyIHN0eWxlID0gbW9kZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSB7IHJldHVybiBzdHlsZSB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgXCIgKyBtb2RlLm5hbWUgKyBcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpXG4gIH1cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbihzdHJlYW0sIHR5cGUsIHN0YXRlKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0cmVhbS5zdGFydDsgdGhpcy5lbmQgPSBzdHJlYW0ucG9zO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgZm9yIGdldFRva2VuQXQgYW5kIGdldExpbmVUb2tlbnNcbiAgZnVuY3Rpb24gdGFrZVRva2VuKGNtLCBwb3MsIHByZWNpc2UsIGFzQXJyYXkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBtb2RlID0gZG9jLm1vZGUsIHN0eWxlO1xuICAgIHBvcyA9IGNsaXBQb3MoZG9jLCBwb3MpO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIHBvcy5saW5lLCBwcmVjaXNlKTtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHRva2VucztcbiAgICBpZiAoYXNBcnJheSkgeyB0b2tlbnMgPSBbXTsgfVxuICAgIHdoaWxlICgoYXNBcnJheSB8fCBzdHJlYW0ucG9zIDwgcG9zLmNoKSAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIGlmIChhc0FycmF5KSB7IHRva2Vucy5wdXNoKG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb3B5U3RhdGUoZG9jLm1vZGUsIGNvbnRleHQuc3RhdGUpKSk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFzQXJyYXkgPyB0b2tlbnMgOiBuZXcgVG9rZW4oc3RyZWFtLCBzdHlsZSwgY29udGV4dC5zdGF0ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RMaW5lQ2xhc3Nlcyh0eXBlLCBvdXRwdXQpIHtcbiAgICBpZiAodHlwZSkgeyBmb3IgKDs7KSB7XG4gICAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXHMrKWxpbmUtKGJhY2tncm91bmQtKT8oXFxTKykvKTtcbiAgICAgIGlmICghbGluZUNsYXNzKSB7IGJyZWFrIH1cbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGxpbmVDbGFzcy5pbmRleCkgKyB0eXBlLnNsaWNlKGxpbmVDbGFzcy5pbmRleCArIGxpbmVDbGFzc1swXS5sZW5ndGgpO1xuICAgICAgdmFyIHByb3AgPSBsaW5lQ2xhc3NbMV0gPyBcImJnQ2xhc3NcIiA6IFwidGV4dENsYXNzXCI7XG4gICAgICBpZiAob3V0cHV0W3Byb3BdID09IG51bGwpXG4gICAgICAgIHsgb3V0cHV0W3Byb3BdID0gbGluZUNsYXNzWzJdOyB9XG4gICAgICBlbHNlIGlmICghKG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiICsgbGluZUNsYXNzWzJdICsgXCIoPzokfFxcXFxzKVwiKSkudGVzdChvdXRwdXRbcHJvcF0pKVxuICAgICAgICB7IG91dHB1dFtwcm9wXSArPSBcIiBcIiArIGxpbmVDbGFzc1syXTsgfVxuICAgIH0gfVxuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIG1vZGUncyBwYXJzZXIgb3ZlciBhIGxpbmUsIGNhbGxpbmcgZiBmb3IgZWFjaCB0b2tlbi5cbiAgZnVuY3Rpb24gcnVuTW9kZShjbSwgdGV4dCwgbW9kZSwgY29udGV4dCwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcbiAgICB2YXIgZmxhdHRlblNwYW5zID0gbW9kZS5mbGF0dGVuU3BhbnM7XG4gICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7IGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zOyB9XG4gICAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKHRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHN0eWxlO1xuICAgIHZhciBpbm5lciA9IGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzICYmIFtudWxsXTtcbiAgICBpZiAodGV4dCA9PSBcIlwiKSB7IGV4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpLCBsaW5lQ2xhc3Nlcyk7IH1cbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xuICAgICAgICBmbGF0dGVuU3BhbnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZvcmNlVG9FbmQpIHsgcHJvY2Vzc0xpbmUoY20sIHRleHQsIGNvbnRleHQsIHN0cmVhbS5wb3MpOyB9XG4gICAgICAgIHN0cmVhbS5wb3MgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgc3R5bGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgY29udGV4dC5zdGF0ZSwgaW5uZXIpLCBsaW5lQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgdmFyIG1OYW1lID0gaW5uZXJbMF0ubmFtZTtcbiAgICAgICAgaWYgKG1OYW1lKSB7IHN0eWxlID0gXCJtLVwiICsgKHN0eWxlID8gbU5hbWUgKyBcIiBcIiArIHN0eWxlIDogbU5hbWUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xuICAgICAgICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0uc3RhcnQpIHtcbiAgICAgICAgICBjdXJTdGFydCA9IE1hdGgubWluKHN0cmVhbS5zdGFydCwgY3VyU3RhcnQgKyA1MDAwKTtcbiAgICAgICAgICBmKGN1clN0YXJ0LCBjdXJTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyU3R5bGUgPSBzdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5wb3MpIHtcbiAgICAgIC8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDRcbiAgICAgIC8vIGNoYXJhY3RlcnMsIGFuZCByZXR1cm5zIGluYWNjdXJhdGUgbWVhc3VyZW1lbnRzIGluIG5vZGVzXG4gICAgICAvLyBzdGFydGluZyBhcm91bmQgNTAwMCBjaGFycy5cbiAgICAgIHZhciBwb3MgPSBNYXRoLm1pbihzdHJlYW0ucG9zLCBjdXJTdGFydCArIDUwMDApO1xuICAgICAgZihwb3MsIGN1clN0eWxlKTtcbiAgICAgIGN1clN0YXJ0ID0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xuICAvLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXG4gIC8vIHZhbGlkIHN0YXRlLiBJZiB0aGF0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBsaW5lIHdpdGggdGhlXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXG4gIC8vIHBhcnNlIGNvcnJlY3RseS5cbiAgZnVuY3Rpb24gZmluZFN0YXJ0TGluZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKTtcbiAgICBmb3IgKHZhciBzZWFyY2ggPSBuOyBzZWFyY2ggPiBsaW07IC0tc2VhcmNoKSB7XG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgeyByZXR1cm4gZG9jLmZpcnN0IH1cbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpLCBhZnRlciA9IGxpbmUuc3RhdGVBZnRlcjtcbiAgICAgIGlmIChhZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoICsgKGFmdGVyIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0ID8gYWZ0ZXIubG9va0FoZWFkIDogMCkgPD0gZG9jLm1vZGVGcm9udGllcikpXG4gICAgICAgIHsgcmV0dXJuIHNlYXJjaCB9XG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XG4gICAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxO1xuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJlYXRGcm9udGllcihkb2MsIG4pIHtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5taW4oZG9jLm1vZGVGcm9udGllciwgbik7XG4gICAgaWYgKGRvYy5oaWdobGlnaHRGcm9udGllciA8IG4gLSAxMCkgeyByZXR1cm4gfVxuICAgIHZhciBzdGFydCA9IGRvYy5maXJzdDtcbiAgICBmb3IgKHZhciBsaW5lID0gbiAtIDE7IGxpbmUgPiBzdGFydDsgbGluZS0tKSB7XG4gICAgICB2YXIgc2F2ZWQgPSBnZXRMaW5lKGRvYywgbGluZSkuc3RhdGVBZnRlcjtcbiAgICAgIC8vIGNoYW5nZSBpcyBvbiAzXG4gICAgICAvLyBzdGF0ZSBvbiBsaW5lIDEgbG9va2VkIGFoZWFkIDIgLS0gc28gc2F3IDNcbiAgICAgIC8vIHRlc3QgMSArIDIgPCAzIHNob3VsZCBjb3ZlciB0aGlzXG4gICAgICBpZiAoc2F2ZWQgJiYgKCEoc2F2ZWQgaW5zdGFuY2VvZiBTYXZlZENvbnRleHQpIHx8IGxpbmUgKyBzYXZlZC5sb29rQWhlYWQgPCBuKSkge1xuICAgICAgICBzdGFydCA9IGxpbmUgKyAxO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBNYXRoLm1pbihkb2MuaGlnaGxpZ2h0RnJvbnRpZXIsIHN0YXJ0KTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIHNvbWUgY29kZSB3aGVuIHRoZXNlIGZlYXR1cmVzIGFyZSBub3QgdXNlZC5cbiAgdmFyIHNhd1JlYWRPbmx5U3BhbnMgPSBmYWxzZSwgc2F3Q29sbGFwc2VkU3BhbnMgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZWVSZWFkT25seVNwYW5zKCkge1xuICAgIHNhd1JlYWRPbmx5U3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VlQ29sbGFwc2VkU3BhbnMoKSB7XG4gICAgc2F3Q29sbGFwc2VkU3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgLy8gVEVYVE1BUktFUiBTUEFOU1xuXG4gIGZ1bmN0aW9uIE1hcmtlZFNwYW4obWFya2VyLCBmcm9tLCB0bykge1xuICAgIHRoaXMubWFya2VyID0gbWFya2VyO1xuICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgfVxuXG4gIC8vIFNlYXJjaCBhbiBhcnJheSBvZiBzcGFucyBmb3IgYSBzcGFuIG1hdGNoaW5nIHRoZSBnaXZlbiBtYXJrZXIuXG4gIGZ1bmN0aW9uIGdldE1hcmtlZFNwYW5Gb3Ioc3BhbnMsIG1hcmtlcikge1xuICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgaWYgKHNwYW4ubWFya2VyID09IG1hcmtlcikgeyByZXR1cm4gc3BhbiB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBSZW1vdmUgYSBzcGFuIGZyb20gYW4gYXJyYXksIHJldHVybmluZyB1bmRlZmluZWQgaWYgbm8gc3BhbnMgYXJlXG4gIC8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXG4gIGZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcbiAgICB2YXIgcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoc3BhbnNbaV0gIT0gc3BhbikgeyAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSk7IH0gfVxuICAgIHJldHVybiByXG4gIH1cblxuICAvLyBBZGQgYSBzcGFuIHRvIGEgbGluZS5cbiAgZnVuY3Rpb24gYWRkTWFya2VkU3BhbihsaW5lLCBzcGFuLCBvcCkge1xuICAgIHZhciBpblRoaXNPcCA9IG9wICYmIHdpbmRvdy5XZWFrU2V0ICYmIChvcC5tYXJrZWRTcGFucyB8fCAob3AubWFya2VkU3BhbnMgPSBuZXcgV2Vha1NldCkpO1xuICAgIGlmIChpblRoaXNPcCAmJiBsaW5lLm1hcmtlZFNwYW5zICYmIGluVGhpc09wLmhhcyhsaW5lLm1hcmtlZFNwYW5zKSkge1xuICAgICAgbGluZS5tYXJrZWRTcGFucy5wdXNoKHNwYW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gbGluZS5tYXJrZWRTcGFucyA/IGxpbmUubWFya2VkU3BhbnMuY29uY2F0KFtzcGFuXSkgOiBbc3Bhbl07XG4gICAgICBpZiAoaW5UaGlzT3ApIHsgaW5UaGlzT3AuYWRkKGxpbmUubWFya2VkU3BhbnMpOyB9XG4gICAgfVxuICAgIHNwYW4ubWFya2VyLmF0dGFjaExpbmUobGluZSk7XG4gIH1cblxuICAvLyBVc2VkIGZvciB0aGUgYWxnb3JpdGhtIHRoYXQgYWRqdXN0cyBtYXJrZXJzIGZvciBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIFRoZXNlIGZ1bmN0aW9ucyBjdXQgYW4gYXJyYXkgb2Ygc3BhbnMgYXQgYSBnaXZlblxuICAvLyBjaGFyYWN0ZXIgcG9zaXRpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiByZW1haW5pbmcgY2h1bmtzIChvclxuICAvLyB1bmRlZmluZWQgaWYgbm90aGluZyByZW1haW5zKS5cbiAgZnVuY3Rpb24gbWFya2VkU3BhbnNCZWZvcmUob2xkLCBzdGFydENoLCBpc0luc2VydCkge1xuICAgIHZhciBudztcbiAgICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXI7XG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcbiAgICAgIGlmIChzdGFydHNCZWZvcmUgfHwgc3Bhbi5mcm9tID09IHN0YXJ0Q2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgIXNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gc3RhcnRDaCA6IHNwYW4udG8gPiBzdGFydENoKVxuICAgICAgICA7KG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHNwYW4uZnJvbSwgZW5kc0FmdGVyID8gbnVsbCA6IHNwYW4udG8pKTtcbiAgICAgIH1cbiAgICB9IH1cbiAgICByZXR1cm4gbndcbiAgfVxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0FmdGVyKG9sZCwgZW5kQ2gsIGlzSW5zZXJ0KSB7XG4gICAgdmFyIG53O1xuICAgIGlmIChvbGQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcbiAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gZW5kQ2ggOiBzcGFuLnRvID4gZW5kQ2gpO1xuICAgICAgaWYgKGVuZHNBZnRlciB8fCBzcGFuLmZyb20gPT0gZW5kQ2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBlbmRDaCA6IHNwYW4uZnJvbSA8IGVuZENoKVxuICAgICAgICA7KG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHN0YXJ0c0JlZm9yZSA/IG51bGwgOiBzcGFuLmZyb20gLSBlbmRDaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnRvID09IG51bGwgPyBudWxsIDogc3Bhbi50byAtIGVuZENoKSk7XG4gICAgICB9XG4gICAgfSB9XG4gICAgcmV0dXJuIG53XG4gIH1cblxuICAvLyBHaXZlbiBhIGNoYW5nZSBvYmplY3QsIGNvbXB1dGUgdGhlIG5ldyBzZXQgb2YgbWFya2VyIHNwYW5zIHRoYXRcbiAgLy8gY292ZXIgdGhlIGxpbmUgaW4gd2hpY2ggdGhlIGNoYW5nZSB0b29rIHBsYWNlLiBSZW1vdmVzIHNwYW5zXG4gIC8vIGVudGlyZWx5IHdpdGhpbiB0aGUgY2hhbmdlLCByZWNvbm5lY3RzIHNwYW5zIGJlbG9uZ2luZyB0byB0aGVcbiAgLy8gc2FtZSBtYXJrZXIgdGhhdCBhcHBlYXIgb24gYm90aCBzaWRlcyBvZiB0aGUgY2hhbmdlLCBhbmQgY3V0cyBvZmZcbiAgLy8gc3BhbnMgcGFydGlhbGx5IHdpdGhpbiB0aGUgY2hhbmdlLiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYW5cbiAgLy8gYXJyYXlzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggbGluZSBpbiAoYWZ0ZXIpIHRoZSBjaGFuZ2UuXG4gIGZ1bmN0aW9uIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlLmZ1bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFucztcbiAgICB2YXIgb2xkTGFzdCA9IGlzTGluZShkb2MsIGNoYW5nZS50by5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgIGlmICghb2xkRmlyc3QgJiYgIW9sZExhc3QpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIHN0YXJ0Q2ggPSBjaGFuZ2UuZnJvbS5jaCwgZW5kQ2ggPSBjaGFuZ2UudG8uY2gsIGlzSW5zZXJ0ID0gY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDA7XG4gICAgLy8gR2V0IHRoZSBzcGFucyB0aGF0ICdzdGljayBvdXQnIG9uIGJvdGggc2lkZXNcbiAgICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xuICAgIHZhciBsYXN0ID0gbWFya2VkU3BhbnNBZnRlcihvbGRMYXN0LCBlbmRDaCwgaXNJbnNlcnQpO1xuXG4gICAgLy8gTmV4dCwgbWVyZ2UgdGhvc2UgdHdvIGVuZHNcbiAgICB2YXIgc2FtZUxpbmUgPSBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSwgb2Zmc2V0ID0gbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoc2FtZUxpbmUgPyBzdGFydENoIDogMCk7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBmaXJzdFtpXTtcbiAgICAgICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGdldE1hcmtlZFNwYW5Gb3IobGFzdCwgc3Bhbi5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQpIHsgc3Bhbi50byA9IHN0YXJ0Q2g7IH1cbiAgICAgICAgICBlbHNlIGlmIChzYW1lTGluZSkgeyBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldDsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0KSB7XG4gICAgICAvLyBGaXggdXAgLmZyb20gaW4gbGFzdCAob3IgbW92ZSB0aGVtIGludG8gZmlyc3QgaW4gY2FzZSBvZiBzYW1lTGluZSlcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxhc3QubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICB2YXIgc3BhbiQxID0gbGFzdFtpJDFdO1xuICAgICAgICBpZiAoc3BhbiQxLnRvICE9IG51bGwpIHsgc3BhbiQxLnRvICs9IG9mZnNldDsgfVxuICAgICAgICBpZiAoc3BhbiQxLmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCQxID0gZ2V0TWFya2VkU3BhbkZvcihmaXJzdCwgc3BhbiQxLm1hcmtlcik7XG4gICAgICAgICAgaWYgKCFmb3VuZCQxKSB7XG4gICAgICAgICAgICBzcGFuJDEuZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhbiQxLmZyb20gKz0gb2Zmc2V0O1xuICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgZGlkbid0IGNyZWF0ZSBhbnkgemVyby1sZW5ndGggc3BhbnNcbiAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBjbGVhckVtcHR5U3BhbnMoZmlyc3QpOyB9XG4gICAgaWYgKGxhc3QgJiYgbGFzdCAhPSBmaXJzdCkgeyBsYXN0ID0gY2xlYXJFbXB0eVNwYW5zKGxhc3QpOyB9XG5cbiAgICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF07XG4gICAgaWYgKCFzYW1lTGluZSkge1xuICAgICAgLy8gRmlsbCBnYXAgd2l0aCB3aG9sZS1saW5lLXNwYW5zXG4gICAgICB2YXIgZ2FwID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMiwgZ2FwTWFya2VycztcbiAgICAgIGlmIChnYXAgPiAwICYmIGZpcnN0KVxuICAgICAgICB7IGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGZpcnN0Lmxlbmd0aDsgKytpJDIpXG4gICAgICAgICAgeyBpZiAoZmlyc3RbaSQyXS50byA9PSBudWxsKVxuICAgICAgICAgICAgeyAoZ2FwTWFya2VycyB8fCAoZ2FwTWFya2VycyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihmaXJzdFtpJDJdLm1hcmtlciwgbnVsbCwgbnVsbCkpOyB9IH0gfVxuICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgZ2FwOyArK2kkMylcbiAgICAgICAgeyBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2Vycyk7IH1cbiAgICAgIG5ld01hcmtlcnMucHVzaChsYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcmtlcnNcbiAgfVxuXG4gIC8vIFJlbW92ZSBzcGFucyB0aGF0IGFyZSBlbXB0eSBhbmQgZG9uJ3QgaGF2ZSBhIGNsZWFyV2hlbkVtcHR5XG4gIC8vIG9wdGlvbiBvZiBmYWxzZS5cbiAgZnVuY3Rpb24gY2xlYXJFbXB0eVNwYW5zKHNwYW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCAmJiBzcGFuLmZyb20gPT0gc3Bhbi50byAmJiBzcGFuLm1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICAgIHsgc3BhbnMuc3BsaWNlKGktLSwgMSk7IH1cbiAgICB9XG4gICAgaWYgKCFzcGFucy5sZW5ndGgpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBzcGFuc1xuICB9XG5cbiAgLy8gVXNlZCB0byAnY2xpcCcgb3V0IHJlYWRPbmx5IHJhbmdlcyB3aGVuIG1ha2luZyBhIGNoYW5nZS5cbiAgZnVuY3Rpb24gcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBmcm9tLCB0bykge1xuICAgIHZhciBtYXJrZXJzID0gbnVsbDtcbiAgICBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpXS5tYXJrZXI7XG4gICAgICAgIGlmIChtYXJrLnJlYWRPbmx5ICYmICghbWFya2VycyB8fCBpbmRleE9mKG1hcmtlcnMsIG1hcmspID09IC0xKSlcbiAgICAgICAgICB7IChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspOyB9XG4gICAgICB9IH1cbiAgICB9KTtcbiAgICBpZiAoIW1hcmtlcnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBwYXJ0cyA9IFt7ZnJvbTogZnJvbSwgdG86IHRvfV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIHAgPSBwYXJ0c1tqXTtcbiAgICAgICAgaWYgKGNtcChwLnRvLCBtLmZyb20pIDwgMCB8fCBjbXAocC5mcm9tLCBtLnRvKSA+IDApIHsgY29udGludWUgfVxuICAgICAgICB2YXIgbmV3UGFydHMgPSBbaiwgMV0sIGRmcm9tID0gY21wKHAuZnJvbSwgbS5mcm9tKSwgZHRvID0gY21wKHAudG8sIG0udG8pO1xuICAgICAgICBpZiAoZGZyb20gPCAwIHx8ICFtay5pbmNsdXNpdmVMZWZ0ICYmICFkZnJvbSlcbiAgICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IHAuZnJvbSwgdG86IG0uZnJvbX0pOyB9XG4gICAgICAgIGlmIChkdG8gPiAwIHx8ICFtay5pbmNsdXNpdmVSaWdodCAmJiAhZHRvKVxuICAgICAgICAgIHsgbmV3UGFydHMucHVzaCh7ZnJvbTogbS50bywgdG86IHAudG99KTsgfVxuICAgICAgICBwYXJ0cy5zcGxpY2UuYXBwbHkocGFydHMsIG5ld1BhcnRzKTtcbiAgICAgICAgaiArPSBuZXdQYXJ0cy5sZW5ndGggLSAzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHNcbiAgfVxuXG4gIC8vIENvbm5lY3Qgb3IgZGlzY29ubmVjdCBzcGFucyBmcm9tIGEgbGluZS5cbiAgZnVuY3Rpb24gZGV0YWNoTWFya2VkU3BhbnMobGluZSkge1xuICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHNwYW5zW2ldLm1hcmtlci5kZXRhY2hMaW5lKGxpbmUpOyB9XG4gICAgbGluZS5tYXJrZWRTcGFucyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoTWFya2VkU3BhbnMobGluZSwgc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIHsgc3BhbnNbaV0ubWFya2VyLmF0dGFjaExpbmUobGluZSk7IH1cbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gc3BhbnM7XG4gIH1cblxuICAvLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cbiAgLy8gY291bnRzIGFzIHRoZSBsYXJnZXIgb25lLlxuICBmdW5jdGlvbiBleHRyYUxlZnQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IC0xIDogMCB9XG4gIGZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyAxIDogMCB9XG5cbiAgLy8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcbiAgLy8gc3BhbnMgaXMgbGFyZ2VyIChhbmQgdGh1cyBpbmNsdWRlcyB0aGUgb3RoZXIpLiBGYWxscyBiYWNrIHRvXG4gIC8vIGNvbXBhcmluZyBpZHMgd2hlbiB0aGUgc3BhbnMgY292ZXIgZXhhY3RseSB0aGUgc2FtZSByYW5nZS5cbiAgZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xuICAgIHZhciBsZW5EaWZmID0gYS5saW5lcy5sZW5ndGggLSBiLmxpbmVzLmxlbmd0aDtcbiAgICBpZiAobGVuRGlmZiAhPSAwKSB7IHJldHVybiBsZW5EaWZmIH1cbiAgICB2YXIgYVBvcyA9IGEuZmluZCgpLCBiUG9zID0gYi5maW5kKCk7XG4gICAgdmFyIGZyb21DbXAgPSBjbXAoYVBvcy5mcm9tLCBiUG9zLmZyb20pIHx8IGV4dHJhTGVmdChhKSAtIGV4dHJhTGVmdChiKTtcbiAgICBpZiAoZnJvbUNtcCkgeyByZXR1cm4gLWZyb21DbXAgfVxuICAgIHZhciB0b0NtcCA9IGNtcChhUG9zLnRvLCBiUG9zLnRvKSB8fCBleHRyYVJpZ2h0KGEpIC0gZXh0cmFSaWdodChiKTtcbiAgICBpZiAodG9DbXApIHsgcmV0dXJuIHRvQ21wIH1cbiAgICByZXR1cm4gYi5pZCAtIGEuaWRcbiAgfVxuXG4gIC8vIEZpbmQgb3V0IHdoZXRoZXIgYSBsaW5lIGVuZHMgb3Igc3RhcnRzIGluIGEgY29sbGFwc2VkIHNwYW4uIElmXG4gIC8vIHNvLCByZXR1cm4gdGhlIG1hcmtlciBmb3IgdGhhdCBzcGFuLlxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHN0YXJ0KSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kO1xuICAgIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHN0YXJ0ID8gc3AuZnJvbSA6IHNwLnRvKSA9PSBudWxsICYmXG4gICAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKVxuICAgICAgICB7IGZvdW5kID0gc3AubWFya2VyOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCB0cnVlKSB9XG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIGZhbHNlKSB9XG5cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkFyb3VuZChsaW5lLCBjaCkge1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zLCBmb3VuZDtcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAoc3AuZnJvbSA9PSBudWxsIHx8IHNwLmZyb20gPCBjaCkgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBjaCkgJiZcbiAgICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpIHsgZm91bmQgPSBzcC5tYXJrZXI7IH1cbiAgICB9IH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxuICAvLyBvdmVybGFwcyAoY292ZXJzIHRoZSBzdGFydCBvciBlbmQsIGJ1dCBub3QgYm90aCkgb2YgYSBuZXcgc3Bhbi5cbiAgLy8gU3VjaCBvdmVybGFwIGlzIG5vdCBhbGxvd2VkLlxuICBmdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vLCBmcm9tLCB0bywgbWFya2VyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vKTtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoIXNwLm1hcmtlci5jb2xsYXBzZWQpIHsgY29udGludWUgfVxuICAgICAgdmFyIGZvdW5kID0gc3AubWFya2VyLmZpbmQoMCk7XG4gICAgICB2YXIgZnJvbUNtcCA9IGNtcChmb3VuZC5mcm9tLCBmcm9tKSB8fCBleHRyYUxlZnQoc3AubWFya2VyKSAtIGV4dHJhTGVmdChtYXJrZXIpO1xuICAgICAgdmFyIHRvQ21wID0gY21wKGZvdW5kLnRvLCB0bykgfHwgZXh0cmFSaWdodChzcC5tYXJrZXIpIC0gZXh0cmFSaWdodChtYXJrZXIpO1xuICAgICAgaWYgKGZyb21DbXAgPj0gMCAmJiB0b0NtcCA8PSAwIHx8IGZyb21DbXAgPD0gMCAmJiB0b0NtcCA+PSAwKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC50bywgZnJvbSkgPj0gMCA6IGNtcChmb3VuZC50bywgZnJvbSkgPiAwKSB8fFxuICAgICAgICAgIGZyb21DbXAgPj0gMCAmJiAoc3AubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gY21wKGZvdW5kLmZyb20sIHRvKSA8PSAwIDogY21wKGZvdW5kLmZyb20sIHRvKSA8IDApKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9IH1cbiAgfVxuXG4gIC8vIEEgdmlzdWFsIGxpbmUgaXMgYSBsaW5lIGFzIGRyYXduIG9uIHRoZSBzY3JlZW4uIEZvbGRpbmcsIGZvclxuICAvLyBleGFtcGxlLCBjYW4gY2F1c2UgbXVsdGlwbGUgbG9naWNhbCBsaW5lcyB0byBhcHBlYXIgb24gdGhlIHNhbWVcbiAgLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxuICAvLyBnaXZlbiBsaW5lIGlzIHBhcnQgb2YgKHVzdWFsbHkgdGhhdCBpcyB0aGUgbGluZSBpdHNlbGYpLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKC0xLCB0cnVlKS5saW5lOyB9XG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmQobGluZSkge1xuICAgIHZhciBtZXJnZWQ7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7IH1cbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBsb2dpY2FsIGxpbmVzIHRoYXQgY29udGludWUgdGhlIHZpc3VhbCBsaW5lXG4gIC8vIHN0YXJ0ZWQgYnkgdGhlIGFyZ3VtZW50LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggbGluZXMuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVDb250aW51ZWQobGluZSkge1xuICAgIHZhciBtZXJnZWQsIGxpbmVzO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpIHtcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lXG4gICAgICA7KGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzXG4gIH1cblxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcbiAgLy8gZ2l2ZW4gbGluZSBudW1iZXIgaXMgcGFydCBvZi5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYywgbGluZU4pIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIHZpcyA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgaWYgKGxpbmUgPT0gdmlzKSB7IHJldHVybiBsaW5lTiB9XG4gICAgcmV0dXJuIGxpbmVObyh2aXMpXG4gIH1cblxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgbmV4dCB2aXN1YWwgbGluZSBhZnRlclxuICAvLyB0aGUgZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZUVuZE5vKGRvYywgbGluZU4pIHtcbiAgICBpZiAobGluZU4gPiBkb2MubGFzdExpbmUoKSkgeyByZXR1cm4gbGluZU4gfVxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkO1xuICAgIGlmICghbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgcmV0dXJuIGxpbmVOIH1cbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxuICAgICAgeyBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTsgfVxuICAgIHJldHVybiBsaW5lTm8obGluZSkgKyAxXG4gIH1cblxuICAvLyBDb21wdXRlIHdoZXRoZXIgYSBsaW5lIGlzIGhpZGRlbi4gTGluZXMgY291bnQgYXMgaGlkZGVuIHdoZW4gdGhleVxuICAvLyBhcmUgcGFydCBvZiBhIHZpc3VhbCBsaW5lIHRoYXQgc3RhcnRzIHdpdGggYW5vdGhlciBsaW5lLCBvciB3aGVuXG4gIC8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXG4gIGZ1bmN0aW9uIGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoc3AuZnJvbSA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoc3AuZnJvbSA9PSAwICYmIHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0ICYmIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9IH1cbiAgfVxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwYW4pIHtcbiAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XG4gICAgICB2YXIgZW5kID0gc3Bhbi5tYXJrZXIuZmluZCgxLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGVuZC5saW5lLCBnZXRNYXJrZWRTcGFuRm9yKGVuZC5saW5lLm1hcmtlZFNwYW5zLCBzcGFuLm1hcmtlcikpXG4gICAgfVxuICAgIGlmIChzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBzcGFuLnRvID09IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmICFzcC5tYXJrZXIud2lkZ2V0Tm9kZSAmJiBzcC5mcm9tID09IHNwYW4udG8gJiZcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmXG4gICAgICAgICAgKHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0IHx8IHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSAmJlxuICAgICAgICAgIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIGhlaWdodEF0TGluZShsaW5lT2JqKSB7XG4gICAgbGluZU9iaiA9IHZpc3VhbExpbmUobGluZU9iaik7XG5cbiAgICB2YXIgaCA9IDAsIGNodW5rID0gbGluZU9iai5wYXJlbnQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXTtcbiAgICAgIGlmIChsaW5lID09IGxpbmVPYmopIHsgYnJlYWsgfVxuICAgICAgZWxzZSB7IGggKz0gbGluZS5oZWlnaHQ7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgcCA9IGNodW5rLnBhcmVudDsgcDsgY2h1bmsgPSBwLCBwID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIGN1ciA9IHAuY2hpbGRyZW5baSQxXTtcbiAgICAgICAgaWYgKGN1ciA9PSBjaHVuaykgeyBicmVhayB9XG4gICAgICAgIGVsc2UgeyBoICs9IGN1ci5oZWlnaHQ7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgYSBsaW5lLCB0YWtpbmcgaW50byBhY2NvdW50XG4gIC8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxuICAvLyBvdGhlciBsaW5lcyBvbnRvIGl0LlxuICBmdW5jdGlvbiBsaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICBpZiAobGluZS5oZWlnaHQgPT0gMCkgeyByZXR1cm4gMCB9XG4gICAgdmFyIGxlbiA9IGxpbmUudGV4dC5sZW5ndGgsIG1lcmdlZCwgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBjdXIgPSBmb3VuZC5mcm9tLmxpbmU7XG4gICAgICBsZW4gKz0gZm91bmQuZnJvbS5jaCAtIGZvdW5kLnRvLmNoO1xuICAgIH1cbiAgICBjdXIgPSBsaW5lO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kJDEgPSBtZXJnZWQuZmluZCgwLCB0cnVlKTtcbiAgICAgIGxlbiAtPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLmZyb20uY2g7XG4gICAgICBjdXIgPSBmb3VuZCQxLnRvLmxpbmU7XG4gICAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS50by5jaDtcbiAgICB9XG4gICAgcmV0dXJuIGxlblxuICB9XG5cbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZE1heExpbmUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KTtcbiAgICBkLm1heExpbmVMZW5ndGggPSBsaW5lTGVuZ3RoKGQubWF4TGluZSk7XG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBsZW4gPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgaWYgKGxlbiA+IGQubWF4TGluZUxlbmd0aCkge1xuICAgICAgICBkLm1heExpbmVMZW5ndGggPSBsZW47XG4gICAgICAgIGQubWF4TGluZSA9IGxpbmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBMSU5FIERBVEEgU1RSVUNUVVJFXG5cbiAgLy8gTGluZSBvYmplY3RzLiBUaGVzZSBob2xkIHN0YXRlIHJlbGF0ZWQgdG8gYSBsaW5lLCBpbmNsdWRpbmdcbiAgLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxuICB2YXIgTGluZSA9IGZ1bmN0aW9uKHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgYXR0YWNoTWFya2VkU3BhbnModGhpcywgbWFya2VkU3BhbnMpO1xuICAgIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodCh0aGlzKSA6IDE7XG4gIH07XG5cbiAgTGluZS5wcm90b3R5cGUubGluZU5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZU5vKHRoaXMpIH07XG4gIGV2ZW50TWl4aW4oTGluZSk7XG5cbiAgLy8gQ2hhbmdlIHRoZSBjb250ZW50ICh0ZXh0LCBtYXJrZXJzKSBvZiBhIGxpbmUuIEF1dG9tYXRpY2FsbHlcbiAgLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcbiAgLy8gbGluZSdzIGhlaWdodC5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZShsaW5lLCB0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICBsaW5lLnRleHQgPSB0ZXh0O1xuICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDsgfVxuICAgIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGw7IH1cbiAgICBpZiAobGluZS5vcmRlciAhPSBudWxsKSB7IGxpbmUub3JkZXIgPSBudWxsOyB9XG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XG4gICAgYXR0YWNoTWFya2VkU3BhbnMobGluZSwgbWFya2VkU3BhbnMpO1xuICAgIHZhciBlc3RIZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KGxpbmUpIDogMTtcbiAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTsgfVxuICB9XG5cbiAgLy8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cbiAgZnVuY3Rpb24gY2xlYW5VcExpbmUobGluZSkge1xuICAgIGxpbmUucGFyZW50ID0gbnVsbDtcbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xuICAvLyBjb250YWluaW5nIG9uZSBvciBtb3JlIHN0eWxlcykgdG8gYSBDU1Mgc3R5bGUuIFRoaXMgaXMgY2FjaGVkLFxuICAvLyBhbmQgYWxzbyBsb29rcyBmb3IgbGluZS13aWRlIHN0eWxlcy5cbiAgdmFyIHN0eWxlVG9DbGFzc0NhY2hlID0ge30sIHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgPSB7fTtcbiAgZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmICghc3R5bGUgfHwgL15cXHMqJC8udGVzdChzdHlsZSkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjYWNoZSA9IG9wdGlvbnMuYWRkTW9kZUNsYXNzID8gc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA6IHN0eWxlVG9DbGFzc0NhY2hlO1xuICAgIHJldHVybiBjYWNoZVtzdHlsZV0gfHxcbiAgICAgIChjYWNoZVtzdHlsZV0gPSBzdHlsZS5yZXBsYWNlKC9cXFMrL2csIFwiY20tJCZcIikpXG4gIH1cblxuICAvLyBSZW5kZXIgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dCBvZiBhIGxpbmUuIEFsc28gYnVpbGRzXG4gIC8vIHVwIGEgJ2xpbmUgbWFwJywgd2hpY2ggcG9pbnRzIGF0IHRoZSBET00gbm9kZXMgdGhhdCByZXByZXNlbnRcbiAgLy8gc3BlY2lmaWMgc3RyZXRjaGVzIG9mIHRleHQsIGFuZCBpcyB1c2VkIGJ5IHRoZSBtZWFzdXJpbmcgY29kZS5cbiAgLy8gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgRE9NIG5vZGUsIHRoaXMgbWFwLCBhbmRcbiAgLy8gaW5mb3JtYXRpb24gYWJvdXQgbGluZS13aWRlIHN0eWxlcyB0aGF0IHdlcmUgc2V0IGJ5IHRoZSBtb2RlLlxuICBmdW5jdGlvbiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgIC8vIFRoZSBwYWRkaW5nLXJpZ2h0IGZvcmNlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgJ2JvcmRlcicsIHdoaWNoXG4gICAgLy8gaXMgbmVlZGVkIG9uIFdlYmtpdCB0byBiZSBhYmxlIHRvIGdldCBsaW5lLWxldmVsIGJvdW5kaW5nXG4gICAgLy8gcmVjdGFuZ2xlcyBmb3IgaXQgKGluIG1lYXN1cmVDaGFyKS5cbiAgICB2YXIgY29udGVudCA9IGVsdFAoXCJzcGFuXCIsIG51bGwsIG51bGwsIHdlYmtpdCA/IFwicGFkZGluZy1yaWdodDogLjFweFwiIDogbnVsbCk7XG4gICAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHRQKFwicHJlXCIsIFtjb250ZW50XSwgXCJDb2RlTWlycm9yLWxpbmVcIiksIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgY29sOiAwLCBwb3M6IDAsIGNtOiBjbSxcbiAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICBzcGxpdFNwYWNlczogY20uZ2V0T3B0aW9uKFwibGluZVdyYXBwaW5nXCIpfTtcbiAgICBsaW5lVmlldy5tZWFzdXJlID0ge307XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGxvZ2ljYWwgbGluZXMgdGhhdCBtYWtlIHVwIHRoaXMgdmlzdWFsIGxpbmUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gKGxpbmVWaWV3LnJlc3QgPyBsaW5lVmlldy5yZXN0Lmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gaSA/IGxpbmVWaWV3LnJlc3RbaSAtIDFdIDogbGluZVZpZXcubGluZSwgb3JkZXIgPSAodm9pZCAwKTtcbiAgICAgIGJ1aWxkZXIucG9zID0gMDtcbiAgICAgIGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuO1xuICAgICAgLy8gT3B0aW9uYWxseSB3aXJlIGluIHNvbWUgaGFja3MgaW50byB0aGUgdG9rZW4tcmVuZGVyaW5nXG4gICAgICAvLyBhbGdvcml0aG0sIHRvIGRlYWwgd2l0aCBicm93c2VyIHF1aXJrcy5cbiAgICAgIGlmIChoYXNCYWRCaWRpUmVjdHMoY20uZGlzcGxheS5tZWFzdXJlKSAmJiAob3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKSkpXG4gICAgICAgIHsgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKTsgfVxuICAgICAgYnVpbGRlci5tYXAgPSBbXTtcbiAgICAgIHZhciBhbGxvd0Zyb250aWVyVXBkYXRlID0gbGluZVZpZXcgIT0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkICYmIGxpbmVObyhsaW5lKTtcbiAgICAgIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIGdldExpbmVTdHlsZXMoY20sIGxpbmUsIGFsbG93RnJvbnRpZXJVcGRhdGUpKTtcbiAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcykge1xuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcylcbiAgICAgICAgICB7IGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcIlwiKTsgfVxuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzKVxuICAgICAgICAgIHsgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFwiXCIpOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBhIHNpbmdsZSBub2RlIGlzIHByZXNlbnQsIGZvciBtZWFzdXJpbmcuXG4gICAgICBpZiAoYnVpbGRlci5tYXAubGVuZ3RoID09IDApXG4gICAgICAgIHsgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7IH1cblxuICAgICAgLy8gU3RvcmUgdGhlIG1hcCBhbmQgYSBjYWNoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGxvZ2ljYWwgbGluZVxuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLm1hcCA9IGJ1aWxkZXIubWFwO1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge307XG4gICAgICB9IGVsc2Uge1xuICAobGluZVZpZXcubWVhc3VyZS5tYXBzIHx8IChsaW5lVmlldy5tZWFzdXJlLm1hcHMgPSBbXSkpLnB1c2goYnVpbGRlci5tYXApXG4gICAgICAgIDsobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzID0gW10pKS5wdXNoKHt9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZWUgaXNzdWUgIzI5MDFcbiAgICBpZiAod2Via2l0KSB7XG4gICAgICB2YXIgbGFzdCA9IGJ1aWxkZXIuY29udGVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAoL1xcYmNtLXRhYlxcYi8udGVzdChsYXN0LmNsYXNzTmFtZSkgfHwgKGxhc3QucXVlcnlTZWxlY3RvciAmJiBsYXN0LnF1ZXJ5U2VsZWN0b3IoXCIuY20tdGFiXCIpKSlcbiAgICAgICAgeyBidWlsZGVyLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJjbS10YWItd3JhcC1oYWNrXCI7IH1cbiAgICB9XG5cbiAgICBzaWduYWwoY20sIFwicmVuZGVyTGluZVwiLCBjbSwgbGluZVZpZXcubGluZSwgYnVpbGRlci5wcmUpO1xuICAgIGlmIChidWlsZGVyLnByZS5jbGFzc05hbWUpXG4gICAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMoYnVpbGRlci5wcmUuY2xhc3NOYW1lLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTsgfVxuXG4gICAgcmV0dXJuIGJ1aWxkZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGNoKSB7XG4gICAgdmFyIHRva2VuID0gZWx0KFwic3BhblwiLCBcIlxcdTIwMjJcIiwgXCJjbS1pbnZhbGlkY2hhclwiKTtcbiAgICB0b2tlbi50aXRsZSA9IFwiXFxcXHVcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgIHRva2VuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9rZW4udGl0bGUpO1xuICAgIHJldHVybiB0b2tlblxuICB9XG5cbiAgLy8gQnVpbGQgdXAgdGhlIERPTSByZXByZXNlbnRhdGlvbiBmb3IgYSBzaW5nbGUgdG9rZW4sIGFuZCBhZGQgaXQgdG9cbiAgLy8gdGhlIGxpbmUgbWFwLiBUYWtlcyBjYXJlIHRvIHJlbmRlciBzcGVjaWFsIGNoYXJhY3RlcnMgc2VwYXJhdGVseS5cbiAgZnVuY3Rpb24gYnVpbGRUb2tlbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIGNzcywgYXR0cmlidXRlcykge1xuICAgIGlmICghdGV4dCkgeyByZXR1cm4gfVxuICAgIHZhciBkaXNwbGF5VGV4dCA9IGJ1aWxkZXIuc3BsaXRTcGFjZXMgPyBzcGxpdFNwYWNlcyh0ZXh0LCBidWlsZGVyLnRyYWlsaW5nU3BhY2UpIDogdGV4dDtcbiAgICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBtdXN0V3JhcCA9IGZhbHNlO1xuICAgIHZhciBjb250ZW50O1xuICAgIGlmICghc3BlY2lhbC50ZXN0KHRleHQpKSB7XG4gICAgICBidWlsZGVyLmNvbCArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dCk7XG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHRleHQubGVuZ3RoLCBjb250ZW50KTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBtdXN0V3JhcCA9IHRydWU7IH1cbiAgICAgIGJ1aWxkZXIucG9zICs9IHRleHQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzcGVjaWFsLmxhc3RJbmRleCA9IHBvcztcbiAgICAgICAgdmFyIG0gPSBzcGVjaWFsLmV4ZWModGV4dCk7XG4gICAgICAgIHZhciBza2lwcGVkID0gbSA/IG0uaW5kZXggLSBwb3MgOiB0ZXh0Lmxlbmd0aCAtIHBvcztcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQuc2xpY2UocG9zLCBwb3MgKyBza2lwcGVkKSk7XG4gICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0XSkpOyB9XG4gICAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0KTsgfVxuICAgICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2tpcHBlZCwgdHh0KTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSBza2lwcGVkO1xuICAgICAgICAgIGJ1aWxkZXIucG9zICs9IHNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtKSB7IGJyZWFrIH1cbiAgICAgICAgcG9zICs9IHNraXBwZWQgKyAxO1xuICAgICAgICB2YXIgdHh0JDEgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKG1bMF0gPT0gXCJcXHRcIikge1xuICAgICAgICAgIHZhciB0YWJTaXplID0gYnVpbGRlci5jbS5vcHRpb25zLnRhYlNpemUsIHRhYldpZHRoID0gdGFiU2l6ZSAtIGJ1aWxkZXIuY29sICUgdGFiU2l6ZTtcbiAgICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBzcGFjZVN0cih0YWJXaWR0aCksIFwiY20tdGFiXCIpKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcXHRcIik7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gdGFiV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAobVswXSA9PSBcIlxcclwiIHx8IG1bMF0gPT0gXCJcXG5cIikge1xuICAgICAgICAgIHR4dCQxID0gY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIG1bMF0gPT0gXCJcXHJcIiA/IFwiXFx1MjQwZFwiIDogXCJcXHUyNDI0XCIsIFwiY20taW52YWxpZGNoYXJcIikpO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eHQkMSA9IGJ1aWxkZXIuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG1bMF0pO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0JDFdKSk7IH1cbiAgICAgICAgICBlbHNlIHsgY29udGVudC5hcHBlbmRDaGlsZCh0eHQkMSk7IH1cbiAgICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgMSwgdHh0JDEpO1xuICAgICAgICBidWlsZGVyLnBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBkaXNwbGF5VGV4dC5jaGFyQ29kZUF0KHRleHQubGVuZ3RoIC0gMSkgPT0gMzI7XG4gICAgaWYgKHN0eWxlIHx8IHN0YXJ0U3R5bGUgfHwgZW5kU3R5bGUgfHwgbXVzdFdyYXAgfHwgY3NzIHx8IGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciBmdWxsU3R5bGUgPSBzdHlsZSB8fCBcIlwiO1xuICAgICAgaWYgKHN0YXJ0U3R5bGUpIHsgZnVsbFN0eWxlICs9IHN0YXJ0U3R5bGU7IH1cbiAgICAgIGlmIChlbmRTdHlsZSkgeyBmdWxsU3R5bGUgKz0gZW5kU3R5bGU7IH1cbiAgICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgW2NvbnRlbnRdLCBmdWxsU3R5bGUsIGNzcyk7XG4gICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJpYnV0ZXMpIHsgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgYXR0ciAhPSBcInN0eWxlXCIgJiYgYXR0ciAhPSBcImNsYXNzXCIpXG4gICAgICAgICAgeyB0b2tlbi5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7IH0gfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh0b2tlbilcbiAgICB9XG4gICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICB9XG5cbiAgLy8gQ2hhbmdlIHNvbWUgc3BhY2VzIHRvIE5CU1AgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGNvbGxhcHNpbmdcbiAgLy8gdHJhaWxpbmcgc3BhY2VzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIHdoZW4gcmVuZGVyaW5nIHRleHQgKGlzc3VlICMxMzYyKS5cbiAgZnVuY3Rpb24gc3BsaXRTcGFjZXModGV4dCwgdHJhaWxpbmdCZWZvcmUpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPiAxICYmICEvICAvLnRlc3QodGV4dCkpIHsgcmV0dXJuIHRleHQgfVxuICAgIHZhciBzcGFjZUJlZm9yZSA9IHRyYWlsaW5nQmVmb3JlLCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICBpZiAoY2ggPT0gXCIgXCIgJiYgc3BhY2VCZWZvcmUgJiYgKGkgPT0gdGV4dC5sZW5ndGggLSAxIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPT0gMzIpKVxuICAgICAgICB7IGNoID0gXCJcXHUwMGEwXCI7IH1cbiAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgIHNwYWNlQmVmb3JlID0gY2ggPT0gXCIgXCI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNlIGRpbWVuc2lvbnMgYmVpbmcgcmVwb3J0ZWQgZm9yIHN0cmV0Y2hlcyBvZlxuICAvLyByaWdodC10by1sZWZ0IHRleHQuXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW5CYWRCaWRpKGlubmVyLCBvcmRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHN0eWxlID0gc3R5bGUgPyBzdHlsZSArIFwiIGNtLWZvcmNlLWJvcmRlclwiIDogXCJjbS1mb3JjZS1ib3JkZXJcIjtcbiAgICAgIHZhciBzdGFydCA9IGJ1aWxkZXIucG9zLCBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICAvLyBGaW5kIHRoZSBwYXJ0IHRoYXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3RhcnQgb2YgdGhpcyB0ZXh0XG4gICAgICAgIHZhciBwYXJ0ID0gKHZvaWQgMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gb3JkZXJbaV07XG4gICAgICAgICAgaWYgKHBhcnQudG8gPiBzdGFydCAmJiBwYXJ0LmZyb20gPD0gc3RhcnQpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgeyByZXR1cm4gaW5uZXIoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIH1cbiAgICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5zbGljZSgwLCBwYXJ0LnRvIC0gc3RhcnQpLCBzdHlsZSwgc3RhcnRTdHlsZSwgbnVsbCwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgc3RhcnRTdHlsZSA9IG51bGw7XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHBhcnQudG8gLSBzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gcGFydC50bztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcbiAgICB2YXIgd2lkZ2V0ID0gIWlnbm9yZVdpZGdldCAmJiBtYXJrZXIud2lkZ2V0Tm9kZTtcbiAgICBpZiAod2lkZ2V0KSB7IGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2l6ZSwgd2lkZ2V0KTsgfVxuICAgIGlmICghaWdub3JlV2lkZ2V0ICYmIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUpIHtcbiAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICB7IHdpZGdldCA9IGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7IH1cbiAgICAgIHdpZGdldC5zZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiwgbWFya2VyLmlkKTtcbiAgICB9XG4gICAgaWYgKHdpZGdldCkge1xuICAgICAgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUod2lkZ2V0KTtcbiAgICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xuICAgIH1cbiAgICBidWlsZGVyLnBvcyArPSBzaXplO1xuICAgIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gT3V0cHV0cyBhIG51bWJlciBvZiBzcGFucyB0byBtYWtlIHVwIGEgbGluZSwgdGFraW5nIGhpZ2hsaWdodGluZ1xuICAvLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBzdHlsZXMpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zLCBhbGxUZXh0ID0gbGluZS50ZXh0LCBhdCA9IDA7XG4gICAgaWYgKCFzcGFucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgc3R5bGVzLmxlbmd0aDsgaSQxKz0yKVxuICAgICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSQxXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2kkMSsxXSwgYnVpbGRlci5jbS5vcHRpb25zKSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBsZW4gPSBhbGxUZXh0Lmxlbmd0aCwgcG9zID0gMCwgaSA9IDEsIHRleHQgPSBcIlwiLCBzdHlsZSwgY3NzO1xuICAgIHZhciBuZXh0Q2hhbmdlID0gMCwgc3BhblN0eWxlLCBzcGFuRW5kU3R5bGUsIHNwYW5TdGFydFN0eWxlLCBjb2xsYXBzZWQsIGF0dHJpYnV0ZXM7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7IC8vIFVwZGF0ZSBjdXJyZW50IG1hcmtlciBzZXRcbiAgICAgICAgc3BhblN0eWxlID0gc3BhbkVuZFN0eWxlID0gc3BhblN0YXJ0U3R5bGUgPSBjc3MgPSBcIlwiO1xuICAgICAgICBhdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgICAgY29sbGFwc2VkID0gbnVsbDsgbmV4dENoYW5nZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgZm91bmRCb29rbWFya3MgPSBbXSwgZW5kU3R5bGVzID0gKHZvaWQgMCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3BhbnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3AgPSBzcGFuc1tqXSwgbSA9IHNwLm1hcmtlcjtcbiAgICAgICAgICBpZiAobS50eXBlID09IFwiYm9va21hcmtcIiAmJiBzcC5mcm9tID09IHBvcyAmJiBtLndpZGdldE5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kQm9va21hcmtzLnB1c2gobSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tIDw9IHBvcyAmJiAoc3AudG8gPT0gbnVsbCB8fCBzcC50byA+IHBvcyB8fCBtLmNvbGxhcHNlZCAmJiBzcC50byA9PSBwb3MgJiYgc3AuZnJvbSA9PSBwb3MpKSB7XG4gICAgICAgICAgICBpZiAoc3AudG8gIT0gbnVsbCAmJiBzcC50byAhPSBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLnRvKSB7XG4gICAgICAgICAgICAgIG5leHRDaGFuZ2UgPSBzcC50bztcbiAgICAgICAgICAgICAgc3BhbkVuZFN0eWxlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtLmNsYXNzTmFtZSkgeyBzcGFuU3R5bGUgKz0gXCIgXCIgKyBtLmNsYXNzTmFtZTsgfVxuICAgICAgICAgICAgaWYgKG0uY3NzKSB7IGNzcyA9IChjc3MgPyBjc3MgKyBcIjtcIiA6IFwiXCIpICsgbS5jc3M7IH1cbiAgICAgICAgICAgIGlmIChtLnN0YXJ0U3R5bGUgJiYgc3AuZnJvbSA9PSBwb3MpIHsgc3BhblN0YXJ0U3R5bGUgKz0gXCIgXCIgKyBtLnN0YXJ0U3R5bGU7IH1cbiAgICAgICAgICAgIGlmIChtLmVuZFN0eWxlICYmIHNwLnRvID09IG5leHRDaGFuZ2UpIHsgKGVuZFN0eWxlcyB8fCAoZW5kU3R5bGVzID0gW10pKS5wdXNoKG0uZW5kU3R5bGUsIHNwLnRvKTsgfVxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgdGhlIG9sZCB0aXRsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvQ29kZU1pcnJvci9wdWxsLzU2NzNcbiAgICAgICAgICAgIGlmIChtLnRpdGxlKSB7IChhdHRyaWJ1dGVzIHx8IChhdHRyaWJ1dGVzID0ge30pKS50aXRsZSA9IG0udGl0bGU7IH1cbiAgICAgICAgICAgIGlmIChtLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBtLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgeyAoYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KSlbYXR0cl0gPSBtLmF0dHJpYnV0ZXNbYXR0cl07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtLmNvbGxhcHNlZCAmJiAoIWNvbGxhcHNlZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhjb2xsYXBzZWQubWFya2VyLCBtKSA8IDApKVxuICAgICAgICAgICAgICB7IGNvbGxhcHNlZCA9IHNwOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tID4gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC5mcm9tKSB7XG4gICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AuZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0eWxlcykgeyBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBlbmRTdHlsZXMubGVuZ3RoOyBqJDEgKz0gMilcbiAgICAgICAgICB7IGlmIChlbmRTdHlsZXNbaiQxICsgMV0gPT0gbmV4dENoYW5nZSkgeyBzcGFuRW5kU3R5bGUgKz0gXCIgXCIgKyBlbmRTdHlsZXNbaiQxXTsgfSB9IH1cblxuICAgICAgICBpZiAoIWNvbGxhcHNlZCB8fCBjb2xsYXBzZWQuZnJvbSA9PSBwb3MpIHsgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgZm91bmRCb29rbWFya3MubGVuZ3RoOyArK2okMilcbiAgICAgICAgICB7IGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAwLCBmb3VuZEJvb2ttYXJrc1tqJDJdKTsgfSB9XG4gICAgICAgIGlmIChjb2xsYXBzZWQgJiYgKGNvbGxhcHNlZC5mcm9tIHx8IDApID09IHBvcykge1xuICAgICAgICAgIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAoY29sbGFwc2VkLnRvID09IG51bGwgPyBsZW4gKyAxIDogY29sbGFwc2VkLnRvKSAtIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbCk7XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBwb3MpIHsgY29sbGFwc2VkID0gZmFsc2U7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA+PSBsZW4pIHsgYnJlYWsgfVxuXG4gICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdmFyIHRva2VuVGV4dCA9IGVuZCA+IHVwdG8gPyB0ZXh0LnNsaWNlKDAsIHVwdG8gLSBwb3MpIDogdGV4dDtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXCJcIiwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZCA+PSB1cHRvKSB7dGV4dCA9IHRleHQuc2xpY2UodXB0byAtIHBvcyk7IHBvcyA9IHVwdG87IGJyZWFrfVxuICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICBzcGFuU3RhcnRTdHlsZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2krK10pO1xuICAgICAgICBzdHlsZSA9IGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sIGJ1aWxkZXIuY20ub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxuICAvLyBwYXJ0IG9mIHRoZSBkb2N1bWVudC4gQSBMaW5lVmlldyBtYXkgY29ycmVzcG9uZCB0byBtdWx0aXBsZVxuICAvLyBsb2dpY2FsIGxpbmVzLCBpZiB0aG9zZSBhcmUgY29ubmVjdGVkIGJ5IGNvbGxhcHNlZCByYW5nZXMuXG4gIGZ1bmN0aW9uIExpbmVWaWV3KGRvYywgbGluZSwgbGluZU4pIHtcbiAgICAvLyBUaGUgc3RhcnRpbmcgbGluZVxuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgLy8gQ29udGludWluZyBsaW5lcywgaWYgYW55XG4gICAgdGhpcy5yZXN0ID0gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKTtcbiAgICAvLyBOdW1iZXIgb2YgbG9naWNhbCBsaW5lcyBpbiB0aGlzIHZpc3VhbCBsaW5lXG4gICAgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gbGluZU5vKGxzdCh0aGlzLnJlc3QpKSAtIGxpbmVOICsgMSA6IDE7XG4gICAgdGhpcy5ub2RlID0gdGhpcy50ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmhpZGRlbiA9IGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgcmFuZ2Ugb2YgTGluZVZpZXcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIGxpbmVzLlxuICBmdW5jdGlvbiBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgYXJyYXkgPSBbXSwgbmV4dFBvcztcbiAgICBmb3IgKHZhciBwb3MgPSBmcm9tOyBwb3MgPCB0bzsgcG9zID0gbmV4dFBvcykge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBnZXRMaW5lKGNtLmRvYywgcG9zKSwgcG9zKTtcbiAgICAgIG5leHRQb3MgPSBwb3MgKyB2aWV3LnNpemU7XG4gICAgICBhcnJheS5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlcbiAgfVxuXG4gIHZhciBvcGVyYXRpb25Hcm91cCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCkge1xuICAgIGlmIChvcGVyYXRpb25Hcm91cCkge1xuICAgICAgb3BlcmF0aW9uR3JvdXAub3BzLnB1c2gob3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcC5vd25zR3JvdXAgPSBvcGVyYXRpb25Hcm91cCA9IHtcbiAgICAgICAgb3BzOiBbb3BdLFxuICAgICAgICBkZWxheWVkQ2FsbGJhY2tzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB7XG4gICAgLy8gQ2FsbHMgZGVsYXllZCBjYWxsYmFja3MgYW5kIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIHVudGlsIG5vXG4gICAgLy8gbmV3IG9uZXMgYXBwZWFyXG4gICAgdmFyIGNhbGxiYWNrcyA9IGdyb3VwLmRlbGF5ZWRDYWxsYmFja3MsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGZvciAoOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGNhbGxiYWNrc1tpXS5jYWxsKG51bGwpOyB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwLm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgb3AgPSBncm91cC5vcHNbal07XG4gICAgICAgIGlmIChvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzKVxuICAgICAgICAgIHsgd2hpbGUgKG9wLmN1cnNvckFjdGl2aXR5Q2FsbGVkIDwgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGgpXG4gICAgICAgICAgICB7IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnNbb3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQrK10uY2FsbChudWxsLCBvcC5jbSk7IH0gfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKGkgPCBjYWxsYmFja3MubGVuZ3RoKVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoT3BlcmF0aW9uKG9wLCBlbmRDYikge1xuICAgIHZhciBncm91cCA9IG9wLm93bnNHcm91cDtcbiAgICBpZiAoIWdyb3VwKSB7IHJldHVybiB9XG5cbiAgICB0cnkgeyBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuICAgICAgZW5kQ2IoZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcblxuICAvLyBPZnRlbiwgd2Ugd2FudCB0byBzaWduYWwgZXZlbnRzIGF0IGEgcG9pbnQgd2hlcmUgd2UgYXJlIGluIHRoZVxuICAvLyBtaWRkbGUgb2Ygc29tZSB3b3JrLCBidXQgZG9uJ3Qgd2FudCB0aGUgaGFuZGxlciB0byBzdGFydCBjYWxsaW5nXG4gIC8vIG90aGVyIG1ldGhvZHMgb24gdGhlIGVkaXRvciwgd2hpY2ggbWlnaHQgYmUgaW4gYW4gaW5jb25zaXN0ZW50XG4gIC8vIHN0YXRlIG9yIHNpbXBseSBub3QgZXhwZWN0IGFueSBvdGhlciBldmVudHMgdG8gaGFwcGVuLlxuICAvLyBzaWduYWxMYXRlciBsb29rcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgaGFuZGxlcnMsIGFuZCBzY2hlZHVsZXNcbiAgLy8gdGhlbSB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBsYXN0IG9wZXJhdGlvbiBlbmRzLCBvciwgaWYgbm9cbiAgLy8gb3BlcmF0aW9uIGlzIGFjdGl2ZSwgd2hlbiBhIHRpbWVvdXQgZmlyZXMuXG4gIGZ1bmN0aW9uIHNpZ25hbExhdGVyKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XG4gICAgdmFyIGFyciA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xuICAgIGlmICghYXJyLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgbGlzdDtcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcbiAgICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSBpZiAob3JwaGFuRGVsYXllZENhbGxiYWNrcykge1xuICAgICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gW107XG4gICAgICBzZXRUaW1lb3V0KGZpcmVPcnBoYW5EZWxheWVkLCAwKTtcbiAgICB9XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICBsaXN0LnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJyW2ldLmFwcGx5KG51bGwsIGFyZ3MpOyB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICBsb29wKCBpICk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcbiAgICB2YXIgZGVsYXllZCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxheWVkLmxlbmd0aDsgKytpKSB7IGRlbGF5ZWRbaV0oKTsgfVxuICB9XG5cbiAgLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXG4gIC8vIGxpbmVWaWV3LmNoYW5nZXMuIFRoaXMgdXBkYXRlcyB0aGUgcmVsZXZhbnQgcGFydCBvZiB0aGUgbGluZSdzXG4gIC8vIERPTSBzdHJ1Y3R1cmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVWaWV3LmNoYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciB0eXBlID0gbGluZVZpZXcuY2hhbmdlc1tqXTtcbiAgICAgIGlmICh0eXBlID09IFwidGV4dFwiKSB7IHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJndXR0ZXJcIikgeyB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiY2xhc3NcIikgeyB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwid2lkZ2V0XCIpIHsgdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTsgfVxuICAgIH1cbiAgICBsaW5lVmlldy5jaGFuZ2VzID0gbnVsbDtcbiAgfVxuXG4gIC8vIExpbmVzIHdpdGggZ3V0dGVyIGVsZW1lbnRzLCB3aWRnZXRzIG9yIGEgYmFja2dyb3VuZCBjbGFzcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQsIGFuZCBoYXZlIHRoZSBleHRyYSBlbGVtZW50cyBhZGRlZCB0byB0aGUgd3JhcHBlciBkaXZcbiAgZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lVmlldy50ZXh0KSB7XG4gICAgICBsaW5lVmlldy5ub2RlID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgICAgaWYgKGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZSlcbiAgICAgICAgeyBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpOyB9XG4gICAgICBsaW5lVmlldy5ub2RlLmFwcGVuZENoaWxkKGxpbmVWaWV3LnRleHQpO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMjsgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZVZpZXcubm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUJhY2tncm91bmQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LmJnQ2xhc3MgPyBsaW5lVmlldy5iZ0NsYXNzICsgXCIgXCIgKyAobGluZVZpZXcubGluZS5iZ0NsYXNzIHx8IFwiXCIpIDogbGluZVZpZXcubGluZS5iZ0NsYXNzO1xuICAgIGlmIChjbHMpIHsgY2xzICs9IFwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcIjsgfVxuICAgIGlmIChsaW5lVmlldy5iYWNrZ3JvdW5kKSB7XG4gICAgICBpZiAoY2xzKSB7IGxpbmVWaWV3LmJhY2tncm91bmQuY2xhc3NOYW1lID0gY2xzOyB9XG4gICAgICBlbHNlIHsgbGluZVZpZXcuYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3LmJhY2tncm91bmQpOyBsaW5lVmlldy5iYWNrZ3JvdW5kID0gbnVsbDsgfVxuICAgIH0gZWxzZSBpZiAoY2xzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIGxpbmVWaWV3LmJhY2tncm91bmQgPSB3cmFwLmluc2VydEJlZm9yZShlbHQoXCJkaXZcIiwgbnVsbCwgY2xzKSwgd3JhcC5maXJzdENoaWxkKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShsaW5lVmlldy5iYWNrZ3JvdW5kKTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwcGVyIGFyb3VuZCBidWlsZExpbmVDb250ZW50IHdoaWNoIHdpbGwgcmV1c2UgdGhlIHN0cnVjdHVyZVxuICAvLyBpbiBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgd2hlbiBwb3NzaWJsZS5cbiAgZnVuY3Rpb24gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGV4dC5saW5lID09IGxpbmVWaWV3LmxpbmUpIHtcbiAgICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgICBsaW5lVmlldy5tZWFzdXJlID0gZXh0Lm1lYXN1cmU7XG4gICAgICByZXR1cm4gZXh0LmJ1aWx0XG4gICAgfVxuICAgIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldylcbiAgfVxuXG4gIC8vIFJlZHJhdyB0aGUgbGluZSdzIHRleHQuIEludGVyYWN0cyB3aXRoIHRoZSBiYWNrZ3JvdW5kIGFuZCB0ZXh0XG4gIC8vIGNsYXNzZXMgYmVjYXVzZSB0aGUgbW9kZSBtYXkgb3V0cHV0IHRva2VucyB0aGF0IGluZmx1ZW5jZSB0aGVzZVxuICAvLyBjbGFzc2VzLlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpIHtcbiAgICB2YXIgY2xzID0gbGluZVZpZXcudGV4dC5jbGFzc05hbWU7XG4gICAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcudGV4dCA9PSBsaW5lVmlldy5ub2RlKSB7IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7IH1cbiAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1aWx0LnByZSwgbGluZVZpZXcudGV4dCk7XG4gICAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICBpZiAoYnVpbHQuYmdDbGFzcyAhPSBsaW5lVmlldy5iZ0NsYXNzIHx8IGJ1aWx0LnRleHRDbGFzcyAhPSBsaW5lVmlldy50ZXh0Q2xhc3MpIHtcbiAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzO1xuICAgICAgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTtcbiAgICB9IGVsc2UgaWYgKGNscykge1xuICAgICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KSB7XG4gICAgdXBkYXRlTGluZUJhY2tncm91bmQoY20sIGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcubGluZS53cmFwQ2xhc3MpXG4gICAgICB7IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KS5jbGFzc05hbWUgPSBsaW5lVmlldy5saW5lLndyYXBDbGFzczsgfVxuICAgIGVsc2UgaWYgKGxpbmVWaWV3Lm5vZGUgIT0gbGluZVZpZXcudGV4dClcbiAgICAgIHsgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcIlwiOyB9XG4gICAgdmFyIHRleHRDbGFzcyA9IGxpbmVWaWV3LnRleHRDbGFzcyA/IGxpbmVWaWV3LnRleHRDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUudGV4dENsYXNzIHx8IFwiXCIpIDogbGluZVZpZXcubGluZS50ZXh0Q2xhc3M7XG4gICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSB0ZXh0Q2xhc3MgfHwgXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIGlmIChsaW5lVmlldy5ndXR0ZXIpIHtcbiAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyKTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xuICAgICAgbGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHg7IHdpZHRoOiBcIiArIChkaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweFwiKSk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCk7XG4gICAgICB3cmFwLmluc2VydEJlZm9yZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kLCBsaW5lVmlldy50ZXh0KTtcbiAgICB9XG4gICAgdmFyIG1hcmtlcnMgPSBsaW5lVmlldy5saW5lLmd1dHRlck1hcmtlcnM7XG4gICAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgfHwgbWFya2Vycykge1xuICAgICAgdmFyIHdyYXAkMSA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIHZhciBndXR0ZXJXcmFwID0gbGluZVZpZXcuZ3V0dGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclwiLCAoXCJsZWZ0OiBcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweFwiKSk7XG4gICAgICBndXR0ZXJXcmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShndXR0ZXJXcmFwKTtcbiAgICAgIHdyYXAkMS5pbnNlcnRCZWZvcmUoZ3V0dGVyV3JhcCwgbGluZVZpZXcudGV4dCk7XG4gICAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcylcbiAgICAgICAgeyBndXR0ZXJXcmFwLmNsYXNzTmFtZSArPSBcIiBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3M7IH1cbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzICYmICghbWFya2VycyB8fCAhbWFya2Vyc1tcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pKVxuICAgICAgICB7IGxpbmVWaWV3LmxpbmVOdW1iZXIgPSBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKFxuICAgICAgICAgIGVsdChcImRpdlwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcbiAgICAgICAgICAgICAgXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pICsgXCJweDsgd2lkdGg6IFwiICsgKGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGgpICsgXCJweFwiKSkpOyB9XG4gICAgICBpZiAobWFya2VycykgeyBmb3IgKHZhciBrID0gMDsgayA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1trXS5jbGFzc05hbWUsIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICB7IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFtmb3VuZF0sIFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W2lkXSkgKyBcInB4OyB3aWR0aDogXCIgKyAoZGltcy5ndXR0ZXJXaWR0aFtpZF0pICsgXCJweFwiKSkpOyB9XG4gICAgICB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuYWxpZ25hYmxlKSB7IGxpbmVWaWV3LmFsaWduYWJsZSA9IG51bGw7IH1cbiAgICB2YXIgaXNXaWRnZXQgPSBjbGFzc1Rlc3QoXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7XG4gICAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dCA9ICh2b2lkIDApOyBub2RlOyBub2RlID0gbmV4dCkge1xuICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoaXNXaWRnZXQudGVzdChub2RlLmNsYXNzTmFtZSkpIHsgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxuICAgIH1cbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICB9XG5cbiAgLy8gQnVpbGQgYSBsaW5lJ3MgRE9NIHJlcHJlc2VudGF0aW9uIGZyb20gc2NyYXRjaFxuICBmdW5jdGlvbiBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xuICAgIGxpbmVWaWV3LnRleHQgPSBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlO1xuICAgIGlmIChidWlsdC5iZ0NsYXNzKSB7IGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzOyB9XG4gICAgaWYgKGJ1aWx0LnRleHRDbGFzcykgeyBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7IH1cblxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XG4gICAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICAgIHJldHVybiBsaW5lVmlldy5ub2RlXG4gIH1cblxuICAvLyBBIGxpbmVWaWV3IG1heSBjb250YWluIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgKHdoZW4gbWVyZ2VkIGJ5XG4gIC8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpO1xuICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgIHsgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LnJlc3RbaV0sIGxpbmVWaWV3LCBkaW1zLCBmYWxzZSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmUsIGxpbmVWaWV3LCBkaW1zLCBhbGxvd0Fib3ZlKSB7XG4gICAgaWYgKCFsaW5lLndpZGdldHMpIHsgcmV0dXJuIH1cbiAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICBmb3IgKHZhciBpID0gMCwgd3MgPSBsaW5lLndpZGdldHM7IGkgPCB3cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHdpZGdldCA9IHdzW2ldLCBub2RlID0gZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIgKyAod2lkZ2V0LmNsYXNzTmFtZSA/IFwiIFwiICsgd2lkZ2V0LmNsYXNzTmFtZSA6IFwiXCIpKTtcbiAgICAgIGlmICghd2lkZ2V0LmhhbmRsZU1vdXNlRXZlbnRzKSB7IG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcbiAgICAgIGlmIChhbGxvd0Fib3ZlICYmIHdpZGdldC5hYm92ZSlcbiAgICAgICAgeyB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB3cmFwLmFwcGVuZENoaWxkKG5vZGUpOyB9XG4gICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFwicmVkcmF3XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcbiAgKGxpbmVWaWV3LmFsaWduYWJsZSB8fCAobGluZVZpZXcuYWxpZ25hYmxlID0gW10pKS5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGg7XG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBkaW1zLmZpeGVkUG9zICsgXCJweFwiO1xuICAgICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcbiAgICAgICAgd2lkdGggLT0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdMZWZ0ID0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH1cbiAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICBub2RlLnN0eWxlLnpJbmRleCA9IDU7XG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgaWYgKCF3aWRnZXQubm9IU2Nyb2xsKSB7IG5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IC1kaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCI7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KSB7XG4gICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gd2lkZ2V0LmhlaWdodCB9XG4gICAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbTtcbiAgICBpZiAoIWNtKSB7IHJldHVybiAwIH1cbiAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xuICAgICAgdmFyIHBhcmVudFN0eWxlID0gXCJwb3NpdGlvbjogcmVsYXRpdmU7XCI7XG4gICAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwibWFyZ2luLWxlZnQ6IC1cIiArIGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCArIFwicHg7XCI7IH1cbiAgICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwid2lkdGg6IFwiICsgY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoICsgXCJweDtcIjsgfVxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgcGFyZW50U3R5bGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZGdldC5oZWlnaHQgPSB3aWRnZXQubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgd2hlbiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQgaGFwcGVuZWQgaW4gYSB3aWRnZXRcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XG4gICAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCFuIHx8IChuLm5vZGVUeXBlID09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIpID09IFwidHJ1ZVwiKSB8fFxuICAgICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxuXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3B9XG4gIGZ1bmN0aW9uIHBhZGRpbmdWZXJ0KGRpc3BsYXkpIHtyZXR1cm4gZGlzcGxheS5tb3Zlci5vZmZzZXRIZWlnaHQgLSBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRIZWlnaHR9XG4gIGZ1bmN0aW9uIHBhZGRpbmdIKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSCB9XG4gICAgdmFyIGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIGVsdChcInByZVwiLCBcInhcIiwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKSk7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlO1xuICAgIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xuICAgIGlmICghaXNOYU4oZGF0YS5sZWZ0KSAmJiAhaXNOYU4oZGF0YS5yaWdodCkpIHsgZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IGRhdGE7IH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsR2FwKGNtKSB7IHJldHVybiBzY3JvbGxlckdhcCAtIGNtLmRpc3BsYXkubmF0aXZlQmFyV2lkdGggfVxuICBmdW5jdGlvbiBkaXNwbGF5V2lkdGgoY20pIHtcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhcldpZHRoXG4gIH1cbiAgZnVuY3Rpb24gZGlzcGxheUhlaWdodChjbSkge1xuICAgIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhckhlaWdodFxuICB9XG5cbiAgLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xuICAvLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXG4gIC8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXG4gIC8vIGhlaWdodC5cbiAgZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sIGxpbmVWaWV3LCByZWN0KSB7XG4gICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKTtcbiAgICBpZiAoIWxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyB8fCB3cmFwcGluZyAmJiBsaW5lVmlldy5tZWFzdXJlLndpZHRoICE9IGN1cldpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xuICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggPSBjdXJXaWR0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IHJlY3RzW2ldLCBuZXh0ID0gcmVjdHNbaSArIDFdO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcbiAgICAgICAgICAgIHsgaGVpZ2h0cy5wdXNoKChjdXIuYm90dG9tICsgbmV4dC50b3ApIC8gMiAtIHJlY3QudG9wKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoZWlnaHRzLnB1c2gocmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgbWFwIChtYXBwaW5nIGNoYXJhY3RlciBvZmZzZXRzIHRvIHRleHQgbm9kZXMpIGFuZCBhXG4gIC8vIG1lYXN1cmVtZW50IGNhY2hlIGZvciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuIChBIGxpbmUgdmlldyBtaWdodFxuICAvLyBjb250YWluIG11bHRpcGxlIGxpbmVzIHdoZW4gY29sbGFwc2VkIHJhbmdlcyBhcmUgcHJlc2VudC4pXG4gIGZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcbiAgICBpZiAobGluZVZpZXcubGluZSA9PSBsaW5lKVxuICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXAsIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlfSB9XG4gICAgaWYgKGxpbmVWaWV3LnJlc3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxuICAgICAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldfSB9IH1cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpJDErKylcbiAgICAgICAgeyBpZiAobGluZU5vKGxpbmVWaWV3LnJlc3RbaSQxXSkgPiBsaW5lTilcbiAgICAgICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaSQxXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2kkMV0sIGJlZm9yZTogdHJ1ZX0gfSB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcbiAgLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cbiAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xuICAgIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcbiAgICB2aWV3LmxpbmVOID0gbGluZU47XG4gICAgdmFyIGJ1aWx0ID0gdmlldy5idWlsdCA9IGJ1aWxkTGluZUNvbnRlbnQoY20sIHZpZXcpO1xuICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpO1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICAvLyBHZXQgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggKGluIGxpbmUtbG9jYWwgY29vcmRpbmF0ZXMpXG4gIC8vIGZvciBhIGdpdmVuIGNoYXJhY3Rlci5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXIoY20sIGxpbmUsIGNoLCBiaWFzKSB7XG4gICAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSksIGNoLCBiaWFzKVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTikge1xuICAgIGlmIChsaW5lTiA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIGxpbmVOIDwgY20uZGlzcGxheS52aWV3VG8pXG4gICAgICB7IHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXSB9XG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGxpbmVOID49IGV4dC5saW5lTiAmJiBsaW5lTiA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxuICAgICAgeyByZXR1cm4gZXh0IH1cbiAgfVxuXG4gIC8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XG4gIC8vIGFwcGxpZXMgdG8gdGhlIHdob2xlIGxpbmUsIGFuZCB0aGUgbWVhc3VyZW1lbnQgb2YgdGhlIGFjdHVhbFxuICAvLyBjaGFyYWN0ZXIuIEZ1bmN0aW9ucyBsaWtlIGNvb3Jkc0NoYXIsIHRoYXQgbmVlZCB0byBkbyBhIGxvdCBvZlxuICAvLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xuICAvLyBvbmx5IGRvbmUgb25jZS5cbiAgZnVuY3Rpb24gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSB7XG4gICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xuICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTik7XG4gICAgaWYgKHZpZXcgJiYgIXZpZXcudGV4dCkge1xuICAgICAgdmlldyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh2aWV3ICYmIHZpZXcuY2hhbmdlcykge1xuICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIHZpZXcsIGxpbmVOLCBnZXREaW1lbnNpb25zKGNtKSk7XG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdmlldylcbiAgICAgIHsgdmlldyA9IHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpOyB9XG5cbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXG4gICAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcbiAgICAgIGhhc0hlaWdodHM6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxuICAvLyBhY3R1YWwgY2hhcmFjdGVyIChvciBmZXRjaGVzIGl0IGZyb20gdGhlIGNhY2hlKS5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWQsIGNoLCBiaWFzLCB2YXJIZWlnaHQpIHtcbiAgICBpZiAocHJlcGFyZWQuYmVmb3JlKSB7IGNoID0gLTE7IH1cbiAgICB2YXIga2V5ID0gY2ggKyAoYmlhcyB8fCBcIlwiKSwgZm91bmQ7XG4gICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGZvdW5kID0gcHJlcGFyZWQuY2FjaGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KVxuICAgICAgICB7IHByZXBhcmVkLnJlY3QgPSBwcmVwYXJlZC52aWV3LnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cbiAgICAgIGlmICghcHJlcGFyZWQuaGFzSGVpZ2h0cykge1xuICAgICAgICBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgcHJlcGFyZWQudmlldywgcHJlcGFyZWQucmVjdCk7XG4gICAgICAgIHByZXBhcmVkLmhhc0hlaWdodHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpO1xuICAgICAgaWYgKCFmb3VuZC5ib2d1cykgeyBwcmVwYXJlZC5jYWNoZVtrZXldID0gZm91bmQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIHtsZWZ0OiBmb3VuZC5sZWZ0LCByaWdodDogZm91bmQucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHZhckhlaWdodCA/IGZvdW5kLnJ0b3AgOiBmb3VuZC50b3AsXG4gICAgICAgICAgICBib3R0b206IHZhckhlaWdodCA/IGZvdW5kLnJib3R0b20gOiBmb3VuZC5ib3R0b219XG4gIH1cblxuICB2YXIgbnVsbFJlY3QgPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfTtcblxuICBmdW5jdGlvbiBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKG1hcCwgY2gsIGJpYXMpIHtcbiAgICB2YXIgbm9kZSwgc3RhcnQsIGVuZCwgY29sbGFwc2UsIG1TdGFydCwgbUVuZDtcbiAgICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxuICAgIC8vIG9yIGNsb3Nlc3QgdG8sIHRoZSB0YXJnZXQgY2hhcmFjdGVyLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBtU3RhcnQgPSBtYXBbaV07XG4gICAgICBtRW5kID0gbWFwW2kgKyAxXTtcbiAgICAgIGlmIChjaCA8IG1TdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7IGVuZCA9IDE7XG4gICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgbUVuZCkge1xuICAgICAgICBzdGFydCA9IGNoIC0gbVN0YXJ0O1xuICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gbWFwLmxlbmd0aCAtIDMgfHwgY2ggPT0gbUVuZCAmJiBtYXBbaSArIDNdID4gY2gpIHtcbiAgICAgICAgZW5kID0gbUVuZCAtIG1TdGFydDtcbiAgICAgICAgc3RhcnQgPSBlbmQgLSAxO1xuICAgICAgICBpZiAoY2ggPj0gbUVuZCkgeyBjb2xsYXBzZSA9IFwicmlnaHRcIjsgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG1hcFtpICsgMl07XG4gICAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIikpXG4gICAgICAgICAgeyBjb2xsYXBzZSA9IGJpYXM7IH1cbiAgICAgICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIgJiYgc3RhcnQgPT0gMClcbiAgICAgICAgICB7IHdoaWxlIChpICYmIG1hcFtpIC0gMl0gPT0gbWFwW2kgLSAzXSAmJiBtYXBbaSAtIDFdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgLT0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGlmIChiaWFzID09IFwicmlnaHRcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxuICAgICAgICAgIHsgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xuICAgICAgICAgICAgbm9kZSA9IG1hcFsoaSArPSAzKSArIDJdO1xuICAgICAgICAgICAgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bm9kZTogbm9kZSwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY29sbGFwc2U6IGNvbGxhcHNlLCBjb3ZlclN0YXJ0OiBtU3RhcnQsIGNvdmVyRW5kOiBtRW5kfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VXNlZnVsUmVjdChyZWN0cywgYmlhcykge1xuICAgIHZhciByZWN0ID0gbnVsbFJlY3Q7XG4gICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChyZWN0ID0gcmVjdHNbaV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9IGVsc2UgeyBmb3IgKHZhciBpJDEgPSByZWN0cy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICAgIGlmICgocmVjdCA9IHJlY3RzW2kkMV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcyk7XG4gICAgdmFyIG5vZGUgPSBwbGFjZS5ub2RlLCBzdGFydCA9IHBsYWNlLnN0YXJ0LCBlbmQgPSBwbGFjZS5lbmQsIGNvbGxhcHNlID0gcGxhY2UuY29sbGFwc2U7XG5cbiAgICB2YXIgcmVjdDtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IC8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA0OyBpJDErKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgc3RhcnQpKSkgeyAtLXN0YXJ0OyB9XG4gICAgICAgIHdoaWxlIChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kIDwgcGxhY2UuY292ZXJFbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIGVuZCkpKSB7ICsrZW5kOyB9XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiBzdGFydCA9PSAwICYmIGVuZCA9PSBwbGFjZS5jb3ZlckVuZCAtIHBsYWNlLmNvdmVyU3RhcnQpXG4gICAgICAgICAgeyByZWN0ID0gbm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJlY3QgPSBnZXRVc2VmdWxSZWN0KHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCksIGJpYXMpOyB9XG4gICAgICAgIGlmIChyZWN0LmxlZnQgfHwgcmVjdC5yaWdodCB8fCBzdGFydCA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KTsgfVxuICAgIH0gZWxzZSB7IC8vIElmIGl0IGlzIGEgd2lkZ2V0LCBzaW1wbHkgZ2V0IHRoZSBib3ggZm9yIHRoZSB3aG9sZSB3aWRnZXQuXG4gICAgICBpZiAoc3RhcnQgPiAwKSB7IGNvbGxhcHNlID0gYmlhcyA9IFwicmlnaHRcIjsgfVxuICAgICAgdmFyIHJlY3RzO1xuICAgICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcbiAgICAgICAgeyByZWN0ID0gcmVjdHNbYmlhcyA9PSBcInJpZ2h0XCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF07IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgIH1cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgIXN0YXJ0ICYmICghcmVjdCB8fCAhcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSkge1xuICAgICAgdmFyIHJTcGFuID0gbm9kZS5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICBpZiAoclNwYW4pXG4gICAgICAgIHsgcmVjdCA9IHtsZWZ0OiByU3Bhbi5sZWZ0LCByaWdodDogclNwYW4ubGVmdCArIGNoYXJXaWR0aChjbS5kaXNwbGF5KSwgdG9wOiByU3Bhbi50b3AsIGJvdHRvbTogclNwYW4uYm90dG9tfTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlY3QgPSBudWxsUmVjdDsgfVxuICAgIH1cblxuICAgIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3A7XG4gICAgdmFyIG1pZCA9IChydG9wICsgcmJvdCkgLyAyO1xuICAgIHZhciBoZWlnaHRzID0gcHJlcGFyZWQudmlldy5tZWFzdXJlLmhlaWdodHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspXG4gICAgICB7IGlmIChtaWQgPCBoZWlnaHRzW2ldKSB7IGJyZWFrIH0gfVxuICAgIHZhciB0b3AgPSBpID8gaGVpZ2h0c1tpIC0gMV0gOiAwLCBib3QgPSBoZWlnaHRzW2ldO1xuICAgIHZhciByZXN1bHQgPSB7bGVmdDogKGNvbGxhcHNlID09IFwicmlnaHRcIiA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IChjb2xsYXBzZSA9PSBcImxlZnRcIiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsIGJvdHRvbTogYm90fTtcbiAgICBpZiAoIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkgeyByZXN1bHQuYm9ndXMgPSB0cnVlOyB9XG4gICAgaWYgKCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpIHsgcmVzdWx0LnJ0b3AgPSBydG9wOyByZXN1bHQucmJvdHRvbSA9IHJib3Q7IH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXG4gIC8vIHJldHVybmVkIGluY29ycmVjdGx5IHdoZW4gem9vbWVkIG9uIElFMTAgYW5kIGJlbG93LlxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKG1lYXN1cmUsIHJlY3QpIHtcbiAgICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHxcbiAgICAgICAgc2NyZWVuLmxvZ2ljYWxYRFBJID09IHNjcmVlbi5kZXZpY2VYRFBJIHx8ICFoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSlcbiAgICAgIHsgcmV0dXJuIHJlY3QgfVxuICAgIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSTtcbiAgICB2YXIgc2NhbGVZID0gc2NyZWVuLmxvZ2ljYWxZRFBJIC8gc2NyZWVuLmRldmljZVlEUEk7XG4gICAgcmV0dXJuIHtsZWZ0OiByZWN0LmxlZnQgKiBzY2FsZVgsIHJpZ2h0OiByZWN0LnJpZ2h0ICogc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAqIHNjYWxlWSwgYm90dG9tOiByZWN0LmJvdHRvbSAqIHNjYWxlWX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubWVhc3VyZSkge1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gbnVsbDtcbiAgICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXSA9IHt9OyB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKSB7XG4gICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xuICAgIHJlbW92ZUNoaWxkcmVuKGNtLmRpc3BsYXkubGluZU1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKVxuICAgICAgeyBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGNtLmRpc3BsYXkudmlld1tpXSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XG4gICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSk7XG4gICAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlOyB9XG4gICAgY20uZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFgoZG9jKSB7XG4gICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDg5MjA2XG4gICAgLy8gd2hpY2ggY2F1c2VzIHBhZ2VfT2Zmc2V0IGFuZCBib3VuZGluZyBjbGllbnQgcmVjdHMgdG8gdXNlXG4gICAgLy8gZGlmZmVyZW50IHJlZmVyZW5jZSB2aWV3cG9ydHMgYW5kIGludmFsaWRhdGUgb3VyIGNhbGN1bGF0aW9ucy5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQpIHsgcmV0dXJuIC0oZG9jLmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jLmJvZHkpLm1hcmdpbkxlZnQpKSB9XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0Vmlldy5wYWdlWE9mZnNldCB8fCAoZG9jLmRvY3VtZW50RWxlbWVudCB8fCBkb2MuYm9keSkuc2Nyb2xsTGVmdFxuICB9XG4gIGZ1bmN0aW9uIHBhZ2VTY3JvbGxZKGRvYykge1xuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCkgeyByZXR1cm4gLShkb2MuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGRvYy5ib2R5KS5tYXJnaW5Ub3ApKSB9XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldCB8fCAoZG9jLmRvY3VtZW50RWxlbWVudCB8fCBkb2MuYm9keSkuc2Nyb2xsVG9wXG4gIH1cblxuICBmdW5jdGlvbiB3aWRnZXRUb3BIZWlnaHQobGluZU9iaikge1xuICAgIHZhciByZWYgPSB2aXN1YWxMaW5lKGxpbmVPYmopO1xuICAgIHZhciB3aWRnZXRzID0gcmVmLndpZGdldHM7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgaWYgKHdpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWRnZXRzLmxlbmd0aDsgKytpKSB7IGlmICh3aWRnZXRzW2ldLmFib3ZlKVxuICAgICAgeyBoZWlnaHQgKz0gd2lkZ2V0SGVpZ2h0KHdpZGdldHNbaV0pOyB9IH0gfVxuICAgIHJldHVybiBoZWlnaHRcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IGZyb20gbGluZS1sb2NhbFxuICAvLyBjb29yZGluYXRlcyBpbnRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uIENvbnRleHQgbWF5IGJlIG9uZSBvZlxuICAvLyBcImxpbmVcIiwgXCJkaXZcIiAoZGlzcGxheS5saW5lRGl2KSwgXCJsb2NhbFwiLi9udWxsIChlZGl0b3IpLCBcIndpbmRvd1wiLFxuICAvLyBvciBcInBhZ2VcIi5cbiAgZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0LCBpbmNsdWRlV2lkZ2V0cykge1xuICAgIGlmICghaW5jbHVkZVdpZGdldHMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSB3aWRnZXRUb3BIZWlnaHQobGluZU9iaik7XG4gICAgICByZWN0LnRvcCArPSBoZWlnaHQ7IHJlY3QuYm90dG9tICs9IGhlaWdodDtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT0gXCJsaW5lXCIpIHsgcmV0dXJuIHJlY3QgfVxuICAgIGlmICghY29udGV4dCkgeyBjb250ZXh0ID0gXCJsb2NhbFwiOyB9XG4gICAgdmFyIHlPZmYgPSBoZWlnaHRBdExpbmUobGluZU9iaik7XG4gICAgaWYgKGNvbnRleHQgPT0gXCJsb2NhbFwiKSB7IHlPZmYgKz0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KTsgfVxuICAgIGVsc2UgeyB5T2ZmIC09IGNtLmRpc3BsYXkudmlld09mZnNldDsgfVxuICAgIGlmIChjb250ZXh0ID09IFwicGFnZVwiIHx8IGNvbnRleHQgPT0gXCJ3aW5kb3dcIikge1xuICAgICAgdmFyIGxPZmYgPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHlPZmYgKz0gbE9mZi50b3AgKyAoY29udGV4dCA9PSBcIndpbmRvd1wiID8gMCA6IHBhZ2VTY3JvbGxZKGRvYyhjbSkpKTtcbiAgICAgIHZhciB4T2ZmID0gbE9mZi5sZWZ0ICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWChkb2MoY20pKSk7XG4gICAgICByZWN0LmxlZnQgKz0geE9mZjsgcmVjdC5yaWdodCArPSB4T2ZmO1xuICAgIH1cbiAgICByZWN0LnRvcCArPSB5T2ZmOyByZWN0LmJvdHRvbSArPSB5T2ZmO1xuICAgIHJldHVybiByZWN0XG4gIH1cblxuICAvLyBDb3ZlcnRzIGEgYm94IGZyb20gXCJkaXZcIiBjb29yZHMgdG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS5cbiAgLy8gQ29udGV4dCBtYXkgYmUgXCJ3aW5kb3dcIiwgXCJwYWdlXCIsIFwiZGl2XCIsIG9yIFwibG9jYWxcIi4vbnVsbC5cbiAgZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLCBjb29yZHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PSBcImRpdlwiKSB7IHJldHVybiBjb29yZHMgfVxuICAgIHZhciBsZWZ0ID0gY29vcmRzLmxlZnQsIHRvcCA9IGNvb3Jkcy50b3A7XG4gICAgLy8gRmlyc3QgbW92ZSBpbnRvIFwicGFnZVwiIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgaWYgKGNvbnRleHQgPT0gXCJwYWdlXCIpIHtcbiAgICAgIGxlZnQgLT0gcGFnZVNjcm9sbFgoZG9jKGNtKSk7XG4gICAgICB0b3AgLT0gcGFnZVNjcm9sbFkoZG9jKGNtKSk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09IFwibG9jYWxcIiB8fCAhY29udGV4dCkge1xuICAgICAgdmFyIGxvY2FsQm94ID0gY20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdDtcbiAgICAgIHRvcCArPSBsb2NhbEJveC50b3A7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTcGFjZUJveCA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7bGVmdDogbGVmdCAtIGxpbmVTcGFjZUJveC5sZWZ0LCB0b3A6IHRvcCAtIGxpbmVTcGFjZUJveC50b3B9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIGJpYXMpIHtcbiAgICBpZiAoIWxpbmVPYmopIHsgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7IH1cbiAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhcihjbSwgbGluZU9iaiwgcG9zLmNoLCBiaWFzKSwgY29udGV4dClcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib3ggZm9yIGEgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uLCB3aGljaCBtYXkgaGF2ZSBhblxuICAvLyAnb3RoZXInIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmRhcnkgY3Vyc29yXG4gIC8vIG9uIGEgYmlkaSBib3VuZGFyeS5cbiAgLy8gQSBjdXJzb3IgUG9zKGxpbmUsIGNoYXIsIFwiYmVmb3JlXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyIC0gMWBcbiAgLy8gYW5kIGFmdGVyIGBjaGFyIC0gMWAgaW4gd3JpdGluZyBvcmRlciBvZiBgY2hhciAtIDFgXG4gIC8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcImFmdGVyXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyYFxuICAvLyBhbmQgYmVmb3JlIGBjaGFyYCBpbiB3cml0aW5nIG9yZGVyIG9mIGBjaGFyYFxuICAvLyBFeGFtcGxlcyAodXBwZXItY2FzZSBsZXR0ZXJzIGFyZSBSVEwsIGxvd2VyLWNhc2UgYXJlIExUUik6XG4gIC8vICAgICBQb3MoMCwgMSwgLi4uKVxuICAvLyAgICAgYmVmb3JlICAgYWZ0ZXJcbiAgLy8gYWIgICAgIGF8YiAgICAgYXxiXG4gIC8vIGFCICAgICBhfEIgICAgIGFCfFxuICAvLyBBYiAgICAgfEFiICAgICBBfGJcbiAgLy8gQUIgICAgIEJ8QSAgICAgQnxBXG4gIC8vIEV2ZXJ5IHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IGNoYXJhY3RlciBvbiBhIGxpbmUgaXMgY29uc2lkZXJlZCB0byBzdGlja1xuICAvLyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gdGhlIGxpbmUuXG4gIGZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHZhckhlaWdodCkge1xuICAgIGxpbmVPYmogPSBsaW5lT2JqIHx8IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIGZ1bmN0aW9uIGdldChjaCwgcmlnaHQpIHtcbiAgICAgIHZhciBtID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgcmlnaHQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiwgdmFySGVpZ2h0KTtcbiAgICAgIGlmIChyaWdodCkgeyBtLmxlZnQgPSBtLnJpZ2h0OyB9IGVsc2UgeyBtLnJpZ2h0ID0gbS5sZWZ0OyB9XG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KVxuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKSwgY2ggPSBwb3MuY2gsIHN0aWNreSA9IHBvcy5zdGlja3k7XG4gICAgaWYgKGNoID49IGxpbmVPYmoudGV4dC5sZW5ndGgpIHtcbiAgICAgIGNoID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICAgIHN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgfSBlbHNlIGlmIChjaCA8PSAwKSB7XG4gICAgICBjaCA9IDA7XG4gICAgICBzdGlja3kgPSBcImFmdGVyXCI7XG4gICAgfVxuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIGdldChzdGlja3kgPT0gXCJiZWZvcmVcIiA/IGNoIC0gMSA6IGNoLCBzdGlja3kgPT0gXCJiZWZvcmVcIikgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcywgaW52ZXJ0KSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW3BhcnRQb3NdLCByaWdodCA9IHBhcnQubGV2ZWwgPT0gMTtcbiAgICAgIHJldHVybiBnZXQoaW52ZXJ0ID8gY2ggLSAxIDogY2gsIHJpZ2h0ICE9IGludmVydClcbiAgICB9XG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KTtcbiAgICB2YXIgb3RoZXIgPSBiaWRpT3RoZXI7XG4gICAgdmFyIHZhbCA9IGdldEJpZGkoY2gsIHBhcnRQb3MsIHN0aWNreSA9PSBcImJlZm9yZVwiKTtcbiAgICBpZiAob3RoZXIgIT0gbnVsbCkgeyB2YWwub3RoZXIgPSBnZXRCaWRpKGNoLCBvdGhlciwgc3RpY2t5ICE9IFwiYmVmb3JlXCIpOyB9XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcbiAgLy8gaW50ZXJtZWRpYXRlIHNjcm9sbCB1cGRhdGVzLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgbGVmdCA9IGNoYXJXaWR0aChjbS5kaXNwbGF5KSAqIHBvcy5jaDsgfVxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3A6IHRvcCwgYm90dG9tOiB0b3AgKyBsaW5lT2JqLmhlaWdodH1cbiAgfVxuXG4gIC8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cbiAgLy8geFJlbCBpcyB0aGUgcmVsYXRpdmUgeCBwb3NpdGlvbiBvZiB0aGUgaW5wdXQgY29vcmRpbmF0ZXMgY29tcGFyZWRcbiAgLy8gdG8gdGhlIGZvdW5kIHBvc2l0aW9uIChzbyB4UmVsID4gMCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgYXJlIHRvXG4gIC8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxuICAvLyBpcyB0cnVlLCB0aGF0IG1lYW5zIHRoZSBjb29yZGluYXRlcyBsaWUgb3V0c2lkZSB0aGUgbGluZSdzXG4gIC8vIHZlcnRpY2FsIHJhbmdlLlxuICBmdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4UmVsKSB7XG4gICAgdmFyIHBvcyA9IFBvcyhsaW5lLCBjaCwgc3RpY2t5KTtcbiAgICBwb3MueFJlbCA9IHhSZWw7XG4gICAgaWYgKG91dHNpZGUpIHsgcG9zLm91dHNpZGUgPSBvdXRzaWRlOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAvLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXCJkaXZcIiBjb29yZGluYXRlIHN5c3RlbSkuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgIGlmICh5IDwgMCkgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0LCAwLCBudWxsLCAtMSwgLTEpIH1cbiAgICB2YXIgbGluZU4gPSBsaW5lQXRIZWlnaHQoZG9jLCB5KSwgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAobGluZU4gPiBsYXN0KVxuICAgICAgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxLCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgsIG51bGwsIDEsIDEpIH1cbiAgICBpZiAoeCA8IDApIHsgeCA9IDA7IH1cblxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZm91bmQgPSBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVOLCB4LCB5KTtcbiAgICAgIHZhciBjb2xsYXBzZWQgPSBjb2xsYXBzZWRTcGFuQXJvdW5kKGxpbmVPYmosIGZvdW5kLmNoICsgKGZvdW5kLnhSZWwgPiAwIHx8IGZvdW5kLm91dHNpZGUgPiAwID8gMSA6IDApKTtcbiAgICAgIGlmICghY29sbGFwc2VkKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICB2YXIgcmFuZ2VFbmQgPSBjb2xsYXBzZWQuZmluZCgxKTtcbiAgICAgIGlmIChyYW5nZUVuZC5saW5lID09IGxpbmVOKSB7IHJldHVybiByYW5nZUVuZCB9XG4gICAgICBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOID0gcmFuZ2VFbmQubGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSkge1xuICAgIHkgLT0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBlbmQgPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgIHZhciBiZWdpbiA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2ggLSAxKS5ib3R0b20gPD0geTsgfSwgZW5kLCAwKTtcbiAgICBlbmQgPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoKS50b3AgPiB5OyB9LCBiZWdpbiwgZW5kKTtcbiAgICByZXR1cm4ge2JlZ2luOiBiZWdpbiwgZW5kOiBlbmR9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSB7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIHZhciB0YXJnZXRUb3AgPSBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSwgXCJsaW5lXCIpLnRvcDtcbiAgICByZXR1cm4gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0VG9wKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzaWRlIG9mIGEgYm94IGlzIGFmdGVyIHRoZSBnaXZlblxuICAvLyBjb29yZGluYXRlcywgaW4gdG9wLXRvLWJvdHRvbSwgbGVmdC10by1yaWdodCBvcmRlci5cbiAgZnVuY3Rpb24gYm94SXNBZnRlcihib3gsIHgsIHksIGxlZnQpIHtcbiAgICByZXR1cm4gYm94LmJvdHRvbSA8PSB5ID8gZmFsc2UgOiBib3gudG9wID4geSA/IHRydWUgOiAobGVmdCA/IGJveC5sZWZ0IDogYm94LnJpZ2h0KSA+IHhcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU5vLCB4LCB5KSB7XG4gICAgLy8gTW92ZSB5IGludG8gbGluZS1sb2NhbCBjb29yZGluYXRlIHNwYWNlXG4gICAgeSAtPSBoZWlnaHRBdExpbmUobGluZU9iaik7XG4gICAgdmFyIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgLy8gV2hlbiBkaXJlY3RseSBjYWxsaW5nIGBtZWFzdXJlQ2hhclByZXBhcmVkYCwgd2UgaGF2ZSB0byBhZGp1c3RcbiAgICAvLyBmb3IgdGhlIHdpZGdldHMgYXQgdGhpcyBsaW5lLlxuICAgIHZhciB3aWRnZXRIZWlnaHQgPSB3aWRnZXRUb3BIZWlnaHQobGluZU9iaik7XG4gICAgdmFyIGJlZ2luID0gMCwgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aCwgbHRyID0gdHJ1ZTtcblxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIC8vIElmIHRoZSBsaW5lIGlzbid0IHBsYWluIGxlZnQtdG8tcmlnaHQgdGV4dCwgZmlyc3QgZmlndXJlIG91dFxuICAgIC8vIHdoaWNoIGJpZGkgc2VjdGlvbiB0aGUgY29vcmRpbmF0ZXMgZmFsbCBpbnRvLlxuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnQgPSAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgPyBjb29yZHNCaWRpUGFydFdyYXBwZWQgOiBjb29yZHNCaWRpUGFydClcbiAgICAgICAgICAgICAgICAgICAoY20sIGxpbmVPYmosIGxpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSk7XG4gICAgICBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICAvLyBUaGUgYXdrd2FyZCAtMSBvZmZzZXRzIGFyZSBuZWVkZWQgYmVjYXVzZSBmaW5kRmlyc3QgKGNhbGxlZFxuICAgICAgLy8gb24gdGhlc2UgYmVsb3cpIHdpbGwgdHJlYXQgaXRzIGZpcnN0IGJvdW5kIGFzIGluY2x1c2l2ZSxcbiAgICAgIC8vIHNlY29uZCBhcyBleGNsdXNpdmUsIGJ1dCB3ZSB3YW50IHRvIGFjdHVhbGx5IGFkZHJlc3MgdGhlXG4gICAgICAvLyBjaGFyYWN0ZXJzIGluIHRoZSBwYXJ0J3MgcmFuZ2VcbiAgICAgIGJlZ2luID0gbHRyID8gcGFydC5mcm9tIDogcGFydC50byAtIDE7XG4gICAgICBlbmQgPSBsdHIgPyBwYXJ0LnRvIDogcGFydC5mcm9tIC0gMTtcbiAgICB9XG5cbiAgICAvLyBBIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgZmlyc3QgY2hhcmFjdGVyIHdob3NlIGJvdW5kaW5nIGJveFxuICAgIC8vIHN0YXJ0cyBhZnRlciB0aGUgY29vcmRpbmF0ZXMuIElmIHdlIHJ1biBhY3Jvc3MgYW55IHdob3NlIGJveCB3cmFwXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBzdG9yZSB0aGF0LlxuICAgIHZhciBjaEFyb3VuZCA9IG51bGwsIGJveEFyb3VuZCA9IG51bGw7XG4gICAgdmFyIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkge1xuICAgICAgdmFyIGJveCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gpO1xuICAgICAgYm94LnRvcCArPSB3aWRnZXRIZWlnaHQ7IGJveC5ib3R0b20gKz0gd2lkZ2V0SGVpZ2h0O1xuICAgICAgaWYgKCFib3hJc0FmdGVyKGJveCwgeCwgeSwgZmFsc2UpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoYm94LnRvcCA8PSB5ICYmIGJveC5sZWZ0IDw9IHgpIHtcbiAgICAgICAgY2hBcm91bmQgPSBjaDtcbiAgICAgICAgYm94QXJvdW5kID0gYm94O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LCBiZWdpbiwgZW5kKTtcblxuICAgIHZhciBiYXNlWCwgc3RpY2t5LCBvdXRzaWRlID0gZmFsc2U7XG4gICAgLy8gSWYgYSBib3ggYXJvdW5kIHRoZSBjb29yZGluYXRlcyB3YXMgZm91bmQsIHVzZSB0aGF0XG4gICAgaWYgKGJveEFyb3VuZCkge1xuICAgICAgLy8gRGlzdGluZ3Vpc2ggY29vcmRpbmF0ZXMgbmVhcmVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGJveFxuICAgICAgdmFyIGF0TGVmdCA9IHggLSBib3hBcm91bmQubGVmdCA8IGJveEFyb3VuZC5yaWdodCAtIHgsIGF0U3RhcnQgPSBhdExlZnQgPT0gbHRyO1xuICAgICAgY2ggPSBjaEFyb3VuZCArIChhdFN0YXJ0ID8gMCA6IDEpO1xuICAgICAgc3RpY2t5ID0gYXRTdGFydCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICBiYXNlWCA9IGF0TGVmdCA/IGJveEFyb3VuZC5sZWZ0IDogYm94QXJvdW5kLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAoQWRqdXN0IGZvciBleHRlbmRlZCBib3VuZCwgaWYgbmVjZXNzYXJ5LilcbiAgICAgIGlmICghbHRyICYmIChjaCA9PSBlbmQgfHwgY2ggPT0gYmVnaW4pKSB7IGNoKys7IH1cbiAgICAgIC8vIFRvIGRldGVybWluZSB3aGljaCBzaWRlIHRvIGFzc29jaWF0ZSB3aXRoLCBnZXQgdGhlIGJveCB0byB0aGVcbiAgICAgIC8vIGxlZnQgb2YgdGhlIGNoYXJhY3RlciBhbmQgY29tcGFyZSBpdCdzIHZlcnRpY2FsIHBvc2l0aW9uIHRvIHRoZVxuICAgICAgLy8gY29vcmRpbmF0ZXNcbiAgICAgIHN0aWNreSA9IGNoID09IDAgPyBcImFmdGVyXCIgOiBjaCA9PSBsaW5lT2JqLnRleHQubGVuZ3RoID8gXCJiZWZvcmVcIiA6XG4gICAgICAgIChtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoIC0gKGx0ciA/IDEgOiAwKSkuYm90dG9tICsgd2lkZ2V0SGVpZ2h0IDw9IHkpID09IGx0ciA/XG4gICAgICAgIFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICAvLyBOb3cgZ2V0IGFjY3VyYXRlIGNvb3JkaW5hdGVzIGZvciB0aGlzIHBsYWNlLCBpbiBvcmRlciB0byBnZXQgYVxuICAgICAgLy8gYmFzZSBYIHBvc2l0aW9uXG4gICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBjaCwgc3RpY2t5KSwgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSk7XG4gICAgICBiYXNlWCA9IGNvb3Jkcy5sZWZ0O1xuICAgICAgb3V0c2lkZSA9IHkgPCBjb29yZHMudG9wID8gLTEgOiB5ID49IGNvb3Jkcy5ib3R0b20gPyAxIDogMDtcbiAgICB9XG5cbiAgICBjaCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lT2JqLnRleHQsIGNoLCAxKTtcbiAgICByZXR1cm4gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4IC0gYmFzZVgpXG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNCaWRpUGFydChjbSwgbGluZU9iaiwgbGluZU5vLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KSB7XG4gICAgLy8gQmlkaSBwYXJ0cyBhcmUgc29ydGVkIGxlZnQtdG8tcmlnaHQsIGFuZCBpbiBhIG5vbi1saW5lLXdyYXBwaW5nXG4gICAgLy8gc2l0dWF0aW9uLCB3ZSBjYW4gdGFrZSB0aGlzIG9yZGVyaW5nIHRvIGNvcnJlc3BvbmQgdG8gdGhlIHZpc3VhbFxuICAgIC8vIG9yZGVyaW5nLiBUaGlzIGZpbmRzIHRoZSBmaXJzdCBwYXJ0IHdob3NlIGVuZCBpcyBhZnRlciB0aGUgZ2l2ZW5cbiAgICAvLyBjb29yZGluYXRlcy5cbiAgICB2YXIgaW5kZXggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV0sIGx0ciA9IHBhcnQubGV2ZWwgIT0gMTtcbiAgICAgIHJldHVybiBib3hJc0FmdGVyKGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgbHRyID8gcGFydC50byA6IHBhcnQuZnJvbSwgbHRyID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSksIHgsIHksIHRydWUpXG4gICAgfSwgMCwgb3JkZXIubGVuZ3RoIC0gMSk7XG4gICAgdmFyIHBhcnQgPSBvcmRlcltpbmRleF07XG4gICAgLy8gSWYgdGhpcyBpc24ndCB0aGUgZmlyc3QgcGFydCwgdGhlIHBhcnQncyBzdGFydCBpcyBhbHNvIGFmdGVyXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBhbmQgdGhlIGNvb3JkaW5hdGVzIGFyZW4ndCBvbiB0aGUgc2FtZSBsaW5lIGFzXG4gICAgLy8gdGhhdCBzdGFydCwgbW92ZSBvbmUgcGFydCBiYWNrLlxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHZhciBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICB2YXIgc3RhcnQgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGx0ciA/IHBhcnQuZnJvbSA6IHBhcnQudG8sIGx0ciA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpO1xuICAgICAgaWYgKGJveElzQWZ0ZXIoc3RhcnQsIHgsIHksIHRydWUpICYmIHN0YXJ0LnRvcCA+IHkpXG4gICAgICAgIHsgcGFydCA9IG9yZGVyW2luZGV4IC0gMV07IH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0JpZGlQYXJ0V3JhcHBlZChjbSwgbGluZU9iaiwgX2xpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSkge1xuICAgIC8vIEluIGEgd3JhcHBlZCBsaW5lLCBydGwgdGV4dCBvbiB3cmFwcGluZyBib3VuZGFyaWVzIGNhbiBkbyB0aGluZ3NcbiAgICAvLyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gdGhlIG9yZGVyaW5nIGluIG91ciBgb3JkZXJgIGFycmF5IGF0XG4gICAgLy8gYWxsLCBzbyBhIGJpbmFyeSBzZWFyY2ggZG9lc24ndCB3b3JrLCBhbmQgd2Ugd2FudCB0byByZXR1cm4gYVxuICAgIC8vIHBhcnQgdGhhdCBvbmx5IHNwYW5zIG9uZSBsaW5lIHNvIHRoYXQgdGhlIGJpbmFyeSBzZWFyY2ggaW5cbiAgICAvLyBjb29yZHNDaGFySW5uZXIgaXMgc2FmZS4gQXMgc3VjaCwgd2UgZmlyc3QgZmluZCB0aGUgZXh0ZW50IG9mIHRoZVxuICAgIC8vIHdyYXBwZWQgbGluZSwgYW5kIHRoZW4gZG8gYSBmbGF0IHNlYXJjaCBpbiB3aGljaCB3ZSBkaXNjYXJkIGFueVxuICAgIC8vIHNwYW5zIHRoYXQgYXJlbid0IG9uIHRoZSBsaW5lLlxuICAgIHZhciByZWYgPSB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB5KTtcbiAgICB2YXIgYmVnaW4gPSByZWYuYmVnaW47XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgaWYgKC9cXHMvLnRlc3QobGluZU9iai50ZXh0LmNoYXJBdChlbmQgLSAxKSkpIHsgZW5kLS07IH1cbiAgICB2YXIgcGFydCA9IG51bGwsIGNsb3Nlc3REaXN0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHAuZnJvbSA+PSBlbmQgfHwgcC50byA8PSBiZWdpbikgeyBjb250aW51ZSB9XG4gICAgICB2YXIgbHRyID0gcC5sZXZlbCAhPSAxO1xuICAgICAgdmFyIGVuZFggPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGx0ciA/IE1hdGgubWluKGVuZCwgcC50bykgLSAxIDogTWF0aC5tYXgoYmVnaW4sIHAuZnJvbSkpLnJpZ2h0O1xuICAgICAgLy8gV2VpZ2ggYWdhaW5zdCBzcGFucyBlbmRpbmcgYmVmb3JlIHRoaXMsIHNvIHRoYXQgdGhleSBhcmUgb25seVxuICAgICAgLy8gcGlja2VkIGlmIG5vdGhpbmcgZW5kcyBhZnRlclxuICAgICAgdmFyIGRpc3QgPSBlbmRYIDwgeCA/IHggLSBlbmRYICsgMWU5IDogZW5kWCAtIHg7XG4gICAgICBpZiAoIXBhcnQgfHwgY2xvc2VzdERpc3QgPiBkaXN0KSB7XG4gICAgICAgIHBhcnQgPSBwO1xuICAgICAgICBjbG9zZXN0RGlzdCA9IGRpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFydCkgeyBwYXJ0ID0gb3JkZXJbb3JkZXIubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBDbGlwIHRoZSBwYXJ0IHRvIHRoZSB3cmFwcGVkIGxpbmUuXG4gICAgaWYgKHBhcnQuZnJvbSA8IGJlZ2luKSB7IHBhcnQgPSB7ZnJvbTogYmVnaW4sIHRvOiBwYXJ0LnRvLCBsZXZlbDogcGFydC5sZXZlbH07IH1cbiAgICBpZiAocGFydC50byA+IGVuZCkgeyBwYXJ0ID0ge2Zyb206IHBhcnQuZnJvbSwgdG86IGVuZCwgbGV2ZWw6IHBhcnQubGV2ZWx9OyB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIHZhciBtZWFzdXJlVGV4dDtcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cbiAgZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgfVxuICAgIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XG4gICAgICBtZWFzdXJlVGV4dCA9IGVsdChcInByZVwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgICAgLy8gTWVhc3VyZSBhIGJ1bmNoIG9mIGxpbmVzLCBmb3IgYnJvd3NlcnMgdGhhdCBjb21wdXRlXG4gICAgICAvLyBmcmFjdGlvbmFsIGhlaWdodHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ5OyArK2kpIHtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFwiYnJcIikpO1xuICAgICAgfVxuICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBtZWFzdXJlVGV4dCk7XG4gICAgdmFyIGhlaWdodCA9IG1lYXN1cmVUZXh0Lm9mZnNldEhlaWdodCAvIDUwO1xuICAgIGlmIChoZWlnaHQgPiAzKSB7IGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGhlaWdodDsgfVxuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkubWVhc3VyZSk7XG4gICAgcmV0dXJuIGhlaWdodCB8fCAxXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0IGNoYXJhY3RlciB3aWR0aC5cbiAgZnVuY3Rpb24gY2hhcldpZHRoKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggfVxuICAgIHZhciBhbmNob3IgPSBlbHQoXCJzcGFuXCIsIFwieHh4eHh4eHh4eFwiKTtcbiAgICB2YXIgcHJlID0gZWx0KFwicHJlXCIsIFthbmNob3JdLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgcHJlKTtcbiAgICB2YXIgcmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAxMDtcbiAgICBpZiAod2lkdGggPiAyKSB7IGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7IH1cbiAgICByZXR1cm4gd2lkdGggfHwgMTBcbiAgfVxuXG4gIC8vIERvIGEgYnVsay1yZWFkIG9mIHRoZSBET00gcG9zaXRpb25zIGFuZCBzaXplcyBuZWVkZWQgdG8gZHJhdyB0aGVcbiAgLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgbGVmdCA9IHt9LCB3aWR0aCA9IHt9O1xuICAgIHZhciBndXR0ZXJMZWZ0ID0gZC5ndXR0ZXJzLmNsaWVudExlZnQ7XG4gICAgZm9yICh2YXIgbiA9IGQuZ3V0dGVycy5maXJzdENoaWxkLCBpID0gMDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcsICsraSkge1xuICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1tpXS5jbGFzc05hbWU7XG4gICAgICBsZWZ0W2lkXSA9IG4ub2Zmc2V0TGVmdCArIG4uY2xpZW50TGVmdCArIGd1dHRlckxlZnQ7XG4gICAgICB3aWR0aFtpZF0gPSBuLmNsaWVudFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4ge2ZpeGVkUG9zOiBjb21wZW5zYXRlRm9ySFNjcm9sbChkKSxcbiAgICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IGQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGd1dHRlckxlZnQ6IGxlZnQsXG4gICAgICAgICAgICBndXR0ZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3cmFwcGVyV2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aH1cbiAgfVxuXG4gIC8vIENvbXB1dGVzIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgLy8gYnV0IHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byBnZXQgYSBzdWItcGl4ZWwtYWNjdXJhdGVcbiAgLy8gcmVzdWx0LlxuICBmdW5jdGlvbiBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSB7XG4gICAgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcbiAgLy8gZmlyc3QgYXBwcm94aW1hdGlvbiB1bnRpbCB0aGUgbGluZSBiZWNvbWVzIHZpc2libGUgKGFuZCBpcyB0aHVzXG4gIC8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xuICAgIHZhciB0aCA9IHRleHRIZWlnaHQoY20uZGlzcGxheSksIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGNtLmRvYywgbGluZSkpIHsgcmV0dXJuIDAgfVxuXG4gICAgICB2YXIgd2lkZ2V0c0hlaWdodCA9IDA7XG4gICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB7IHdpZGdldHNIZWlnaHQgKz0gbGluZS53aWRnZXRzW2ldLmhlaWdodDsgfVxuICAgICAgfSB9XG5cbiAgICAgIGlmICh3cmFwcGluZylcbiAgICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIChNYXRoLmNlaWwobGluZS50ZXh0Lmxlbmd0aCAvIHBlckxpbmUpIHx8IDEpICogdGggfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgdGggfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBlc3QgPSBlc3RpbWF0ZUhlaWdodChjbSk7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBlc3RIZWlnaHQgPSBlc3QobGluZSk7XG4gICAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTsgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxuICAvLyBpcyBmYWxzZSwgaXQgY2hlY2tzIHdoZXRoZXIgYSBndXR0ZXIgb3Igc2Nyb2xsYmFyIHdhcyBjbGlja2VkLFxuICAvLyBhbmQgcmV0dXJucyBudWxsIGlmIGl0IHdhcy4gZm9yUmVjdCBpcyB1c2VkIGJ5IHJlY3Rhbmd1bGFyXG4gIC8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxuICAvLyBjb29yZGluYXRlcyBiZXlvbmQgdGhlIHJpZ2h0IG9mIHRoZSB0ZXh0LlxuICBmdW5jdGlvbiBwb3NGcm9tTW91c2UoY20sIGUsIGxpYmVyYWwsIGZvclJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFsaWJlcmFsICYmIGVfdGFyZ2V0KGUpLmdldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIpID09IFwidHJ1ZVwiKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciB4LCB5LCBzcGFjZSA9IGRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cbiAgICB0cnkgeyB4ID0gZS5jbGllbnRYIC0gc3BhY2UubGVmdDsgeSA9IGUuY2xpZW50WSAtIHNwYWNlLnRvcDsgfVxuICAgIGNhdGNoIChlJDEpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjb29yZHMgPSBjb29yZHNDaGFyKGNtLCB4LCB5KSwgbGluZTtcbiAgICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA+IDAgJiYgKGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY29vcmRzLmxpbmUpLnRleHQpLmxlbmd0aCA9PSBjb29yZHMuY2gpIHtcbiAgICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGNvb3JkcyA9IFBvcyhjb29yZHMubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoeCAtIHBhZGRpbmdIKGNtLmRpc3BsYXkpLmxlZnQpIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKSAtIGNvbERpZmYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3Jkc1xuICB9XG5cbiAgLy8gRmluZCB0aGUgdmlldyBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBsaW5lLiBSZXR1cm4gbnVsbFxuICAvLyB3aGVuIHRoZSBsaW5lIGlzbid0IHZpc2libGUuXG4gIGZ1bmN0aW9uIGZpbmRWaWV3SW5kZXgoY20sIG4pIHtcbiAgICBpZiAobiA+PSBjbS5kaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gbnVsbCB9XG4gICAgbiAtPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xuICAgIGlmIChuIDwgMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBuIC09IHZpZXdbaV0uc2l6ZTtcbiAgICAgIGlmIChuIDwgMCkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheS52aWV3IGRhdGEgc3RydWN0dXJlIGZvciBhIGdpdmVuIGNoYW5nZSB0byB0aGVcbiAgLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXG4gIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXG4gIC8vIHVzZWQgZm9yIGNoYW5nZXMgdGhhdCBzcGFuIG11bHRpcGxlIGxpbmVzLCBvciBjaGFuZ2UgdGhlIHdheVxuICAvLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXG4gIC8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxuICBmdW5jdGlvbiByZWdDaGFuZ2UoY20sIGZyb20sIHRvLCBsZW5kaWZmKSB7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkgeyBmcm9tID0gY20uZG9jLmZpcnN0OyB9XG4gICAgaWYgKHRvID09IG51bGwpIHsgdG8gPSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZTsgfVxuICAgIGlmICghbGVuZGlmZikgeyBsZW5kaWZmID0gMDsgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXG4gICAgICB7IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tOyB9XG5cbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAoZnJvbSA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBDaGFuZ2UgYWZ0ZXJcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKSA8IGRpc3BsYXkudmlld1RvKVxuICAgICAgICB7IHJlc2V0VmlldyhjbSk7IH1cbiAgICB9IGVsc2UgaWYgKHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gQ2hhbmdlIGJlZm9yZVxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvICsgbGVuZGlmZikgPiBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tICs9IGxlbmRpZmY7XG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20gJiYgdG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gRnVsbCBvdmVybGFwXG4gICAgICByZXNldFZpZXcoY20pO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFRvcCBvdmVybGFwXG4gICAgICB2YXIgY3V0ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0KSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShjdXQuaW5kZXgpO1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tID0gY3V0LmxpbmVOO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEJvdHRvbSBvdmVybGFwXG4gICAgICB2YXIgY3V0JDEgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICBpZiAoY3V0JDEpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dCQxLmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gPSBjdXQkMS5saW5lTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gR2FwIGluIHRoZSBtaWRkbGVcbiAgICAgIHZhciBjdXRUb3AgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICB2YXIgY3V0Qm90ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0VG9wICYmIGN1dEJvdCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KVxuICAgICAgICAgIC5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGN1dFRvcC5saW5lTiwgY3V0Qm90LmxpbmVOKSlcbiAgICAgICAgICAuY29uY2F0KGRpc3BsYXkudmlldy5zbGljZShjdXRCb3QuaW5kZXgpKTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4dCA9IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0KSB7XG4gICAgICBpZiAodG8gPCBleHQubGluZU4pXG4gICAgICAgIHsgZXh0LmxpbmVOICs9IGxlbmRpZmY7IH1cbiAgICAgIGVsc2UgaWYgKGZyb20gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcbiAgICAgICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcInRleHRcIixcbiAgLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXG4gIGZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lID49IGV4dC5saW5lTiAmJiBsaW5lIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7IH1cblxuICAgIGlmIChsaW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCBsaW5lID49IGRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XG4gICAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgdmFyIGFyciA9IGxpbmVWaWV3LmNoYW5nZXMgfHwgKGxpbmVWaWV3LmNoYW5nZXMgPSBbXSk7XG4gICAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgeyBhcnIucHVzaCh0eXBlKTsgfVxuICB9XG5cbiAgLy8gQ2xlYXIgdGhlIHZpZXcuXG4gIGZ1bmN0aW9uIHJlc2V0VmlldyhjbSkge1xuICAgIGNtLmRpc3BsYXkudmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdUbyA9IGNtLmRvYy5maXJzdDtcbiAgICBjbS5kaXNwbGF5LnZpZXcgPSBbXTtcbiAgICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlld0N1dHRpbmdQb2ludChjbSwgb2xkTiwgbmV3TiwgZGlyKSB7XG4gICAgdmFyIGluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgb2xkTiksIGRpZmYsIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgaWYgKCFzYXdDb2xsYXBzZWRTcGFucyB8fCBuZXdOID09IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplKVxuICAgICAgeyByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059IH1cbiAgICB2YXIgbiA9IGNtLmRpc3BsYXkudmlld0Zyb207XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgeyBuICs9IHZpZXdbaV0uc2l6ZTsgfVxuICAgIGlmIChuICE9IG9sZE4pIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE47XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gbiAtIG9sZE47XG4gICAgICB9XG4gICAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcbiAgICB9XG4gICAgd2hpbGUgKHZpc3VhbExpbmVObyhjbS5kb2MsIG5ld04pICE9IG5ld04pIHtcbiAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplO1xuICAgICAgaW5kZXggKz0gZGlyO1xuICAgIH1cbiAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059XG4gIH1cblxuICAvLyBGb3JjZSB0aGUgdmlldyB0byBjb3ZlciBhIGdpdmVuIHJhbmdlLCBhZGRpbmcgZW1wdHkgdmlldyBlbGVtZW50XG4gIC8vIG9yIGNsaXBwaW5nIG9mZiBleGlzdGluZyBvbmVzIGFzIG5lZWRlZC5cbiAgZnVuY3Rpb24gYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgaWYgKHZpZXcubGVuZ3RoID09IDAgfHwgZnJvbSA+PSBkaXNwbGF5LnZpZXdUbyB8fCB0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pO1xuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tID4gZnJvbSlcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgZGlzcGxheS52aWV3RnJvbSkuY29uY2F0KGRpc3BsYXkudmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShmaW5kVmlld0luZGV4KGNtLCBmcm9tKSk7IH1cbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgICAgaWYgKGRpc3BsYXkudmlld1RvIDwgdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld1RvID4gdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSk7IH1cbiAgICB9XG4gICAgZGlzcGxheS52aWV3VG8gPSB0bztcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXG4gIC8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXG4gIGZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpIHsgKytkaXJ0eTsgfVxuICAgIH1cbiAgICByZXR1cm4gZGlydHlcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihjbSkge1xuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjbS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XG4gICAgaWYgKCBwcmltYXJ5ID09PSB2b2lkIDAgKSBwcmltYXJ5ID0gdHJ1ZTtcblxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9O1xuICAgIHZhciBjdXJGcmFnbWVudCA9IHJlc3VsdC5jdXJzb3JzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBzZWxGcmFnbWVudCA9IHJlc3VsdC5zZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICB2YXIgY3VzdG9tQ3Vyc29yID0gY20ub3B0aW9ucy4kY3VzdG9tQ3Vyc29yO1xuICAgIGlmIChjdXN0b21DdXJzb3IpIHsgcHJpbWFyeSA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByaW1hcnkgJiYgaSA9PSBkb2Muc2VsLnByaW1JbmRleCkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZS5mcm9tKCkubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdUbyB8fCByYW5nZS50bygpLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBjb2xsYXBzZWQgPSByYW5nZS5lbXB0eSgpO1xuICAgICAgaWYgKGN1c3RvbUN1cnNvcikge1xuICAgICAgICB2YXIgaGVhZCA9IGN1c3RvbUN1cnNvcihjbSwgcmFuZ2UpO1xuICAgICAgICBpZiAoaGVhZCkgeyBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBoZWFkLCBjdXJGcmFnbWVudCk7IH1cbiAgICAgIH0gZWxzZSBpZiAoY29sbGFwc2VkIHx8IGNtLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpIHtcbiAgICAgICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcmFuZ2UuaGVhZCwgY3VyRnJhZ21lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2xsYXBzZWQpXG4gICAgICAgIHsgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIERyYXdzIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gcmFuZ2VcbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgaGVhZCwgb3V0cHV0KSB7XG4gICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgaGVhZCwgXCJkaXZcIiwgbnVsbCwgbnVsbCwgIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSk7XG5cbiAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvclwiKSk7XG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcInB4XCI7XG5cbiAgICBpZiAoL1xcYmNtLWZhdC1jdXJzb3JcXGIvLnRlc3QoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5jbGFzc05hbWUpKSB7XG4gICAgICB2YXIgY2hhclBvcyA9IGNoYXJDb29yZHMoY20sIGhlYWQsIFwiZGl2XCIsIG51bGwsIG51bGwpO1xuICAgICAgdmFyIHdpZHRoID0gY2hhclBvcy5yaWdodCAtIGNoYXJQb3MubGVmdDtcbiAgICAgIGN1cnNvci5zdHlsZS53aWR0aCA9ICh3aWR0aCA+IDAgPyB3aWR0aCA6IGNtLmRlZmF1bHRDaGFyV2lkdGgoKSkgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgaWYgKHBvcy5vdGhlcikge1xuICAgICAgLy8gU2Vjb25kYXJ5IGN1cnNvciwgc2hvd24gd2hlbiBvbiBhICdqdW1wJyBpbiBiaS1kaXJlY3Rpb25hbCB0ZXh0XG4gICAgICB2YXIgb3RoZXJDdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFwiXFx1MDBhMFwiLCBcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXCIpKTtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5vdGhlci5sZWZ0ICsgXCJweFwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUudG9wID0gcG9zLm90aGVyLnRvcCArIFwicHhcIjtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmhlaWdodCA9IChwb3Mub3RoZXIuYm90dG9tIC0gcG9zLm90aGVyLnRvcCkgKiAuODUgKyBcInB4XCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY21wQ29vcmRzKGEsIGIpIHsgcmV0dXJuIGEudG9wIC0gYi50b3AgfHwgYS5sZWZ0IC0gYi5sZWZ0IH1cblxuICAvLyBEcmF3cyB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBoaWdobGlnaHRlZCBzZWxlY3Rpb25cbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgb3V0cHV0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBwYWRkaW5nID0gcGFkZGluZ0goY20uZGlzcGxheSksIGxlZnRTaWRlID0gcGFkZGluZy5sZWZ0O1xuICAgIHZhciByaWdodFNpZGUgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsIGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQpIC0gcGFkZGluZy5yaWdodDtcbiAgICB2YXIgZG9jTFRSID0gZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiO1xuXG4gICAgZnVuY3Rpb24gYWRkKGxlZnQsIHRvcCwgd2lkdGgsIGJvdHRvbSkge1xuICAgICAgaWYgKHRvcCA8IDApIHsgdG9wID0gMDsgfVxuICAgICAgdG9wID0gTWF0aC5yb3VuZCh0b3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5yb3VuZChib3R0b20pO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLCAoXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IFwiICsgbGVmdCArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiICsgdG9wICsgXCJweDsgd2lkdGg6IFwiICsgKHdpZHRoID09IG51bGwgPyByaWdodFNpZGUgLSBsZWZ0IDogd2lkdGgpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIgKyAoYm90dG9tIC0gdG9wKSArIFwicHhcIikpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShsaW5lLCBmcm9tQXJnLCB0b0FyZykge1xuICAgICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSk7XG4gICAgICB2YXIgbGluZUxlbiA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQsIGVuZDtcbiAgICAgIGZ1bmN0aW9uIGNvb3JkcyhjaCwgYmlhcykge1xuICAgICAgICByZXR1cm4gY2hhckNvb3JkcyhjbSwgUG9zKGxpbmUsIGNoKSwgXCJkaXZcIiwgbGluZU9iaiwgYmlhcylcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd3JhcFgocG9zLCBkaXIsIHNpZGUpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZU9iaiwgbnVsbCwgcG9zKTtcbiAgICAgICAgdmFyIHByb3AgPSAoZGlyID09IFwibHRyXCIpID09IChzaWRlID09IFwiYWZ0ZXJcIikgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgdmFyIGNoID0gc2lkZSA9PSBcImFmdGVyXCIgPyBleHRlbnQuYmVnaW4gOiBleHRlbnQuZW5kIC0gKC9cXHMvLnRlc3QobGluZU9iai50ZXh0LmNoYXJBdChleHRlbnQuZW5kIC0gMSkpID8gMiA6IDEpO1xuICAgICAgICByZXR1cm4gY29vcmRzKGNoLCBwcm9wKVtwcm9wXVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBkb2MuZGlyZWN0aW9uKTtcbiAgICAgIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsIGZyb21BcmcgfHwgMCwgdG9BcmcgPT0gbnVsbCA/IGxpbmVMZW4gOiB0b0FyZywgZnVuY3Rpb24gKGZyb20sIHRvLCBkaXIsIGkpIHtcbiAgICAgICAgdmFyIGx0ciA9IGRpciA9PSBcImx0clwiO1xuICAgICAgICB2YXIgZnJvbVBvcyA9IGNvb3Jkcyhmcm9tLCBsdHIgPyBcImxlZnRcIiA6IFwicmlnaHRcIik7XG4gICAgICAgIHZhciB0b1BvcyA9IGNvb3Jkcyh0byAtIDEsIGx0ciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcblxuICAgICAgICB2YXIgb3BlblN0YXJ0ID0gZnJvbUFyZyA9PSBudWxsICYmIGZyb20gPT0gMCwgb3BlbkVuZCA9IHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbjtcbiAgICAgICAgdmFyIGZpcnN0ID0gaSA9PSAwLCBsYXN0ID0gIW9yZGVyIHx8IGkgPT0gb3JkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRvUG9zLnRvcCAtIGZyb21Qb3MudG9wIDw9IDMpIHsgLy8gU2luZ2xlIGxpbmVcbiAgICAgICAgICB2YXIgb3BlbkxlZnQgPSAoZG9jTFRSID8gb3BlblN0YXJ0IDogb3BlbkVuZCkgJiYgZmlyc3Q7XG4gICAgICAgICAgdmFyIG9wZW5SaWdodCA9IChkb2NMVFIgPyBvcGVuRW5kIDogb3BlblN0YXJ0KSAmJiBsYXN0O1xuICAgICAgICAgIHZhciBsZWZ0ID0gb3BlbkxlZnQgPyBsZWZ0U2lkZSA6IChsdHIgPyBmcm9tUG9zIDogdG9Qb3MpLmxlZnQ7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gb3BlblJpZ2h0ID8gcmlnaHRTaWRlIDogKGx0ciA/IHRvUG9zIDogZnJvbVBvcykucmlnaHQ7XG4gICAgICAgICAgYWRkKGxlZnQsIGZyb21Qb3MudG9wLCByaWdodCAtIGxlZnQsIGZyb21Qb3MuYm90dG9tKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gTXVsdGlwbGUgbGluZXNcbiAgICAgICAgICB2YXIgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdExlZnQsIGJvdFJpZ2h0O1xuICAgICAgICAgIGlmIChsdHIpIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSBkb2NMVFIgJiYgb3BlblN0YXJ0ICYmIGZpcnN0ID8gbGVmdFNpZGUgOiBmcm9tUG9zLmxlZnQ7XG4gICAgICAgICAgICB0b3BSaWdodCA9IGRvY0xUUiA/IHJpZ2h0U2lkZSA6IHdyYXBYKGZyb20sIGRpciwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICBib3RMZWZ0ID0gZG9jTFRSID8gbGVmdFNpZGUgOiB3cmFwWCh0bywgZGlyLCBcImFmdGVyXCIpO1xuICAgICAgICAgICAgYm90UmlnaHQgPSBkb2NMVFIgJiYgb3BlbkVuZCAmJiBsYXN0ID8gcmlnaHRTaWRlIDogdG9Qb3MucmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSAhZG9jTFRSID8gbGVmdFNpZGUgOiB3cmFwWChmcm9tLCBkaXIsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgdG9wUmlnaHQgPSAhZG9jTFRSICYmIG9wZW5TdGFydCAmJiBmaXJzdCA/IHJpZ2h0U2lkZSA6IGZyb21Qb3MucmlnaHQ7XG4gICAgICAgICAgICBib3RMZWZ0ID0gIWRvY0xUUiAmJiBvcGVuRW5kICYmIGxhc3QgPyBsZWZ0U2lkZSA6IHRvUG9zLmxlZnQ7XG4gICAgICAgICAgICBib3RSaWdodCA9ICFkb2NMVFIgPyByaWdodFNpZGUgOiB3cmFwWCh0bywgZGlyLCBcImFmdGVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGQodG9wTGVmdCwgZnJvbVBvcy50b3AsIHRvcFJpZ2h0IC0gdG9wTGVmdCwgZnJvbVBvcy5ib3R0b20pO1xuICAgICAgICAgIGlmIChmcm9tUG9zLmJvdHRvbSA8IHRvUG9zLnRvcCkgeyBhZGQobGVmdFNpZGUsIGZyb21Qb3MuYm90dG9tLCBudWxsLCB0b1Bvcy50b3ApOyB9XG4gICAgICAgICAgYWRkKGJvdExlZnQsIHRvUG9zLnRvcCwgYm90UmlnaHQgLSBib3RMZWZ0LCB0b1Bvcy5ib3R0b20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGFydCB8fCBjbXBDb29yZHMoZnJvbVBvcywgc3RhcnQpIDwgMCkgeyBzdGFydCA9IGZyb21Qb3M7IH1cbiAgICAgICAgaWYgKGNtcENvb3Jkcyh0b1Bvcywgc3RhcnQpIDwgMCkgeyBzdGFydCA9IHRvUG9zOyB9XG4gICAgICAgIGlmICghZW5kIHx8IGNtcENvb3Jkcyhmcm9tUG9zLCBlbmQpIDwgMCkgeyBlbmQgPSBmcm9tUG9zOyB9XG4gICAgICAgIGlmIChjbXBDb29yZHModG9Qb3MsIGVuZCkgPCAwKSB7IGVuZCA9IHRvUG9zOyB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH1cbiAgICB9XG5cbiAgICB2YXIgc0Zyb20gPSByYW5nZS5mcm9tKCksIHNUbyA9IHJhbmdlLnRvKCk7XG4gICAgaWYgKHNGcm9tLmxpbmUgPT0gc1RvLmxpbmUpIHtcbiAgICAgIGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzVG8uY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZnJvbUxpbmUgPSBnZXRMaW5lKGRvYywgc0Zyb20ubGluZSksIHRvTGluZSA9IGdldExpbmUoZG9jLCBzVG8ubGluZSk7XG4gICAgICB2YXIgc2luZ2xlVkxpbmUgPSB2aXN1YWxMaW5lKGZyb21MaW5lKSA9PSB2aXN1YWxMaW5lKHRvTGluZSk7XG4gICAgICB2YXIgbGVmdEVuZCA9IGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzaW5nbGVWTGluZSA/IGZyb21MaW5lLnRleHQubGVuZ3RoICsgMSA6IG51bGwpLmVuZDtcbiAgICAgIHZhciByaWdodFN0YXJ0ID0gZHJhd0ZvckxpbmUoc1RvLmxpbmUsIHNpbmdsZVZMaW5lID8gMCA6IG51bGwsIHNUby5jaCkuc3RhcnQ7XG4gICAgICBpZiAoc2luZ2xlVkxpbmUpIHtcbiAgICAgICAgaWYgKGxlZnRFbmQudG9wIDwgcmlnaHRTdGFydC50b3AgLSAyKSB7XG4gICAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCBudWxsLCBsZWZ0RW5kLmJvdHRvbSk7XG4gICAgICAgICAgYWRkKGxlZnRTaWRlLCByaWdodFN0YXJ0LnRvcCwgcmlnaHRTdGFydC5sZWZ0LCByaWdodFN0YXJ0LmJvdHRvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCByaWdodFN0YXJ0LmxlZnQgLSBsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0RW5kLmJvdHRvbSA8IHJpZ2h0U3RhcnQudG9wKVxuICAgICAgICB7IGFkZChsZWZ0U2lkZSwgbGVmdEVuZC5ib3R0b20sIG51bGwsIHJpZ2h0U3RhcnQudG9wKTsgfVxuICAgIH1cblxuICAgIG91dHB1dC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH1cblxuICAvLyBDdXJzb3ItYmxpbmtpbmdcbiAgZnVuY3Rpb24gcmVzdGFydEJsaW5rKGNtKSB7XG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IHJldHVybiB9XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGNsZWFySW50ZXJ2YWwoZGlzcGxheS5ibGlua2VyKTtcbiAgICB2YXIgb24gPSB0cnVlO1xuICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA+IDApXG4gICAgICB7IGRpc3BsYXkuYmxpbmtlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7IG9uQmx1cihjbSk7IH1cbiAgICAgICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IChvbiA9ICFvbikgPyBcIlwiIDogXCJoaWRkZW5cIjtcbiAgICAgIH0sIGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlKTsgfVxuICAgIGVsc2UgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlIDwgMClcbiAgICAgIHsgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUZvY3VzKGNtKSB7XG4gICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgb25Gb2N1cyhjbSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSkge1xuICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XG4gICAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgb25CbHVyKGNtKTsgfVxuICAgIH0gfSwgMTAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRm9jdXMoY20sIGUpIHtcbiAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dCkgeyBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlOyB9XG5cbiAgICBpZiAoY20ub3B0aW9ucy5yZWFkT25seSA9PSBcIm5vY3Vyc29yXCIpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgIHNpZ25hbChjbSwgXCJmb2N1c1wiLCBjbSwgZSk7XG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAvLyBUaGlzIHRlc3QgcHJldmVudHMgdGhpcyBmcm9tIGZpcmluZyB3aGVuIGEgY29udGV4dFxuICAgICAgLy8gbWVudSBpcyBjbG9zZWQgKHNpbmNlIHRoZSBpbnB1dCByZXNldCB3b3VsZCBraWxsIHRoZVxuICAgICAgLy8gc2VsZWN0LWFsbCBkZXRlY3Rpb24gaGFjaylcbiAgICAgIGlmICghY20uY3VyT3AgJiYgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSAhPSBjbS5kb2Muc2VsKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgaWYgKHdlYmtpdCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKTsgfSAvLyBJc3N1ZSAjMTczMFxuICAgICAgfVxuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKCk7XG4gICAgfVxuICAgIHJlc3RhcnRCbGluayhjbSk7XG4gIH1cbiAgZnVuY3Rpb24gb25CbHVyKGNtLCBlKSB7XG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7IHJldHVybiB9XG5cbiAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgc2lnbmFsKGNtLCBcImJsdXJcIiwgY20sIGUpO1xuICAgICAgY20uc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIH1cbiAgICBjbGVhckludGVydmFsKGNtLmRpc3BsYXkuYmxpbmtlcik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7IH0gfSwgMTUwKTtcbiAgfVxuXG4gIC8vIFJlYWQgdGhlIGFjdHVhbCBoZWlnaHRzIG9mIHRoZSByZW5kZXJlZCBsaW5lcywgYW5kIHVwZGF0ZSB0aGVpclxuICAvLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cbiAgZnVuY3Rpb24gdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIHByZXZCb3R0b20gPSBkaXNwbGF5LmxpbmVEaXYub2Zmc2V0VG9wO1xuICAgIHZhciB2aWV3VG9wID0gTWF0aC5tYXgoMCwgZGlzcGxheS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xuICAgIHZhciBvbGRIZWlnaHQgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIHZhciBtdXN0U2Nyb2xsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IGRpc3BsYXkudmlld1tpXSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICAgIHZhciBoZWlnaHQgPSAodm9pZCAwKSwgd2lkdGggPSAwO1xuICAgICAgaWYgKGN1ci5oaWRkZW4pIHsgY29udGludWUgfVxuICAgICAgb2xkSGVpZ2h0ICs9IGN1ci5saW5lLmhlaWdodDtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xuICAgICAgICB2YXIgYm90ID0gY3VyLm5vZGUub2Zmc2V0VG9wICsgY3VyLm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSBib3QgLSBwcmV2Qm90dG9tO1xuICAgICAgICBwcmV2Qm90dG9tID0gYm90O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJveCA9IGN1ci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBoZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBsaW5lcyBkb24ndCBleHRlbmQgcGFzdCB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gZWRpdG9yIHdpZHRoXG4gICAgICAgIGlmICghd3JhcHBpbmcgJiYgY3VyLnRleHQuZmlyc3RDaGlsZClcbiAgICAgICAgICB7IHdpZHRoID0gY3VyLnRleHQuZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAtIGJveC5sZWZ0IC0gMTsgfVxuICAgICAgfVxuICAgICAgdmFyIGRpZmYgPSBjdXIubGluZS5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICBpZiAoZGlmZiA+IC4wMDUgfHwgZGlmZiA8IC0uMDA1KSB7XG4gICAgICAgIGlmIChvbGRIZWlnaHQgPCB2aWV3VG9wKSB7IG11c3RTY3JvbGwgLT0gZGlmZjsgfVxuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGN1ci5saW5lLCBoZWlnaHQpO1xuICAgICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO1xuICAgICAgICBpZiAoY3VyLnJlc3QpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBjdXIucmVzdC5sZW5ndGg7IGorKylcbiAgICAgICAgICB7IHVwZGF0ZVdpZGdldEhlaWdodChjdXIucmVzdFtqXSk7IH0gfVxuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID4gY20uZGlzcGxheS5zaXplcldpZHRoKSB7XG4gICAgICAgIHZhciBjaFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKTtcbiAgICAgICAgaWYgKGNoV2lkdGggPiBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGggPSBjaFdpZHRoO1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IGN1ci5saW5lO1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhtdXN0U2Nyb2xsKSA+IDIpIHsgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gbXVzdFNjcm9sbDsgfVxuICB9XG5cbiAgLy8gUmVhZCBhbmQgc3RvcmUgdGhlIGhlaWdodCBvZiBsaW5lIHdpZGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAvLyBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiB1cGRhdGVXaWRnZXRIZWlnaHQobGluZSkge1xuICAgIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB3ID0gbGluZS53aWRnZXRzW2ldLCBwYXJlbnQgPSB3Lm5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQpIHsgdy5oZWlnaHQgPSBwYXJlbnQub2Zmc2V0SGVpZ2h0OyB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXG4gIC8vIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcbiAgLy8gaGVpZ2h0LCBhbmQgZW5zdXJlIChzZWUgb3Auc2Nyb2xsVG9Qb3MpIHByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MsIHZpZXdwb3J0KSB7XG4gICAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIHRvcCA9IE1hdGguZmxvb3IodG9wIC0gcGFkZGluZ1RvcChkaXNwbGF5KSk7XG4gICAgdmFyIGJvdHRvbSA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LmJvdHRvbSAhPSBudWxsID8gdmlld3BvcnQuYm90dG9tIDogdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcblxuICAgIHZhciBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgdG9wKSwgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBib3R0b20pO1xuICAgIC8vIEVuc3VyZSBpcyBhIHtmcm9tOiB7bGluZSwgY2h9LCB0bzoge2xpbmUsIGNofX0gb2JqZWN0LCBhbmRcbiAgICAvLyBmb3JjZXMgdGhvc2UgbGluZXMgaW50byB0aGUgdmlld3BvcnQgKGlmIHBvc3NpYmxlKS5cbiAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XG4gICAgICB2YXIgZW5zdXJlRnJvbSA9IHZpZXdwb3J0LmVuc3VyZS5mcm9tLmxpbmUsIGVuc3VyZVRvID0gdmlld3BvcnQuZW5zdXJlLnRvLmxpbmU7XG4gICAgICBpZiAoZW5zdXJlRnJvbSA8IGZyb20pIHtcbiAgICAgICAgZnJvbSA9IGVuc3VyZUZyb207XG4gICAgICAgIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVGcm9tKSkgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5taW4oZW5zdXJlVG8sIGRvYy5sYXN0TGluZSgpKSA+PSB0bykge1xuICAgICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIHRvID0gZW5zdXJlVG87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7ZnJvbTogZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSl9XG4gIH1cblxuICAvLyBTQ1JPTExJTkcgVEhJTkdTIElOVE8gVklFV1xuXG4gIC8vIElmIGFuIGVkaXRvciBzaXRzIG9uIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSB3aW5kb3csIHBhcnRpYWxseVxuICAvLyBzY3JvbGxlZCBvdXQgb2YgdmlldywgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBpcyB2aXNpYmxlLlxuICBmdW5jdGlvbiBtYXliZVNjcm9sbFdpbmRvdyhjbSwgcmVjdCkge1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgXCJzY3JvbGxDdXJzb3JJbnRvVmlld1wiKSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBib3ggPSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb1Njcm9sbCA9IG51bGw7XG4gICAgdmFyIGRvYyA9IGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50O1xuICAgIGlmIChyZWN0LnRvcCArIGJveC50b3AgPCAwKSB7IGRvU2Nyb2xsID0gdHJ1ZTsgfVxuICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tICsgYm94LnRvcCA+IChkb2MuZGVmYXVsdFZpZXcuaW5uZXJIZWlnaHQgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpKSB7IGRvU2Nyb2xsID0gZmFsc2U7IH1cbiAgICBpZiAoZG9TY3JvbGwgIT0gbnVsbCAmJiAhcGhhbnRvbSkge1xuICAgICAgdmFyIHNjcm9sbE5vZGUgPSBlbHQoXCJkaXZcIiwgXCJcXHUyMDBiXCIsIG51bGwsIChcInBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIiArIChyZWN0LnRvcCAtIGRpc3BsYXkudmlld09mZnNldCAtIHBhZGRpbmdUb3AoY20uZGlzcGxheSkpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wICsgc2Nyb2xsR2FwKGNtKSArIGRpc3BsYXkuYmFySGVpZ2h0KSArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiICsgKHJlY3QubGVmdCkgKyBcInB4OyB3aWR0aDogXCIgKyAoTWF0aC5tYXgoMiwgcmVjdC5yaWdodCAtIHJlY3QubGVmdCkpICsgXCJweDtcIikpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuYXBwZW5kQ2hpbGQoc2Nyb2xsTm9kZSk7XG4gICAgICBzY3JvbGxOb2RlLnNjcm9sbEludG9WaWV3KGRvU2Nyb2xsKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKHNjcm9sbE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHBvc2l0aW9uIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLCB2ZXJpZnlpbmcgdGhhdFxuICAvLyBpdCBhY3R1YWxseSBiZWNhbWUgdmlzaWJsZSAoYXMgbGluZSBoZWlnaHRzIGFyZSBhY2N1cmF0ZWx5XG4gIC8vIG1lYXN1cmVkLCB0aGUgcG9zaXRpb24gb2Ygc29tZXRoaW5nIG1heSAnZHJpZnQnIGR1cmluZyBkcmF3aW5nKS5cbiAgZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIHBvcywgZW5kLCBtYXJnaW4pIHtcbiAgICBpZiAobWFyZ2luID09IG51bGwpIHsgbWFyZ2luID0gMDsgfVxuICAgIHZhciByZWN0O1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgcG9zID09IGVuZCkge1xuICAgICAgLy8gU2V0IHBvcyBhbmQgZW5kIHRvIHRoZSBjdXJzb3IgcG9zaXRpb25zIGFyb3VuZCB0aGUgY2hhcmFjdGVyIHBvcyBzdGlja3MgdG9cbiAgICAgIC8vIElmIHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiwgdGhhdCBpcyBhcm91bmQgcG9zLmNoIC0gMSwgb3RoZXJ3aXNlIGFyb3VuZCBwb3MuY2hcbiAgICAgIC8vIElmIHBvcyA9PSBQb3MoXywgMCwgXCJiZWZvcmVcIiksIHBvcyBhbmQgZW5kIGFyZSB1bmNoYW5nZWRcbiAgICAgIGVuZCA9IHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IFBvcyhwb3MubGluZSwgcG9zLmNoICsgMSwgXCJiZWZvcmVcIikgOiBwb3M7XG4gICAgICBwb3MgPSBwb3MuY2ggPyBQb3MocG9zLmxpbmUsIHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IHBvcy5jaCAtIDEgOiBwb3MuY2gsIFwiYWZ0ZXJcIikgOiBwb3M7XG4gICAgfVxuICAgIGZvciAodmFyIGxpbWl0ID0gMDsgbGltaXQgPCA1OyBsaW1pdCsrKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgcG9zKTtcbiAgICAgIHZhciBlbmRDb29yZHMgPSAhZW5kIHx8IGVuZCA9PSBwb3MgPyBjb29yZHMgOiBjdXJzb3JDb29yZHMoY20sIGVuZCk7XG4gICAgICByZWN0ID0ge2xlZnQ6IE1hdGgubWluKGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXG4gICAgICAgICAgICAgIHRvcDogTWF0aC5taW4oY29vcmRzLnRvcCwgZW5kQ29vcmRzLnRvcCkgLSBtYXJnaW4sXG4gICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxuICAgICAgICAgICAgICBib3R0b206IE1hdGgubWF4KGNvb3Jkcy5ib3R0b20sIGVuZENvb3Jkcy5ib3R0b20pICsgbWFyZ2lufTtcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpO1xuICAgICAgdmFyIHN0YXJ0VG9wID0gY20uZG9jLnNjcm9sbFRvcCwgc3RhcnRMZWZ0ID0gY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSBzdGFydExlZnQpID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgaWYgKCFjaGFuZ2VkKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcyBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KS5cbiAgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY20sIHJlY3QpIHtcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KTtcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7IH1cbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkgeyBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7IH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhIG5ldyBzY3JvbGwgcG9zaXRpb24gbmVlZGVkIHRvIHNjcm9sbCB0aGUgZ2l2ZW5cbiAgLy8gcmVjdGFuZ2xlIGludG8gdmlldy4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzY3JvbGxUb3AgYW5kXG4gIC8vIHNjcm9sbExlZnQgcHJvcGVydGllcy4gV2hlbiB0aGVzZSBhcmUgdW5kZWZpbmVkLCB0aGVcbiAgLy8gdmVydGljYWwvaG9yaXpvbnRhbCBwb3NpdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkanVzdGVkLlxuICBmdW5jdGlvbiBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNuYXBNYXJnaW4gPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpO1xuICAgIGlmIChyZWN0LnRvcCA8IDApIHsgcmVjdC50b3AgPSAwOyB9XG4gICAgdmFyIHNjcmVlbnRvcCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsVG9wIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgdmFyIHNjcmVlbiA9IGRpc3BsYXlIZWlnaHQoY20pLCByZXN1bHQgPSB7fTtcbiAgICBpZiAocmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IHNjcmVlbikgeyByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgc2NyZWVuOyB9XG4gICAgdmFyIGRvY0JvdHRvbSA9IGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChkaXNwbGF5KTtcbiAgICB2YXIgYXRUb3AgPSByZWN0LnRvcCA8IHNuYXBNYXJnaW4sIGF0Qm90dG9tID0gcmVjdC5ib3R0b20gPiBkb2NCb3R0b20gLSBzbmFwTWFyZ2luO1xuICAgIGlmIChyZWN0LnRvcCA8IHNjcmVlbnRvcCkge1xuICAgICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHJlY3QudG9wO1xuICAgIH0gZWxzZSBpZiAocmVjdC5ib3R0b20gPiBzY3JlZW50b3AgKyBzY3JlZW4pIHtcbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgKGF0Qm90dG9tID8gZG9jQm90dG9tIDogcmVjdC5ib3R0b20pIC0gc2NyZWVuKTtcbiAgICAgIGlmIChuZXdUb3AgIT0gc2NyZWVudG9wKSB7IHJlc3VsdC5zY3JvbGxUb3AgPSBuZXdUb3A7IH1cbiAgICB9XG5cbiAgICB2YXIgZ3V0dGVyU3BhY2UgPSBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gMCA6IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgc2NyZWVubGVmdCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbExlZnQgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbExlZnQgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgLSBndXR0ZXJTcGFjZTtcbiAgICB2YXIgc2NyZWVudyA9IGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHRvb1dpZGUgPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0ID4gc2NyZWVudztcbiAgICBpZiAodG9vV2lkZSkgeyByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgc2NyZWVudzsgfVxuICAgIGlmIChyZWN0LmxlZnQgPCAxMClcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSAwOyB9XG4gICAgZWxzZSBpZiAocmVjdC5sZWZ0IDwgc2NyZWVubGVmdClcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQgKyBndXR0ZXJTcGFjZSAtICh0b29XaWRlID8gMCA6IDEwKSk7IH1cbiAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gc2NyZWVudyArIHNjcmVlbmxlZnQgLSAzKVxuICAgICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IHJlY3QucmlnaHQgKyAodG9vV2lkZSA/IDAgOiAxMCkgLSBzY3JlZW53OyB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gU3RvcmUgYSByZWxhdGl2ZSBhZGp1c3RtZW50IHRvIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAgLy8gb3BlcmF0aW9uICh0byBiZSBhcHBsaWVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaW5pc2hlcykuXG4gIGZ1bmN0aW9uIGFkZFRvU2Nyb2xsVG9wKGNtLCB0b3ApIHtcbiAgICBpZiAodG9wID09IG51bGwpIHsgcmV0dXJuIH1cbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvcCA9IChjbS5jdXJPcC5zY3JvbGxUb3AgPT0gbnVsbCA/IGNtLmRvYy5zY3JvbGxUb3AgOiBjbS5jdXJPcC5zY3JvbGxUb3ApICsgdG9wO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uIHRoZSBjdXJyZW50IGN1cnNvciBpc1xuICAvLyBzaG93bi5cbiAgZnVuY3Rpb24gZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSkge1xuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcigpO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0ge2Zyb206IGN1ciwgdG86IGN1ciwgbWFyZ2luOiBjbS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbn07XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb0Nvb3JkcyhjbSwgeCwgeSkge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSB7IHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7IH1cbiAgICBpZiAoeCAhPSBudWxsKSB7IGNtLmN1ck9wLnNjcm9sbExlZnQgPSB4OyB9XG4gICAgaWYgKHkgIT0gbnVsbCkgeyBjbS5jdXJPcC5zY3JvbGxUb3AgPSB5OyB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb1JhbmdlKGNtLCByYW5nZSkge1xuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSByYW5nZTtcbiAgfVxuXG4gIC8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxuICAvLyBzY3JvbGwgYWN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiwgdGhpc1xuICAvLyAnc2ltdWxhdGVzJyBzY3JvbGxpbmcgdGhhdCBwb3NpdGlvbiBpbnRvIHZpZXcgaW4gYSBjaGVhcCB3YXksIHNvXG4gIC8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxuICBmdW5jdGlvbiByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIHtcbiAgICB2YXIgcmFuZ2UgPSBjbS5jdXJPcC5zY3JvbGxUb1BvcztcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gbnVsbDtcbiAgICAgIHZhciBmcm9tID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLmZyb20pLCB0byA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS50byk7XG4gICAgICBzY3JvbGxUb0Nvb3Jkc1JhbmdlKGNtLCBmcm9tLCB0bywgcmFuZ2UubWFyZ2luKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb0Nvb3Jkc1JhbmdlKGNtLCBmcm9tLCB0bywgbWFyZ2luKSB7XG4gICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHtcbiAgICAgIGxlZnQ6IE1hdGgubWluKGZyb20ubGVmdCwgdG8ubGVmdCksXG4gICAgICB0b3A6IE1hdGgubWluKGZyb20udG9wLCB0by50b3ApIC0gbWFyZ2luLFxuICAgICAgcmlnaHQ6IE1hdGgubWF4KGZyb20ucmlnaHQsIHRvLnJpZ2h0KSxcbiAgICAgIGJvdHRvbTogTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyBtYXJnaW5cbiAgICB9KTtcbiAgICBzY3JvbGxUb0Nvb3JkcyhjbSwgc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcCk7XG4gIH1cblxuICAvLyBTeW5jIHRoZSBzY3JvbGxhYmxlIGFyZWEgYW5kIHNjcm9sbGJhcnMsIGVuc3VyZSB0aGUgdmlld3BvcnRcbiAgLy8gY292ZXJzIHRoZSB2aXNpYmxlIGFyZWEuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbFRvcChjbSwgdmFsKSB7XG4gICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSB2YWwpIDwgMikgeyByZXR1cm4gfVxuICAgIGlmICghZ2Vja28pIHsgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwge3RvcDogdmFsfSk7IH1cbiAgICBzZXRTY3JvbGxUb3AoY20sIHZhbCwgdHJ1ZSk7XG4gICAgaWYgKGdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pOyB9XG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCwgZm9yY2VTY3JvbGwpIHtcbiAgICB2YWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LCB2YWwpKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPT0gdmFsICYmICFmb3JjZVNjcm9sbCkgeyByZXR1cm4gfVxuICAgIGNtLmRvYy5zY3JvbGxUb3AgPSB2YWw7XG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcCh2YWwpO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSB2YWw7IH1cbiAgfVxuXG4gIC8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXG4gIC8vIGFsaWduZWQuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlciwgZm9yY2VTY3JvbGwpIHtcbiAgICB2YWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWwsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKSk7XG4gICAgaWYgKChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgJiYgIWZvcmNlU2Nyb2xsKSB7IHJldHVybiB9XG4gICAgY20uZG9jLnNjcm9sbExlZnQgPSB2YWw7XG4gICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gdmFsKSB7IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHZhbDsgfVxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbCk7XG4gIH1cblxuICAvLyBTQ1JPTExCQVJTXG5cbiAgLy8gUHJlcGFyZSBET00gcmVhZHMgbmVlZGVkIHRvIHVwZGF0ZSB0aGUgc2Nyb2xsYmFycy4gRG9uZSBpbiBvbmVcbiAgLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxuICBmdW5jdGlvbiBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgZ3V0dGVyVyA9IGQuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgZG9jSCA9IE1hdGgucm91bmQoY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50SGVpZ2h0OiBkLnNjcm9sbGVyLmNsaWVudEhlaWdodCxcbiAgICAgIHZpZXdIZWlnaHQ6IGQud3JhcHBlci5jbGllbnRIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogZC5zY3JvbGxlci5zY3JvbGxXaWR0aCwgY2xpZW50V2lkdGg6IGQuc2Nyb2xsZXIuY2xpZW50V2lkdGgsXG4gICAgICB2aWV3V2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aCxcbiAgICAgIGJhckxlZnQ6IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBndXR0ZXJXIDogMCxcbiAgICAgIGRvY0hlaWdodDogZG9jSCxcbiAgICAgIHNjcm9sbEhlaWdodDogZG9jSCArIHNjcm9sbEdhcChjbSkgKyBkLmJhckhlaWdodCxcbiAgICAgIG5hdGl2ZUJhcldpZHRoOiBkLm5hdGl2ZUJhcldpZHRoLFxuICAgICAgZ3V0dGVyV2lkdGg6IGd1dHRlcldcbiAgICB9XG4gIH1cblxuICB2YXIgTmF0aXZlU2Nyb2xsYmFycyA9IGZ1bmN0aW9uKHBsYWNlLCBzY3JvbGwsIGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJtaW4td2lkdGg6IDFweFwiKV0sIFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXCIpO1xuICAgIHZhciBob3JpeiA9IHRoaXMuaG9yaXogPSBlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBudWxsLCBudWxsLCBcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcIik7XG4gICAgdmVydC50YWJJbmRleCA9IGhvcml6LnRhYkluZGV4ID0gLTE7XG4gICAgcGxhY2UodmVydCk7IHBsYWNlKGhvcml6KTtcblxuICAgIG9uKHZlcnQsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2ZXJ0LmNsaWVudEhlaWdodCkgeyBzY3JvbGwodmVydC5zY3JvbGxUb3AsIFwidmVydGljYWxcIik7IH1cbiAgICB9KTtcbiAgICBvbihob3JpeiwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGhvcml6LmNsaWVudFdpZHRoKSB7IHNjcm9sbChob3Jpei5zY3JvbGxMZWZ0LCBcImhvcml6b250YWxcIik7IH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IGZhbHNlO1xuICAgIC8vIE5lZWQgdG8gc2V0IGEgbWluaW11bSB3aWR0aCB0byBzZWUgdGhlIHNjcm9sbGJhciBvbiBJRTcgKGJ1dCBtdXN0IG5vdCBzZXQgaXQgb24gSUU4KS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgdGhpcy5ob3Jpei5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUubWluV2lkdGggPSBcIjE4cHhcIjsgfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcbiAgICB2YXIgbmVlZHNWID0gbWVhc3VyZS5zY3JvbGxIZWlnaHQgPiBtZWFzdXJlLmNsaWVudEhlaWdodCArIDE7XG4gICAgdmFyIHNXaWR0aCA9IG1lYXN1cmUubmF0aXZlQmFyV2lkdGg7XG5cbiAgICBpZiAobmVlZHNWKSB7XG4gICAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5ib3R0b20gPSBuZWVkc0ggPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIHZhciB0b3RhbEhlaWdodCA9IG1lYXN1cmUudmlld0hlaWdodCAtIChuZWVkc0ggPyBzV2lkdGggOiAwKTtcbiAgICAgIC8vIEEgYnVnIGluIElFOCBjYW4gY2F1c2UgdGhpcyB2YWx1ZSB0byBiZSBuZWdhdGl2ZSwgc28gZ3VhcmQgaXQuXG4gICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPVxuICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbEhlaWdodCAtIG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgdG90YWxIZWlnaHQpICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0gpIHtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUucmlnaHQgPSBuZWVkc1YgPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUubGVmdCA9IG1lYXN1cmUuYmFyTGVmdCArIFwicHhcIjtcbiAgICAgIHZhciB0b3RhbFdpZHRoID0gbWVhc3VyZS52aWV3V2lkdGggLSBtZWFzdXJlLmJhckxlZnQgLSAobmVlZHNWID8gc1dpZHRoIDogMCk7XG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxuICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbFdpZHRoIC0gbWVhc3VyZS5jbGllbnRXaWR0aCArIHRvdGFsV2lkdGgpICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGggJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICBpZiAoc1dpZHRoID09IDApIHsgdGhpcy56ZXJvV2lkdGhIYWNrKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtyaWdodDogbmVlZHNWID8gc1dpZHRoIDogMCwgYm90dG9tOiBuZWVkc0ggPyBzV2lkdGggOiAwfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgaWYgKHRoaXMuaG9yaXouc2Nyb2xsTGVmdCAhPSBwb3MpIHsgdGhpcy5ob3Jpei5zY3JvbGxMZWZ0ID0gcG9zOyB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZUhvcml6KSB7IHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosIHRoaXMuZGlzYWJsZUhvcml6LCBcImhvcml6XCIpOyB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHBvcykge1xuICAgIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykgeyB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gcG9zOyB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZVZlcnQpIHsgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy52ZXJ0LCB0aGlzLmRpc2FibGVWZXJ0LCBcInZlcnRcIik7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS56ZXJvV2lkdGhIYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB3ID0gbWFjICYmICFtYWNfZ2VNb3VudGFpbkxpb24gPyBcIjEycHhcIiA6IFwiMThweFwiO1xuICAgIHRoaXMuaG9yaXouc3R5bGUuaGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLndpZHRoID0gdztcbiAgICB0aGlzLmhvcml6LnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLnZlcnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgdGhpcy5kaXNhYmxlSG9yaXogPSBuZXcgRGVsYXllZDtcbiAgICB0aGlzLmRpc2FibGVWZXJ0ID0gbmV3IERlbGF5ZWQ7XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuZW5hYmxlWmVyb1dpZHRoQmFyID0gZnVuY3Rpb24gKGJhciwgZGVsYXksIHR5cGUpIHtcbiAgICBiYXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgZnVuY3Rpb24gbWF5YmVEaXNhYmxlKCkge1xuICAgICAgLy8gVG8gZmluZCBvdXQgd2hldGhlciB0aGUgc2Nyb2xsYmFyIGlzIHN0aWxsIHZpc2libGUsIHdlXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBlbGVtZW50IHVuZGVyIHRoZSBwaXhlbCBpbiB0aGUgYm90dG9tXG4gICAgICAvLyByaWdodCBjb3JuZXIgb2YgdGhlIHNjcm9sbGJhciBib3ggaXMgdGhlIHNjcm9sbGJhciBib3hcbiAgICAgIC8vIGl0c2VsZiAod2hlbiB0aGUgYmFyIGlzIHN0aWxsIHZpc2libGUpIG9yIGl0cyBmaWxsZXIgY2hpbGRcbiAgICAgIC8vICh3aGVuIHRoZSBiYXIgaXMgaGlkZGVuKS4gSWYgaXQgaXMgc3RpbGwgdmlzaWJsZSwgd2Uga2VlcFxuICAgICAgLy8gaXQgZW5hYmxlZCwgaWYgaXQncyBoaWRkZW4sIHdlIGRpc2FibGUgcG9pbnRlciBldmVudHMuXG4gICAgICB2YXIgYm94ID0gYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGVsdCA9IHR5cGUgPT0gXCJ2ZXJ0XCIgPyBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGJveC5yaWdodCAtIDEsIChib3gudG9wICsgYm94LmJvdHRvbSkgLyAyKVxuICAgICAgICAgIDogZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCgoYm94LnJpZ2h0ICsgYm94LmxlZnQpIC8gMiwgYm94LmJvdHRvbSAtIDEpO1xuICAgICAgaWYgKGVsdCAhPSBiYXIpIHsgYmFyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiOyB9XG4gICAgICBlbHNlIHsgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7IH1cbiAgICB9XG4gICAgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuaG9yaXoucGFyZW50Tm9kZTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3Jpeik7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMudmVydCk7XG4gIH07XG5cbiAgdmFyIE51bGxTY3JvbGxiYXJzID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHtib3R0b206IDAsIHJpZ2h0OiAwfSB9O1xuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHt9O1xuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG1lYXN1cmUpIHtcbiAgICBpZiAoIW1lYXN1cmUpIHsgbWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTsgfVxuICAgIHZhciBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aCwgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodDtcbiAgICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAmJiBzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggfHwgc3RhcnRIZWlnaHQgIT0gY20uZGlzcGxheS5iYXJIZWlnaHQ7IGkrKykge1xuICAgICAgaWYgKHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7IH1cbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKTtcbiAgICAgIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoOyBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlLXN5bmNocm9uaXplIHRoZSBmYWtlIHNjcm9sbGJhcnMgd2l0aCB0aGUgYWN0dWFsIHNpemUgb2YgdGhlXG4gIC8vIGNvbnRlbnQuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICB2YXIgc2l6ZXMgPSBkLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpO1xuXG4gICAgZC5zaXplci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAoZC5iYXJXaWR0aCA9IHNpemVzLnJpZ2h0KSArIFwicHhcIjtcbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXCJweFwiO1xuICAgIGQuaGVpZ2h0Rm9yY2VyLnN0eWxlLmJvcmRlckJvdHRvbSA9IHNpemVzLmJvdHRvbSArIFwicHggc29saWQgdHJhbnNwYXJlbnRcIjtcblxuICAgIGlmIChzaXplcy5yaWdodCAmJiBzaXplcy5ib3R0b20pIHtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcInB4XCI7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXCJweFwiO1xuICAgIH0gZWxzZSB7IGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB9XG4gICAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcInB4XCI7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS53aWR0aCA9IG1lYXN1cmUuZ3V0dGVyV2lkdGggKyBcInB4XCI7XG4gICAgfSBlbHNlIHsgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgfVxuXG4gIHZhciBzY3JvbGxiYXJNb2RlbCA9IHtcIm5hdGl2ZVwiOiBOYXRpdmVTY3JvbGxiYXJzLCBcIm51bGxcIjogTnVsbFNjcm9sbGJhcnN9O1xuXG4gIGZ1bmN0aW9uIGluaXRTY3JvbGxiYXJzKGNtKSB7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycykge1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLmNsZWFyKCk7XG4gICAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxuICAgICAgICB7IHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpOyB9XG4gICAgfVxuXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzID0gbmV3IHNjcm9sbGJhck1vZGVsW2NtLm9wdGlvbnMuc2Nyb2xsYmFyU3R5bGVdKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBjbS5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGNtLmRpc3BsYXkuc2Nyb2xsYmFyRmlsbGVyKTtcbiAgICAgIC8vIFByZXZlbnQgY2xpY2tzIGluIHRoZSBzY3JvbGxiYXJzIGZyb20ga2lsbGluZyBmb2N1c1xuICAgICAgb24obm9kZSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMCk7IH1cbiAgICAgIH0pO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgfSwgZnVuY3Rpb24gKHBvcywgYXhpcykge1xuICAgICAgaWYgKGF4aXMgPT0gXCJob3Jpem9udGFsXCIpIHsgc2V0U2Nyb2xsTGVmdChjbSwgcG9zKTsgfVxuICAgICAgZWxzZSB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgcG9zKTsgfVxuICAgIH0sIGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxuICAgICAgeyBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7IH1cbiAgfVxuXG4gIC8vIE9wZXJhdGlvbnMgYXJlIHVzZWQgdG8gd3JhcCBhIHNlcmllcyBvZiBjaGFuZ2VzIHRvIHRoZSBlZGl0b3JcbiAgLy8gc3RhdGUgaW4gc3VjaCBhIHdheSB0aGF0IGVhY2ggY2hhbmdlIHdvbid0IGhhdmUgdG8gdXBkYXRlIHRoZVxuICAvLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxuICAvLyBlcnJvci1wcm9uZSkuIEluc3RlYWQsIGRpc3BsYXkgdXBkYXRlcyBhcmUgYmF0Y2hlZCBhbmQgdGhlbiBhbGxcbiAgLy8gY29tYmluZWQgYW5kIGV4ZWN1dGVkIGF0IG9uY2UuXG5cbiAgdmFyIG5leHRPcElkID0gMDtcbiAgLy8gU3RhcnQgYSBuZXcgb3BlcmF0aW9uLlxuICBmdW5jdGlvbiBzdGFydE9wZXJhdGlvbihjbSkge1xuICAgIGNtLmN1ck9wID0ge1xuICAgICAgY206IGNtLFxuICAgICAgdmlld0NoYW5nZWQ6IGZhbHNlLCAgICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBsaW5lcyBtaWdodCBuZWVkIHRvIGJlIHJlZHJhd25cbiAgICAgIHN0YXJ0SGVpZ2h0OiBjbS5kb2MuaGVpZ2h0LCAvLyBVc2VkIHRvIGRldGVjdCBuZWVkIHRvIHVwZGF0ZSBzY3JvbGxiYXJcbiAgICAgIGZvcmNlVXBkYXRlOiBmYWxzZSwgICAgICAvLyBVc2VkIHRvIGZvcmNlIGEgcmVkcmF3XG4gICAgICB1cGRhdGVJbnB1dDogMCwgICAgICAgLy8gV2hldGhlciB0byByZXNldCB0aGUgaW5wdXQgdGV4dGFyZWFcbiAgICAgIHR5cGluZzogZmFsc2UsICAgICAgICAgICAvLyBXaGV0aGVyIHRoaXMgcmVzZXQgc2hvdWxkIGJlIGNhcmVmdWwgdG8gbGVhdmUgZXhpc3RpbmcgdGV4dCAoZm9yIGNvbXBvc2l0aW5nKVxuICAgICAgY2hhbmdlT2JqczogbnVsbCwgICAgICAgIC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xuICAgICAgY3Vyc29yQWN0aXZpdHlIYW5kbGVyczogbnVsbCwgLy8gU2V0IG9mIGhhbmRsZXJzIHRvIGZpcmUgY3Vyc29yQWN0aXZpdHkgb25cbiAgICAgIGN1cnNvckFjdGl2aXR5Q2FsbGVkOiAwLCAvLyBUcmFja3Mgd2hpY2ggY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgaGF2ZSBiZWVuIGNhbGxlZCBhbHJlYWR5XG4gICAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmYWxzZSwgLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHJlZHJhd25cbiAgICAgIHVwZGF0ZU1heExpbmU6IGZhbHNlLCAgICAvLyBTZXQgd2hlbiB0aGUgd2lkZXN0IGxpbmUgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBhbmV3XG4gICAgICBzY3JvbGxMZWZ0OiBudWxsLCBzY3JvbGxUb3A6IG51bGwsIC8vIEludGVybWVkaWF0ZSBzY3JvbGwgcG9zaXRpb24sIG5vdCBwdXNoZWQgdG8gRE9NIHlldFxuICAgICAgc2Nyb2xsVG9Qb3M6IG51bGwsICAgICAgIC8vIFVzZWQgdG8gc2Nyb2xsIHRvIGEgc3BlY2lmaWMgcG9zaXRpb25cbiAgICAgIGZvY3VzOiBmYWxzZSxcbiAgICAgIGlkOiArK25leHRPcElkLCAgICAgICAgICAvLyBVbmlxdWUgSURcbiAgICAgIG1hcmtBcnJheXM6IG51bGwgICAgICAgICAvLyBVc2VkIGJ5IGFkZE1hcmtlZFNwYW5cbiAgICB9O1xuICAgIHB1c2hPcGVyYXRpb24oY20uY3VyT3ApO1xuICB9XG5cbiAgLy8gRmluaXNoIGFuIG9wZXJhdGlvbiwgdXBkYXRpbmcgdGhlIGRpc3BsYXkgYW5kIHNpZ25hbGxpbmcgZGVsYXllZCBldmVudHNcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uKGNtKSB7XG4gICAgdmFyIG9wID0gY20uY3VyT3A7XG4gICAgaWYgKG9wKSB7IGZpbmlzaE9wZXJhdGlvbihvcCwgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm9wcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBncm91cC5vcHNbaV0uY20uY3VyT3AgPSBudWxsOyB9XG4gICAgICBlbmRPcGVyYXRpb25zKGdyb3VwKTtcbiAgICB9KTsgfVxuICB9XG5cbiAgLy8gVGhlIERPTSB1cGRhdGVzIGRvbmUgd2hlbiBhbiBvcGVyYXRpb24gZmluaXNoZXMgYXJlIGJhdGNoZWQgc29cbiAgLy8gdGhhdCB0aGUgbWluaW11bSBudW1iZXIgb2YgcmVsYXlvdXRzIGFyZSByZXF1aXJlZC5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCkge1xuICAgIHZhciBvcHMgPSBncm91cC5vcHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXG4gICAgICB7IGVuZE9wZXJhdGlvbl9SMShvcHNbaV0pOyB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb3BzLmxlbmd0aDsgaSQxKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXG4gICAgICB7IGVuZE9wZXJhdGlvbl9XMShvcHNbaSQxXSk7IH1cbiAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBvcHMubGVuZ3RoOyBpJDIrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX1IyKG9wc1tpJDJdKTsgfVxuICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG9wcy5sZW5ndGg7IGkkMysrKSAvLyBXcml0ZSBET00gKG1heWJlKVxuICAgICAgeyBlbmRPcGVyYXRpb25fVzIob3BzW2kkM10pOyB9XG4gICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgb3BzLmxlbmd0aDsgaSQ0KyspIC8vIFJlYWQgRE9NXG4gICAgICB7IGVuZE9wZXJhdGlvbl9maW5pc2gob3BzW2kkNF0pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fUjEob3ApIHtcbiAgICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSk7XG4gICAgaWYgKG9wLnVwZGF0ZU1heExpbmUpIHsgZmluZE1heExpbmUoY20pOyB9XG5cbiAgICBvcC5tdXN0VXBkYXRlID0gb3Audmlld0NoYW5nZWQgfHwgb3AuZm9yY2VVcGRhdGUgfHwgb3Auc2Nyb2xsVG9wICE9IG51bGwgfHxcbiAgICAgIG9wLnNjcm9sbFRvUG9zICYmIChvcC5zY3JvbGxUb1Bvcy5mcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgb3Auc2Nyb2xsVG9Qb3MudG8ubGluZSA+PSBkaXNwbGF5LnZpZXdUbykgfHxcbiAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgb3AudXBkYXRlID0gb3AubXVzdFVwZGF0ZSAmJlxuICAgICAgbmV3IERpc3BsYXlVcGRhdGUoY20sIG9wLm11c3RVcGRhdGUgJiYge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cxKG9wKSB7XG4gICAgb3AudXBkYXRlZERpc3BsYXkgPSBvcC5tdXN0VXBkYXRlICYmIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChvcC5jbSwgb3AudXBkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMihvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pOyB9XG5cbiAgICBvcC5iYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuXG4gICAgLy8gSWYgdGhlIG1heCBsaW5lIGNoYW5nZWQgc2luY2UgaXQgd2FzIGxhc3QgbWVhc3VyZWQsIG1lYXN1cmUgaXQsXG4gICAgLy8gYW5kIGVuc3VyZSB0aGUgZG9jdW1lbnQncyB3aWR0aCBtYXRjaGVzIGl0LlxuICAgIC8vIHVwZGF0ZURpc3BsYXlfVzIgd2lsbCB1c2UgdGhlc2UgcHJvcGVydGllcyB0byBkbyB0aGUgYWN0dWFsIHJlc2l6aW5nXG4gICAgaWYgKGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBvcC5hZGp1c3RXaWR0aFRvID0gbWVhc3VyZUNoYXIoY20sIGRpc3BsYXkubWF4TGluZSwgZGlzcGxheS5tYXhMaW5lLnRleHQubGVuZ3RoKS5sZWZ0ICsgMztcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG9wLmFkanVzdFdpZHRoVG87XG4gICAgICBvcC5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID1cbiAgICAgICAgTWF0aC5tYXgoZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyArIHNjcm9sbEdhcChjbSkgKyBjbS5kaXNwbGF5LmJhcldpZHRoKTtcbiAgICAgIG9wLm1heFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvIC0gZGlzcGxheVdpZHRoKGNtKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnNlbGVjdGlvbkNoYW5nZWQpXG4gICAgICB7IG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMihvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtO1xuXG4gICAgaWYgKG9wLmFkanVzdFdpZHRoVG8gIT0gbnVsbCkge1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IG9wLmFkanVzdFdpZHRoVG8gKyBcInB4XCI7XG4gICAgICBpZiAob3AubWF4U2Nyb2xsTGVmdCA8IGNtLmRvYy5zY3JvbGxMZWZ0KVxuICAgICAgICB7IHNldFNjcm9sbExlZnQoY20sIE1hdGgubWluKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgb3AubWF4U2Nyb2xsTGVmdCksIHRydWUpOyB9XG4gICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRha2VGb2N1cyA9IG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdChyb290KGNtKSk7XG4gICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKVxuICAgICAgeyBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24sIHRha2VGb2N1cyk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc3RhcnRIZWlnaHQgIT0gY20uZG9jLmhlaWdodClcbiAgICAgIHsgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpXG4gICAgICB7IHNldERvY3VtZW50SGVpZ2h0KGNtLCBvcC5iYXJNZWFzdXJlKTsgfVxuXG4gICAgaWYgKG9wLnNlbGVjdGlvbkNoYW5nZWQpIHsgcmVzdGFydEJsaW5rKGNtKTsgfVxuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQgJiYgb3AudXBkYXRlSW5wdXQpXG4gICAgICB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKTsgfVxuICAgIGlmICh0YWtlRm9jdXMpIHsgZW5zdXJlRm9jdXMob3AuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fZmluaXNoKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSk7IH1cblxuICAgIC8vIEFib3J0IG1vdXNlIHdoZWVsIGRlbHRhIG1lYXN1cmVtZW50LCB3aGVuIHNjcm9sbGluZyBleHBsaWNpdGx5XG4gICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggIT0gbnVsbCAmJiAob3Auc2Nyb2xsVG9wICE9IG51bGwgfHwgb3Auc2Nyb2xsTGVmdCAhPSBudWxsIHx8IG9wLnNjcm9sbFRvUG9zKSlcbiAgICAgIHsgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsOyB9XG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxuICAgIGlmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCkgeyBzZXRTY3JvbGxUb3AoY20sIG9wLnNjcm9sbFRvcCwgb3AuZm9yY2VTY3JvbGwpOyB9XG5cbiAgICBpZiAob3Auc2Nyb2xsTGVmdCAhPSBudWxsKSB7IHNldFNjcm9sbExlZnQoY20sIG9wLnNjcm9sbExlZnQsIHRydWUsIHRydWUpOyB9XG4gICAgLy8gSWYgd2UgbmVlZCB0byBzY3JvbGwgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbnRvIHZpZXcsIGRvIHNvLlxuICAgIGlmIChvcC5zY3JvbGxUb1Bvcykge1xuICAgICAgdmFyIHJlY3QgPSBzY3JvbGxQb3NJbnRvVmlldyhjbSwgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MudG8pLCBvcC5zY3JvbGxUb1Bvcy5tYXJnaW4pO1xuICAgICAgbWF5YmVTY3JvbGxXaW5kb3coY20sIHJlY3QpO1xuICAgIH1cblxuICAgIC8vIEZpcmUgZXZlbnRzIGZvciBtYXJrZXJzIHRoYXQgYXJlIGhpZGRlbi91bmlkZGVuIGJ5IGVkaXRpbmcgb3JcbiAgICAvLyB1bmRvaW5nXG4gICAgdmFyIGhpZGRlbiA9IG9wLm1heWJlSGlkZGVuTWFya2VycywgdW5oaWRkZW4gPSBvcC5tYXliZVVuaGlkZGVuTWFya2VycztcbiAgICBpZiAoaGlkZGVuKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoIWhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKGhpZGRlbltpXSwgXCJoaWRlXCIpOyB9IH0gfVxuICAgIGlmICh1bmhpZGRlbikgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB1bmhpZGRlbi5sZW5ndGg7ICsraSQxKVxuICAgICAgeyBpZiAodW5oaWRkZW5baSQxXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKHVuaGlkZGVuW2kkMV0sIFwidW5oaWRlXCIpOyB9IH0gfVxuXG4gICAgaWYgKGRpc3BsYXkud3JhcHBlci5vZmZzZXRIZWlnaHQpXG4gICAgICB7IGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDsgfVxuXG4gICAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvcC5jaGFuZ2VPYmpzKVxuICAgICAgeyBzaWduYWwoY20sIFwiY2hhbmdlc1wiLCBjbSwgb3AuY2hhbmdlT2Jqcyk7IH1cbiAgICBpZiAob3AudXBkYXRlKVxuICAgICAgeyBvcC51cGRhdGUuZmluaXNoKCk7IH1cbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uXG4gIGZ1bmN0aW9uIHJ1bkluT3AoY20sIGYpIHtcbiAgICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYoKSB9XG4gICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgIHRyeSB7IHJldHVybiBmKCkgfVxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gIH1cbiAgLy8gV3JhcHMgYSBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb24uIFJldHVybnMgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIG9wZXJhdGlvbihjbSwgZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH1cbiAgfVxuICAvLyBVc2VkIHRvIGFkZCBtZXRob2RzIHRvIGVkaXRvciBhbmQgZG9jIGluc3RhbmNlcywgd3JhcHBpbmcgdGhlbSBpblxuICAvLyBvcGVyYXRpb25zLlxuICBmdW5jdGlvbiBtZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbih0aGlzKTsgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgIGlmICghY20gfHwgY20uY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gSElHSExJR0hUIFdPUktFUlxuXG4gIGZ1bmN0aW9uIHN0YXJ0V29ya2VyKGNtLCB0aW1lKSB7XG4gICAgaWYgKGNtLmRvYy5oaWdobGlnaHRGcm9udGllciA8IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgeyBjbS5zdGF0ZS5oaWdobGlnaHQuc2V0KHRpbWUsIGJpbmQoaGlnaGxpZ2h0V29ya2VyLCBjbSkpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIGlmIChkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cbiAgICB2YXIgZW5kID0gK25ldyBEYXRlICsgY20ub3B0aW9ucy53b3JrVGltZTtcbiAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIGRvYy5oaWdobGlnaHRGcm9udGllcik7XG4gICAgdmFyIGNoYW5nZWRMaW5lcyA9IFtdO1xuXG4gICAgZG9jLml0ZXIoY29udGV4dC5saW5lLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgY20uZGlzcGxheS52aWV3VG8gKyA1MDApLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNvbnRleHQubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFZpc2libGVcbiAgICAgICAgdmFyIG9sZFN0eWxlcyA9IGxpbmUuc3R5bGVzO1xuICAgICAgICB2YXIgcmVzZXRTdGF0ZSA9IGxpbmUudGV4dC5sZW5ndGggPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCA/IGNvcHlTdGF0ZShkb2MubW9kZSwgY29udGV4dC5zdGF0ZSkgOiBudWxsO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc2V0U3RhdGUpIHsgY29udGV4dC5zdGF0ZSA9IHJlc2V0U3RhdGU7IH1cbiAgICAgICAgbGluZS5zdHlsZXMgPSBoaWdobGlnaHRlZC5zdHlsZXM7XG4gICAgICAgIHZhciBvbGRDbHMgPSBsaW5lLnN0eWxlQ2xhc3NlcywgbmV3Q2xzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcbiAgICAgICAgaWYgKG5ld0NscykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG5ld0NsczsgfVxuICAgICAgICBlbHNlIGlmIChvbGRDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBpc2NoYW5nZSA9ICFvbGRTdHlsZXMgfHwgb2xkU3R5bGVzLmxlbmd0aCAhPSBsaW5lLnN0eWxlcy5sZW5ndGggfHxcbiAgICAgICAgICBvbGRDbHMgIT0gbmV3Q2xzICYmICghb2xkQ2xzIHx8ICFuZXdDbHMgfHwgb2xkQ2xzLmJnQ2xhc3MgIT0gbmV3Q2xzLmJnQ2xhc3MgfHwgb2xkQ2xzLnRleHRDbGFzcyAhPSBuZXdDbHMudGV4dENsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFpc2NoYW5nZSAmJiBpIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpKSB7IGlzY2hhbmdlID0gb2xkU3R5bGVzW2ldICE9IGxpbmUuc3R5bGVzW2ldOyB9XG4gICAgICAgIGlmIChpc2NoYW5nZSkgeyBjaGFuZ2VkTGluZXMucHVzaChjb250ZXh0LmxpbmUpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZS50ZXh0Lmxlbmd0aCA8PSBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aClcbiAgICAgICAgICB7IHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQubGluZSAlIDUgPT0gMCA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xuICAgICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRvYy5oaWdobGlnaHRGcm9udGllciA9IGNvbnRleHQubGluZTtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5tYXgoZG9jLm1vZGVGcm9udGllciwgY29udGV4dC5saW5lKTtcbiAgICBpZiAoY2hhbmdlZExpbmVzLmxlbmd0aCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZWRMaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyByZWdMaW5lQ2hhbmdlKGNtLCBjaGFuZ2VkTGluZXNbaV0sIFwidGV4dFwiKTsgfVxuICAgIH0pOyB9XG4gIH1cblxuICAvLyBESVNQTEFZIERSQVdJTkdcblxuICB2YXIgRGlzcGxheVVwZGF0ZSA9IGZ1bmN0aW9uKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG5cbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgLy8gU3RvcmUgc29tZSB2YWx1ZXMgdGhhdCB3ZSdsbCBuZWVkIGxhdGVyIChidXQgZG9uJ3Qgd2FudCB0byBmb3JjZSBhIHJlbGF5b3V0IGZvcilcbiAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgdGhpcy5lZGl0b3JJc0hpZGRlbiA9ICFkaXNwbGF5LndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy53cmFwcGVySGVpZ2h0ID0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICB0aGlzLm9sZERpc3BsYXlXaWR0aCA9IGRpc3BsYXlXaWR0aChjbSk7XG4gICAgdGhpcy5mb3JjZSA9IGZvcmNlO1xuICAgIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gIH07XG5cbiAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcbiAgICAgIHsgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpOyB9XG4gIH07XG4gIERpc3BsYXlVcGRhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBzaWduYWwuYXBwbHkobnVsbCwgdGhpcy5ldmVudHNbaV0pOyB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgJiYgZGlzcGxheS5zY3JvbGxlci5vZmZzZXRXaWR0aCkge1xuICAgICAgZGlzcGxheS5uYXRpdmVCYXJXaWR0aCA9IGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGggLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoO1xuICAgICAgZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tID0gLWRpc3BsYXkubmF0aXZlQmFyV2lkdGggKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uU25hcHNob3QoY20pIHtcbiAgICBpZiAoY20uaGFzRm9jdXMoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGFjdGl2ZSA9IGFjdGl2ZUVsdChyb290KGNtKSk7XG4gICAgaWYgKCFhY3RpdmUgfHwgIWNvbnRhaW5zKGNtLmRpc3BsYXkubGluZURpdiwgYWN0aXZlKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHJlc3VsdCA9IHthY3RpdmVFbHQ6IGFjdGl2ZX07XG4gICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBzZWwgPSB3aW4oY20pLmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbC5hbmNob3JOb2RlICYmIHNlbC5leHRlbmQgJiYgY29udGFpbnMoY20uZGlzcGxheS5saW5lRGl2LCBzZWwuYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgcmVzdWx0LmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgcmVzdWx0LmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHJlc3VsdC5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICByZXN1bHQuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24oc25hcHNob3QpIHtcbiAgICBpZiAoIXNuYXBzaG90IHx8ICFzbmFwc2hvdC5hY3RpdmVFbHQgfHwgc25hcHNob3QuYWN0aXZlRWx0ID09IGFjdGl2ZUVsdChyb290Tm9kZShzbmFwc2hvdC5hY3RpdmVFbHQpKSkgeyByZXR1cm4gfVxuICAgIHNuYXBzaG90LmFjdGl2ZUVsdC5mb2N1cygpO1xuICAgIGlmICghL14oSU5QVVR8VEVYVEFSRUEpJC8udGVzdChzbmFwc2hvdC5hY3RpdmVFbHQubm9kZU5hbWUpICYmXG4gICAgICAgIHNuYXBzaG90LmFuY2hvck5vZGUgJiYgY29udGFpbnMoZG9jdW1lbnQuYm9keSwgc25hcHNob3QuYW5jaG9yTm9kZSkgJiYgY29udGFpbnMoZG9jdW1lbnQuYm9keSwgc25hcHNob3QuZm9jdXNOb2RlKSkge1xuICAgICAgdmFyIGRvYyA9IHNuYXBzaG90LmFjdGl2ZUVsdC5vd25lckRvY3VtZW50O1xuICAgICAgdmFyIHNlbCA9IGRvYy5kZWZhdWx0Vmlldy5nZXRTZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNldEVuZChzbmFwc2hvdC5hbmNob3JOb2RlLCBzbmFwc2hvdC5hbmNob3JPZmZzZXQpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbC5leHRlbmQoc25hcHNob3QuZm9jdXNOb2RlLCBzbmFwc2hvdC5mb2N1c09mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRG9lcyB0aGUgYWN0dWFsIHVwZGF0aW5nIG9mIHRoZSBsaW5lIGRpc3BsYXkuIEJhaWxzIG91dFxuICAvLyAocmV0dXJuaW5nIGZhbHNlKSB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gYmUgZG9uZSBhbmQgZm9yY2VkIGlzXG4gIC8vIGZhbHNlLlxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuXG4gICAgaWYgKHVwZGF0ZS5lZGl0b3JJc0hpZGRlbikge1xuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIEJhaWwgb3V0IGlmIHRoZSB2aXNpYmxlIGFyZWEgaXMgYWxyZWFkeSByZW5kZXJlZCBhbmQgbm90aGluZyBjaGFuZ2VkLlxuICAgIGlmICghdXBkYXRlLmZvcmNlICYmXG4gICAgICAgIHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBkaXNwbGF5LnZpZXdUbyAmJlxuICAgICAgICAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPj0gZGlzcGxheS52aWV3VG8pICYmXG4gICAgICAgIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJiBjb3VudERpcnR5VmlldyhjbSkgPT0gMClcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkpIHtcbiAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB1cGRhdGUuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgYSBzdWl0YWJsZSBuZXcgdmlld3BvcnQgKGZyb20gJiB0bylcbiAgICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemU7XG4gICAgdmFyIGZyb20gPSBNYXRoLm1heCh1cGRhdGUudmlzaWJsZS5mcm9tIC0gY20ub3B0aW9ucy52aWV3cG9ydE1hcmdpbiwgZG9jLmZpcnN0KTtcbiAgICB2YXIgdG8gPSBNYXRoLm1pbihlbmQsIHVwZGF0ZS52aXNpYmxlLnRvICsgY20ub3B0aW9ucy52aWV3cG9ydE1hcmdpbik7XG4gICAgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tICYmIGZyb20gLSBkaXNwbGF5LnZpZXdGcm9tIDwgMjApIHsgZnJvbSA9IE1hdGgubWF4KGRvYy5maXJzdCwgZGlzcGxheS52aWV3RnJvbSk7IH1cbiAgICBpZiAoZGlzcGxheS52aWV3VG8gPiB0byAmJiBkaXNwbGF5LnZpZXdUbyAtIHRvIDwgMjApIHsgdG8gPSBNYXRoLm1pbihlbmQsIGRpc3BsYXkudmlld1RvKTsgfVxuICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucykge1xuICAgICAgZnJvbSA9IHZpc3VhbExpbmVObyhjbS5kb2MsIGZyb20pO1xuICAgICAgdG8gPSB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byk7XG4gICAgfVxuXG4gICAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxuICAgICAgZGlzcGxheS5sYXN0V3JhcEhlaWdodCAhPSB1cGRhdGUud3JhcHBlckhlaWdodCB8fCBkaXNwbGF5Lmxhc3RXcmFwV2lkdGggIT0gdXBkYXRlLndyYXBwZXJXaWR0aDtcbiAgICBhZGp1c3RWaWV3KGNtLCBmcm9tLCB0byk7XG5cbiAgICBkaXNwbGF5LnZpZXdPZmZzZXQgPSBoZWlnaHRBdExpbmUoZ2V0TGluZShjbS5kb2MsIGRpc3BsYXkudmlld0Zyb20pKTtcbiAgICAvLyBQb3NpdGlvbiB0aGUgbW92ZXIgZGl2IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgY20uZGlzcGxheS5tb3Zlci5zdHlsZS50b3AgPSBkaXNwbGF5LnZpZXdPZmZzZXQgKyBcInB4XCI7XG5cbiAgICB2YXIgdG9VcGRhdGUgPSBjb3VudERpcnR5VmlldyhjbSk7XG4gICAgaWYgKCFkaWZmZXJlbnQgJiYgdG9VcGRhdGUgPT0gMCAmJiAhdXBkYXRlLmZvcmNlICYmIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJlxuICAgICAgICAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPj0gZGlzcGxheS52aWV3VG8pKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgLy8gRm9yIGJpZyBjaGFuZ2VzLCB3ZSBoaWRlIHRoZSBlbmNsb3NpbmcgZWxlbWVudCBkdXJpbmcgdGhlXG4gICAgLy8gdXBkYXRlLCBzaW5jZSB0aGF0IHNwZWVkcyB1cCB0aGUgb3BlcmF0aW9ucyBvbiBtb3N0IGJyb3dzZXJzLlxuICAgIHZhciBzZWxTbmFwc2hvdCA9IHNlbGVjdGlvblNuYXBzaG90KGNtKTtcbiAgICBpZiAodG9VcGRhdGUgPiA0KSB7IGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IH1cbiAgICBwYXRjaERpc3BsYXkoY20sIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMsIHVwZGF0ZS5kaW1zKTtcbiAgICBpZiAodG9VcGRhdGUgPiA0KSB7IGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgfVxuICAgIGRpc3BsYXkucmVuZGVyZWRWaWV3ID0gZGlzcGxheS52aWV3O1xuICAgIC8vIFRoZXJlIG1pZ2h0IGhhdmUgYmVlbiBhIHdpZGdldCB3aXRoIGEgZm9jdXNlZCBlbGVtZW50IHRoYXQgZ290XG4gICAgLy8gaGlkZGVuIG9yIHVwZGF0ZWQsIGlmIHNvIHJlLWZvY3VzIGl0LlxuICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsU25hcHNob3QpO1xuXG4gICAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuY3Vyc29yRGl2KTtcbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LnNlbGVjdGlvbkRpdik7XG4gICAgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IGRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gMDtcblxuICAgIGlmIChkaWZmZXJlbnQpIHtcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgPSB1cGRhdGUud3JhcHBlckhlaWdodDtcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBXaWR0aCA9IHVwZGF0ZS53cmFwcGVyV2lkdGg7XG4gICAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gdXBkYXRlLnZpZXdwb3J0O1xuXG4gICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgaWYgKCFmaXJzdCB8fCAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgfHwgdXBkYXRlLm9sZERpc3BsYXlXaWR0aCA9PSBkaXNwbGF5V2lkdGgoY20pKSB7XG4gICAgICAgIC8vIENsaXAgZm9yY2VkIHZpZXdwb3J0IHRvIGFjdHVhbCBzY3JvbGxhYmxlIGFyZWEuXG4gICAgICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbClcbiAgICAgICAgICB7IHZpZXdwb3J0ID0ge3RvcDogTWF0aC5taW4oY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpIC0gZGlzcGxheUhlaWdodChjbSksIHZpZXdwb3J0LnRvcCl9OyB9XG4gICAgICAgIC8vIFVwZGF0ZWQgbGluZSBoZWlnaHRzIG1pZ2h0IHJlc3VsdCBpbiB0aGUgZHJhd24gYXJlYSBub3RcbiAgICAgICAgLy8gYWN0dWFsbHkgY292ZXJpbmcgdGhlIHZpZXdwb3J0LiBLZWVwIGxvb3BpbmcgdW50aWwgaXQgZG9lcy5cbiAgICAgICAgdXBkYXRlLnZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgICAgIGlmICh1cGRhdGUudmlzaWJsZS5mcm9tID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgdXBkYXRlLnZpc2libGUudG8gPD0gY20uZGlzcGxheS52aWV3VG8pXG4gICAgICAgICAgeyBicmVhayB9XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0KSB7XG4gICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHsgYnJlYWsgfVxuICAgICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuICAgICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgYmFyTWVhc3VyZSk7XG4gICAgICB1cGRhdGUuZm9yY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInVwZGF0ZVwiLCBjbSk7XG4gICAgaWYgKGNtLmRpc3BsYXkudmlld0Zyb20gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tIHx8IGNtLmRpc3BsYXkudmlld1RvICE9IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8pIHtcbiAgICAgIHVwZGF0ZS5zaWduYWwoY20sIFwidmlld3BvcnRDaGFuZ2VcIiwgY20sIGNtLmRpc3BsYXkudmlld0Zyb20sIGNtLmRpc3BsYXkudmlld1RvKTtcbiAgICAgIGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld0Zyb207IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8gPSBjbS5kaXNwbGF5LnZpZXdUbztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB2aWV3cG9ydCkge1xuICAgIHZhciB1cGRhdGUgPSBuZXcgRGlzcGxheVVwZGF0ZShjbSwgdmlld3BvcnQpO1xuICAgIGlmICh1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHtcbiAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcbiAgICAgIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpO1xuICAgICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgYmFyTWVhc3VyZSk7XG4gICAgICB1cGRhdGUuZmluaXNoKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3luYyB0aGUgYWN0dWFsIGRpc3BsYXkgRE9NIHN0cnVjdHVyZSB3aXRoIGRpc3BsYXkudmlldywgcmVtb3ZpbmdcbiAgLy8gbm9kZXMgZm9yIGxpbmVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB2aWV3LCBhbmQgY3JlYXRpbmcgdGhlIG9uZXNcbiAgLy8gdGhhdCBhcmUgbm90IHRoZXJlIHlldCwgYW5kIHVwZGF0aW5nIHRoZSBvbmVzIHRoYXQgYXJlIG91dCBvZlxuICAvLyBkYXRlLlxuICBmdW5jdGlvbiBwYXRjaERpc3BsYXkoY20sIHVwZGF0ZU51bWJlcnNGcm9tLCBkaW1zKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBsaW5lTnVtYmVycyA9IGNtLm9wdGlvbnMubGluZU51bWJlcnM7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRpc3BsYXkubGluZURpdiwgY3VyID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICBmdW5jdGlvbiBybShub2RlKSB7XG4gICAgICB2YXIgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAvLyBXb3JrcyBhcm91bmQgYSB0aHJvdy1zY3JvbGwgYnVnIGluIE9TIFggV2Via2l0XG4gICAgICBpZiAod2Via2l0ICYmIG1hYyAmJiBjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9PSBub2RlKVxuICAgICAgICB7IG5vZGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpOyB9XG4gICAgICByZXR1cm4gbmV4dFxuICAgIH1cblxuICAgIHZhciB2aWV3ID0gZGlzcGxheS52aWV3LCBsaW5lTiA9IGRpc3BsYXkudmlld0Zyb207XG4gICAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcbiAgICAvLyBpbiBkaXNwbGF5LmxpbmVEaXYpIHdpdGggdGhlIHZpZXcgYXMgd2UgZ28uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xuICAgICAgaWYgKGxpbmVWaWV3LmhpZGRlbikgOyBlbHNlIGlmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5ub2RlLnBhcmVudE5vZGUgIT0gY29udGFpbmVyKSB7IC8vIE5vdCBkcmF3biB5ZXRcbiAgICAgICAgdmFyIG5vZGUgPSBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cik7XG4gICAgICB9IGVsc2UgeyAvLyBBbHJlYWR5IGRyYXduXG4gICAgICAgIHdoaWxlIChjdXIgIT0gbGluZVZpZXcubm9kZSkgeyBjdXIgPSBybShjdXIpOyB9XG4gICAgICAgIHZhciB1cGRhdGVOdW1iZXIgPSBsaW5lTnVtYmVycyAmJiB1cGRhdGVOdW1iZXJzRnJvbSAhPSBudWxsICYmXG4gICAgICAgICAgdXBkYXRlTnVtYmVyc0Zyb20gPD0gbGluZU4gJiYgbGluZVZpZXcubGluZU51bWJlcjtcbiAgICAgICAgaWYgKGxpbmVWaWV3LmNoYW5nZXMpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcImd1dHRlclwiKSA+IC0xKSB7IHVwZGF0ZU51bWJlciA9IGZhbHNlOyB9XG4gICAgICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU51bWJlcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGxpbmVWaWV3LmxpbmVOdW1iZXIpO1xuICAgICAgICAgIGxpbmVWaWV3LmxpbmVOdW1iZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZU51bWJlckZvcihjbS5vcHRpb25zLCBsaW5lTikpKTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBsaW5lVmlldy5ub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgbGluZU4gKz0gbGluZVZpZXcuc2l6ZTtcbiAgICB9XG4gICAgd2hpbGUgKGN1cikgeyBjdXIgPSBybShjdXIpOyB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShkaXNwbGF5KSB7XG4gICAgdmFyIHdpZHRoID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luTGVmdCA9IHdpZHRoICsgXCJweFwiO1xuICAgIC8vIFNlbmQgYW4gZXZlbnQgdG8gY29uc3VtZXJzIHJlc3BvbmRpbmcgdG8gY2hhbmdlcyBpbiBndXR0ZXIgd2lkdGguXG4gICAgc2lnbmFsTGF0ZXIoZGlzcGxheSwgXCJndXR0ZXJDaGFuZ2VkXCIsIGRpc3BsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcbiAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IG1lYXN1cmUuZG9jSGVpZ2h0ICsgXCJweFwiO1xuICAgIGNtLmRpc3BsYXkuaGVpZ2h0Rm9yY2VyLnN0eWxlLnRvcCA9IG1lYXN1cmUuZG9jSGVpZ2h0ICsgXCJweFwiO1xuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSAobWVhc3VyZS5kb2NIZWlnaHQgKyBjbS5kaXNwbGF5LmJhckhlaWdodCArIHNjcm9sbEdhcChjbSkpICsgXCJweFwiO1xuICB9XG5cbiAgLy8gUmUtYWxpZ24gbGluZSBudW1iZXJzIGFuZCBndXR0ZXIgbWFya3MgdG8gY29tcGVuc2F0ZSBmb3JcbiAgLy8gaG9yaXpvbnRhbCBzY3JvbGxpbmcuXG4gIGZ1bmN0aW9uIGFsaWduSG9yaXpvbnRhbGx5KGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICghZGlzcGxheS5hbGlnbldpZGdldHMgJiYgKCFkaXNwbGF5Lmd1dHRlcnMuZmlyc3RDaGlsZCB8fCAhY20ub3B0aW9ucy5maXhlZEd1dHRlcikpIHsgcmV0dXJuIH1cbiAgICB2YXIgY29tcCA9IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIC0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgdmFyIGd1dHRlclcgPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsIGxlZnQgPSBjb21wICsgXCJweFwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykgeyBpZiAoIXZpZXdbaV0uaGlkZGVuKSB7XG4gICAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xuICAgICAgICBpZiAodmlld1tpXS5ndXR0ZXIpXG4gICAgICAgICAgeyB2aWV3W2ldLmd1dHRlci5zdHlsZS5sZWZ0ID0gbGVmdDsgfVxuICAgICAgICBpZiAodmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kKVxuICAgICAgICAgIHsgdmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kLnN0eWxlLmxlZnQgPSBsZWZ0OyB9XG4gICAgICB9XG4gICAgICB2YXIgYWxpZ24gPSB2aWV3W2ldLmFsaWduYWJsZTtcbiAgICAgIGlmIChhbGlnbikgeyBmb3IgKHZhciBqID0gMDsgaiA8IGFsaWduLmxlbmd0aDsgaisrKVxuICAgICAgICB7IGFsaWduW2pdLnN0eWxlLmxlZnQgPSBsZWZ0OyB9IH1cbiAgICB9IH1cbiAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcilcbiAgICAgIHsgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSAoY29tcCArIGd1dHRlclcpICsgXCJweFwiOyB9XG4gIH1cblxuICAvLyBVc2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBsaW5lIG51bWJlciBndXR0ZXIgaXMgc3RpbGwgdGhlIHJpZ2h0XG4gIC8vIHNpemUgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IHNpemUuIFJldHVybnMgdHJ1ZSB3aGVuIGFuIHVwZGF0ZVxuICAvLyBpcyBuZWVkZWQuXG4gIGZ1bmN0aW9uIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSB7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVOdW1iZXJzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgbGFzdCA9IGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKGxhc3QubGVuZ3RoICE9IGRpc3BsYXkubGluZU51bUNoYXJzKSB7XG4gICAgICB2YXIgdGVzdCA9IGRpc3BsYXkubWVhc3VyZS5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBsYXN0KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIpKTtcbiAgICAgIHZhciBpbm5lclcgPSB0ZXN0LmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGgsIHBhZGRpbmcgPSB0ZXN0Lm9mZnNldFdpZHRoIC0gaW5uZXJXO1xuICAgICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgIGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPSBNYXRoLm1heChpbm5lclcsIGRpc3BsYXkubGluZUd1dHRlci5vZmZzZXRXaWR0aCAtIHBhZGRpbmcpICsgMTtcbiAgICAgIGRpc3BsYXkubGluZU51bVdpZHRoID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCArIHBhZGRpbmc7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1DaGFycyA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPyBsYXN0Lmxlbmd0aCA6IC0xO1xuICAgICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gZGlzcGxheS5saW5lTnVtV2lkdGggKyBcInB4XCI7XG4gICAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbS5kaXNwbGF5KTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0R3V0dGVycyhndXR0ZXJzLCBsaW5lTnVtYmVycykge1xuICAgIHZhciByZXN1bHQgPSBbXSwgc2F3TGluZU51bWJlcnMgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGd1dHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gZ3V0dGVyc1tpXSwgc3R5bGUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIpIHsgc3R5bGUgPSBuYW1lLnN0eWxlOyBuYW1lID0gbmFtZS5jbGFzc05hbWU7IH1cbiAgICAgIGlmIChuYW1lID09IFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiKSB7XG4gICAgICAgIGlmICghbGluZU51bWJlcnMpIHsgY29udGludWUgfVxuICAgICAgICBlbHNlIHsgc2F3TGluZU51bWJlcnMgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh7Y2xhc3NOYW1lOiBuYW1lLCBzdHlsZTogc3R5bGV9KTtcbiAgICB9XG4gICAgaWYgKGxpbmVOdW1iZXJzICYmICFzYXdMaW5lTnVtYmVycykgeyByZXN1bHQucHVzaCh7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIiwgc3R5bGU6IG51bGx9KTsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFJlYnVpbGQgdGhlIGd1dHRlciBlbGVtZW50cywgZW5zdXJlIHRoZSBtYXJnaW4gdG8gdGhlIGxlZnQgb2YgdGhlXG4gIC8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cbiAgZnVuY3Rpb24gcmVuZGVyR3V0dGVycyhkaXNwbGF5KSB7XG4gICAgdmFyIGd1dHRlcnMgPSBkaXNwbGF5Lmd1dHRlcnMsIHNwZWNzID0gZGlzcGxheS5ndXR0ZXJTcGVjcztcbiAgICByZW1vdmVDaGlsZHJlbihndXR0ZXJzKTtcbiAgICBkaXNwbGF5LmxpbmVHdXR0ZXIgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciByZWYgPSBzcGVjc1tpXTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWYuY2xhc3NOYW1lO1xuICAgICAgdmFyIHN0eWxlID0gcmVmLnN0eWxlO1xuICAgICAgdmFyIGdFbHQgPSBndXR0ZXJzLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyIFwiICsgY2xhc3NOYW1lKSk7XG4gICAgICBpZiAoc3R5bGUpIHsgZ0VsdC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7IH1cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgZGlzcGxheS5saW5lR3V0dGVyID0gZ0VsdDtcbiAgICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChkaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3V0dGVycy5zdHlsZS5kaXNwbGF5ID0gc3BlY3MubGVuZ3RoID8gXCJcIiA6IFwibm9uZVwiO1xuICAgIHVwZGF0ZUd1dHRlclNwYWNlKGRpc3BsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVycyhjbSkge1xuICAgIHJlbmRlckd1dHRlcnMoY20uZGlzcGxheSk7XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgICBhbGlnbkhvcml6b250YWxseShjbSk7XG4gIH1cblxuICAvLyBUaGUgZGlzcGxheSBoYW5kbGVzIHRoZSBET00gaW50ZWdyYXRpb24sIGJvdGggZm9yIGlucHV0IHJlYWRpbmdcbiAgLy8gYW5kIGNvbnRlbnQgZHJhd2luZy4gSXQgaG9sZHMgcmVmZXJlbmNlcyB0byBET00gbm9kZXMgYW5kXG4gIC8vIGRpc3BsYXktcmVsYXRlZCBzdGF0ZS5cblxuICBmdW5jdGlvbiBEaXNwbGF5KHBsYWNlLCBkb2MsIGlucHV0LCBvcHRpb25zKSB7XG4gICAgdmFyIGQgPSB0aGlzO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICAgIC8vIENvdmVycyBib3R0b20tcmlnaHQgc3F1YXJlIHdoZW4gYm90aCBzY3JvbGxiYXJzIGFyZSBwcmVzZW50LlxuICAgIGQuc2Nyb2xsYmFyRmlsbGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyXCIpO1xuICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICAvLyBDb3ZlcnMgYm90dG9tIG9mIGd1dHRlciB3aGVuIGNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyIGlzIG9uXG4gICAgLy8gYW5kIGggc2Nyb2xsYmFyIGlzIHByZXNlbnQuXG4gICAgZC5ndXR0ZXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1maWxsZXJcIik7XG4gICAgZC5ndXR0ZXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgIC8vIFdpbGwgY29udGFpbiB0aGUgYWN0dWFsIGNvZGUsIHBvc2l0aW9uZWQgdG8gY292ZXIgdGhlIHZpZXdwb3J0LlxuICAgIGQubGluZURpdiA9IGVsdFAoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWNvZGVcIik7XG4gICAgLy8gRWxlbWVudHMgYXJlIGFkZGVkIHRvIHRoZXNlIHRvIHJlcHJlc2VudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMuXG4gICAgZC5zZWxlY3Rpb25EaXYgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmU7IHotaW5kZXg6IDFcIik7XG4gICAgZC5jdXJzb3JEaXYgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWN1cnNvcnNcIik7XG4gICAgLy8gQSB2aXNpYmlsaXR5OiBoaWRkZW4gZWxlbWVudCB1c2VkIHRvIGZpbmQgdGhlIHNpemUgb2YgdGhpbmdzLlxuICAgIGQubWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAvLyBXaGVuIGxpbmVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGFyZSBtZWFzdXJlZCwgdGhleSBhcmUgZHJhd24gaW4gdGhpcy5cbiAgICBkLmxpbmVNZWFzdXJlID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1tZWFzdXJlXCIpO1xuICAgIC8vIFdyYXBzIGV2ZXJ5dGhpbmcgdGhhdCBuZWVkcyB0byBleGlzdCBpbnNpZGUgdGhlIHZlcnRpY2FsbHktcGFkZGVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgZC5saW5lU3BhY2UgPSBlbHRQKFwiZGl2XCIsIFtkLm1lYXN1cmUsIGQubGluZU1lYXN1cmUsIGQuc2VsZWN0aW9uRGl2LCBkLmN1cnNvckRpdiwgZC5saW5lRGl2XSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICB2YXIgbGluZXMgPSBlbHRQKFwiZGl2XCIsIFtkLmxpbmVTcGFjZV0sIFwiQ29kZU1pcnJvci1saW5lc1wiKTtcbiAgICAvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXG4gICAgZC5tb3ZlciA9IGVsdChcImRpdlwiLCBbbGluZXNdLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtcbiAgICAvLyBTZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQsIGFsbG93aW5nIHNjcm9sbGluZy5cbiAgICBkLnNpemVyID0gZWx0KFwiZGl2XCIsIFtkLm1vdmVyXSwgXCJDb2RlTWlycm9yLXNpemVyXCIpO1xuICAgIGQuc2l6ZXJXaWR0aCA9IG51bGw7XG4gICAgLy8gQmVoYXZpb3Igb2YgZWx0cyB3aXRoIG92ZXJmbG93OiBhdXRvIGFuZCBwYWRkaW5nIGlzXG4gICAgLy8gaW5jb25zaXN0ZW50IGFjcm9zcyBicm93c2Vycy4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGVcbiAgICAvLyBzY3JvbGxhYmxlIGFyZWEgaXMgYmlnIGVub3VnaC5cbiAgICBkLmhlaWdodEZvcmNlciA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiBcIiArIHNjcm9sbGVyR2FwICsgXCJweDsgd2lkdGg6IDFweDtcIik7XG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBndXR0ZXJzLCBpZiBhbnkuXG4gICAgZC5ndXR0ZXJzID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXJzXCIpO1xuICAgIGQubGluZUd1dHRlciA9IG51bGw7XG4gICAgLy8gQWN0dWFsIHNjcm9sbGFibGUgZWxlbWVudC5cbiAgICBkLnNjcm9sbGVyID0gZWx0KFwiZGl2XCIsIFtkLnNpemVyLCBkLmhlaWdodEZvcmNlciwgZC5ndXR0ZXJzXSwgXCJDb2RlTWlycm9yLXNjcm9sbFwiKTtcbiAgICBkLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIFwiLTFcIik7XG4gICAgLy8gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy5cbiAgICBkLndyYXBwZXIgPSBlbHQoXCJkaXZcIiwgW2Quc2Nyb2xsYmFyRmlsbGVyLCBkLmd1dHRlckZpbGxlciwgZC5zY3JvbGxlcl0sIFwiQ29kZU1pcnJvclwiKTtcbiAgICAvLyBTZWUgIzY5ODIuIEZJWE1FIHJlbW92ZSB3aGVuIHRoaXMgaGFzIGJlZW4gZml4ZWQgZm9yIGEgd2hpbGUgaW4gQ2hyb21lXG4gICAgaWYgKGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA9PT0gMTA1KSB7IGQud3JhcHBlci5zdHlsZS5jbGlwUGF0aCA9IFwiaW5zZXQoMHB4KVwiOyB9XG5cbiAgICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyByZXNwZWN0ZWQgYnkgYXV0b21hdGljIHRyYW5zbGF0aW9uIHN5c3RlbXMgc3VjaCBhcyBHb29nbGUgVHJhbnNsYXRlLFxuICAgIC8vIGFuZCBtYXkgYWxzbyBiZSByZXNwZWN0ZWQgYnkgdG9vbHMgdXNlZCBieSBodW1hbiB0cmFuc2xhdG9ycy5cbiAgICBkLndyYXBwZXIuc2V0QXR0cmlidXRlKCd0cmFuc2xhdGUnLCAnbm8nKTtcblxuICAgIC8vIFdvcmsgYXJvdW5kIElFNyB6LWluZGV4IGJ1ZyAobm90IHBlcmZlY3QsIGhlbmNlIElFNyBub3QgcmVhbGx5IGJlaW5nIHN1cHBvcnRlZClcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgZC5ndXR0ZXJzLnN0eWxlLnpJbmRleCA9IC0xOyBkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IDA7IH1cbiAgICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIHsgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XG5cbiAgICBpZiAocGxhY2UpIHtcbiAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkgeyBwbGFjZS5hcHBlbmRDaGlsZChkLndyYXBwZXIpOyB9XG4gICAgICBlbHNlIHsgcGxhY2UoZC53cmFwcGVyKTsgfVxuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxuICAgIGQudmlld0Zyb20gPSBkLnZpZXdUbyA9IGRvYy5maXJzdDtcbiAgICBkLnJlcG9ydGVkVmlld0Zyb20gPSBkLnJlcG9ydGVkVmlld1RvID0gZG9jLmZpcnN0O1xuICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cbiAgICBkLnZpZXcgPSBbXTtcbiAgICBkLnJlbmRlcmVkVmlldyA9IG51bGw7XG4gICAgLy8gSG9sZHMgaW5mbyBhYm91dCBhIHNpbmdsZSByZW5kZXJlZCBsaW5lIHdoZW4gaXQgd2FzIHJlbmRlcmVkXG4gICAgLy8gZm9yIG1lYXN1cmVtZW50LCB3aGlsZSBub3QgaW4gdmlldy5cbiAgICBkLmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgIC8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XG4gICAgZC52aWV3T2Zmc2V0ID0gMDtcbiAgICBkLmxhc3RXcmFwSGVpZ2h0ID0gZC5sYXN0V3JhcFdpZHRoID0gMDtcbiAgICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIGQubmF0aXZlQmFyV2lkdGggPSBkLmJhckhlaWdodCA9IGQuYmFyV2lkdGggPSAwO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxuICAgIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgY3Jvc3NlcyBhIGJvdW5kYXJ5IHRoYXQgbWFrZXMgaXRzIHdpZHRoIGNoYW5nZSlcbiAgICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGw7XG4gICAgLy8gU2V0IHRvIHRydWUgd2hlbiBhIG5vbi1ob3Jpem9udGFsLXNjcm9sbGluZyBsaW5lIHdpZGdldCBpc1xuICAgIC8vIGFkZGVkLiBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmUgd2lkZ2V0IGFsaWduaW5nIGlzIHNraXBwZWQgd2hlblxuICAgIC8vIHRoaXMgaXMgZmFsc2UuXG4gICAgZC5hbGlnbldpZGdldHMgPSBmYWxzZTtcblxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG5cbiAgICAvLyBUcmFja3MgdGhlIG1heGltdW0gbGluZSBsZW5ndGggc28gdGhhdCB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXJcbiAgICAvLyBjYW4gYmUga2VwdCBzdGF0aWMgd2hlbiBzY3JvbGxpbmcuXG4gICAgZC5tYXhMaW5lID0gbnVsbDtcbiAgICBkLm1heExpbmVMZW5ndGggPSAwO1xuICAgIGQubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgZm9yIG1lYXN1cmluZyB3aGVlbCBzY3JvbGxpbmcgZ3JhbnVsYXJpdHlcbiAgICBkLndoZWVsRFggPSBkLndoZWVsRFkgPSBkLndoZWVsU3RhcnRYID0gZC53aGVlbFN0YXJ0WSA9IG51bGw7XG5cbiAgICAvLyBUcnVlIHdoZW4gc2hpZnQgaXMgaGVsZCBkb3duLlxuICAgIGQuc2hpZnQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnl0aGluZyBoYXBwZW5lZCBzaW5jZSB0aGUgY29udGV4dCBtZW51XG4gICAgLy8gd2FzIG9wZW5lZC5cbiAgICBkLnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcblxuICAgIGQuYWN0aXZlVG91Y2ggPSBudWxsO1xuXG4gICAgZC5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnMob3B0aW9ucy5ndXR0ZXJzLCBvcHRpb25zLmxpbmVOdW1iZXJzKTtcbiAgICByZW5kZXJHdXR0ZXJzKGQpO1xuXG4gICAgaW5wdXQuaW5pdChkKTtcbiAgfVxuXG4gIC8vIFNpbmNlIHRoZSBkZWx0YSB2YWx1ZXMgcmVwb3J0ZWQgb24gbW91c2Ugd2hlZWwgZXZlbnRzIGFyZVxuICAvLyB1bnN0YW5kYXJkaXplZCBiZXR3ZWVuIGJyb3dzZXJzIGFuZCBldmVuIGJyb3dzZXIgdmVyc2lvbnMsIGFuZFxuICAvLyBnZW5lcmFsbHkgaG9ycmlibHkgdW5wcmVkaWN0YWJsZSwgdGhpcyBjb2RlIHN0YXJ0cyBieSBtZWFzdXJpbmdcbiAgLy8gdGhlIHNjcm9sbCBlZmZlY3QgdGhhdCB0aGUgZmlyc3QgZmV3IG1vdXNlIHdoZWVsIGV2ZW50cyBoYXZlLFxuICAvLyBhbmQsIGZyb20gdGhhdCwgZGV0ZWN0cyB0aGUgd2F5IGl0IGNhbiBjb252ZXJ0IGRlbHRhcyB0byBwaXhlbFxuICAvLyBvZmZzZXRzIGFmdGVyd2FyZHMuXG4gIC8vXG4gIC8vIFRoZSByZWFzb24gd2Ugd2FudCB0byBrbm93IHRoZSBhbW91bnQgYSB3aGVlbCBldmVudCB3aWxsIHNjcm9sbFxuICAvLyBpcyB0aGF0IGl0IGdpdmVzIHVzIGEgY2hhbmNlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBiZWZvcmUgdGhlXG4gIC8vIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgcmVkdWNpbmcgZmxpY2tlcmluZy5cblxuICB2YXIgd2hlZWxTYW1wbGVzID0gMCwgd2hlZWxQaXhlbHNQZXJVbml0ID0gbnVsbDtcbiAgLy8gRmlsbCBpbiBhIGJyb3dzZXItZGV0ZWN0ZWQgc3RhcnRpbmcgdmFsdWUgb24gYnJvd3NlcnMgd2hlcmUgd2VcbiAgLy8ga25vdyBvbmUuIFRoZXNlIGRvbid0IGhhdmUgdG8gYmUgYWNjdXJhdGUgLS0gdGhlIHJlc3VsdCBvZiB0aGVtXG4gIC8vIGJlaW5nIHdyb25nIHdvdWxkIGp1c3QgYmUgYSBzbGlnaHQgZmxpY2tlciBvbiB0aGUgZmlyc3Qgd2hlZWxcbiAgLy8gc2Nyb2xsIChpZiBpdCBpcyBsYXJnZSBlbm91Z2gpLlxuICBpZiAoaWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS41MzsgfVxuICBlbHNlIGlmIChnZWNrbykgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAxNTsgfVxuICBlbHNlIGlmIChjaHJvbWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS43OyB9XG4gIGVsc2UgaWYgKHNhZmFyaSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMS8zOyB9XG5cbiAgZnVuY3Rpb24gd2hlZWxFdmVudERlbHRhKGUpIHtcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XG4gICAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSB7IGR4ID0gZS5kZXRhaWw7IH1cbiAgICBpZiAoZHkgPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5WRVJUSUNBTF9BWElTKSB7IGR5ID0gZS5kZXRhaWw7IH1cbiAgICBlbHNlIGlmIChkeSA9PSBudWxsKSB7IGR5ID0gZS53aGVlbERlbHRhOyB9XG4gICAgcmV0dXJuIHt4OiBkeCwgeTogZHl9XG4gIH1cbiAgZnVuY3Rpb24gd2hlZWxFdmVudFBpeGVscyhlKSB7XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpO1xuICAgIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIGRlbHRhLnkgKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGxXaGVlbChjbSwgZSkge1xuICAgIC8vIE9uIENocm9tZSAxMDIsIHZpZXdwb3J0IHVwZGF0ZXMgc29tZWhvdyBzdG9wIHdoZWVsLWJhc2VkXG4gICAgLy8gc2Nyb2xsaW5nLiBUdXJuaW5nIG9mZiBwb2ludGVyIGV2ZW50cyBkdXJpbmcgdGhlIHNjcm9sbCBzZWVtc1xuICAgIC8vIHRvIGF2b2lkIHRoZSBpc3N1ZS5cbiAgICBpZiAoY2hyb21lICYmIGNocm9tZV92ZXJzaW9uID09IDEwMikge1xuICAgICAgaWYgKGNtLmRpc3BsYXkuY2hyb21lU2Nyb2xsSGFjayA9PSBudWxsKSB7IGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiOyB9XG4gICAgICBlbHNlIHsgY2xlYXJUaW1lb3V0KGNtLmRpc3BsYXkuY2hyb21lU2Nyb2xsSGFjayk7IH1cbiAgICAgIGNtLmRpc3BsYXkuY2hyb21lU2Nyb2xsSGFjayA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjbS5kaXNwbGF5LmNocm9tZVNjcm9sbEhhY2sgPSBudWxsO1xuICAgICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiO1xuICAgICAgfSwgMTAwKTtcbiAgICB9XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpLCBkeCA9IGRlbHRhLngsIGR5ID0gZGVsdGEueTtcbiAgICB2YXIgcGl4ZWxzUGVyVW5pdCA9IHdoZWVsUGl4ZWxzUGVyVW5pdDtcbiAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDApIHtcbiAgICAgIGR4ID0gZS5kZWx0YVg7XG4gICAgICBkeSA9IGUuZGVsdGFZO1xuICAgICAgcGl4ZWxzUGVyVW5pdCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzY3JvbGwgPSBkaXNwbGF5LnNjcm9sbGVyO1xuICAgIC8vIFF1aXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNjcm9sbCBoZXJlXG4gICAgdmFyIGNhblNjcm9sbFggPSBzY3JvbGwuc2Nyb2xsV2lkdGggPiBzY3JvbGwuY2xpZW50V2lkdGg7XG4gICAgdmFyIGNhblNjcm9sbFkgPSBzY3JvbGwuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsLmNsaWVudEhlaWdodDtcbiAgICBpZiAoIShkeCAmJiBjYW5TY3JvbGxYIHx8IGR5ICYmIGNhblNjcm9sbFkpKSB7IHJldHVybiB9XG5cbiAgICAvLyBXZWJraXQgYnJvd3NlcnMgb24gT1MgWCBhYm9ydCBtb21lbnR1bSBzY3JvbGxzIHdoZW4gdGhlIHRhcmdldFxuICAgIC8vIG9mIHRoZSBzY3JvbGwgZXZlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBoYWNrIChzZWUgcmVsYXRlZCBjb2RlIGluIHBhdGNoRGlzcGxheSkgbWFrZXMgc3VyZSB0aGVcbiAgICAvLyBlbGVtZW50IGlzIGtlcHQgYXJvdW5kLlxuICAgIGlmIChkeSAmJiBtYWMgJiYgd2Via2l0KSB7XG4gICAgICBvdXRlcjogZm9yICh2YXIgY3VyID0gZS50YXJnZXQsIHZpZXcgPSBkaXNwbGF5LnZpZXc7IGN1ciAhPSBzY3JvbGw7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh2aWV3W2ldLm5vZGUgPT0gY3VyKSB7XG4gICAgICAgICAgICBjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9IGN1cjtcbiAgICAgICAgICAgIGJyZWFrIG91dGVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT24gc29tZSBicm93c2VycywgaG9yaXpvbnRhbCBzY3JvbGxpbmcgd2lsbCBjYXVzZSByZWRyYXdzIHRvXG4gICAgLy8gaGFwcGVuIGJlZm9yZSB0aGUgZ3V0dGVyIGhhcyBiZWVuIHJlYWxpZ25lZCwgY2F1c2luZyBpdCB0b1xuICAgIC8vIHdyaWdnbGUgYXJvdW5kIGluIGEgbW9zdCB1bnNlZW1seSB3YXkuIFdoZW4gd2UgaGF2ZSBhblxuICAgIC8vIGVzdGltYXRlZCBwaXhlbHMvZGVsdGEgdmFsdWUsIHdlIGp1c3QgaGFuZGxlIGhvcml6b250YWxcbiAgICAvLyBzY3JvbGxpbmcgZW50aXJlbHkgaGVyZS4gSXQnbGwgYmUgc2xpZ2h0bHkgb2ZmIGZyb20gbmF0aXZlLCBidXRcbiAgICAvLyBiZXR0ZXIgdGhhbiBnbGl0Y2hpbmcgb3V0LlxuICAgIGlmIChkeCAmJiAhZ2Vja28gJiYgIXByZXN0byAmJiBwaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcbiAgICAgIGlmIChkeSAmJiBjYW5TY3JvbGxZKVxuICAgICAgICB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgTWF0aC5tYXgoMCwgc2Nyb2xsLnNjcm9sbFRvcCArIGR5ICogcGl4ZWxzUGVyVW5pdCkpOyB9XG4gICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1heCgwLCBzY3JvbGwuc2Nyb2xsTGVmdCArIGR4ICogcGl4ZWxzUGVyVW5pdCkpO1xuICAgICAgLy8gT25seSBwcmV2ZW50IGRlZmF1bHQgc2Nyb2xsaW5nIGlmIHZlcnRpY2FsIHNjcm9sbGluZyBpc1xuICAgICAgLy8gYWN0dWFsbHkgcG9zc2libGUuIE90aGVyd2lzZSwgaXQgY2F1c2VzIHZlcnRpY2FsIHNjcm9sbFxuICAgICAgLy8gaml0dGVyIG9uIE9TWCB0cmFja3BhZHMgd2hlbiBkZWx0YVggaXMgc21hbGwgYW5kIGRlbHRhWVxuICAgICAgLy8gaXMgbGFyZ2UgKGlzc3VlICMzNTc5KVxuICAgICAgaWYgKCFkeSB8fCAoZHkgJiYgY2FuU2Nyb2xsWSkpXG4gICAgICAgIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IG51bGw7IC8vIEFib3J0IG1lYXN1cmVtZW50LCBpZiBpbiBwcm9ncmVzc1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gJ1Byb2plY3QnIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHRvIGNvdmVyIHRoZSBhcmVhIHRoYXQgaXMgYmVpbmdcbiAgICAvLyBzY3JvbGxlZCBpbnRvIHZpZXcgKGlmIHdlIGtub3cgZW5vdWdoIHRvIGVzdGltYXRlIGl0KS5cbiAgICBpZiAoZHkgJiYgcGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcGl4ZWxzID0gZHkgKiBwaXhlbHNQZXJVbml0O1xuICAgICAgdmFyIHRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIGJvdCA9IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAocGl4ZWxzIDwgMCkgeyB0b3AgPSBNYXRoLm1heCgwLCB0b3AgKyBwaXhlbHMgLSA1MCk7IH1cbiAgICAgIGVsc2UgeyBib3QgPSBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0LCBib3QgKyBwaXhlbHMgKyA1MCk7IH1cbiAgICAgIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHRvcCwgYm90dG9tOiBib3R9KTtcbiAgICB9XG5cbiAgICBpZiAod2hlZWxTYW1wbGVzIDwgMjAgJiYgZS5kZWx0YU1vZGUgIT09IDApIHtcbiAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IHNjcm9sbC5zY3JvbGxMZWZ0OyBkaXNwbGF5LndoZWVsU3RhcnRZID0gc2Nyb2xsLnNjcm9sbFRvcDtcbiAgICAgICAgZGlzcGxheS53aGVlbERYID0gZHg7IGRpc3BsYXkud2hlZWxEWSA9IGR5O1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgICAgICAgdmFyIG1vdmVkWCA9IHNjcm9sbC5zY3JvbGxMZWZ0IC0gZGlzcGxheS53aGVlbFN0YXJ0WDtcbiAgICAgICAgICB2YXIgbW92ZWRZID0gc2Nyb2xsLnNjcm9sbFRvcCAtIGRpc3BsYXkud2hlZWxTdGFydFk7XG4gICAgICAgICAgdmFyIHNhbXBsZSA9IChtb3ZlZFkgJiYgZGlzcGxheS53aGVlbERZICYmIG1vdmVkWSAvIGRpc3BsYXkud2hlZWxEWSkgfHxcbiAgICAgICAgICAgIChtb3ZlZFggJiYgZGlzcGxheS53aGVlbERYICYmIG1vdmVkWCAvIGRpc3BsYXkud2hlZWxEWCk7XG4gICAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsO1xuICAgICAgICAgIGlmICghc2FtcGxlKSB7IHJldHVybiB9XG4gICAgICAgICAgd2hlZWxQaXhlbHNQZXJVbml0ID0gKHdoZWVsUGl4ZWxzUGVyVW5pdCAqIHdoZWVsU2FtcGxlcyArIHNhbXBsZSkgLyAod2hlZWxTYW1wbGVzICsgMSk7XG4gICAgICAgICAgKyt3aGVlbFNhbXBsZXM7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5LndoZWVsRFggKz0gZHg7IGRpc3BsYXkud2hlZWxEWSArPSBkeTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTZWxlY3Rpb24gb2JqZWN0cyBhcmUgaW1tdXRhYmxlLiBBIG5ldyBvbmUgaXMgY3JlYXRlZCBldmVyeSB0aW1lXG4gIC8vIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy4gQSBzZWxlY3Rpb24gaXMgb25lIG9yIG1vcmUgbm9uLW92ZXJsYXBwaW5nXG4gIC8vIChhbmQgbm9uLXRvdWNoaW5nKSByYW5nZXMsIHNvcnRlZCwgYW5kIGFuIGludGVnZXIgdGhhdCBpbmRpY2F0ZXNcbiAgLy8gd2hpY2ggb25lIGlzIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiAodGhlIG9uZSB0aGF0J3Mgc2Nyb2xsZWQgaW50b1xuICAvLyB2aWV3LCB0aGF0IGdldEN1cnNvciByZXR1cm5zLCBldGMpLlxuICB2YXIgU2VsZWN0aW9uID0gZnVuY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpIHtcbiAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICB0aGlzLnByaW1JbmRleCA9IHByaW1JbmRleDtcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLnByaW1hcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLnByaW1JbmRleF0gfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIGlmIChvdGhlciA9PSB0aGlzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAob3RoZXIucHJpbUluZGV4ICE9IHRoaXMucHJpbUluZGV4IHx8IG90aGVyLnJhbmdlcy5sZW5ndGggIT0gdGhpcy5yYW5nZXMubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlcmUgPSB0aGlzLnJhbmdlc1tpXSwgdGhlcmUgPSBvdGhlci5yYW5nZXNbaV07XG4gICAgICBpZiAoIWVxdWFsQ3Vyc29yUG9zKGhlcmUuYW5jaG9yLCB0aGVyZS5hbmNob3IpIHx8ICFlcXVhbEN1cnNvclBvcyhoZXJlLmhlYWQsIHRoZXJlLmhlYWQpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgb3V0W2ldID0gbmV3IFJhbmdlKGNvcHlQb3ModGhpcy5yYW5nZXNbaV0uYW5jaG9yKSwgY29weVBvcyh0aGlzLnJhbmdlc1tpXS5oZWFkKSk7IH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIHRoaXMucHJpbUluZGV4KVxuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuc29tZXRoaW5nU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgaWYgKCF0aGlzLnJhbmdlc1tpXS5lbXB0eSgpKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocG9zLCBlbmQpIHtcbiAgICBpZiAoIWVuZCkgeyBlbmQgPSBwb3M7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlc1tpXTtcbiAgICAgIGlmIChjbXAoZW5kLCByYW5nZS5mcm9tKCkpID49IDAgJiYgY21wKHBvcywgcmFuZ2UudG8oKSkgPD0gMClcbiAgICAgICAgeyByZXR1cm4gaSB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9O1xuXG4gIHZhciBSYW5nZSA9IGZ1bmN0aW9uKGFuY2hvciwgaGVhZCkge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yOyB0aGlzLmhlYWQgPSBoZWFkO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5mcm9tID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWluUG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpIH07XG4gIFJhbmdlLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xuICBSYW5nZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmhlYWQubGluZSA9PSB0aGlzLmFuY2hvci5saW5lICYmIHRoaXMuaGVhZC5jaCA9PSB0aGlzLmFuY2hvci5jaCB9O1xuXG4gIC8vIFRha2UgYW4gdW5zb3J0ZWQsIHBvdGVudGlhbGx5IG92ZXJsYXBwaW5nIHNldCBvZiByYW5nZXMsIGFuZFxuICAvLyBidWlsZCBhIHNlbGVjdGlvbiBvdXQgb2YgaXQuICdDb25zdW1lcycgcmFuZ2VzIGFycmF5IChtb2RpZnlpbmdcbiAgLy8gaXQpLlxuICBmdW5jdGlvbiBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcywgcHJpbUluZGV4KSB7XG4gICAgdmFyIG1heVRvdWNoID0gY20gJiYgY20ub3B0aW9ucy5zZWxlY3Rpb25zTWF5VG91Y2g7XG4gICAgdmFyIHByaW0gPSByYW5nZXNbcHJpbUluZGV4XTtcbiAgICByYW5nZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGEuZnJvbSgpLCBiLmZyb20oKSk7IH0pO1xuICAgIHByaW1JbmRleCA9IGluZGV4T2YocmFuZ2VzLCBwcmltKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICB2YXIgZGlmZiA9IGNtcChwcmV2LnRvKCksIGN1ci5mcm9tKCkpO1xuICAgICAgaWYgKG1heVRvdWNoICYmICFjdXIuZW1wdHkoKSA/IGRpZmYgPiAwIDogZGlmZiA+PSAwKSB7XG4gICAgICAgIHZhciBmcm9tID0gbWluUG9zKHByZXYuZnJvbSgpLCBjdXIuZnJvbSgpKSwgdG8gPSBtYXhQb3MocHJldi50bygpLCBjdXIudG8oKSk7XG4gICAgICAgIHZhciBpbnYgPSBwcmV2LmVtcHR5KCkgPyBjdXIuZnJvbSgpID09IGN1ci5oZWFkIDogcHJldi5mcm9tKCkgPT0gcHJldi5oZWFkO1xuICAgICAgICBpZiAoaSA8PSBwcmltSW5kZXgpIHsgLS1wcmltSW5kZXg7IH1cbiAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihbbmV3IFJhbmdlKGFuY2hvciwgaGVhZCB8fCBhbmNob3IpXSwgMClcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgYSBjaGFuZ2UgKGl0cyAndG8nIHByb3BlcnR5XG4gIC8vIHJlZmVycyB0byB0aGUgcHJlLWNoYW5nZSBlbmQpLlxuICBmdW5jdGlvbiBjaGFuZ2VFbmQoY2hhbmdlKSB7XG4gICAgaWYgKCFjaGFuZ2UudGV4dCkgeyByZXR1cm4gY2hhbmdlLnRvIH1cbiAgICByZXR1cm4gUG9zKGNoYW5nZS5mcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgPyBjaGFuZ2UuZnJvbS5jaCA6IDApKVxuICB9XG5cbiAgLy8gQWRqdXN0IGEgcG9zaXRpb24gdG8gcmVmZXIgdG8gdGhlIHBvc3QtY2hhbmdlIHBvc2l0aW9uIG9mIHRoZVxuICAvLyBzYW1lIHRleHQsIG9yIHRoZSBlbmQgb2YgdGhlIGNoYW5nZSBpZiB0aGUgY2hhbmdlIGNvdmVycyBpdC5cbiAgZnVuY3Rpb24gYWRqdXN0Rm9yQ2hhbmdlKHBvcywgY2hhbmdlKSB7XG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS5mcm9tKSA8IDApIHsgcmV0dXJuIHBvcyB9XG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS50bykgPD0gMCkgeyByZXR1cm4gY2hhbmdlRW5kKGNoYW5nZSkgfVxuXG4gICAgdmFyIGxpbmUgPSBwb3MubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpIC0gMSwgY2ggPSBwb3MuY2g7XG4gICAgaWYgKHBvcy5saW5lID09IGNoYW5nZS50by5saW5lKSB7IGNoICs9IGNoYW5nZUVuZChjaGFuZ2UpLmNoIC0gY2hhbmdlLnRvLmNoOyB9XG4gICAgcmV0dXJuIFBvcyhsaW5lLCBjaClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIG91dC5wdXNoKG5ldyBSYW5nZShhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuYW5jaG9yLCBjaGFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdEZvckNoYW5nZShyYW5nZS5oZWFkLCBjaGFuZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0UG9zKHBvcywgb2xkLCBudykge1xuICAgIGlmIChwb3MubGluZSA9PSBvbGQubGluZSlcbiAgICAgIHsgcmV0dXJuIFBvcyhudy5saW5lLCBwb3MuY2ggLSBvbGQuY2ggKyBudy5jaCkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIFBvcyhudy5saW5lICsgKHBvcy5saW5lIC0gb2xkLmxpbmUpLCBwb3MuY2gpIH1cbiAgfVxuXG4gIC8vIFVzZWQgYnkgcmVwbGFjZVNlbGVjdGlvbnMgdG8gYWxsb3cgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG8gdGhlXG4gIC8vIHN0YXJ0IG9yIGFyb3VuZCB0aGUgcmVwbGFjZWQgdGVzdC4gSGludCBtYXkgYmUgXCJzdGFydFwiIG9yIFwiYXJvdW5kXCIuXG4gIGZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIG9sZFByZXYgPSBQb3MoZG9jLmZpcnN0LCAwKSwgbmV3UHJldiA9IG9sZFByZXY7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0UG9zKGNoYW5nZS5mcm9tLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgIHZhciB0byA9IG9mZnNldFBvcyhjaGFuZ2VFbmQoY2hhbmdlKSwgb2xkUHJldiwgbmV3UHJldik7XG4gICAgICBvbGRQcmV2ID0gY2hhbmdlLnRvO1xuICAgICAgbmV3UHJldiA9IHRvO1xuICAgICAgaWYgKGhpbnQgPT0gXCJhcm91bmRcIikge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXSwgaW52ID0gY21wKHJhbmdlLmhlYWQsIHJhbmdlLmFuY2hvcikgPCAwO1xuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGZyb20sIGZyb20pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxuICB9XG5cbiAgLy8gVXNlZCB0byBnZXQgdGhlIGVkaXRvciBpbnRvIGEgY29uc2lzdGVudCBzdGF0ZSBhZ2FpbiB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuXG4gIGZ1bmN0aW9uIGxvYWRNb2RlKGNtKSB7XG4gICAgY20uZG9jLm1vZGUgPSBnZXRNb2RlKGNtLm9wdGlvbnMsIGNtLmRvYy5tb2RlT3B0aW9uKTtcbiAgICByZXNldE1vZGVTdGF0ZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldE1vZGVTdGF0ZShjbSkge1xuICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cbiAgICAgIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGw7IH1cbiAgICB9KTtcbiAgICBjbS5kb2MubW9kZUZyb250aWVyID0gY20uZG9jLmhpZ2hsaWdodEZyb250aWVyID0gY20uZG9jLmZpcnN0O1xuICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xuICAgIGNtLnN0YXRlLm1vZGVHZW4rKztcbiAgICBpZiAoY20uY3VyT3ApIHsgcmVnQ2hhbmdlKGNtKTsgfVxuICB9XG5cbiAgLy8gRE9DVU1FTlQgREFUQSBTVFJVQ1RVUkVcblxuICAvLyBCeSBkZWZhdWx0LCB1cGRhdGVzIHRoYXQgc3RhcnQgYW5kIGVuZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZVxuICAvLyBhcmUgdHJlYXRlZCBzcGVjaWFsbHksIGluIG9yZGVyIHRvIG1ha2UgdGhlIGFzc29jaWF0aW9uIG9mIGxpbmVcbiAgLy8gd2lkZ2V0cyBhbmQgbWFya2VyIGVsZW1lbnRzIHdpdGggdGhlIHRleHQgYmVoYXZlIG1vcmUgaW50dWl0aXZlLlxuICBmdW5jdGlvbiBpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkge1xuICAgIHJldHVybiBjaGFuZ2UuZnJvbS5jaCA9PSAwICYmIGNoYW5nZS50by5jaCA9PSAwICYmIGxzdChjaGFuZ2UudGV4dCkgPT0gXCJcIiAmJlxuICAgICAgKCFkb2MuY20gfHwgZG9jLmNtLm9wdGlvbnMud2hvbGVMaW5lVXBkYXRlQmVmb3JlKVxuICB9XG5cbiAgLy8gUGVyZm9ybSBhIGNoYW5nZSBvbiB0aGUgZG9jdW1lbnQgZGF0YSBzdHJ1Y3R1cmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgZnVuY3Rpb24gc3BhbnNGb3Iobikge3JldHVybiBtYXJrZWRTcGFucyA/IG1hcmtlZFNwYW5zW25dIDogbnVsbH1cbiAgICBmdW5jdGlvbiB1cGRhdGUobGluZSwgdGV4dCwgc3BhbnMpIHtcbiAgICAgIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KTtcbiAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFwiY2hhbmdlXCIsIGxpbmUsIGNoYW5nZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVzRm9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKVxuICAgICAgICB7IHJlc3VsdC5wdXNoKG5ldyBMaW5lKHRleHRbaV0sIHNwYW5zRm9yKGkpLCBlc3RpbWF0ZUhlaWdodCkpOyB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG8sIHRleHQgPSBjaGFuZ2UudGV4dDtcbiAgICB2YXIgZmlyc3RMaW5lID0gZ2V0TGluZShkb2MsIGZyb20ubGluZSksIGxhc3RMaW5lID0gZ2V0TGluZShkb2MsIHRvLmxpbmUpO1xuICAgIHZhciBsYXN0VGV4dCA9IGxzdCh0ZXh0KSwgbGFzdFNwYW5zID0gc3BhbnNGb3IodGV4dC5sZW5ndGggLSAxKSwgbmxpbmVzID0gdG8ubGluZSAtIGZyb20ubGluZTtcblxuICAgIC8vIEFkanVzdCB0aGUgbGluZSBzdHJ1Y3R1cmVcbiAgICBpZiAoY2hhbmdlLmZ1bGwpIHtcbiAgICAgIGRvYy5pbnNlcnQoMCwgbGluZXNGb3IoMCwgdGV4dC5sZW5ndGgpKTtcbiAgICAgIGRvYy5yZW1vdmUodGV4dC5sZW5ndGgsIGRvYy5zaXplIC0gdGV4dC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd2hvbGUtbGluZSByZXBsYWNlLiBUcmVhdGVkIHNwZWNpYWxseSB0byBtYWtlXG4gICAgICAvLyBzdXJlIGxpbmUgb2JqZWN0cyBtb3ZlIHRoZSB3YXkgdGhleSBhcmUgc3VwcG9zZWQgdG8uXG4gICAgICB2YXIgYWRkZWQgPSBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0TGluZS50ZXh0LCBsYXN0U3BhbnMpO1xuICAgICAgaWYgKG5saW5lcykgeyBkb2MucmVtb3ZlKGZyb20ubGluZSwgbmxpbmVzKTsgfVxuICAgICAgaWYgKGFkZGVkLmxlbmd0aCkgeyBkb2MuaW5zZXJ0KGZyb20ubGluZSwgYWRkZWQpOyB9XG4gICAgfSBlbHNlIGlmIChmaXJzdExpbmUgPT0gbGFzdExpbmUpIHtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgbGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYWRkZWQkMSA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIGFkZGVkJDEucHVzaChuZXcgTGluZShsYXN0VGV4dCArIGZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkpO1xuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcbiAgICAgICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBzcGFuc0ZvcigwKSk7XG4gICAgICBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xuICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0VGV4dCArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xuICAgICAgdmFyIGFkZGVkJDIgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKG5saW5lcyA+IDEpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMgLSAxKTsgfVxuICAgICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCQyKTtcbiAgICB9XG5cbiAgICBzaWduYWxMYXRlcihkb2MsIFwiY2hhbmdlXCIsIGRvYywgY2hhbmdlKTtcbiAgfVxuXG4gIC8vIENhbGwgZiBmb3IgYWxsIGxpbmtlZCBkb2N1bWVudHMuXG4gIGZ1bmN0aW9uIGxpbmtlZERvY3MoZG9jLCBmLCBzaGFyZWRIaXN0T25seSkge1xuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZShkb2MsIHNraXAsIHNoYXJlZEhpc3QpIHtcbiAgICAgIGlmIChkb2MubGlua2VkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVsID0gZG9jLmxpbmtlZFtpXTtcbiAgICAgICAgaWYgKHJlbC5kb2MgPT0gc2tpcCkgeyBjb250aW51ZSB9XG4gICAgICAgIHZhciBzaGFyZWQgPSBzaGFyZWRIaXN0ICYmIHJlbC5zaGFyZWRIaXN0O1xuICAgICAgICBpZiAoc2hhcmVkSGlzdE9ubHkgJiYgIXNoYXJlZCkgeyBjb250aW51ZSB9XG4gICAgICAgIGYocmVsLmRvYywgc2hhcmVkKTtcbiAgICAgICAgcHJvcGFnYXRlKHJlbC5kb2MsIGRvYywgc2hhcmVkKTtcbiAgICAgIH0gfVxuICAgIH1cbiAgICBwcm9wYWdhdGUoZG9jLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBhIGRvY3VtZW50IHRvIGFuIGVkaXRvci5cbiAgZnVuY3Rpb24gYXR0YWNoRG9jKGNtLCBkb2MpIHtcbiAgICBpZiAoZG9jLmNtKSB7IHRocm93IG5ldyBFcnJvcihcIlRoaXMgZG9jdW1lbnQgaXMgYWxyZWFkeSBpbiB1c2UuXCIpIH1cbiAgICBjbS5kb2MgPSBkb2M7XG4gICAgZG9jLmNtID0gY207XG4gICAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7XG4gICAgbG9hZE1vZGUoY20pO1xuICAgIHNldERpcmVjdGlvbkNsYXNzKGNtKTtcbiAgICBjbS5vcHRpb25zLmRpcmVjdGlvbiA9IGRvYy5kaXJlY3Rpb247XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBmaW5kTWF4TGluZShjbSk7IH1cbiAgICBjbS5vcHRpb25zLm1vZGUgPSBkb2MubW9kZU9wdGlvbjtcbiAgICByZWdDaGFuZ2UoY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RGlyZWN0aW9uQ2xhc3MoY20pIHtcbiAgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IGFkZENsYXNzIDogcm1DbGFzcykoY20uZGlzcGxheS5saW5lRGl2LCBcIkNvZGVNaXJyb3ItcnRsXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlyZWN0aW9uQ2hhbmdlZChjbSkge1xuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldERpcmVjdGlvbkNsYXNzKGNtKTtcbiAgICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBIaXN0b3J5KHByZXYpIHtcbiAgICAvLyBBcnJheXMgb2YgY2hhbmdlIGV2ZW50cyBhbmQgc2VsZWN0aW9ucy4gRG9pbmcgc29tZXRoaW5nIGFkZHMgYW5cbiAgICAvLyBldmVudCB0byBkb25lIGFuZCBjbGVhcnMgdW5kby4gVW5kb2luZyBtb3ZlcyBldmVudHMgZnJvbSBkb25lXG4gICAgLy8gdG8gdW5kb25lLCByZWRvaW5nIG1vdmVzIHRoZW0gaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICB0aGlzLmRvbmUgPSBbXTsgdGhpcy51bmRvbmUgPSBbXTtcbiAgICB0aGlzLnVuZG9EZXB0aCA9IHByZXYgPyBwcmV2LnVuZG9EZXB0aCA6IEluZmluaXR5O1xuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hlbiBjaGFuZ2VzIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZSB1bmRvXG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5sYXN0U2VsVGltZSA9IDA7XG4gICAgdGhpcy5sYXN0T3AgPSB0aGlzLmxhc3RTZWxPcCA9IG51bGw7XG4gICAgdGhpcy5sYXN0T3JpZ2luID0gdGhpcy5sYXN0U2VsT3JpZ2luID0gbnVsbDtcbiAgICAvLyBVc2VkIGJ5IHRoZSBpc0NsZWFuKCkgbWV0aG9kXG4gICAgdGhpcy5nZW5lcmF0aW9uID0gdGhpcy5tYXhHZW5lcmF0aW9uID0gcHJldiA/IHByZXYubWF4R2VuZXJhdGlvbiA6IDE7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBoaXN0b3J5IGNoYW5nZSBldmVudCBmcm9tIGFuIHVwZGF0ZURvYy1zdHlsZSBjaGFuZ2VcbiAgLy8gb2JqZWN0LlxuICBmdW5jdGlvbiBoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIHZhciBoaXN0Q2hhbmdlID0ge2Zyb206IGNvcHlQb3MoY2hhbmdlLmZyb20pLCB0bzogY2hhbmdlRW5kKGNoYW5nZSksIHRleHQ6IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKX07XG4gICAgYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7XG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpOyB9LCB0cnVlKTtcbiAgICByZXR1cm4gaGlzdENoYW5nZVxuICB9XG5cbiAgLy8gUG9wIGFsbCBzZWxlY3Rpb24gZXZlbnRzIG9mZiB0aGUgZW5kIG9mIGEgaGlzdG9yeSBhcnJheS4gU3RvcCBhdFxuICAvLyBhIGNoYW5nZSBldmVudC5cbiAgZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb25FdmVudHMoYXJyYXkpIHtcbiAgICB3aGlsZSAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICB2YXIgbGFzdCA9IGxzdChhcnJheSk7XG4gICAgICBpZiAobGFzdC5yYW5nZXMpIHsgYXJyYXkucG9wKCk7IH1cbiAgICAgIGVsc2UgeyBicmVhayB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgdG9wIGNoYW5nZSBldmVudCBpbiB0aGUgaGlzdG9yeS4gUG9wIG9mZiBzZWxlY3Rpb25cbiAgLy8gZXZlbnRzIHRoYXQgYXJlIGluIHRoZSB3YXkuXG4gIGZ1bmN0aW9uIGxhc3RDaGFuZ2VFdmVudChoaXN0LCBmb3JjZSkge1xuICAgIGlmIChmb3JjZSkge1xuICAgICAgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC5kb25lKTtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxuICAgIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCAmJiAhbHN0KGhpc3QuZG9uZSkucmFuZ2VzKSB7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggPiAxICYmICFoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDJdLnJhbmdlcykge1xuICAgICAgaGlzdC5kb25lLnBvcCgpO1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgaW4gdGhlIGhpc3RvcnkuIE1lcmdlcyBjaGFuZ2VzIHRoYXQgYXJlIHdpdGhpblxuICAvLyBhIHNpbmdsZSBvcGVyYXRpb24sIG9yIGFyZSBjbG9zZSB0b2dldGhlciB3aXRoIGFuIG9yaWdpbiB0aGF0XG4gIC8vIGFsbG93cyBtZXJnaW5nIChzdGFydGluZyB3aXRoIFwiK1wiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxuICBmdW5jdGlvbiBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBvcElkKSB7XG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeTtcbiAgICBoaXN0LnVuZG9uZS5sZW5ndGggPSAwO1xuICAgIHZhciB0aW1lID0gK25ldyBEYXRlLCBjdXI7XG4gICAgdmFyIGxhc3Q7XG5cbiAgICBpZiAoKGhpc3QubGFzdE9wID09IG9wSWQgfHxcbiAgICAgICAgIGhpc3QubGFzdE9yaWdpbiA9PSBjaGFuZ2Uub3JpZ2luICYmIGNoYW5nZS5vcmlnaW4gJiZcbiAgICAgICAgICgoY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIrXCIgJiYgaGlzdC5sYXN0TW9kVGltZSA+IHRpbWUgLSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApKSB8fFxuICAgICAgICAgIGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiKlwiKSkgJiZcbiAgICAgICAgKGN1ciA9IGxhc3RDaGFuZ2VFdmVudChoaXN0LCBoaXN0Lmxhc3RPcCA9PSBvcElkKSkpIHtcbiAgICAgIC8vIE1lcmdlIHRoaXMgY2hhbmdlIGludG8gdGhlIGxhc3QgZXZlbnRcbiAgICAgIGxhc3QgPSBsc3QoY3VyLmNoYW5nZXMpO1xuICAgICAgaWYgKGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwICYmIGNtcChjaGFuZ2UuZnJvbSwgbGFzdC50bykgPT0gMCkge1xuICAgICAgICAvLyBPcHRpbWl6ZWQgY2FzZSBmb3Igc2ltcGxlIGluc2VydGlvbiAtLSBkb24ndCB3YW50IHRvIGFkZFxuICAgICAgICAvLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXG4gICAgICAgIGxhc3QudG8gPSBjaGFuZ2VFbmQoY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBuZXcgc3ViLWV2ZW50XG4gICAgICAgIGN1ci5jaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FuIG5vdCBiZSBtZXJnZWQsIHN0YXJ0IGEgbmV3IGV2ZW50LlxuICAgICAgdmFyIGJlZm9yZSA9IGxzdChoaXN0LmRvbmUpO1xuICAgICAgaWYgKCFiZWZvcmUgfHwgIWJlZm9yZS5yYW5nZXMpXG4gICAgICAgIHsgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShkb2Muc2VsLCBoaXN0LmRvbmUpOyB9XG4gICAgICBjdXIgPSB7Y2hhbmdlczogW2hpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKV0sXG4gICAgICAgICAgICAgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufTtcbiAgICAgIGhpc3QuZG9uZS5wdXNoKGN1cik7XG4gICAgICB3aGlsZSAoaGlzdC5kb25lLmxlbmd0aCA+IGhpc3QudW5kb0RlcHRoKSB7XG4gICAgICAgIGhpc3QuZG9uZS5zaGlmdCgpO1xuICAgICAgICBpZiAoIWhpc3QuZG9uZVswXS5yYW5nZXMpIHsgaGlzdC5kb25lLnNoaWZ0KCk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgaGlzdC5kb25lLnB1c2goc2VsQWZ0ZXIpO1xuICAgIGhpc3QuZ2VuZXJhdGlvbiA9ICsraGlzdC5tYXhHZW5lcmF0aW9uO1xuICAgIGhpc3QubGFzdE1vZFRpbWUgPSBoaXN0Lmxhc3RTZWxUaW1lID0gdGltZTtcbiAgICBoaXN0Lmxhc3RPcCA9IGhpc3QubGFzdFNlbE9wID0gb3BJZDtcbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBjaGFuZ2Uub3JpZ2luO1xuXG4gICAgaWYgKCFsYXN0KSB7IHNpZ25hbChkb2MsIFwiaGlzdG9yeUFkZGVkXCIpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYywgb3JpZ2luLCBwcmV2LCBzZWwpIHtcbiAgICB2YXIgY2ggPSBvcmlnaW4uY2hhckF0KDApO1xuICAgIHJldHVybiBjaCA9PSBcIipcIiB8fFxuICAgICAgY2ggPT0gXCIrXCIgJiZcbiAgICAgIHByZXYucmFuZ2VzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aCAmJlxuICAgICAgcHJldi5zb21ldGhpbmdTZWxlY3RlZCgpID09IHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpICYmXG4gICAgICBuZXcgRGF0ZSAtIGRvYy5oaXN0b3J5Lmxhc3RTZWxUaW1lIDw9IChkb2MuY20gPyBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSA6IDUwMClcbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0aW9uIGNoYW5nZXMsIHNldHMgdGhlIG5ldyBzZWxlY3Rpb24gYXNcbiAgLy8gdGhlIHBlbmRpbmcgc2VsZWN0aW9uIGluIHRoZSBoaXN0b3J5LCBhbmQgcHVzaGVzIHRoZSBvbGQgcGVuZGluZ1xuICAvLyBzZWxlY3Rpb24gaW50byB0aGUgJ2RvbmUnIGFycmF5IHdoZW4gaXQgd2FzIHNpZ25pZmljYW50bHlcbiAgLy8gZGlmZmVyZW50IChpbiBudW1iZXIgb2Ygc2VsZWN0ZWQgcmFuZ2VzLCBlbXB0aW5lc3MsIG9yIHRpbWUpLlxuICBmdW5jdGlvbiBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBzZWwsIG9wSWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBvcmlnaW4gPSBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luO1xuXG4gICAgLy8gQSBuZXcgZXZlbnQgaXMgc3RhcnRlZCB3aGVuIHRoZSBwcmV2aW91cyBvcmlnaW4gZG9lcyBub3QgbWF0Y2hcbiAgICAvLyB0aGUgY3VycmVudCwgb3IgdGhlIG9yaWdpbnMgZG9uJ3QgYWxsb3cgbWF0Y2hpbmcuIE9yaWdpbnNcbiAgICAvLyBzdGFydGluZyB3aXRoICogYXJlIGFsd2F5cyBtZXJnZWQsIHRob3NlIHN0YXJ0aW5nIHdpdGggKyBhcmVcbiAgICAvLyBtZXJnZWQgd2hlbiBzaW1pbGFyIGFuZCBjbG9zZSB0b2dldGhlciBpbiB0aW1lLlxuICAgIGlmIChvcElkID09IGhpc3QubGFzdFNlbE9wIHx8XG4gICAgICAgIChvcmlnaW4gJiYgaGlzdC5sYXN0U2VsT3JpZ2luID09IG9yaWdpbiAmJlxuICAgICAgICAgKGhpc3QubGFzdE1vZFRpbWUgPT0gaGlzdC5sYXN0U2VsVGltZSAmJiBoaXN0Lmxhc3RPcmlnaW4gPT0gb3JpZ2luIHx8XG4gICAgICAgICAgc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgbHN0KGhpc3QuZG9uZSksIHNlbCkpKSlcbiAgICAgIHsgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbDsgfVxuICAgIGVsc2VcbiAgICAgIHsgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWwsIGhpc3QuZG9uZSk7IH1cblxuICAgIGhpc3QubGFzdFNlbFRpbWUgPSArbmV3IERhdGU7XG4gICAgaGlzdC5sYXN0U2VsT3JpZ2luID0gb3JpZ2luO1xuICAgIGhpc3QubGFzdFNlbE9wID0gb3BJZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNsZWFyUmVkbyAhPT0gZmFsc2UpXG4gICAgICB7IGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QudW5kb25lKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWwsIGRlc3QpIHtcbiAgICB2YXIgdG9wID0gbHN0KGRlc3QpO1xuICAgIGlmICghKHRvcCAmJiB0b3AucmFuZ2VzICYmIHRvcC5lcXVhbHMoc2VsKSkpXG4gICAgICB7IGRlc3QucHVzaChzZWwpOyB9XG4gIH1cblxuICAvLyBVc2VkIHRvIHN0b3JlIG1hcmtlZCBzcGFuIGluZm9ybWF0aW9uIGluIHRoZSBoaXN0b3J5LlxuICBmdW5jdGlvbiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgY2hhbmdlLCBmcm9tLCB0bykge1xuICAgIHZhciBleGlzdGluZyA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXSwgbiA9IDA7XG4gICAgZG9jLml0ZXIoTWF0aC5tYXgoZG9jLmZpcnN0LCBmcm9tKSwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIHRvKSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKVxuICAgICAgICB7IChleGlzdGluZyB8fCAoZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0gPSB7fSkpW25dID0gbGluZS5tYXJrZWRTcGFuczsgfVxuICAgICAgKytuO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gV2hlbiB1bi9yZS1kb2luZyByZXN0b3JlcyB0ZXh0IGNvbnRhaW5pbmcgbWFya2VkIHNwYW5zLCB0aG9zZVxuICAvLyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IGNsZWFyZWQgc2hvdWxkIG5vdCBiZSByZXN0b3JlZC5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xlYXJlZFNwYW5zKHNwYW5zKSB7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG91dDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoc3BhbnNbaV0ubWFya2VyLmV4cGxpY2l0bHlDbGVhcmVkKSB7IGlmICghb3V0KSB7IG91dCA9IHNwYW5zLnNsaWNlKDAsIGkpOyB9IH1cbiAgICAgIGVsc2UgaWYgKG91dCkgeyBvdXQucHVzaChzcGFuc1tpXSk7IH1cbiAgICB9XG4gICAgcmV0dXJuICFvdXQgPyBzcGFucyA6IG91dC5sZW5ndGggPyBvdXQgOiBudWxsXG4gIH1cblxuICAvLyBSZXRyaWV2ZSBhbmQgZmlsdGVyIHRoZSBvbGQgbWFya2VkIHNwYW5zIHN0b3JlZCBpbiBhIGNoYW5nZSBldmVudC5cbiAgZnVuY3Rpb24gZ2V0T2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgZm91bmQgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF07XG4gICAgaWYgKCFmb3VuZCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG53ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2UudGV4dC5sZW5ndGg7ICsraSlcbiAgICAgIHsgbncucHVzaChyZW1vdmVDbGVhcmVkU3BhbnMoZm91bmRbaV0pKTsgfVxuICAgIHJldHVybiBud1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgdW4vcmUtZG9pbmcgY2hhbmdlcyBmcm9tIHRoZSBoaXN0b3J5LiBDb21iaW5lcyB0aGVcbiAgLy8gcmVzdWx0IG9mIGNvbXB1dGluZyB0aGUgZXhpc3Rpbmcgc3BhbnMgd2l0aCB0aGUgc2V0IG9mIHNwYW5zIHRoYXRcbiAgLy8gZXhpc3RlZCBpbiB0aGUgaGlzdG9yeSAoc28gdGhhdCBkZWxldGluZyBhcm91bmQgYSBzcGFuIGFuZCB0aGVuXG4gIC8vIHVuZG9pbmcgYnJpbmdzIGJhY2sgdGhlIHNwYW4pLlxuICBmdW5jdGlvbiBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIG9sZCA9IGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKTtcbiAgICB2YXIgc3RyZXRjaGVkID0gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSk7XG4gICAgaWYgKCFvbGQpIHsgcmV0dXJuIHN0cmV0Y2hlZCB9XG4gICAgaWYgKCFzdHJldGNoZWQpIHsgcmV0dXJuIG9sZCB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIG9sZEN1ciA9IG9sZFtpXSwgc3RyZXRjaEN1ciA9IHN0cmV0Y2hlZFtpXTtcbiAgICAgIGlmIChvbGRDdXIgJiYgc3RyZXRjaEN1cikge1xuICAgICAgICBzcGFuczogZm9yICh2YXIgaiA9IDA7IGogPCBzdHJldGNoQ3VyLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBzdHJldGNoQ3VyW2pdO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2xkQ3VyLmxlbmd0aDsgKytrKVxuICAgICAgICAgICAgeyBpZiAob2xkQ3VyW2tdLm1hcmtlciA9PSBzcGFuLm1hcmtlcikgeyBjb250aW51ZSBzcGFucyB9IH1cbiAgICAgICAgICBvbGRDdXIucHVzaChzcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJldGNoQ3VyKSB7XG4gICAgICAgIG9sZFtpXSA9IHN0cmV0Y2hDdXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbGRcbiAgfVxuXG4gIC8vIFVzZWQgYm90aCB0byBwcm92aWRlIGEgSlNPTi1zYWZlIG9iamVjdCBpbiAuZ2V0SGlzdG9yeSwgYW5kLCB3aGVuXG4gIC8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cbiAgZnVuY3Rpb24gY29weUhpc3RvcnlBcnJheShldmVudHMsIG5ld0dyb3VwLCBpbnN0YW50aWF0ZVNlbCkge1xuICAgIHZhciBjb3B5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgY29weS5wdXNoKGluc3RhbnRpYXRlU2VsID8gU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VzID0gZXZlbnQuY2hhbmdlcywgbmV3Q2hhbmdlcyA9IFtdO1xuICAgICAgY29weS5wdXNoKHtjaGFuZ2VzOiBuZXdDaGFuZ2VzfSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYW5nZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal0sIG0gPSAodm9pZCAwKTtcbiAgICAgICAgbmV3Q2hhbmdlcy5wdXNoKHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZS50bywgdGV4dDogY2hhbmdlLnRleHR9KTtcbiAgICAgICAgaWYgKG5ld0dyb3VwKSB7IGZvciAodmFyIHByb3AgaW4gY2hhbmdlKSB7IGlmIChtID0gcHJvcC5tYXRjaCgvXnNwYW5zXyhcXGQrKSQvKSkge1xuICAgICAgICAgIGlmIChpbmRleE9mKG5ld0dyb3VwLCBOdW1iZXIobVsxXSkpID4gLTEpIHtcbiAgICAgICAgICAgIGxzdChuZXdDaGFuZ2VzKVtwcm9wXSA9IGNoYW5nZVtwcm9wXTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weVxuICB9XG5cbiAgLy8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXG4gIC8vIHRoZSBuZXcgY3Vyc29yIHBvc2l0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXJcbiAgLy8gbW9kaWZ5aW5nIHRoZSBzZWxlY3Rpb24uXG5cbiAgLy8gSWYgc2hpZnQgaXMgaGVsZCBvciB0aGUgZXh0ZW5kIGZsYWcgaXMgc2V0LCBleHRlbmRzIGEgcmFuZ2UgdG9cbiAgLy8gaW5jbHVkZSBhIGdpdmVuIHBvc2l0aW9uIChhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBwb3NpdGlvbikuXG4gIC8vIE90aGVyd2lzZSwgc2ltcGx5IHJldHVybnMgdGhlIHJhbmdlIGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgLy8gVXNlZCBmb3IgY3Vyc29yIG1vdGlvbiBhbmQgc3VjaC5cbiAgZnVuY3Rpb24gZXh0ZW5kUmFuZ2UocmFuZ2UsIGhlYWQsIG90aGVyLCBleHRlbmQpIHtcbiAgICBpZiAoZXh0ZW5kKSB7XG4gICAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yO1xuICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgIHZhciBwb3NCZWZvcmUgPSBjbXAoaGVhZCwgYW5jaG9yKSA8IDA7XG4gICAgICAgIGlmIChwb3NCZWZvcmUgIT0gKGNtcChvdGhlciwgYW5jaG9yKSA8IDApKSB7XG4gICAgICAgICAgYW5jaG9yID0gaGVhZDtcbiAgICAgICAgICBoZWFkID0gb3RoZXI7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zQmVmb3JlICE9IChjbXAoaGVhZCwgb3RoZXIpIDwgMCkpIHtcbiAgICAgICAgICBoZWFkID0gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKG90aGVyIHx8IGhlYWQsIGhlYWQpXG4gICAgfVxuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZSwgZGlzY2FyZCB0aGUgcmVzdC5cbiAgZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9uKGRvYywgaGVhZCwgb3RoZXIsIG9wdGlvbnMsIGV4dGVuZCkge1xuICAgIGlmIChleHRlbmQgPT0gbnVsbCkgeyBleHRlbmQgPSBkb2MuY20gJiYgKGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpOyB9XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbZXh0ZW5kUmFuZ2UoZG9jLnNlbC5wcmltYXJ5KCksIGhlYWQsIG90aGVyLCBleHRlbmQpXSwgMCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIGFsbCBzZWxlY3Rpb25zIChwb3MgaXMgYW4gYXJyYXkgb2Ygc2VsZWN0aW9ucyB3aXRoIGxlbmd0aFxuICAvLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHNlbGVjdGlvbnMpXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbnMoZG9jLCBoZWFkcywgb3B0aW9ucykge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgZXh0ZW5kID0gZG9jLmNtICYmIChkb2MuY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBvdXRbaV0gPSBleHRlbmRSYW5nZShkb2Muc2VsLnJhbmdlc1tpXSwgaGVhZHNbaV0sIG51bGwsIGV4dGVuZCk7IH1cbiAgICB2YXIgbmV3U2VsID0gbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgb3V0LCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3U2VsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGksIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJhbmdlcyA9IGRvYy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgIHJhbmdlc1tpXSA9IHJhbmdlO1xuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIHJhbmdlcywgZG9jLnNlbC5wcmltSW5kZXgpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBzZWxlY3Rpb24gdG8gYSBzaW5nbGUgcmFuZ2UuXG4gIGZ1bmN0aW9uIHNldFNpbXBsZVNlbGVjdGlvbihkb2MsIGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgIHNldFNlbGVjdGlvbihkb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEdpdmUgYmVmb3JlU2VsZWN0aW9uQ2hhbmdlIGhhbmRsZXJzIGEgY2hhbmdlIHRvIGluZmx1ZW5jZSBhXG4gIC8vIHNlbGVjdGlvbiB1cGRhdGUuXG4gIGZ1bmN0aW9uIGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7XG4gICAgICByYW5nZXM6IHNlbC5yYW5nZXMsXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uKHJhbmdlcykge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IHRoaXMucmFuZ2VzW2ldID0gbmV3IFJhbmdlKGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uYW5jaG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmhlYWQpKTsgfVxuICAgICAgfSxcbiAgICAgIG9yaWdpbjogb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpblxuICAgIH07XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHsgc2lnbmFsKGRvYy5jbSwgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIiwgZG9jLmNtLCBvYmopOyB9XG4gICAgaWYgKG9iai5yYW5nZXMgIT0gc2VsLnJhbmdlcykgeyByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgb2JqLnJhbmdlcywgb2JqLnJhbmdlcy5sZW5ndGggLSAxKSB9XG4gICAgZWxzZSB7IHJldHVybiBzZWwgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9uZSA9IGRvYy5oaXN0b3J5LmRvbmUsIGxhc3QgPSBsc3QoZG9uZSk7XG4gICAgaWYgKGxhc3QgJiYgbGFzdC5yYW5nZXMpIHtcbiAgICAgIGRvbmVbZG9uZS5sZW5ndGggLSAxXSA9IHNlbDtcbiAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IGEgbmV3IHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBkb2Muc2VsLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4sIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKVxuICAgICAgeyBzZWwgPSBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpOyB9XG5cbiAgICB2YXIgYmlhcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5iaWFzIHx8XG4gICAgICAoY21wKHNlbC5wcmltYXJ5KCkuaGVhZCwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCkgPCAwID8gLTEgOiAxKTtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgdHJ1ZSkpO1xuXG4gICAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLnNjcm9sbCA9PT0gZmFsc2UpICYmIGRvYy5jbSAmJiBkb2MuY20uZ2V0T3B0aW9uKFwicmVhZE9ubHlcIikgIT0gXCJub2N1cnNvclwiKVxuICAgICAgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKGRvYy5jbSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2VsKSB7XG4gICAgaWYgKHNlbC5lcXVhbHMoZG9jLnNlbCkpIHsgcmV0dXJuIH1cblxuICAgIGRvYy5zZWwgPSBzZWw7XG5cbiAgICBpZiAoZG9jLmNtKSB7XG4gICAgICBkb2MuY20uY3VyT3AudXBkYXRlSW5wdXQgPSAxO1xuICAgICAgZG9jLmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgc2lnbmFsQ3Vyc29yQWN0aXZpdHkoZG9jLmNtKTtcbiAgICB9XG4gICAgc2lnbmFsTGF0ZXIoZG9jLCBcImN1cnNvckFjdGl2aXR5XCIsIGRvYyk7XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB0aGUgc2VsZWN0aW9uIGRvZXMgbm90IHBhcnRpYWxseSBzZWxlY3QgYW55IGF0b21pY1xuICAvLyBtYXJrZWQgcmFuZ2VzLlxuICBmdW5jdGlvbiByZUNoZWNrU2VsZWN0aW9uKGRvYykge1xuICAgIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgZG9jLnNlbCwgbnVsbCwgZmFsc2UpKTtcbiAgfVxuXG4gIC8vIFJldHVybiBhIHNlbGVjdGlvbiB0aGF0IGRvZXMgbm90IHBhcnRpYWxseSBzZWxlY3QgYW55IGF0b21pY1xuICAvLyByYW5nZXMuXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgbWF5Q2xlYXIpIHtcbiAgICB2YXIgb3V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgIHZhciBvbGQgPSBzZWwucmFuZ2VzLmxlbmd0aCA9PSBkb2Muc2VsLnJhbmdlcy5sZW5ndGggJiYgZG9jLnNlbC5yYW5nZXNbaV07XG4gICAgICB2YXIgbmV3QW5jaG9yID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlLmFuY2hvciwgb2xkICYmIG9sZC5hbmNob3IsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIHZhciBuZXdIZWFkID0gcmFuZ2UuaGVhZCA9PSByYW5nZS5hbmNob3IgPyBuZXdBbmNob3IgOiBza2lwQXRvbWljKGRvYywgcmFuZ2UuaGVhZCwgb2xkICYmIG9sZC5oZWFkLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICBpZiAob3V0IHx8IG5ld0FuY2hvciAhPSByYW5nZS5hbmNob3IgfHwgbmV3SGVhZCAhPSByYW5nZS5oZWFkKSB7XG4gICAgICAgIGlmICghb3V0KSB7IG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaSk7IH1cbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIHNlbC5wcmltSW5kZXgpIDogc2VsXG4gIH1cblxuICBmdW5jdGlvbiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKTtcbiAgICBpZiAobGluZS5tYXJrZWRTcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXI7XG5cbiAgICAgIC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgcHJldmVudCB0aGUgY3Vyc29yIGJlaW5nIHBsYWNlZCB0byB0aGUgbGVmdC9yaWdodCBvZiBhbiBhdG9taWMgbWFya2VyXG4gICAgICAvLyBIaXN0b3JpY2FsbHkgdGhpcyB3YXMgZGV0ZXJtaW5lZCB1c2luZyB0aGUgaW5jbHVzaXZlTGVmdC9SaWdodCBvcHRpb24sIGJ1dCB0aGUgbmV3IHdheSB0byBjb250cm9sIGl0XG4gICAgICAvLyBpcyB3aXRoIHNlbGVjdExlZnQvUmlnaHRcbiAgICAgIHZhciBwcmV2ZW50Q3Vyc29yTGVmdCA9IChcInNlbGVjdExlZnRcIiBpbiBtKSA/ICFtLnNlbGVjdExlZnQgOiBtLmluY2x1c2l2ZUxlZnQ7XG4gICAgICB2YXIgcHJldmVudEN1cnNvclJpZ2h0ID0gKFwic2VsZWN0UmlnaHRcIiBpbiBtKSA/ICFtLnNlbGVjdFJpZ2h0IDogbS5pbmNsdXNpdmVSaWdodDtcblxuICAgICAgaWYgKChzcC5mcm9tID09IG51bGwgfHwgKHByZXZlbnRDdXJzb3JMZWZ0ID8gc3AuZnJvbSA8PSBwb3MuY2ggOiBzcC5mcm9tIDwgcG9zLmNoKSkgJiZcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCAocHJldmVudEN1cnNvclJpZ2h0ID8gc3AudG8gPj0gcG9zLmNoIDogc3AudG8gPiBwb3MuY2gpKSkge1xuICAgICAgICBpZiAobWF5Q2xlYXIpIHtcbiAgICAgICAgICBzaWduYWwobSwgXCJiZWZvcmVDdXJzb3JFbnRlclwiKTtcbiAgICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLm1hcmtlZFNwYW5zKSB7IGJyZWFrIH1cbiAgICAgICAgICAgIGVsc2Ugey0taTsgY29udGludWV9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbS5hdG9taWMpIHsgY29udGludWUgfVxuXG4gICAgICAgIGlmIChvbGRQb3MpIHtcbiAgICAgICAgICB2YXIgbmVhciA9IG0uZmluZChkaXIgPCAwID8gMSA6IC0xKSwgZGlmZiA9ICh2b2lkIDApO1xuICAgICAgICAgIGlmIChkaXIgPCAwID8gcHJldmVudEN1cnNvclJpZ2h0IDogcHJldmVudEN1cnNvckxlZnQpXG4gICAgICAgICAgICB7IG5lYXIgPSBtb3ZlUG9zKGRvYywgbmVhciwgLWRpciwgbmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cbiAgICAgICAgICBpZiAobmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgJiYgKGRpZmYgPSBjbXAobmVhciwgb2xkUG9zKSkgJiYgKGRpciA8IDAgPyBkaWZmIDwgMCA6IGRpZmYgPiAwKSlcbiAgICAgICAgICAgIHsgcmV0dXJuIHNraXBBdG9taWNJbm5lcihkb2MsIG5lYXIsIHBvcywgZGlyLCBtYXlDbGVhcikgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhciA9IG0uZmluZChkaXIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgaWYgKGRpciA8IDAgPyBwcmV2ZW50Q3Vyc29yTGVmdCA6IHByZXZlbnRDdXJzb3JSaWdodClcbiAgICAgICAgICB7IGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cbiAgICAgICAgcmV0dXJuIGZhciA/IHNraXBBdG9taWNJbm5lcihkb2MsIGZhciwgcG9zLCBkaXIsIG1heUNsZWFyKSA6IG51bGxcbiAgICAgIH1cbiAgICB9IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvLyBFbnN1cmUgYSBnaXZlbiBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGFuIGF0b21pYyByYW5nZS5cbiAgZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBiaWFzLCBtYXlDbGVhcikge1xuICAgIHZhciBkaXIgPSBiaWFzIHx8IDE7XG4gICAgdmFyIGZvdW5kID0gc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgbWF5Q2xlYXIpIHx8XG4gICAgICAgICghbWF5Q2xlYXIgJiYgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgdHJ1ZSkpIHx8XG4gICAgICAgIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCBtYXlDbGVhcikgfHxcbiAgICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgLWRpciwgdHJ1ZSkpO1xuICAgIGlmICghZm91bmQpIHtcbiAgICAgIGRvYy5jYW50RWRpdCA9IHRydWU7XG4gICAgICByZXR1cm4gUG9zKGRvYy5maXJzdCwgMClcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlUG9zKGRvYywgcG9zLCBkaXIsIGxpbmUpIHtcbiAgICBpZiAoZGlyIDwgMCAmJiBwb3MuY2ggPT0gMCkge1xuICAgICAgaWYgKHBvcy5saW5lID4gZG9jLmZpcnN0KSB7IHJldHVybiBjbGlwUG9zKGRvYywgUG9zKHBvcy5saW5lIC0gMSkpIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XG4gICAgfSBlbHNlIGlmIChkaXIgPiAwICYmIHBvcy5jaCA9PSAobGluZSB8fCBnZXRMaW5lKGRvYywgcG9zLmxpbmUpKS50ZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKHBvcy5saW5lIDwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSB7IHJldHVybiBQb3MocG9zLmxpbmUgKyAxLCAwKSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIG51bGwgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvcyhwb3MubGluZSwgcG9zLmNoICsgZGlyKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEFsbChjbSkge1xuICAgIGNtLnNldFNlbGVjdGlvbihQb3MoY20uZmlyc3RMaW5lKCksIDApLCBQb3MoY20ubGFzdExpbmUoKSksIHNlbF9kb250U2Nyb2xsKTtcbiAgfVxuXG4gIC8vIFVQREFUSU5HXG5cbiAgLy8gQWxsb3cgXCJiZWZvcmVDaGFuZ2VcIiBldmVudCBoYW5kbGVycyB0byBpbmZsdWVuY2UgYSBjaGFuZ2VcbiAgZnVuY3Rpb24gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB1cGRhdGUpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgZnJvbTogY2hhbmdlLmZyb20sXG4gICAgICB0bzogY2hhbmdlLnRvLFxuICAgICAgdGV4dDogY2hhbmdlLnRleHQsXG4gICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW4sXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iai5jYW5jZWxlZCA9IHRydWU7IH1cbiAgICB9O1xuICAgIGlmICh1cGRhdGUpIHsgb2JqLnVwZGF0ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgdGV4dCwgb3JpZ2luKSB7XG4gICAgICBpZiAoZnJvbSkgeyBvYmouZnJvbSA9IGNsaXBQb3MoZG9jLCBmcm9tKTsgfVxuICAgICAgaWYgKHRvKSB7IG9iai50byA9IGNsaXBQb3MoZG9jLCB0byk7IH1cbiAgICAgIGlmICh0ZXh0KSB7IG9iai50ZXh0ID0gdGV4dDsgfVxuICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7IG9iai5vcmlnaW4gPSBvcmlnaW47IH1cbiAgICB9OyB9XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVDaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHsgc2lnbmFsKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIiwgZG9jLmNtLCBvYmopOyB9XG5cbiAgICBpZiAob2JqLmNhbmNlbGVkKSB7XG4gICAgICBpZiAoZG9jLmNtKSB7IGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IDI7IH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiB7ZnJvbTogb2JqLmZyb20sIHRvOiBvYmoudG8sIHRleHQ6IG9iai50ZXh0LCBvcmlnaW46IG9iai5vcmlnaW59XG4gIH1cblxuICAvLyBBcHBseSBhIGNoYW5nZSB0byBhIGRvY3VtZW50LCBhbmQgYWRkIGl0IHRvIHRoZSBkb2N1bWVudCdzXG4gIC8vIGhpc3RvcnksIGFuZCBwcm9wYWdhdGluZyBpdCB0byBhbGwgbGlua2VkIGRvY3VtZW50cy5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIHtcbiAgICBpZiAoZG9jLmNtKSB7XG4gICAgICBpZiAoIWRvYy5jbS5jdXJPcCkgeyByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZSkoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB9XG4gICAgICBpZiAoZG9jLmNtLnN0YXRlLnN1cHByZXNzRWRpdHMpIHsgcmV0dXJuIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIikpIHtcbiAgICAgIGNoYW5nZSA9IGZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoYW5nZSkgeyByZXR1cm4gfVxuICAgIH1cblxuICAgIC8vIFBvc3NpYmx5IHNwbGl0IG9yIHN1cHByZXNzIHRoZSB1cGRhdGUgYmFzZWQgb24gdGhlIHByZXNlbmNlXG4gICAgLy8gb2YgcmVhZC1vbmx5IHNwYW5zIGluIGl0cyByYW5nZS5cbiAgICB2YXIgc3BsaXQgPSBzYXdSZWFkT25seVNwYW5zICYmICFpZ25vcmVSZWFkT25seSAmJiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgIGlmIChzcGxpdCkge1xuICAgICAgZm9yICh2YXIgaSA9IHNwbGl0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICB7IG1ha2VDaGFuZ2VJbm5lcihkb2MsIHtmcm9tOiBzcGxpdFtpXS5mcm9tLCB0bzogc3BsaXRbaV0udG8sIHRleHQ6IGkgPyBbXCJcIl0gOiBjaGFuZ2UudGV4dCwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgY2hhbmdlLnRleHRbMF0gPT0gXCJcIiAmJiBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCkgeyByZXR1cm4gfVxuICAgIHZhciBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7XG4gICAgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOKTtcblxuICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgdmFyIHJlYmFzZWQgPSBbXTtcblxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcbiAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgIH1cbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmVydCBhIGNoYW5nZSBzdG9yZWQgaW4gYSBkb2N1bWVudCdzIGhpc3RvcnkuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeShkb2MsIHR5cGUsIGFsbG93U2VsZWN0aW9uT25seSkge1xuICAgIHZhciBzdXBwcmVzcyA9IGRvYy5jbSAmJiBkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cztcbiAgICBpZiAoc3VwcHJlc3MgJiYgIWFsbG93U2VsZWN0aW9uT25seSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgZXZlbnQsIHNlbEFmdGVyID0gZG9jLnNlbDtcbiAgICB2YXIgc291cmNlID0gdHlwZSA9PSBcInVuZG9cIiA/IGhpc3QuZG9uZSA6IGhpc3QudW5kb25lLCBkZXN0ID0gdHlwZSA9PSBcInVuZG9cIiA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lO1xuXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYSB1c2VhYmxlIGV2ZW50IChzbyB0aGF0IGN0cmwteiB3b24ndFxuICAgIC8vIG5lZWRsZXNzbHkgY2xlYXIgc2VsZWN0aW9uIGV2ZW50cylcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV2ZW50ID0gc291cmNlW2ldO1xuICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSA/IGV2ZW50LnJhbmdlcyAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpIDogIWV2ZW50LnJhbmdlcylcbiAgICAgICAgeyBicmVhayB9XG4gICAgfVxuICAgIGlmIChpID09IHNvdXJjZS5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgZXZlbnQgPSBzb3VyY2UucG9wKCk7XG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZXZlbnQsIGRlc3QpO1xuICAgICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkpIHtcbiAgICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBldmVudCwge2NsZWFyUmVkbzogZmFsc2V9KTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzZWxBZnRlciA9IGV2ZW50O1xuICAgICAgfSBlbHNlIGlmIChzdXBwcmVzcykge1xuICAgICAgICBzb3VyY2UucHVzaChldmVudCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHVwIGEgcmV2ZXJzZSBjaGFuZ2Ugb2JqZWN0IHRvIGFkZCB0byB0aGUgb3Bwb3NpdGUgaGlzdG9yeVxuICAgIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxuICAgIHZhciBhbnRpQ2hhbmdlcyA9IFtdO1xuICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsQWZ0ZXIsIGRlc3QpO1xuICAgIGRlc3QucHVzaCh7Y2hhbmdlczogYW50aUNoYW5nZXMsIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn0pO1xuICAgIGhpc3QuZ2VuZXJhdGlvbiA9IGV2ZW50LmdlbmVyYXRpb24gfHwgKytoaXN0Lm1heEdlbmVyYXRpb247XG5cbiAgICB2YXIgZmlsdGVyID0gaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIik7XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBldmVudC5jaGFuZ2VzW2ldO1xuICAgICAgY2hhbmdlLm9yaWdpbiA9IHR5cGU7XG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIGZhbHNlKSkge1xuICAgICAgICBzb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgICB9XG5cbiAgICAgIGFudGlDaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcblxuICAgICAgdmFyIGFmdGVyID0gaSA/IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkgOiBsc3Qoc291cmNlKTtcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIGFmdGVyLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICBpZiAoIWkgJiYgZG9jLmNtKSB7IGRvYy5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKX0pOyB9XG4gICAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcbiAgICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSk7XG4gICAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSQxID0gZXZlbnQuY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgLS1pJDEpIHtcbiAgICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkkMSApO1xuXG4gICAgICBpZiAoIHJldHVybmVkICkgcmV0dXJuIHJldHVybmVkLnY7XG4gICAgfVxuICB9XG5cbiAgLy8gU3ViLXZpZXdzIG5lZWQgdGhlaXIgbGluZSBudW1iZXJzIHNoaWZ0ZWQgd2hlbiB0ZXh0IGlzIGFkZGVkXG4gIC8vIGFib3ZlIG9yIGJlbG93IHRoZW0gaW4gdGhlIHBhcmVudCBkb2N1bWVudC5cbiAgZnVuY3Rpb24gc2hpZnREb2MoZG9jLCBkaXN0YW5jZSkge1xuICAgIGlmIChkaXN0YW5jZSA9PSAwKSB7IHJldHVybiB9XG4gICAgZG9jLmZpcnN0ICs9IGRpc3RhbmNlO1xuICAgIGRvYy5zZWwgPSBuZXcgU2VsZWN0aW9uKG1hcChkb2Muc2VsLnJhbmdlcywgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICBQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcbiAgICAgIFBvcyhyYW5nZS5oZWFkLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuaGVhZC5jaClcbiAgICApOyB9KSwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIHJlZ0NoYW5nZShkb2MuY20sIGRvYy5maXJzdCwgZG9jLmZpcnN0IC0gZGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgICAgIGZvciAodmFyIGQgPSBkb2MuY20uZGlzcGxheSwgbCA9IGQudmlld0Zyb207IGwgPCBkLnZpZXdUbzsgbCsrKVxuICAgICAgICB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcImd1dHRlclwiKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1vcmUgbG93ZXItbGV2ZWwgY2hhbmdlIGZ1bmN0aW9uLCBoYW5kbGluZyBvbmx5IGEgc2luZ2xlIGRvY3VtZW50XG4gIC8vIChub3QgbGlua2VkIG9uZXMpLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIHtcbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApXG4gICAgICB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlU2luZ2xlRG9jKShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHNwYW5zKSB9XG5cbiAgICBpZiAoY2hhbmdlLnRvLmxpbmUgPCBkb2MuZmlyc3QpIHtcbiAgICAgIHNoaWZ0RG9jKGRvYywgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoY2hhbmdlLmZyb20ubGluZSA+IGRvYy5sYXN0TGluZSgpKSB7IHJldHVybiB9XG5cbiAgICAvLyBDbGlwIHRoZSBjaGFuZ2UgdG8gdGhlIHNpemUgb2YgdGhpcyBkb2NcbiAgICBpZiAoY2hhbmdlLmZyb20ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgdmFyIHNoaWZ0ID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChkb2MuZmlyc3QgLSBjaGFuZ2UuZnJvbS5saW5lKTtcbiAgICAgIHNoaWZ0RG9jKGRvYywgc2hpZnQpO1xuICAgICAgY2hhbmdlID0ge2Zyb206IFBvcyhkb2MuZmlyc3QsIDApLCB0bzogUG9zKGNoYW5nZS50by5saW5lICsgc2hpZnQsIGNoYW5nZS50by5jaCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2xzdChjaGFuZ2UudGV4dCldLCBvcmlnaW46IGNoYW5nZS5vcmlnaW59O1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IGRvYy5sYXN0TGluZSgpO1xuICAgIGlmIChjaGFuZ2UudG8ubGluZSA+IGxhc3QpIHtcbiAgICAgIGNoYW5nZSA9IHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHRleHQ6IFtjaGFuZ2UudGV4dFswXV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuXG4gICAgY2hhbmdlLnJlbW92ZWQgPSBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG5cbiAgICBpZiAoIXNlbEFmdGVyKSB7IHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTsgfVxuICAgIGlmIChkb2MuY20pIHsgbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGRvYy5jbSwgY2hhbmdlLCBzcGFucyk7IH1cbiAgICBlbHNlIHsgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucyk7IH1cbiAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWxBZnRlciwgc2VsX2RvbnRTY3JvbGwpO1xuXG4gICAgaWYgKGRvYy5jYW50RWRpdCAmJiBza2lwQXRvbWljKGRvYywgUG9zKGRvYy5maXJzdExpbmUoKSwgMCkpKVxuICAgICAgeyBkb2MuY2FudEVkaXQgPSBmYWxzZTsgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxuICAvLyB0aGF0IHRoaXMgZG9jdW1lbnQgaXMgcGFydCBvZi5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGNtLCBjaGFuZ2UsIHNwYW5zKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXksIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG87XG5cbiAgICB2YXIgcmVjb21wdXRlTWF4TGVuZ3RoID0gZmFsc2UsIGNoZWNrV2lkdGhTdGFydCA9IGZyb20ubGluZTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBjaGVja1dpZHRoU3RhcnQgPSBsaW5lTm8odmlzdWFsTGluZShnZXRMaW5lKGRvYywgZnJvbS5saW5lKSkpO1xuICAgICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUgPT0gZGlzcGxheS5tYXhMaW5lKSB7XG4gICAgICAgICAgcmVjb21wdXRlTWF4TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnNlbC5jb250YWlucyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA+IC0xKVxuICAgICAgeyBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSk7IH1cblxuICAgIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KGNtKSk7XG5cbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIGZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XG4gICAgICAgIGlmIChsZW4gPiBkaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmUgPSBsaW5lO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgfVxuXG4gICAgcmV0cmVhdEZyb250aWVyKGRvYywgZnJvbS5saW5lKTtcbiAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcblxuICAgIHZhciBsZW5kaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvLmxpbmUgLSBmcm9tLmxpbmUpIC0gMTtcbiAgICAvLyBSZW1lbWJlciB0aGF0IHRoZXNlIGxpbmVzIGNoYW5nZWQsIGZvciB1cGRhdGluZyB0aGUgZGlzcGxheVxuICAgIGlmIChjaGFuZ2UuZnVsbClcbiAgICAgIHsgcmVnQ2hhbmdlKGNtKTsgfVxuICAgIGVsc2UgaWYgKGZyb20ubGluZSA9PSB0by5saW5lICYmIGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmICFpc1dob2xlTGluZVVwZGF0ZShjbS5kb2MsIGNoYW5nZSkpXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXCJ0ZXh0XCIpOyB9XG4gICAgZWxzZVxuICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEsIGxlbmRpZmYpOyB9XG5cbiAgICB2YXIgY2hhbmdlc0hhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcImNoYW5nZXNcIiksIGNoYW5nZUhhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcImNoYW5nZVwiKTtcbiAgICBpZiAoY2hhbmdlSGFuZGxlciB8fCBjaGFuZ2VzSGFuZGxlcikge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgZnJvbTogZnJvbSwgdG86IHRvLFxuICAgICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcbiAgICAgICAgcmVtb3ZlZDogY2hhbmdlLnJlbW92ZWQsXG4gICAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpblxuICAgICAgfTtcbiAgICAgIGlmIChjaGFuZ2VIYW5kbGVyKSB7IHNpZ25hbExhdGVyKGNtLCBcImNoYW5nZVwiLCBjbSwgb2JqKTsgfVxuICAgICAgaWYgKGNoYW5nZXNIYW5kbGVyKSB7IChjbS5jdXJPcC5jaGFuZ2VPYmpzIHx8IChjbS5jdXJPcC5jaGFuZ2VPYmpzID0gW10pKS5wdXNoKG9iaik7IH1cbiAgICB9XG4gICAgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUmFuZ2UoZG9jLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgdmFyIGFzc2lnbjtcblxuICAgIGlmICghdG8pIHsgdG8gPSBmcm9tOyB9XG4gICAgaWYgKGNtcCh0bywgZnJvbSkgPCAwKSB7IChhc3NpZ24gPSBbdG8sIGZyb21dLCBmcm9tID0gYXNzaWduWzBdLCB0byA9IGFzc2lnblsxXSk7IH1cbiAgICBpZiAodHlwZW9mIGNvZGUgPT0gXCJzdHJpbmdcIikgeyBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSk7IH1cbiAgICBtYWtlQ2hhbmdlKGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogY29kZSwgb3JpZ2luOiBvcmlnaW59KTtcbiAgfVxuXG4gIC8vIFJlYmFzaW5nL3Jlc2V0dGluZyBoaXN0b3J5IHRvIGRlYWwgd2l0aCBleHRlcm5hbGx5LXNvdXJjZWQgY2hhbmdlc1xuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RTZWxTaW5nbGUocG9zLCBmcm9tLCB0bywgZGlmZikge1xuICAgIGlmICh0byA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSArPSBkaWZmO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSA9IGZyb207XG4gICAgICBwb3MuY2ggPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWVzIHRvIHJlYmFzZSBhbiBhcnJheSBvZiBoaXN0b3J5IGV2ZW50cyBnaXZlbiBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxuICAvLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xuICAvLyBiZWZvcmUgdGhlIGV2ZW50LCB0aGUgZXZlbnQncyBwb3NpdGlvbnMgYXJlIHVwZGF0ZWQuIFVzZXMgYVxuICAvLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXG4gIC8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXG4gIC8vIHNoYXJlZCBwb3NpdGlvbiBvYmplY3RzIGJlaW5nIHVuc2FmZWx5IHVwZGF0ZWQuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSwgZnJvbSwgdG8sIGRpZmYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViID0gYXJyYXlbaV0sIG9rID0gdHJ1ZTtcbiAgICAgIGlmIChzdWIucmFuZ2VzKSB7XG4gICAgICAgIGlmICghc3ViLmNvcGllZCkgeyBzdWIgPSBhcnJheVtpXSA9IHN1Yi5kZWVwQ29weSgpOyBzdWIuY29waWVkID0gdHJ1ZTsgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uYW5jaG9yLCBmcm9tLCB0bywgZGlmZik7XG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2okMSkge1xuICAgICAgICB2YXIgY3VyID0gc3ViLmNoYW5nZXNbaiQxXTtcbiAgICAgICAgaWYgKHRvIDwgY3VyLmZyb20ubGluZSkge1xuICAgICAgICAgIGN1ci5mcm9tID0gUG9zKGN1ci5mcm9tLmxpbmUgKyBkaWZmLCBjdXIuZnJvbS5jaCk7XG4gICAgICAgICAgY3VyLnRvID0gUG9zKGN1ci50by5saW5lICsgZGlmZiwgY3VyLnRvLmNoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tIDw9IGN1ci50by5saW5lKSB7XG4gICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbS5saW5lLCB0byA9IGNoYW5nZS50by5saW5lLCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSkgLSAxO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZm9yIGFwcGx5aW5nIGEgY2hhbmdlIHRvIGEgbGluZSBieSBoYW5kbGUgb3IgbnVtYmVyLFxuICAvLyByZXR1cm5pbmcgdGhlIG51bWJlciBhbmQgb3B0aW9uYWxseSByZWdpc3RlcmluZyB0aGUgbGluZSBhc1xuICAvLyBjaGFuZ2VkLlxuICBmdW5jdGlvbiBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBjaGFuZ2VUeXBlLCBvcCkge1xuICAgIHZhciBubyA9IGhhbmRsZSwgbGluZSA9IGhhbmRsZTtcbiAgICBpZiAodHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiKSB7IGxpbmUgPSBnZXRMaW5lKGRvYywgY2xpcExpbmUoZG9jLCBoYW5kbGUpKTsgfVxuICAgIGVsc2UgeyBubyA9IGxpbmVObyhoYW5kbGUpOyB9XG4gICAgaWYgKG5vID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIGlmIChvcChsaW5lLCBubykgJiYgZG9jLmNtKSB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBubywgY2hhbmdlVHlwZSk7IH1cbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gVGhlIGRvY3VtZW50IGlzIHJlcHJlc2VudGVkIGFzIGEgQlRyZWUgY29uc2lzdGluZyBvZiBsZWF2ZXMsIHdpdGhcbiAgLy8gY2h1bmsgb2YgbGluZXMgaW4gdGhlbSwgYW5kIGJyYW5jaGVzLCB3aXRoIHVwIHRvIHRlbiBsZWF2ZXMgb3JcbiAgLy8gb3RoZXIgYnJhbmNoIG5vZGVzIGJlbG93IHRoZW0uIFRoZSB0b3Agbm9kZSBpcyBhbHdheXMgYSBicmFuY2hcbiAgLy8gbm9kZSwgYW5kIGlzIHRoZSBkb2N1bWVudCBvYmplY3QgaXRzZWxmIChtZWFuaW5nIGl0IGhhc1xuICAvLyBhZGRpdGlvbmFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMpLlxuICAvL1xuICAvLyBBbGwgbm9kZXMgaGF2ZSBwYXJlbnQgbGlua3MuIFRoZSB0cmVlIGlzIHVzZWQgYm90aCB0byBnbyBmcm9tXG4gIC8vIGxpbmUgbnVtYmVycyB0byBsaW5lIG9iamVjdHMsIGFuZCB0byBnbyBmcm9tIG9iamVjdHMgdG8gbnVtYmVycy5cbiAgLy8gSXQgYWxzbyBpbmRleGVzIGJ5IGhlaWdodCwgYW5kIGlzIHVzZWQgdG8gY29udmVydCBiZXR3ZWVuIGhlaWdodFxuICAvLyBhbmQgbGluZSBvYmplY3QsIGFuZCB0byBmaW5kIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LlxuICAvL1xuICAvLyBTZWUgYWxzbyBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvY29kZW1pcnJvci1saW5lLXRyZWUuaHRtbFxuXG4gIGZ1bmN0aW9uIExlYWZDaHVuayhsaW5lcykge1xuICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgbGluZXNbaV0ucGFyZW50ID0gdGhpcztcbiAgICAgIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgTGVhZkNodW5rLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGggfSxcblxuICAgIC8vIFJlbW92ZSB0aGUgbiBsaW5lcyBhdCBvZmZzZXQgJ2F0Jy5cbiAgICByZW1vdmVJbm5lcjogZnVuY3Rpb24oYXQsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSBhdCwgZSA9IGF0ICsgbjsgaSA8IGU7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0O1xuICAgICAgICBjbGVhblVwTGluZShsaW5lKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXCJkZWxldGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmVzLnNwbGljZShhdCwgbik7XG4gICAgfSxcblxuICAgIC8vIEhlbHBlciB1c2VkIHRvIGNvbGxhcHNlIGEgc21hbGwgYnJhbmNoIGludG8gYSBzaW5nbGUgbGVhZi5cbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIHRoaXMubGluZXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnNlcnQgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzIGF0IG9mZnNldCAnYXQnLCBjb3VudCB0aGVtIGFzXG4gICAgLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBhdCkuY29uY2F0KGxpbmVzKS5jb25jYXQodGhpcy5saW5lcy5zbGljZShhdCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzOyB9XG4gICAgfSxcblxuICAgIC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cbiAgICBpdGVyTjogZnVuY3Rpb24oYXQsIG4sIG9wKSB7XG4gICAgICBmb3IgKHZhciBlID0gYXQgKyBuOyBhdCA8IGU7ICsrYXQpXG4gICAgICAgIHsgaWYgKG9wKHRoaXMubGluZXNbYXRdKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQnJhbmNoQ2h1bmsoY2hpbGRyZW4pIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdmFyIHNpemUgPSAwLCBoZWlnaHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgc2l6ZSArPSBjaC5jaHVua1NpemUoKTsgaGVpZ2h0ICs9IGNoLmhlaWdodDtcbiAgICAgIGNoLnBhcmVudCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB9XG5cbiAgQnJhbmNoQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNpemUgfSxcblxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgdGhpcy5zaXplIC09IG47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDwgc3opIHtcbiAgICAgICAgICB2YXIgcm0gPSBNYXRoLm1pbihuLCBzeiAtIGF0KSwgb2xkSGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGNoaWxkLnJlbW92ZUlubmVyKGF0LCBybSk7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gb2xkSGVpZ2h0IC0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGlmIChzeiA9PSBybSkgeyB0aGlzLmNoaWxkcmVuLnNwbGljZShpLS0sIDEpOyBjaGlsZC5wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKChuIC09IHJtKSA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgICBhdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7IGF0IC09IHN6OyB9XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhbiAyNSBsaW5lcywgZW5zdXJlIHRoYXQgaXQgaXMgYVxuICAgICAgLy8gc2luZ2xlIGxlYWYgbm9kZS5cbiAgICAgIGlmICh0aGlzLnNpemUgLSBuIDwgMjUgJiZcbiAgICAgICAgICAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEodGhpcy5jaGlsZHJlblswXSBpbnN0YW5jZW9mIExlYWZDaHVuaykpKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbGxhcHNlKGxpbmVzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGVhZkNodW5rKGxpbmVzKV07XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0ucGFyZW50ID0gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHsgdGhpcy5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcyk7IH1cbiAgICB9LFxuXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnNpemUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8PSBzeikge1xuICAgICAgICAgIGNoaWxkLmluc2VydElubmVyKGF0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICAgICAgICBpZiAoY2hpbGQubGluZXMgJiYgY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIG1lbW9yeSB0aHJhc2hpbmcgd2hlbiBjaGlsZC5saW5lcyBpcyBodWdlIChlLmcuIGZpcnN0IHZpZXcgb2YgYSBsYXJnZSBmaWxlKSwgaXQncyBuZXZlciBzcGxpY2VkLlxuICAgICAgICAgICAgLy8gSW5zdGVhZCwgc21hbGwgc2xpY2VzIGFyZSB0YWtlbi4gVGhleSdyZSB0YWtlbiBpbiBvcmRlciBiZWNhdXNlIHNlcXVlbnRpYWwgbWVtb3J5IGFjY2Vzc2VzIGFyZSBmYXN0ZXN0LlxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGNoaWxkLmxpbmVzLmxlbmd0aCAlIDI1ICsgMjU7XG4gICAgICAgICAgICBmb3IgKHZhciBwb3MgPSByZW1haW5pbmc7IHBvcyA8IGNoaWxkLmxpbmVzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgdmFyIGxlYWYgPSBuZXcgTGVhZkNodW5rKGNoaWxkLmxpbmVzLnNsaWNlKHBvcywgcG9zICs9IDI1KSk7XG4gICAgICAgICAgICAgIGNoaWxkLmhlaWdodCAtPSBsZWFmLmhlaWdodDtcbiAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoKytpLCAwLCBsZWFmKTtcbiAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQubGluZXMgPSBjaGlsZC5saW5lcy5zbGljZSgwLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgdGhpcy5tYXliZVNwaWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgYXQgLT0gc3o7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFdoZW4gYSBub2RlIGhhcyBncm93biwgY2hlY2sgd2hldGhlciBpdCBzaG91bGQgYmUgc3BsaXQuXG4gICAgbWF5YmVTcGlsbDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gMTApIHsgcmV0dXJuIH1cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBzcGlsbGVkID0gbWUuY2hpbGRyZW4uc3BsaWNlKG1lLmNoaWxkcmVuLmxlbmd0aCAtIDUsIDUpO1xuICAgICAgICB2YXIgc2libGluZyA9IG5ldyBCcmFuY2hDaHVuayhzcGlsbGVkKTtcbiAgICAgICAgaWYgKCFtZS5wYXJlbnQpIHsgLy8gQmVjb21lIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgIHZhciBjb3B5ID0gbmV3IEJyYW5jaENodW5rKG1lLmNoaWxkcmVuKTtcbiAgICAgICAgICBjb3B5LnBhcmVudCA9IG1lO1xuICAgICAgICAgIG1lLmNoaWxkcmVuID0gW2NvcHksIHNpYmxpbmddO1xuICAgICAgICAgIG1lID0gY29weTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLnNpemUgLT0gc2libGluZy5zaXplO1xuICAgICAgICAgIG1lLmhlaWdodCAtPSBzaWJsaW5nLmhlaWdodDtcbiAgICAgICAgICB2YXIgbXlJbmRleCA9IGluZGV4T2YobWUucGFyZW50LmNoaWxkcmVuLCBtZSk7XG4gICAgICAgICAgbWUucGFyZW50LmNoaWxkcmVuLnNwbGljZShteUluZGV4ICsgMSwgMCwgc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBtZS5wYXJlbnQ7XG4gICAgICB9IHdoaWxlIChtZS5jaGlsZHJlbi5sZW5ndGggPiAxMClcbiAgICAgIG1lLnBhcmVudC5tYXliZVNwaWxsKCk7XG4gICAgfSxcblxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgIHZhciB1c2VkID0gTWF0aC5taW4obiwgc3ogLSBhdCk7XG4gICAgICAgICAgaWYgKGNoaWxkLml0ZXJOKGF0LCB1c2VkLCBvcCkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmICgobiAtPSB1c2VkKSA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgICBhdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7IGF0IC09IHN6OyB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIExpbmUgd2lkZ2V0cyBhcmUgYmxvY2sgZWxlbWVudHMgZGlzcGxheWVkIGFib3ZlIG9yIGJlbG93IGEgbGluZS5cblxuICB2YXIgTGluZVdpZGdldCA9IGZ1bmN0aW9uKGRvYywgbm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7IGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7IGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpXG4gICAgICB7IHRoaXNbb3B0XSA9IG9wdGlvbnNbb3B0XTsgfSB9IH1cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9O1xuXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKTtcbiAgICBpZiAobm8gPT0gbnVsbCB8fCAhd3MpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdzLmxlbmd0aDsgKytpKSB7IGlmICh3c1tpXSA9PSB0aGlzKSB7IHdzLnNwbGljZShpLS0sIDEpOyB9IH1cbiAgICBpZiAoIXdzLmxlbmd0aCkgeyBsaW5lLndpZGdldHMgPSBudWxsOyB9XG4gICAgdmFyIGhlaWdodCA9IHdpZGdldEhlaWdodCh0aGlzKTtcbiAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIE1hdGgubWF4KDAsIGxpbmUuaGVpZ2h0IC0gaGVpZ2h0KSk7XG4gICAgaWYgKGNtKSB7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIC1oZWlnaHQpO1xuICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBubywgXCJ3aWRnZXRcIik7XG4gICAgICB9KTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImxpbmVXaWRnZXRDbGVhcmVkXCIsIGNtLCB0aGlzLCBubyk7XG4gICAgfVxuICB9O1xuXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvbGRIID0gdGhpcy5oZWlnaHQsIGNtID0gdGhpcy5kb2MuY20sIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgIHZhciBkaWZmID0gd2lkZ2V0SGVpZ2h0KHRoaXMpIC0gb2xkSDtcbiAgICBpZiAoIWRpZmYpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpOyB9XG4gICAgaWYgKGNtKSB7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZik7XG4gICAgICAgIHNpZ25hbExhdGVyKGNtLCBcImxpbmVXaWRnZXRDaGFuZ2VkXCIsIGNtLCB0aGlzJDEsIGxpbmVObyhsaW5lKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGV2ZW50TWl4aW4oTGluZVdpZGdldCk7XG5cbiAgZnVuY3Rpb24gYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZikge1xuICAgIGlmIChoZWlnaHRBdExpbmUobGluZSkgPCAoKGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCkgfHwgY20uZG9jLnNjcm9sbFRvcCkpXG4gICAgICB7IGFkZFRvU2Nyb2xsVG9wKGNtLCBkaWZmKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGluZVdpZGdldChkb2MsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgIHZhciB3aWRnZXQgPSBuZXcgTGluZVdpZGdldChkb2MsIG5vZGUsIG9wdGlvbnMpO1xuICAgIHZhciBjbSA9IGRvYy5jbTtcbiAgICBpZiAoY20gJiYgd2lkZ2V0Lm5vSFNjcm9sbCkgeyBjbS5kaXNwbGF5LmFsaWduV2lkZ2V0cyA9IHRydWU7IH1cbiAgICBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBcIndpZGdldFwiLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgdmFyIHdpZGdldHMgPSBsaW5lLndpZGdldHMgfHwgKGxpbmUud2lkZ2V0cyA9IFtdKTtcbiAgICAgIGlmICh3aWRnZXQuaW5zZXJ0QXQgPT0gbnVsbCkgeyB3aWRnZXRzLnB1c2god2lkZ2V0KTsgfVxuICAgICAgZWxzZSB7IHdpZGdldHMuc3BsaWNlKE1hdGgubWluKHdpZGdldHMubGVuZ3RoLCBNYXRoLm1heCgwLCB3aWRnZXQuaW5zZXJ0QXQpKSwgMCwgd2lkZ2V0KTsgfVxuICAgICAgd2lkZ2V0LmxpbmUgPSBsaW5lO1xuICAgICAgaWYgKGNtICYmICFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkge1xuICAgICAgICB2YXIgYWJvdmVWaXNpYmxlID0gaGVpZ2h0QXRMaW5lKGxpbmUpIDwgZG9jLnNjcm9sbFRvcDtcbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIHdpZGdldEhlaWdodCh3aWRnZXQpKTtcbiAgICAgICAgaWYgKGFib3ZlVmlzaWJsZSkgeyBhZGRUb1Njcm9sbFRvcChjbSwgd2lkZ2V0LmhlaWdodCk7IH1cbiAgICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KTtcbiAgICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldEFkZGVkXCIsIGNtLCB3aWRnZXQsIHR5cGVvZiBoYW5kbGUgPT0gXCJudW1iZXJcIiA/IGhhbmRsZSA6IGxpbmVObyhoYW5kbGUpKTsgfVxuICAgIHJldHVybiB3aWRnZXRcbiAgfVxuXG4gIC8vIFRFWFRNQVJLRVJTXG5cbiAgLy8gQ3JlYXRlZCB3aXRoIG1hcmtUZXh0IGFuZCBzZXRCb29rbWFyayBtZXRob2RzLiBBIFRleHRNYXJrZXIgaXMgYVxuICAvLyBoYW5kbGUgdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhciBvciBmaW5kIGEgbWFya2VkIHBvc2l0aW9uIGluIHRoZVxuICAvLyBkb2N1bWVudC4gTGluZSBvYmplY3RzIGhvbGQgYXJyYXlzIChtYXJrZWRTcGFucykgY29udGFpbmluZ1xuICAvLyB7ZnJvbSwgdG8sIG1hcmtlcn0gb2JqZWN0IHBvaW50aW5nIHRvIHN1Y2ggbWFya2VyIG9iamVjdHMsIGFuZFxuICAvLyBpbmRpY2F0aW5nIHRoYXQgc3VjaCBhIG1hcmtlciBpcyBwcmVzZW50IG9uIHRoYXQgbGluZS4gTXVsdGlwbGVcbiAgLy8gbGluZXMgbWF5IHBvaW50IHRvIHRoZSBzYW1lIG1hcmtlciB3aGVuIGl0IHNwYW5zIGFjcm9zcyBsaW5lcy5cbiAgLy8gVGhlIHNwYW5zIHdpbGwgaGF2ZSBudWxsIGZvciB0aGVpciBmcm9tL3RvIHByb3BlcnRpZXMgd2hlbiB0aGVcbiAgLy8gbWFya2VyIGNvbnRpbnVlcyBiZXlvbmQgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgbGluZS4gTWFya2VycyBoYXZlXG4gIC8vIGxpbmtzIGJhY2sgdG8gdGhlIGxpbmVzIHRoZXkgY3VycmVudGx5IHRvdWNoLlxuXG4gIC8vIENvbGxhcHNlZCBtYXJrZXJzIGhhdmUgdW5pcXVlIGlkcywgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBvcmRlclxuICAvLyB0aGVtLCB3aGljaCBpcyBuZWVkZWQgZm9yIHVuaXF1ZWx5IGRldGVybWluaW5nIGFuIG91dGVyIG1hcmtlclxuICAvLyB3aGVuIHRoZXkgb3ZlcmxhcCAodGhleSBtYXkgbmVzdCwgYnV0IG5vdCBwYXJ0aWFsbHkgb3ZlcmxhcCkuXG4gIHZhciBuZXh0TWFya2VySWQgPSAwO1xuXG4gIHZhciBUZXh0TWFya2VyID0gZnVuY3Rpb24oZG9jLCB0eXBlKSB7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICB9O1xuXG4gIC8vIENsZWFyIHRoZSBtYXJrZXIuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdpdGhPcCA9IGNtICYmICFjbS5jdXJPcDtcbiAgICBpZiAod2l0aE9wKSB7IHN0YXJ0T3BlcmF0aW9uKGNtKTsgfVxuICAgIGlmIChoYXNIYW5kbGVyKHRoaXMsIFwiY2xlYXJcIikpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZCgpO1xuICAgICAgaWYgKGZvdW5kKSB7IHNpZ25hbExhdGVyKHRoaXMsIFwiY2xlYXJcIiwgZm91bmQuZnJvbSwgZm91bmQudG8pOyB9XG4gICAgfVxuICAgIHZhciBtaW4gPSBudWxsLCBtYXggPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKGNtICYmICF0aGlzLmNvbGxhcHNlZCkgeyByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFwidGV4dFwiKTsgfVxuICAgICAgZWxzZSBpZiAoY20pIHtcbiAgICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkgeyBtYXggPSBsaW5lTm8obGluZSk7IH1cbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7IG1pbiA9IGxpbmVObyhsaW5lKTsgfVxuICAgICAgfVxuICAgICAgbGluZS5tYXJrZWRTcGFucyA9IHJlbW92ZU1hcmtlZFNwYW4obGluZS5tYXJrZWRTcGFucywgc3Bhbik7XG4gICAgICBpZiAoc3Bhbi5mcm9tID09IG51bGwgJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkgJiYgY20pXG4gICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpKTsgfVxuICAgIH1cbiAgICBpZiAoY20gJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kkMSkge1xuICAgICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUodGhpcy5saW5lc1tpJDFdKSwgbGVuID0gbGluZUxlbmd0aCh2aXN1YWwpO1xuICAgICAgaWYgKGxlbiA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmUgPSB2aXN1YWw7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSB9XG5cbiAgICBpZiAobWluICE9IG51bGwgJiYgY20gJiYgdGhpcy5jb2xsYXBzZWQpIHsgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpOyB9XG4gICAgdGhpcy5saW5lcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmF0b21pYyAmJiB0aGlzLmRvYy5jYW50RWRpdCkge1xuICAgICAgdGhpcy5kb2MuY2FudEVkaXQgPSBmYWxzZTtcbiAgICAgIGlmIChjbSkgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7IH1cbiAgICB9XG4gICAgaWYgKGNtKSB7IHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNsZWFyZWRcIiwgY20sIHRoaXMsIG1pbiwgbWF4KTsgfVxuICAgIGlmICh3aXRoT3ApIHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIGlmICh0aGlzLnBhcmVudCkgeyB0aGlzLnBhcmVudC5jbGVhcigpOyB9XG4gIH07XG5cbiAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBpbiB0aGUgZG9jdW1lbnQuIFJldHVybnMgYSB7ZnJvbSxcbiAgLy8gdG99IG9iamVjdCBieSBkZWZhdWx0LiBTaWRlIGNhbiBiZSBwYXNzZWQgdG8gZ2V0IGEgc3BlY2lmaWMgc2lkZVxuICAvLyAtLSAwIChib3RoKSwgLTEgKGxlZnQpLCBvciAxIChyaWdodCkuIFdoZW4gbGluZU9iaiBpcyB0cnVlLCB0aGVcbiAgLy8gUG9zIG9iamVjdHMgcmV0dXJuZWQgY29udGFpbiBhIGxpbmUgb2JqZWN0LCByYXRoZXIgdGhhbiBhIGxpbmVcbiAgLy8gbnVtYmVyICh1c2VkIHRvIHByZXZlbnQgbG9va2luZyB1cCB0aGUgc2FtZSBsaW5lIHR3aWNlKS5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzaWRlLCBsaW5lT2JqKSB7XG4gICAgaWYgKHNpZGUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT0gXCJib29rbWFya1wiKSB7IHNpZGUgPSAxOyB9XG4gICAgdmFyIGZyb20sIHRvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGZyb20gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4uZnJvbSk7XG4gICAgICAgIGlmIChzaWRlID09IC0xKSB7IHJldHVybiBmcm9tIH1cbiAgICAgIH1cbiAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcbiAgICAgICAgdG8gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4udG8pO1xuICAgICAgICBpZiAoc2lkZSA9PSAxKSB7IHJldHVybiB0byB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tICYmIHtmcm9tOiBmcm9tLCB0bzogdG99XG4gIH07XG5cbiAgLy8gU2lnbmFscyB0aGF0IHRoZSBtYXJrZXIncyB3aWRnZXQgY2hhbmdlZCwgYW5kIHN1cnJvdW5kaW5nIGxheW91dFxuICAvLyBzaG91bGQgYmUgcmVjb21wdXRlZC5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMuZmluZCgtMSwgdHJ1ZSksIHdpZGdldCA9IHRoaXMsIGNtID0gdGhpcy5kb2MuY207XG4gICAgaWYgKCFwb3MgfHwgIWNtKSB7IHJldHVybiB9XG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxpbmUgPSBwb3MubGluZSwgbGluZU4gPSBsaW5lTm8ocG9zLmxpbmUpO1xuICAgICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3Iodmlldyk7XG4gICAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgIGlmICghbGluZUlzSGlkZGVuKHdpZGdldC5kb2MsIGxpbmUpICYmIHdpZGdldC5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gd2lkZ2V0LmhlaWdodDtcbiAgICAgICAgd2lkZ2V0LmhlaWdodCA9IG51bGw7XG4gICAgICAgIHZhciBkSGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHdpZGdldCkgLSBvbGRIZWlnaHQ7XG4gICAgICAgIGlmIChkSGVpZ2h0KVxuICAgICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRIZWlnaHQpOyB9XG4gICAgICB9XG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJtYXJrZXJDaGFuZ2VkXCIsIGNtLCB0aGlzJDEpO1xuICAgIH0pO1xuICB9O1xuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmF0dGFjaExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wO1xuICAgICAgaWYgKCFvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgaW5kZXhPZihvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHRoaXMpID09IC0xKVxuICAgICAgICB7IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7IH1cbiAgICB9XG4gICAgdGhpcy5saW5lcy5wdXNoKGxpbmUpO1xuICB9O1xuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmRldGFjaExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIHRoaXMubGluZXMuc3BsaWNlKGluZGV4T2YodGhpcy5saW5lcywgbGluZSksIDEpO1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wXG4gICAgICA7KG9wLm1heWJlSGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVIaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNaXhpbihUZXh0TWFya2VyKTtcblxuICAvLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcbiAgZnVuY3Rpb24gbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xuICAgIC8vIFNoYXJlZCBtYXJrZXJzIChhY3Jvc3MgbGlua2VkIGRvY3VtZW50cykgYXJlIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXG4gICAgLy8gZG9jdW1lbnQpLlxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkKSB7IHJldHVybiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XG4gICAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXG4gICAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYXJrVGV4dCkoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkgfVxuXG4gICAgdmFyIG1hcmtlciA9IG5ldyBUZXh0TWFya2VyKGRvYywgdHlwZSksIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgIGlmIChvcHRpb25zKSB7IGNvcHlPYmoob3B0aW9ucywgbWFya2VyLCBmYWxzZSk7IH1cbiAgICAvLyBEb24ndCBjb25uZWN0IGVtcHR5IG1hcmtlcnMgdW5sZXNzIGNsZWFyV2hlbkVtcHR5IGlzIGZhbHNlXG4gICAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gbWFya2VyIH1cbiAgICBpZiAobWFya2VyLnJlcGxhY2VkV2l0aCkge1xuICAgICAgLy8gU2hvd2luZyB1cCBhcyBhIHdpZGdldCBpbXBsaWVzIGNvbGxhcHNlZCAod2lkZ2V0IHJlcGxhY2VzIHRleHQpXG4gICAgICBtYXJrZXIuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIG1hcmtlci53aWRnZXROb2RlID0gZWx0UChcInNwYW5cIiwgW21hcmtlci5yZXBsYWNlZFdpdGhdLCBcIkNvZGVNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgaWYgKCFvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzKSB7IG1hcmtlci53aWRnZXROb2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpOyB9XG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRMZWZ0KSB7IG1hcmtlci53aWRnZXROb2RlLmluc2VydExlZnQgPSB0cnVlOyB9XG4gICAgfVxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICBpZiAoY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGZyb20ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikgfHxcbiAgICAgICAgICBmcm9tLmxpbmUgIT0gdG8ubGluZSAmJiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgdG8ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikpXG4gICAgICAgIHsgdGhyb3cgbmV3IEVycm9yKFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVwiKSB9XG4gICAgICBzZWVDb2xsYXBzZWRTcGFucygpO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXIuYWRkVG9IaXN0b3J5KVxuICAgICAgeyBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCBvcmlnaW46IFwibWFya1RleHRcIn0sIGRvYy5zZWwsIE5hTik7IH1cblxuICAgIHZhciBjdXJMaW5lID0gZnJvbS5saW5lLCBjbSA9IGRvYy5jbSwgdXBkYXRlTWF4TGluZTtcbiAgICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChjbSAmJiBtYXJrZXIuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiB2aXN1YWxMaW5lKGxpbmUpID09IGNtLmRpc3BsYXkubWF4TGluZSlcbiAgICAgICAgeyB1cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQgJiYgY3VyTGluZSAhPSBmcm9tLmxpbmUpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxuICAgICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gdG8ubGluZSA/IHRvLmNoIDogbnVsbCksIGRvYy5jbSAmJiBkb2MuY20uY3VyT3ApO1xuICAgICAgKytjdXJMaW5lO1xuICAgIH0pO1xuICAgIC8vIGxpbmVJc0hpZGRlbiBkZXBlbmRzIG9uIHRoZSBwcmVzZW5jZSBvZiB0aGUgc3BhbnMsIHNvIG5lZWRzIGEgc2Vjb25kIHBhc3NcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkgeyBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7IH1cbiAgICB9KTsgfVxuXG4gICAgaWYgKG1hcmtlci5jbGVhck9uRW50ZXIpIHsgb24obWFya2VyLCBcImJlZm9yZUN1cnNvckVudGVyXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtlci5jbGVhcigpOyB9KTsgfVxuXG4gICAgaWYgKG1hcmtlci5yZWFkT25seSkge1xuICAgICAgc2VlUmVhZE9ubHlTcGFucygpO1xuICAgICAgaWYgKGRvYy5oaXN0b3J5LmRvbmUubGVuZ3RoIHx8IGRvYy5oaXN0b3J5LnVuZG9uZS5sZW5ndGgpXG4gICAgICAgIHsgZG9jLmNsZWFySGlzdG9yeSgpOyB9XG4gICAgfVxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICBtYXJrZXIuaWQgPSArK25leHRNYXJrZXJJZDtcbiAgICAgIG1hcmtlci5hdG9taWMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY20pIHtcbiAgICAgIC8vIFN5bmMgZWRpdG9yIHN0YXRlXG4gICAgICBpZiAodXBkYXRlTWF4TGluZSkgeyBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpXG4gICAgICAgIHsgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxKTsgfVxuICAgICAgZWxzZSBpZiAobWFya2VyLmNsYXNzTmFtZSB8fCBtYXJrZXIuc3RhcnRTdHlsZSB8fCBtYXJrZXIuZW5kU3R5bGUgfHwgbWFya2VyLmNzcyB8fFxuICAgICAgICAgICAgICAgbWFya2VyLmF0dHJpYnV0ZXMgfHwgbWFya2VyLnRpdGxlKVxuICAgICAgICB7IGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPD0gdG8ubGluZTsgaSsrKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGksIFwidGV4dFwiKTsgfSB9XG4gICAgICBpZiAobWFya2VyLmF0b21pYykgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7IH1cbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckFkZGVkXCIsIGNtLCBtYXJrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyXG4gIH1cblxuICAvLyBTSEFSRUQgVEVYVE1BUktFUlNcblxuICAvLyBBIHNoYXJlZCBtYXJrZXIgc3BhbnMgbXVsdGlwbGUgbGlua2VkIGRvY3VtZW50cy4gSXQgaXNcbiAgLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXG4gIC8vIG1hcmtlcnMuXG4gIHZhciBTaGFyZWRUZXh0TWFya2VyID0gZnVuY3Rpb24obWFya2VycywgcHJpbWFyeSkge1xuICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICB7IG1hcmtlcnNbaV0ucGFyZW50ID0gdGhpczsgfVxuICB9O1xuXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHRoaXMubWFya2Vyc1tpXS5jbGVhcigpOyB9XG4gICAgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiKTtcbiAgfTtcblxuICBTaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNpZGUsIGxpbmVPYmopIHtcbiAgICByZXR1cm4gdGhpcy5wcmltYXJ5LmZpbmQoc2lkZSwgbGluZU9iailcbiAgfTtcbiAgZXZlbnRNaXhpbihTaGFyZWRUZXh0TWFya2VyKTtcblxuICBmdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgb3B0aW9ucyA9IGNvcHlPYmoob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5zaGFyZWQgPSBmYWxzZTtcbiAgICB2YXIgbWFya2VycyA9IFttYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKV0sIHByaW1hcnkgPSBtYXJrZXJzWzBdO1xuICAgIHZhciB3aWRnZXQgPSBvcHRpb25zLndpZGdldE5vZGU7XG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIGlmICh3aWRnZXQpIHsgb3B0aW9ucy53aWRnZXROb2RlID0gd2lkZ2V0LmNsb25lTm9kZSh0cnVlKTsgfVxuICAgICAgbWFya2Vycy5wdXNoKG1hcmtUZXh0KGRvYywgY2xpcFBvcyhkb2MsIGZyb20pLCBjbGlwUG9zKGRvYywgdG8pLCBvcHRpb25zLCB0eXBlKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpXG4gICAgICAgIHsgaWYgKGRvYy5saW5rZWRbaV0uaXNQYXJlbnQpIHsgcmV0dXJuIH0gfVxuICAgICAgcHJpbWFyeSA9IGxzdChtYXJrZXJzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNoYXJlZFRleHRNYXJrZXIobWFya2VycywgcHJpbWFyeSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYykge1xuICAgIHJldHVybiBkb2MuZmluZE1hcmtzKFBvcyhkb2MuZmlyc3QsIDApLCBkb2MuY2xpcFBvcyhQb3MoZG9jLmxhc3RMaW5lKCkpKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ucGFyZW50OyB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29weVNoYXJlZE1hcmtlcnMoZG9jLCBtYXJrZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgcG9zID0gbWFya2VyLmZpbmQoKTtcbiAgICAgIHZhciBtRnJvbSA9IGRvYy5jbGlwUG9zKHBvcy5mcm9tKSwgbVRvID0gZG9jLmNsaXBQb3MocG9zLnRvKTtcbiAgICAgIGlmIChjbXAobUZyb20sIG1UbykpIHtcbiAgICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKTtcbiAgICAgICAgbWFya2VyLm1hcmtlcnMucHVzaChzdWJNYXJrKTtcbiAgICAgICAgc3ViTWFyay5wYXJlbnQgPSBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoU2hhcmVkTWFya2VycyhtYXJrZXJzKSB7XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgbGlua2VkID0gW21hcmtlci5wcmltYXJ5LmRvY107XG4gICAgICBsaW5rZWREb2NzKG1hcmtlci5wcmltYXJ5LmRvYywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGxpbmtlZC5wdXNoKGQpOyB9KTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFya2VyLm1hcmtlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHN1Yk1hcmtlciA9IG1hcmtlci5tYXJrZXJzW2pdO1xuICAgICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XG4gICAgICAgICAgc3ViTWFya2VyLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgbWFya2VyLm1hcmtlcnMuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIH1cblxuICB2YXIgbmV4dERvY0lkID0gMDtcbiAgdmFyIERvYyA9IGZ1bmN0aW9uKHRleHQsIG1vZGUsIGZpcnN0TGluZSwgbGluZVNlcCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvYykpIHsgcmV0dXJuIG5ldyBEb2ModGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIH1cbiAgICBpZiAoZmlyc3RMaW5lID09IG51bGwpIHsgZmlyc3RMaW5lID0gMDsgfVxuXG4gICAgQnJhbmNoQ2h1bmsuY2FsbCh0aGlzLCBbbmV3IExlYWZDaHVuayhbbmV3IExpbmUoXCJcIiwgbnVsbCldKV0pO1xuICAgIHRoaXMuZmlyc3QgPSBmaXJzdExpbmU7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgIHRoaXMuY2FudEVkaXQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDE7XG4gICAgdGhpcy5tb2RlRnJvbnRpZXIgPSB0aGlzLmhpZ2hsaWdodEZyb250aWVyID0gZmlyc3RMaW5lO1xuICAgIHZhciBzdGFydCA9IFBvcyhmaXJzdExpbmUsIDApO1xuICAgIHRoaXMuc2VsID0gc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KTtcbiAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICB0aGlzLmlkID0gKytuZXh0RG9jSWQ7XG4gICAgdGhpcy5tb2RlT3B0aW9uID0gbW9kZTtcbiAgICB0aGlzLmxpbmVTZXAgPSBsaW5lU2VwO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gKGRpcmVjdGlvbiA9PSBcInJ0bFwiKSA/IFwicnRsXCIgOiBcImx0clwiO1xuICAgIHRoaXMuZXh0ZW5kID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIikgeyB0ZXh0ID0gdGhpcy5zcGxpdExpbmVzKHRleHQpOyB9XG4gICAgdXBkYXRlRG9jKHRoaXMsIHtmcm9tOiBzdGFydCwgdG86IHN0YXJ0LCB0ZXh0OiB0ZXh0fSk7XG4gICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbihzdGFydCksIHNlbF9kb250U2Nyb2xsKTtcbiAgfTtcblxuICBEb2MucHJvdG90eXBlID0gY3JlYXRlT2JqKEJyYW5jaENodW5rLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiBEb2MsXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcbiAgICAvLyBhcmd1bWVudCwgaXQgY2FsbHMgdGhhdCBmb3IgZWFjaCBsaW5lIGluIHRoZSBkb2N1bWVudC4gV2l0aFxuICAgIC8vIHRocmVlLCBpdCBpdGVyYXRlcyBvdmVyIHRoZSByYW5nZSBnaXZlbiBieSB0aGUgZmlyc3QgdHdvICh3aXRoXG4gICAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cbiAgICBpdGVyOiBmdW5jdGlvbihmcm9tLCB0bywgb3ApIHtcbiAgICAgIGlmIChvcCkgeyB0aGlzLml0ZXJOKGZyb20gLSB0aGlzLmZpcnN0LCB0byAtIGZyb20sIG9wKTsgfVxuICAgICAgZWxzZSB7IHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSk7IH1cbiAgICB9LFxuXG4gICAgLy8gTm9uLXB1YmxpYyBpbnRlcmZhY2UgZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgbGluZXMuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhdCwgbGluZXMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBoZWlnaHQgKz0gbGluZXNbaV0uaGVpZ2h0OyB9XG4gICAgICB0aGlzLmluc2VydElubmVyKGF0IC0gdGhpcy5maXJzdCwgbGluZXMsIGhlaWdodCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGF0LCBuKSB7IHRoaXMucmVtb3ZlSW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBuKTsgfSxcblxuICAgIC8vIEZyb20gaGVyZSwgdGhlIG1ldGhvZHMgYXJlIHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIE1vc3RcbiAgICAvLyBhcmUgYWxzbyBhdmFpbGFibGUgZnJvbSBDb2RlTWlycm9yIChlZGl0b3IpIGluc3RhbmNlcy5cblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKTtcbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgeyByZXR1cm4gbGluZXMgfVxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcbiAgICB9LFxuICAgIHNldFZhbHVlOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlKSB7XG4gICAgICB2YXIgdG9wID0gUG9zKHRoaXMuZmlyc3QsIDApLCBsYXN0ID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7XG4gICAgICBtYWtlQ2hhbmdlKHRoaXMsIHtmcm9tOiB0b3AsIHRvOiBQb3MobGFzdCwgZ2V0TGluZSh0aGlzLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoY29kZSksIG9yaWdpbjogXCJzZXRWYWx1ZVwiLCBmdWxsOiB0cnVlfSwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5jbSkgeyBzY3JvbGxUb0Nvb3Jkcyh0aGlzLmNtLCAwLCAwKTsgfVxuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbih0b3ApLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgfSksXG4gICAgcmVwbGFjZVJhbmdlOiBmdW5jdGlvbihjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTtcbiAgICAgIHRvID0gdG8gPyBjbGlwUG9zKHRoaXMsIHRvKSA6IGZyb207XG4gICAgICByZXBsYWNlUmFuZ2UodGhpcywgY29kZSwgZnJvbSwgdG8sIG9yaWdpbik7XG4gICAgfSxcbiAgICBnZXRSYW5nZTogZnVuY3Rpb24oZnJvbSwgdG8sIGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldEJldHdlZW4odGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0bykpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICBpZiAobGluZVNlcCA9PT0gJycpIHsgcmV0dXJuIGxpbmVzLmpvaW4oJycpIH1cbiAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXG4gICAgfSxcblxuICAgIGdldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHt2YXIgbCA9IHRoaXMuZ2V0TGluZUhhbmRsZShsaW5lKTsgcmV0dXJuIGwgJiYgbC50ZXh0fSxcblxuICAgIGdldExpbmVIYW5kbGU6IGZ1bmN0aW9uKGxpbmUpIHtpZiAoaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBnZXRMaW5lKHRoaXMsIGxpbmUpIH19LFxuICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpfSxcblxuICAgIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7IH1cbiAgICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpXG4gICAgfSxcblxuICAgIGxpbmVDb3VudDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2l6ZX0sXG4gICAgZmlyc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdH0sXG4gICAgbGFzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMX0sXG5cbiAgICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtyZXR1cm4gY2xpcFBvcyh0aGlzLCBwb3MpfSxcblxuICAgIGdldEN1cnNvcjogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsLnByaW1hcnkoKSwgcG9zO1xuICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXCJoZWFkXCIpIHsgcG9zID0gcmFuZ2UuaGVhZDsgfVxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXCJhbmNob3JcIikgeyBwb3MgPSByYW5nZS5hbmNob3I7IH1cbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiZW5kXCIgfHwgc3RhcnQgPT0gXCJ0b1wiIHx8IHN0YXJ0ID09PSBmYWxzZSkgeyBwb3MgPSByYW5nZS50bygpOyB9XG4gICAgICBlbHNlIHsgcG9zID0gcmFuZ2UuZnJvbSgpOyB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfSxcbiAgICBsaXN0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbC5yYW5nZXMgfSxcbiAgICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LFxuXG4gICAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgdHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIiA/IFBvcyhsaW5lLCBjaCB8fCAwKSA6IGxpbmUpLCBudWxsLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBzZXRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvciksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGhlYWQpLCBvdGhlciAmJiBjbGlwUG9zKHRoaXMsIG90aGVyKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZHMsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uc0J5OiBkb2NNZXRob2RPcChmdW5jdGlvbihmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaGVhZHMgPSBtYXAodGhpcy5zZWwucmFuZ2VzLCBmKTtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgc2V0U2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLCBwcmltYXJ5LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyh0aGlzLCByYW5nZXNbaV0uaGVhZCB8fCByYW5nZXNbaV0uYW5jaG9yKSk7IH1cbiAgICAgIGlmIChwcmltYXJ5ID09IG51bGwpIHsgcHJpbWFyeSA9IE1hdGgubWluKHJhbmdlcy5sZW5ndGggLSAxLCB0aGlzLnNlbC5wcmltSW5kZXgpOyB9XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKHRoaXMuY20sIG91dCwgcHJpbWFyeSksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGFkZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvcikpKTtcbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24odGhpcy5jbSwgcmFuZ2VzLCByYW5nZXMubGVuZ3RoIC0gMSksIG9wdGlvbnMpO1xuICAgIH0pLFxuXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLCBsaW5lcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgbGluZXMgPSBsaW5lcyA/IGxpbmVzLmNvbmNhdChzZWwpIDogc2VsO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSkgfVxuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgdmFyIHBhcnRzID0gW10sIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgaWYgKGxpbmVTZXAgIT09IGZhbHNlKSB7IHNlbCA9IHNlbC5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpOyB9XG4gICAgICAgIHBhcnRzW2ldID0gc2VsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzXG4gICAgfSxcbiAgICByZXBsYWNlU2VsZWN0aW9uOiBmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XG4gICAgICB2YXIgZHVwID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBkdXBbaV0gPSBjb2RlOyB9XG4gICAgICB0aGlzLnJlcGxhY2VTZWxlY3Rpb25zKGR1cCwgY29sbGFwc2UsIG9yaWdpbiB8fCBcIitpbnB1dFwiKTtcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XG4gICAgICB2YXIgY2hhbmdlcyA9IFtdLCBzZWwgPSB0aGlzLnNlbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgICBjaGFuZ2VzW2ldID0ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCksIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlW2ldKSwgb3JpZ2luOiBvcmlnaW59O1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbCA9IGNvbGxhcHNlICYmIGNvbGxhcHNlICE9IFwiZW5kXCIgJiYgY29tcHV0ZVJlcGxhY2VkU2VsKHRoaXMsIGNoYW5nZXMsIGNvbGxhcHNlKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKVxuICAgICAgICB7IG1ha2VDaGFuZ2UodGhpcywgY2hhbmdlc1tpJDFdKTsgfVxuICAgICAgaWYgKG5ld1NlbCkgeyBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLCBuZXdTZWwpOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLmNtKSB7IGVuc3VyZUN1cnNvclZpc2libGUodGhpcy5jbSk7IH1cbiAgICB9KSxcbiAgICB1bmRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIpO30pLFxuICAgIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIik7fSksXG4gICAgdW5kb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwidW5kb1wiLCB0cnVlKTt9KSxcbiAgICByZWRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJyZWRvXCIsIHRydWUpO30pLFxuXG4gICAgc2V0RXh0ZW5kaW5nOiBmdW5jdGlvbih2YWwpIHt0aGlzLmV4dGVuZCA9IHZhbDt9LFxuICAgIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZXh0ZW5kfSxcblxuICAgIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5LCBkb25lID0gMCwgdW5kb25lID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC5kb25lLmxlbmd0aDsgaSsrKSB7IGlmICghaGlzdC5kb25lW2ldLnJhbmdlcykgeyArK2RvbmU7IH0gfVxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpJDErKykgeyBpZiAoIWhpc3QudW5kb25lW2kkMV0ucmFuZ2VzKSB7ICsrdW5kb25lOyB9IH1cbiAgICAgIHJldHVybiB7dW5kbzogZG9uZSwgcmVkbzogdW5kb25lfVxuICAgIH0sXG4gICAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkpO1xuICAgICAgbGlua2VkRG9jcyh0aGlzLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBkb2MuaGlzdG9yeSA9IHRoaXMkMS5oaXN0b3J5OyB9LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gdGhpcy5jaGFuZ2VHZW5lcmF0aW9uKHRydWUpO1xuICAgIH0sXG4gICAgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24oZm9yY2VTcGxpdCkge1xuICAgICAgaWYgKGZvcmNlU3BsaXQpXG4gICAgICAgIHsgdGhpcy5oaXN0b3J5Lmxhc3RPcCA9IHRoaXMuaGlzdG9yeS5sYXN0U2VsT3AgPSB0aGlzLmhpc3RvcnkubGFzdE9yaWdpbiA9IG51bGw7IH1cbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvblxuICAgIH0sXG4gICAgaXNDbGVhbjogZnVuY3Rpb24gKGdlbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pXG4gICAgfSxcblxuICAgIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtkb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lKSxcbiAgICAgICAgICAgICAgdW5kb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUpfVxuICAgIH0sXG4gICAgc2V0SGlzdG9yeTogZnVuY3Rpb24oaGlzdERhdGEpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5KTtcbiAgICAgIGhpc3QuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XG4gICAgICBoaXN0LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEudW5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gbGluZS5ndXR0ZXJNYXJrZXJzIHx8IChsaW5lLmd1dHRlck1hcmtlcnMgPSB7fSk7XG4gICAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgY2xlYXJHdXR0ZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmd1dHRlck1hcmtlcnMgJiYgbGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXSkge1xuICAgICAgICAgIGNoYW5nZUxpbmUodGhpcyQxLCBsaW5lLCBcImd1dHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGxpbmUuZ3V0dGVyTWFya2VycykpIHsgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksXG5cbiAgICBsaW5lSW5mbzogZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoIWlzTGluZSh0aGlzLCBsaW5lKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIG4gPSBsaW5lO1xuICAgICAgICBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKTtcbiAgICAgICAgaWYgKCFsaW5lKSB7IHJldHVybiBudWxsIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBsaW5lTm8obGluZSk7XG4gICAgICAgIGlmIChuID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxuICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGxpbmUudGV4dENsYXNzLCBiZ0NsYXNzOiBsaW5lLmJnQ2xhc3MsIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c31cbiAgICB9LFxuXG4gICAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICBpZiAoIWxpbmVbcHJvcF0pIHsgbGluZVtwcm9wXSA9IGNsczsgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc1Rlc3QoY2xzKS50ZXN0KGxpbmVbcHJvcF0pKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgeyBsaW5lW3Byb3BdICs9IFwiIFwiICsgY2xzOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlclwiIDogXCJjbGFzc1wiLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFwidGV4dFwiID8gXCJ0ZXh0Q2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiYmFja2dyb3VuZFwiID8gXCJiZ0NsYXNzXCJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJDbGFzc1wiIDogXCJ3cmFwQ2xhc3NcIjtcbiAgICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcF07XG4gICAgICAgIGlmICghY3VyKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgaWYgKGNscyA9PSBudWxsKSB7IGxpbmVbcHJvcF0gPSBudWxsOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChjbGFzc1Rlc3QoY2xzKSk7XG4gICAgICAgICAgaWYgKCFmb3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIHZhciBlbmQgPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aDtcbiAgICAgICAgICBsaW5lW3Byb3BdID0gY3VyLnNsaWNlKDAsIGZvdW5kLmluZGV4KSArICghZm91bmQuaW5kZXggfHwgZW5kID09IGN1ci5sZW5ndGggPyBcIlwiIDogXCIgXCIpICsgY3VyLnNsaWNlKGVuZCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIGFkZExpbmVXaWRnZXQ6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGFkZExpbmVXaWRnZXQodGhpcywgaGFuZGxlLCBub2RlLCBvcHRpb25zKVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVXaWRnZXQ6IGZ1bmN0aW9uKHdpZGdldCkgeyB3aWRnZXQuY2xlYXIoKTsgfSxcblxuICAgIG1hcmtUZXh0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcInJhbmdlXCIpXG4gICAgfSxcbiAgICBzZXRCb29rbWFyazogZnVuY3Rpb24ocG9zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVhbE9wdHMgPSB7cmVwbGFjZWRXaXRoOiBvcHRpb25zICYmIChvcHRpb25zLm5vZGVUeXBlID09IG51bGwgPyBvcHRpb25zLndpZGdldCA6IG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgIGluc2VydExlZnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyV2hlbkVtcHR5OiBmYWxzZSwgc2hhcmVkOiBvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkLFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnRzOiBvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHN9O1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXCJib29rbWFya1wiKVxuICAgIH0sXG4gICAgZmluZE1hcmtzQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgdmFyIG1hcmtlcnMgPSBbXSwgc3BhbnMgPSBnZXRMaW5lKHRoaXMsIHBvcy5saW5lKS5tYXJrZWRTcGFucztcbiAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIGlmICgoc3Bhbi5mcm9tID09IG51bGwgfHwgc3Bhbi5mcm9tIDw9IHBvcy5jaCkgJiZcbiAgICAgICAgICAgIChzcGFuLnRvID09IG51bGwgfHwgc3Bhbi50byA+PSBwb3MuY2gpKVxuICAgICAgICAgIHsgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cbiAgICAgIH0gfVxuICAgICAgcmV0dXJuIG1hcmtlcnNcbiAgICB9LFxuICAgIGZpbmRNYXJrczogZnVuY3Rpb24oZnJvbSwgdG8sIGZpbHRlcikge1xuICAgICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7IHRvID0gY2xpcFBvcyh0aGlzLCB0byk7XG4gICAgICB2YXIgZm91bmQgPSBbXSwgbGluZU5vID0gZnJvbS5saW5lO1xuICAgICAgdGhpcy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgICBpZiAoIShzcGFuLnRvICE9IG51bGwgJiYgbGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gPT0gbnVsbCAmJiBsaW5lTm8gIT0gZnJvbS5saW5lIHx8XG4gICAgICAgICAgICAgICAgc3Bhbi5mcm9tICE9IG51bGwgJiYgbGluZU5vID09IHRvLmxpbmUgJiYgc3Bhbi5mcm9tID49IHRvLmNoKSAmJlxuICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcbiAgICAgICAgICAgIHsgZm91bmQucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpOyB9XG4gICAgICAgIH0gfVxuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kXG4gICAgfSxcbiAgICBnZXRBbGxNYXJrczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcHMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHsgaWYgKHNwc1tpXS5mcm9tICE9IG51bGwpIHsgbWFya2Vycy5wdXNoKHNwc1tpXS5tYXJrZXIpOyB9IH0gfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH0sXG5cbiAgICBwb3NGcm9tSW5kZXg6IGZ1bmN0aW9uKG9mZikge1xuICAgICAgdmFyIGNoLCBsaW5lTm8gPSB0aGlzLmZpcnN0LCBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzeiA9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplO1xuICAgICAgICBpZiAoc3ogPiBvZmYpIHsgY2ggPSBvZmY7IHJldHVybiB0cnVlIH1cbiAgICAgICAgb2ZmIC09IHN6O1xuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObywgY2gpKVxuICAgIH0sXG4gICAgaW5kZXhGcm9tUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICBjb29yZHMgPSBjbGlwUG9zKHRoaXMsIGNvb3Jkcyk7XG4gICAgICB2YXIgaW5kZXggPSBjb29yZHMuY2g7XG4gICAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHsgcmV0dXJuIDAgfVxuICAgICAgdmFyIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICB0aGlzLml0ZXIodGhpcy5maXJzdCwgY29vcmRzLmxpbmUsIGZ1bmN0aW9uIChsaW5lKSB7IC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZVxuICAgICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluZGV4XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKGNvcHlIaXN0b3J5KSB7XG4gICAgICB2YXIgZG9jID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgICAgZG9jLnNlbCA9IHRoaXMuc2VsO1xuICAgICAgZG9jLmV4dGVuZCA9IGZhbHNlO1xuICAgICAgaWYgKGNvcHlIaXN0b3J5KSB7XG4gICAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGg7XG4gICAgICAgIGRvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuXG4gICAgbGlua2VkRG9jOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZTtcbiAgICAgIGlmIChvcHRpb25zLmZyb20gIT0gbnVsbCAmJiBvcHRpb25zLmZyb20gPiBmcm9tKSB7IGZyb20gPSBvcHRpb25zLmZyb207IH1cbiAgICAgIGlmIChvcHRpb25zLnRvICE9IG51bGwgJiYgb3B0aW9ucy50byA8IHRvKSB7IHRvID0gb3B0aW9ucy50bzsgfVxuICAgICAgdmFyIGNvcHkgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIGZyb20sIHRvKSwgb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgZnJvbSwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBpZiAob3B0aW9ucy5zaGFyZWRIaXN0KSB7IGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeVxuICAgICAgOyB9KHRoaXMubGlua2VkIHx8ICh0aGlzLmxpbmtlZCA9IFtdKSkucHVzaCh7ZG9jOiBjb3B5LCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9KTtcbiAgICAgIGNvcHkubGlua2VkID0gW3tkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9XTtcbiAgICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgIHJldHVybiBjb3B5XG4gICAgfSxcbiAgICB1bmxpbmtEb2M6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSB7IG90aGVyID0gb3RoZXIuZG9jOyB9XG4gICAgICBpZiAodGhpcy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMubGlua2VkW2ldO1xuICAgICAgICBpZiAobGluay5kb2MgIT0gb3RoZXIpIHsgY29udGludWUgfVxuICAgICAgICB0aGlzLmxpbmtlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG90aGVyLnVubGlua0RvYyh0aGlzKTtcbiAgICAgICAgZGV0YWNoU2hhcmVkTWFya2VycyhmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IH1cbiAgICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cbiAgICAgIGlmIChvdGhlci5oaXN0b3J5ID09IHRoaXMuaGlzdG9yeSkge1xuICAgICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdO1xuICAgICAgICBsaW5rZWREb2NzKG90aGVyLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBzcGxpdElkcy5wdXNoKGRvYy5pZCk7IH0sIHRydWUpO1xuICAgICAgICBvdGhlci5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbCk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7bGlua2VkRG9jcyh0aGlzLCBmKTt9LFxuXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZX0sXG4gICAgZ2V0RWRpdG9yOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5jbX0sXG5cbiAgICBzcGxpdExpbmVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVTZXApIHsgcmV0dXJuIHN0ci5zcGxpdCh0aGlzLmxpbmVTZXApIH1cbiAgICAgIHJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpXG4gICAgfSxcbiAgICBsaW5lU2VwYXJhdG9yOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZVNlcCB8fCBcIlxcblwiIH0sXG5cbiAgICBzZXREaXJlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIGlmIChkaXIgIT0gXCJydGxcIikgeyBkaXIgPSBcImx0clwiOyB9XG4gICAgICBpZiAoZGlyID09IHRoaXMuZGlyZWN0aW9uKSB7IHJldHVybiB9XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcjtcbiAgICAgIHRoaXMuaXRlcihmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gbGluZS5vcmRlciA9IG51bGw7IH0pO1xuICAgICAgaWYgKHRoaXMuY20pIHsgZGlyZWN0aW9uQ2hhbmdlZCh0aGlzLmNtKTsgfVxuICAgIH0pXG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBhbGlhcy5cbiAgRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlcjtcblxuICAvLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgc3RyYW5nZSBJRSBiZWhhdmlvciB3aGVyZSBpdCdsbCBzb21ldGltZXNcbiAgLy8gcmUtZmlyZSBhIHNlcmllcyBvZiBkcmFnLXJlbGF0ZWQgZXZlbnRzIHJpZ2h0IGFmdGVyIHRoZSBkcm9wICgjMTU1MSlcbiAgdmFyIGxhc3REcm9wID0gMDtcblxuICBmdW5jdGlvbiBvbkRyb3AoZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgY2xlYXJEcmFnQ3Vyc29yKGNtKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXG4gICAgICB7IHJldHVybiB9XG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICBpZiAoaWUpIHsgbGFzdERyb3AgPSArbmV3IERhdGU7IH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoIXBvcyB8fCBjbS5pc1JlYWRPbmx5KCkpIHsgcmV0dXJuIH1cbiAgICAvLyBNaWdodCBiZSBhIGZpbGUgZHJvcCwgaW4gd2hpY2ggY2FzZSB3ZSBzaW1wbHkgZXh0cmFjdCB0aGUgdGV4dFxuICAgIC8vIGFuZCBpbnNlcnQgaXQuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZSkge1xuICAgICAgdmFyIG4gPSBmaWxlcy5sZW5ndGgsIHRleHQgPSBBcnJheShuKSwgcmVhZCA9IDA7XG4gICAgICB2YXIgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgrK3JlYWQgPT0gbikge1xuICAgICAgICAgIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0ge2Zyb206IHBvcywgdG86IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY20uZG9jLnNwbGl0TGluZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAhPSBudWxsOyB9KS5qb2luKGNtLmRvYy5saW5lU2VwYXJhdG9yKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInBhc3RlXCJ9O1xuICAgICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihjbGlwUG9zKGNtLmRvYywgcG9zKSwgY2xpcFBvcyhjbS5kb2MsIGNoYW5nZUVuZChjaGFuZ2UpKSkpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVhZFRleHRGcm9tRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBpKSB7XG4gICAgICAgIGlmIChjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyAmJlxuICAgICAgICAgICAgaW5kZXhPZihjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcywgZmlsZS50eXBlKSA9PSAtMSkge1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7IH07XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRbaV0gPSBjb250ZW50O1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHsgcmVhZFRleHRGcm9tRmlsZShmaWxlc1tpXSwgaSk7IH1cbiAgICB9IGVsc2UgeyAvLyBOb3JtYWwgZHJvcFxuICAgICAgLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cbiAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID4gLTEpIHtcbiAgICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0KGUpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGVkaXRvciBpcyByZS1mb2N1c2VkXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRleHQkMSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCQxKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5KVxuICAgICAgICAgICAgeyBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7IH1cbiAgICAgICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zLCBwb3MpKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2VsZWN0ZWQubGVuZ3RoOyArK2kkMSlcbiAgICAgICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwgc2VsZWN0ZWRbaSQxXS5hbmNob3IsIHNlbGVjdGVkW2kkMV0uaGVhZCwgXCJkcmFnXCIpOyB9IH1cbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHRleHQkMSwgXCJhcm91bmRcIiwgXCJwYXN0ZVwiKTtcbiAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoKGUkMSl7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGNtLCBlKSB7XG4gICAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybiB9XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XG5cbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCBjbS5nZXRTZWxlY3Rpb24oKSk7XG4gICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcblxuICAgIC8vIFVzZSBkdW1teSBpbWFnZSBpbnN0ZWFkIG9mIGRlZmF1bHQgYnJvd3NlcnMgaW1hZ2UuXG4gICAgLy8gUmVjZW50IFNhZmFyaSAofjYuMC4yKSBoYXZlIGEgdGVuZGVuY3kgdG8gc2VnZmF1bHQgd2hlbiB0aGlzIGhhcHBlbnMsIHNvIHdlIGRvbid0IGRvIGl0IHRoZXJlLlxuICAgIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIXNhZmFyaSkge1xuICAgICAgdmFyIGltZyA9IGVsdChcImltZ1wiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtcbiAgICAgIGltZy5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7XG4gICAgICBpZiAocHJlc3RvKSB7XG4gICAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxO1xuICAgICAgICBjbS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgLy8gRm9yY2UgYSByZWxheW91dCwgb3IgT3BlcmEgd29uJ3QgdXNlIG91ciBpbWFnZSBmb3Igc29tZSBvYnNjdXJlIHJlYXNvblxuICAgICAgICBpbWcuX3RvcCA9IGltZy5vZmZzZXRUb3A7XG4gICAgICB9XG4gICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgIGlmIChwcmVzdG8pIHsgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ092ZXIoY20sIGUpIHtcbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICBpZiAoIXBvcykgeyByZXR1cm4gfVxuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHBvcywgZnJhZyk7XG4gICAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29ycyBDb2RlTWlycm9yLWRyYWdjdXJzb3JzXCIpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgY20uZGlzcGxheS5jdXJzb3JEaXYpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGZyYWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XG4gICAgaWYgKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoY20uZGlzcGxheS5kcmFnQ3Vyc29yKTtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlc2UgbXVzdCBiZSBoYW5kbGVkIGNhcmVmdWxseSwgYmVjYXVzZSBuYWl2ZWx5IHJlZ2lzdGVyaW5nIGFcbiAgLy8gaGFuZGxlciBmb3IgZWFjaCBlZGl0b3Igd2lsbCBjYXVzZSB0aGUgZWRpdG9ycyB0byBuZXZlciBiZVxuICAvLyBnYXJiYWdlIGNvbGxlY3RlZC5cblxuICBmdW5jdGlvbiBmb3JFYWNoQ29kZU1pcnJvcihmKSB7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7IHJldHVybiB9XG4gICAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiQ29kZU1pcnJvclwiKSwgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnlDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xuICAgICAgaWYgKGNtKSB7IGVkaXRvcnMucHVzaChjbSk7IH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoKSB7IGVkaXRvcnNbMF0ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRpdG9ycy5sZW5ndGg7IGkrKykgeyBmKGVkaXRvcnNbaV0pOyB9XG4gICAgfSk7IH1cbiAgfVxuXG4gIHZhciBnbG9iYWxzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBlbnN1cmVHbG9iYWxIYW5kbGVycygpIHtcbiAgICBpZiAoZ2xvYmFsc1JlZ2lzdGVyZWQpIHsgcmV0dXJuIH1cbiAgICByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCk7XG4gICAgZ2xvYmFsc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKSB7XG4gICAgLy8gV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCBhY3RpdmUgZWRpdG9ycy5cbiAgICB2YXIgcmVzaXplVGltZXI7XG4gICAgb24od2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgeyByZXNpemVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNpemVUaW1lciA9IG51bGw7XG4gICAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcbiAgICAgIH0sIDEwMCk7IH1cbiAgICB9KTtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcbiAgICBvbih3aW5kb3csIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpOyB9KTtcbiAgfVxuICAvLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcbiAgZnVuY3Rpb24gb25SZXNpemUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgLy8gTWlnaHQgYmUgYSB0ZXh0IHNjYWxpbmcgb3BlcmF0aW9uLCBjbGVhciBzaXplIGNhY2hlcy5cbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcbiAgICBjbS5zZXRTaXplKCk7XG4gIH1cblxuICB2YXIga2V5TmFtZXMgPSB7XG4gICAgMzogXCJQYXVzZVwiLCA4OiBcIkJhY2tzcGFjZVwiLCA5OiBcIlRhYlwiLCAxMzogXCJFbnRlclwiLCAxNjogXCJTaGlmdFwiLCAxNzogXCJDdHJsXCIsIDE4OiBcIkFsdFwiLFxuICAgIDE5OiBcIlBhdXNlXCIsIDIwOiBcIkNhcHNMb2NrXCIsIDI3OiBcIkVzY1wiLCAzMjogXCJTcGFjZVwiLCAzMzogXCJQYWdlVXBcIiwgMzQ6IFwiUGFnZURvd25cIiwgMzU6IFwiRW5kXCIsXG4gICAgMzY6IFwiSG9tZVwiLCAzNzogXCJMZWZ0XCIsIDM4OiBcIlVwXCIsIDM5OiBcIlJpZ2h0XCIsIDQwOiBcIkRvd25cIiwgNDQ6IFwiUHJpbnRTY3JuXCIsIDQ1OiBcIkluc2VydFwiLFxuICAgIDQ2OiBcIkRlbGV0ZVwiLCA1OTogXCI7XCIsIDYxOiBcIj1cIiwgOTE6IFwiTW9kXCIsIDkyOiBcIk1vZFwiLCA5MzogXCJNb2RcIixcbiAgICAxMDY6IFwiKlwiLCAxMDc6IFwiPVwiLCAxMDk6IFwiLVwiLCAxMTA6IFwiLlwiLCAxMTE6IFwiL1wiLCAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAgIDE3MzogXCItXCIsIDE4NjogXCI7XCIsIDE4NzogXCI9XCIsIDE4ODogXCIsXCIsIDE4OTogXCItXCIsIDE5MDogXCIuXCIsIDE5MTogXCIvXCIsIDE5MjogXCJgXCIsIDIxOTogXCJbXCIsIDIyMDogXCJcXFxcXCIsXG4gICAgMjIxOiBcIl1cIiwgMjIyOiBcIidcIiwgMjI0OiBcIk1vZFwiLCA2MzIzMjogXCJVcFwiLCA2MzIzMzogXCJEb3duXCIsIDYzMjM0OiBcIkxlZnRcIiwgNjMyMzU6IFwiUmlnaHRcIiwgNjMyNzI6IFwiRGVsZXRlXCIsXG4gICAgNjMyNzM6IFwiSG9tZVwiLCA2MzI3NTogXCJFbmRcIiwgNjMyNzY6IFwiUGFnZVVwXCIsIDYzMjc3OiBcIlBhZ2VEb3duXCIsIDYzMzAyOiBcIkluc2VydFwiXG4gIH07XG5cbiAgLy8gTnVtYmVyIGtleXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7IGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpOyB9XG4gIC8vIEFscGhhYmV0aWMga2V5c1xuICBmb3IgKHZhciBpJDEgPSA2NTsgaSQxIDw9IDkwOyBpJDErKykgeyBrZXlOYW1lc1tpJDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShpJDEpOyB9XG4gIC8vIEZ1bmN0aW9uIGtleXNcbiAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDw9IDEyOyBpJDIrKykgeyBrZXlOYW1lc1tpJDIgKyAxMTFdID0ga2V5TmFtZXNbaSQyICsgNjMyMzVdID0gXCJGXCIgKyBpJDI7IH1cblxuICB2YXIga2V5TWFwID0ge307XG5cbiAga2V5TWFwLmJhc2ljID0ge1xuICAgIFwiTGVmdFwiOiBcImdvQ2hhckxlZnRcIiwgXCJSaWdodFwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiVXBcIjogXCJnb0xpbmVVcFwiLCBcIkRvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJFbmRcIjogXCJnb0xpbmVFbmRcIiwgXCJIb21lXCI6IFwiZ29MaW5lU3RhcnRTbWFydFwiLCBcIlBhZ2VVcFwiOiBcImdvUGFnZVVwXCIsIFwiUGFnZURvd25cIjogXCJnb1BhZ2VEb3duXCIsXG4gICAgXCJEZWxldGVcIjogXCJkZWxDaGFyQWZ0ZXJcIiwgXCJCYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsIFwiU2hpZnQtQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLFxuICAgIFwiVGFiXCI6IFwiZGVmYXVsdFRhYlwiLCBcIlNoaWZ0LVRhYlwiOiBcImluZGVudEF1dG9cIixcbiAgICBcIkVudGVyXCI6IFwibmV3bGluZUFuZEluZGVudFwiLCBcIkluc2VydFwiOiBcInRvZ2dsZU92ZXJ3cml0ZVwiLFxuICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uXCJcbiAgfTtcbiAgLy8gTm90ZSB0aGF0IHRoZSBzYXZlIGFuZCBmaW5kLXJlbGF0ZWQgY29tbWFuZHMgYXJlbid0IGRlZmluZWQgYnlcbiAgLy8gZGVmYXVsdC4gVXNlciBjb2RlIG9yIGFkZG9ucyBjYW4gZGVmaW5lIHRoZW0uIFVua25vd24gY29tbWFuZHNcbiAgLy8gYXJlIHNpbXBseSBpZ25vcmVkLlxuICBrZXlNYXAucGNEZWZhdWx0ID0ge1xuICAgIFwiQ3RybC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ3RybC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkN0cmwtWlwiOiBcInVuZG9cIiwgXCJTaGlmdC1DdHJsLVpcIjogXCJyZWRvXCIsIFwiQ3RybC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ3RybC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDdHJsLVVwXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLURvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJDdHJsLUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLCBcIkN0cmwtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJBbHQtTGVmdFwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQWx0LVJpZ2h0XCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgXCJDdHJsLUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsIFwiQ3RybC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQ3RybC1TXCI6IFwic2F2ZVwiLCBcIkN0cmwtRlwiOiBcImZpbmRcIixcbiAgICBcIkN0cmwtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ3RybC1HXCI6IFwiZmluZFByZXZcIiwgXCJTaGlmdC1DdHJsLUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ3RybC1SXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgIFwiQ3RybC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkN0cmwtXVwiOiBcImluZGVudE1vcmVcIixcbiAgICBcIkN0cmwtVVwiOiBcInVuZG9TZWxlY3Rpb25cIiwgXCJTaGlmdC1DdHJsLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQWx0LVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsXG4gICAgXCJmYWxsdGhyb3VnaFwiOiBcImJhc2ljXCJcbiAgfTtcbiAgLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cbiAga2V5TWFwLmVtYWNzeSA9IHtcbiAgICBcIkN0cmwtRlwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiQ3RybC1CXCI6IFwiZ29DaGFyTGVmdFwiLCBcIkN0cmwtUFwiOiBcImdvTGluZVVwXCIsIFwiQ3RybC1OXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiQ3RybC1BXCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJDdHJsLUVcIjogXCJnb0xpbmVFbmRcIiwgXCJDdHJsLVZcIjogXCJnb1BhZ2VEb3duXCIsIFwiU2hpZnQtQ3RybC1WXCI6IFwiZ29QYWdlVXBcIixcbiAgICBcIkN0cmwtRFwiOiBcImRlbENoYXJBZnRlclwiLCBcIkN0cmwtSFwiOiBcImRlbENoYXJCZWZvcmVcIiwgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsV29yZEJlZm9yZVwiLCBcIkN0cmwtS1wiOiBcImtpbGxMaW5lXCIsXG4gICAgXCJDdHJsLVRcIjogXCJ0cmFuc3Bvc2VDaGFyc1wiLCBcIkN0cmwtT1wiOiBcIm9wZW5MaW5lXCJcbiAgfTtcbiAga2V5TWFwLm1hY0RlZmF1bHQgPSB7XG4gICAgXCJDbWQtQVwiOiBcInNlbGVjdEFsbFwiLCBcIkNtZC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkNtZC1aXCI6IFwidW5kb1wiLCBcIlNoaWZ0LUNtZC1aXCI6IFwicmVkb1wiLCBcIkNtZC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ21kLUhvbWVcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ21kLVVwXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkNtZC1FbmRcIjogXCJnb0RvY0VuZFwiLCBcIkNtZC1Eb3duXCI6IFwiZ29Eb2NFbmRcIiwgXCJBbHQtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsXG4gICAgXCJBbHQtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJDbWQtTGVmdFwiOiBcImdvTGluZUxlZnRcIiwgXCJDbWQtUmlnaHRcIjogXCJnb0xpbmVSaWdodFwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEJlZm9yZVwiLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkFsdC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQ21kLVNcIjogXCJzYXZlXCIsIFwiQ21kLUZcIjogXCJmaW5kXCIsXG4gICAgXCJDbWQtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ21kLUdcIjogXCJmaW5kUHJldlwiLCBcIkNtZC1BbHQtRlwiOiBcInJlcGxhY2VcIiwgXCJTaGlmdC1DbWQtQWx0LUZcIjogXCJyZXBsYWNlQWxsXCIsXG4gICAgXCJDbWQtW1wiOiBcImluZGVudExlc3NcIiwgXCJDbWQtXVwiOiBcImluZGVudE1vcmVcIiwgXCJDbWQtQmFja3NwYWNlXCI6IFwiZGVsV3JhcHBlZExpbmVMZWZ0XCIsIFwiQ21kLURlbGV0ZVwiOiBcImRlbFdyYXBwZWRMaW5lUmlnaHRcIixcbiAgICBcIkNtZC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLCBcIlNoaWZ0LUNtZC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLCBcIkN0cmwtVXBcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ3RybC1Eb3duXCI6IFwiZ29Eb2NFbmRcIixcbiAgICBcImZhbGx0aHJvdWdoXCI6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXG4gIH07XG4gIGtleU1hcFtcImRlZmF1bHRcIl0gPSBtYWMgPyBrZXlNYXAubWFjRGVmYXVsdCA6IGtleU1hcC5wY0RlZmF1bHQ7XG5cbiAgLy8gS0VZTUFQIERJU1BBVENIXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBhbHQsIGN0cmwsIHNoaWZ0LCBjbWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHsgY21kID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSB7IGFsdCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7IHNoaWZ0ID0gdHJ1ZTsgfVxuICAgICAgZWxzZSB7IHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCkgfVxuICAgIH1cbiAgICBpZiAoYWx0KSB7IG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7IH1cbiAgICBpZiAoY3RybCkgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICAgIGlmIChjbWQpIHsgbmFtZSA9IFwiQ21kLVwiICsgbmFtZTsgfVxuICAgIGlmIChzaGlmdCkgeyBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7IH1cbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gVGhpcyBpcyBhIGtsdWRnZSB0byBrZWVwIGtleW1hcHMgbW9zdGx5IHdvcmtpbmcgYXMgcmF3IG9iamVjdHNcbiAgLy8gKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIHN1cHBvcnQgZmVhdHVyZXNcbiAgLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXG4gIC8vIG5ldyBub3JtYWxpemVkIGtleW1hcCwgYW5kIHRoZW4gdXBkYXRlcyB0aGUgb2xkIG9iamVjdCB0byByZWZsZWN0XG4gIC8vIHRoaXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleU1hcChrZXltYXApIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIGZvciAodmFyIGtleW5hbWUgaW4ga2V5bWFwKSB7IGlmIChrZXltYXAuaGFzT3duUHJvcGVydHkoa2V5bmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGtleW1hcFtrZXluYW1lXTtcbiAgICAgIGlmICgvXihuYW1lfGZhbGx0aHJvdWdofChkZXxhdCl0YWNoKSQvLnRlc3Qoa2V5bmFtZSkpIHsgY29udGludWUgfVxuICAgICAgaWYgKHZhbHVlID09IFwiLi4uXCIpIHsgZGVsZXRlIGtleW1hcFtrZXluYW1lXTsgY29udGludWUgfVxuXG4gICAgICB2YXIga2V5cyA9IG1hcChrZXluYW1lLnNwbGl0KFwiIFwiKSwgbm9ybWFsaXplS2V5TmFtZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbCA9ICh2b2lkIDApLCBuYW1lID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChpID09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG5hbWUgPSBrZXlzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICB2YWwgPSBcIi4uLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ID0gY29weVtuYW1lXTtcbiAgICAgICAgaWYgKCFwcmV2KSB7IGNvcHlbbmFtZV0gPSB2YWw7IH1cbiAgICAgICAgZWxzZSBpZiAocHJldiAhPSB2YWwpIHsgdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IGJpbmRpbmdzIGZvciBcIiArIG5hbWUpIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBrZXltYXBba2V5bmFtZV07XG4gICAgfSB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBjb3B5KSB7IGtleW1hcFtwcm9wXSA9IGNvcHlbcHJvcF07IH1cbiAgICByZXR1cm4ga2V5bWFwXG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBLZXkoa2V5LCBtYXAsIGhhbmRsZSwgY29udGV4dCkge1xuICAgIG1hcCA9IGdldEtleU1hcChtYXApO1xuICAgIHZhciBmb3VuZCA9IG1hcC5jYWxsID8gbWFwLmNhbGwoa2V5LCBjb250ZXh0KSA6IG1hcFtrZXldO1xuICAgIGlmIChmb3VuZCA9PT0gZmFsc2UpIHsgcmV0dXJuIFwibm90aGluZ1wiIH1cbiAgICBpZiAoZm91bmQgPT09IFwiLi4uXCIpIHsgcmV0dXJuIFwibXVsdGlcIiB9XG4gICAgaWYgKGZvdW5kICE9IG51bGwgJiYgaGFuZGxlKGZvdW5kKSkgeyByZXR1cm4gXCJoYW5kbGVkXCIgfVxuXG4gICAgaWYgKG1hcC5mYWxsdGhyb3VnaCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAuZmFsbHRocm91Z2gpICE9IFwiW29iamVjdCBBcnJheV1cIilcbiAgICAgICAgeyByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoLCBoYW5kbGUsIGNvbnRleHQpIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmZhbGx0aHJvdWdoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2hbaV0sIGhhbmRsZSwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW9kaWZpZXIga2V5IHByZXNzZXMgZG9uJ3QgY291bnQgYXMgJ3JlYWwnIGtleSBwcmVzc2VzIGZvciB0aGVcbiAgLy8gcHVycG9zZSBvZiBrZXltYXAgZmFsbHRocm91Z2guXG4gIGZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkodmFsdWUpIHtcbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiID8gdmFsdWUgOiBrZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXTtcbiAgICByZXR1cm4gbmFtZSA9PSBcIkN0cmxcIiB8fCBuYW1lID09IFwiQWx0XCIgfHwgbmFtZSA9PSBcIlNoaWZ0XCIgfHwgbmFtZSA9PSBcIk1vZFwiXG4gIH1cblxuICBmdW5jdGlvbiBhZGRNb2RpZmllck5hbWVzKG5hbWUsIGV2ZW50LCBub1NoaWZ0KSB7XG4gICAgdmFyIGJhc2UgPSBuYW1lO1xuICAgIGlmIChldmVudC5hbHRLZXkgJiYgYmFzZSAhPSBcIkFsdFwiKSB7IG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7IH1cbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpICYmIGJhc2UgIT0gXCJDdHJsXCIpIHsgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7IH1cbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQuY3RybEtleSA6IGV2ZW50Lm1ldGFLZXkpICYmIGJhc2UgIT0gXCJNb2RcIikgeyBuYW1lID0gXCJDbWQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKCFub1NoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGJhc2UgIT0gXCJTaGlmdFwiKSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBuYW1lIG9mIGEga2V5IGFzIGluZGljYXRlZCBieSBhbiBldmVudCBvYmplY3QuXG4gIGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQsIG5vU2hpZnQpIHtcbiAgICBpZiAocHJlc3RvICYmIGV2ZW50LmtleUNvZGUgPT0gMzQgJiYgZXZlbnRbXCJjaGFyXCJdKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lc1tldmVudC5rZXlDb2RlXTtcbiAgICBpZiAobmFtZSA9PSBudWxsIHx8IGV2ZW50LmFsdEdyYXBoS2V5KSB7IHJldHVybiBmYWxzZSB9XG4gICAgLy8gQ3RybC1TY3JvbGxMb2NrIGhhcyBrZXlDb2RlIDMsIHNhbWUgYXMgQ3RybC1QYXVzZSxcbiAgICAvLyBzbyB3ZSdsbCB1c2UgZXZlbnQuY29kZSB3aGVuIGF2YWlsYWJsZSAoQ2hyb21lIDQ4KywgRkYgMzgrLCBTYWZhcmkgMTAuMSspXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMyAmJiBldmVudC5jb2RlKSB7IG5hbWUgPSBldmVudC5jb2RlOyB9XG4gICAgcmV0dXJuIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlNYXAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiA/IGtleU1hcFt2YWxdIDogdmFsXG4gIH1cblxuICAvLyBIZWxwZXIgZm9yIGRlbGV0aW5nIHRleHQgbmVhciB0aGUgc2VsZWN0aW9uKHMpLCB1c2VkIHRvIGltcGxlbWVudFxuICAvLyBiYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIHNpbWlsYXIgZnVuY3Rpb25hbGl0eS5cbiAgZnVuY3Rpb24gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgY29tcHV0ZSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5kb2Muc2VsLnJhbmdlcywga2lsbCA9IFtdO1xuICAgIC8vIEJ1aWxkIHVwIGEgc2V0IG9mIHJhbmdlcyB0byBraWxsIGZpcnN0LCBtZXJnaW5nIG92ZXJsYXBwaW5nXG4gICAgLy8gcmFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9LaWxsID0gY29tcHV0ZShyYW5nZXNbaV0pO1xuICAgICAgd2hpbGUgKGtpbGwubGVuZ3RoICYmIGNtcCh0b0tpbGwuZnJvbSwgbHN0KGtpbGwpLnRvKSA8PSAwKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IGtpbGwucG9wKCk7XG4gICAgICAgIGlmIChjbXAocmVwbGFjZWQuZnJvbSwgdG9LaWxsLmZyb20pIDwgMCkge1xuICAgICAgICAgIHRvS2lsbC5mcm9tID0gcmVwbGFjZWQuZnJvbTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBraWxsLnB1c2godG9LaWxsKTtcbiAgICB9XG4gICAgLy8gTmV4dCwgcmVtb3ZlIHRob3NlIGFjdHVhbCByYW5nZXMuXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwga2lsbFtpXS5mcm9tLCBraWxsW2ldLnRvLCBcIitkZWxldGVcIik7IH1cbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgY2gsIGRpcikge1xuICAgIHZhciB0YXJnZXQgPSBza2lwRXh0ZW5kaW5nQ2hhcnMobGluZS50ZXh0LCBjaCArIGRpciwgZGlyKTtcbiAgICByZXR1cm4gdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPiBsaW5lLnRleHQubGVuZ3RoID8gbnVsbCA6IHRhcmdldFxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKSB7XG4gICAgdmFyIGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgc3RhcnQuY2gsIGRpcik7XG4gICAgcmV0dXJuIGNoID09IG51bGwgPyBudWxsIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgZGlyIDwgMCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIpXG4gIH1cblxuICBmdW5jdGlvbiBlbmRPZkxpbmUodmlzdWFsbHksIGNtLCBsaW5lT2JqLCBsaW5lTm8sIGRpcikge1xuICAgIGlmICh2aXN1YWxseSkge1xuICAgICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIikgeyBkaXIgPSAtZGlyOyB9XG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChvcmRlcikge1xuICAgICAgICB2YXIgcGFydCA9IGRpciA8IDAgPyBsc3Qob3JkZXIpIDogb3JkZXJbMF07XG4gICAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSk7XG4gICAgICAgIHZhciBzdGlja3kgPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgICB2YXIgY2g7XG4gICAgICAgIC8vIFdpdGggYSB3cmFwcGVkIHJ0bCBjaHVuayAocG9zc2libHkgc3Bhbm5pbmcgbXVsdGlwbGUgYmlkaSBwYXJ0cyksXG4gICAgICAgIC8vIGl0IGNvdWxkIGJlIHRoYXQgdGhlIGxhc3QgYmlkaSBwYXJ0IGlzIG5vdCBvbiB0aGUgbGFzdCB2aXN1YWwgbGluZSxcbiAgICAgICAgLy8gc2luY2UgdmlzdWFsIGxpbmVzIGNvbnRhaW4gY29udGVudCBvcmRlci1jb25zZWN1dGl2ZSBjaHVua3MuXG4gICAgICAgIC8vIFRodXMsIGluIHJ0bCwgd2UgYXJlIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCAoY29udGVudC1vcmRlcikgY2hhcmFjdGVyXG4gICAgICAgIC8vIGluIHRoZSBydGwgY2h1bmsgdGhhdCBpcyBvbiB0aGUgbGFzdCBsaW5lICh0aGF0IGlzLCB0aGUgc2FtZSBsaW5lXG4gICAgICAgIC8vIGFzIHRoZSBsYXN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXIpLlxuICAgICAgICBpZiAocGFydC5sZXZlbCA+IDAgfHwgY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiKSB7XG4gICAgICAgICAgdmFyIHByZXAgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xuICAgICAgICAgIGNoID0gZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICB2YXIgdGFyZ2V0VG9wID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcCwgY2gpLnRvcDtcbiAgICAgICAgICBjaCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoKS50b3AgPT0gdGFyZ2V0VG9wOyB9LCAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSkgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIC0gMSwgY2gpO1xuICAgICAgICAgIGlmIChzdGlja3kgPT0gXCJiZWZvcmVcIikgeyBjaCA9IG1vdmVDaGFyTG9naWNhbGx5KGxpbmVPYmosIGNoLCAxKTsgfVxuICAgICAgICB9IGVsc2UgeyBjaCA9IGRpciA8IDAgPyBwYXJ0LnRvIDogcGFydC5mcm9tOyB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGxpbmVObywgY2gsIHN0aWNreSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb3MobGluZU5vLCBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCA6IDAsIGRpciA8IDAgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiKVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGNtLCBsaW5lLCBzdGFydCwgZGlyKSB7XG4gICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICBpZiAoIWJpZGkpIHsgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcikgfVxuICAgIGlmIChzdGFydC5jaCA+PSBsaW5lLnRleHQubGVuZ3RoKSB7XG4gICAgICBzdGFydC5jaCA9IGxpbmUudGV4dC5sZW5ndGg7XG4gICAgICBzdGFydC5zdGlja3kgPSBcImJlZm9yZVwiO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQuY2ggPD0gMCkge1xuICAgICAgc3RhcnQuY2ggPSAwO1xuICAgICAgc3RhcnQuc3RpY2t5ID0gXCJhZnRlclwiO1xuICAgIH1cbiAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQoYmlkaSwgc3RhcnQuY2gsIHN0YXJ0LnN0aWNreSksIHBhcnQgPSBiaWRpW3BhcnRQb3NdO1xuICAgIGlmIChjbS5kb2MuZGlyZWN0aW9uID09IFwibHRyXCIgJiYgcGFydC5sZXZlbCAlIDIgPT0gMCAmJiAoZGlyID4gMCA/IHBhcnQudG8gPiBzdGFydC5jaCA6IHBhcnQuZnJvbSA8IHN0YXJ0LmNoKSkge1xuICAgICAgLy8gQ2FzZSAxOiBXZSBtb3ZlIHdpdGhpbiBhbiBsdHIgcGFydCBpbiBhbiBsdHIgZWRpdG9yLiBFdmVuIHdpdGggd3JhcHBlZCBsaW5lcyxcbiAgICAgIC8vIG5vdGhpbmcgaW50ZXJlc3RpbmcgaGFwcGVucy5cbiAgICAgIHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpXG4gICAgfVxuXG4gICAgdmFyIG12ID0gZnVuY3Rpb24gKHBvcywgZGlyKSB7IHJldHVybiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBwb3MgaW5zdGFuY2VvZiBQb3MgPyBwb3MuY2ggOiBwb3MsIGRpcik7IH07XG4gICAgdmFyIHByZXA7XG4gICAgdmFyIGdldFdyYXBwZWRMaW5lRXh0ZW50ID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IHJldHVybiB7YmVnaW46IDAsIGVuZDogbGluZS50ZXh0Lmxlbmd0aH0gfVxuICAgICAgcHJlcCA9IHByZXAgfHwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKTtcbiAgICAgIHJldHVybiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmUsIHByZXAsIGNoKVxuICAgIH07XG4gICAgdmFyIHdyYXBwZWRMaW5lRXh0ZW50ID0gZ2V0V3JhcHBlZExpbmVFeHRlbnQoc3RhcnQuc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBtdihzdGFydCwgLTEpIDogc3RhcnQuY2gpO1xuXG4gICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiB8fCBwYXJ0LmxldmVsID09IDEpIHtcbiAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAocGFydC5sZXZlbCA9PSAxKSA9PSAoZGlyIDwgMCk7XG4gICAgICB2YXIgY2ggPSBtdihzdGFydCwgbW92ZUluU3RvcmFnZU9yZGVyID8gMSA6IC0xKTtcbiAgICAgIGlmIChjaCAhPSBudWxsICYmICghbW92ZUluU3RvcmFnZU9yZGVyID8gY2ggPj0gcGFydC5mcm9tICYmIGNoID49IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogY2ggPD0gcGFydC50byAmJiBjaCA8PSB3cmFwcGVkTGluZUV4dGVudC5lbmQpKSB7XG4gICAgICAgIC8vIENhc2UgMjogV2UgbW92ZSB3aXRoaW4gYW4gcnRsIHBhcnQgb3IgaW4gYW4gcnRsIGVkaXRvciBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZVxuICAgICAgICB2YXIgc3RpY2t5ID0gbW92ZUluU3RvcmFnZU9yZGVyID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIHN0aWNreSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYXNlIDM6IENvdWxkIG5vdCBtb3ZlIHdpdGhpbiB0aGlzIGJpZGkgcGFydCBpbiB0aGlzIHZpc3VhbCBsaW5lLCBzbyBsZWF2ZVxuICAgIC8vIHRoZSBjdXJyZW50IGJpZGkgcGFydFxuXG4gICAgdmFyIHNlYXJjaEluVmlzdWFsTGluZSA9IGZ1bmN0aW9uIChwYXJ0UG9zLCBkaXIsIHdyYXBwZWRMaW5lRXh0ZW50KSB7XG4gICAgICB2YXIgZ2V0UmVzID0gZnVuY3Rpb24gKGNoLCBtb3ZlSW5TdG9yYWdlT3JkZXIpIHsgcmV0dXJuIG1vdmVJblN0b3JhZ2VPcmRlclxuICAgICAgICA/IG5ldyBQb3Moc3RhcnQubGluZSwgbXYoY2gsIDEpLCBcImJlZm9yZVwiKVxuICAgICAgICA6IG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIFwiYWZ0ZXJcIik7IH07XG5cbiAgICAgIGZvciAoOyBwYXJ0UG9zID49IDAgJiYgcGFydFBvcyA8IGJpZGkubGVuZ3RoOyBwYXJ0UG9zICs9IGRpcikge1xuICAgICAgICB2YXIgcGFydCA9IGJpZGlbcGFydFBvc107XG4gICAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAoZGlyID4gMCkgPT0gKHBhcnQubGV2ZWwgIT0gMSk7XG4gICAgICAgIHZhciBjaCA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogbXYod3JhcHBlZExpbmVFeHRlbnQuZW5kLCAtMSk7XG4gICAgICAgIGlmIChwYXJ0LmZyb20gPD0gY2ggJiYgY2ggPCBwYXJ0LnRvKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxuICAgICAgICBjaCA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IHBhcnQuZnJvbSA6IG12KHBhcnQudG8sIC0xKTtcbiAgICAgICAgaWYgKHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDw9IGNoICYmIGNoIDwgd3JhcHBlZExpbmVFeHRlbnQuZW5kKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDYXNlIDNhOiBMb29rIGZvciBvdGhlciBiaWRpIHBhcnRzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXG4gICAgdmFyIHJlcyA9IHNlYXJjaEluVmlzdWFsTGluZShwYXJ0UG9zICsgZGlyLCBkaXIsIHdyYXBwZWRMaW5lRXh0ZW50KTtcbiAgICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxuXG4gICAgLy8gQ2FzZSAzYjogTG9vayBmb3Igb3RoZXIgYmlkaSBwYXJ0cyBvbiB0aGUgbmV4dCB2aXN1YWwgbGluZVxuICAgIHZhciBuZXh0Q2ggPSBkaXIgPiAwID8gd3JhcHBlZExpbmVFeHRlbnQuZW5kIDogbXYod3JhcHBlZExpbmVFeHRlbnQuYmVnaW4sIC0xKTtcbiAgICBpZiAobmV4dENoICE9IG51bGwgJiYgIShkaXIgPiAwICYmIG5leHRDaCA9PSBsaW5lLnRleHQubGVuZ3RoKSkge1xuICAgICAgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKGRpciA+IDAgPyAwIDogYmlkaS5sZW5ndGggLSAxLCBkaXIsIGdldFdyYXBwZWRMaW5lRXh0ZW50KG5leHRDaCkpO1xuICAgICAgaWYgKHJlcykgeyByZXR1cm4gcmVzIH1cbiAgICB9XG5cbiAgICAvLyBDYXNlIDQ6IE5vd2hlcmUgdG8gbW92ZVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDb21tYW5kcyBhcmUgcGFyYW1ldGVyLWxlc3MgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgb24gYW5cbiAgLy8gZWRpdG9yLCBtb3N0bHkgdXNlZCBmb3Iga2V5YmluZGluZ3MuXG4gIHZhciBjb21tYW5kcyA9IHtcbiAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcbiAgICBzaW5nbGVTZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uc2V0U2VsZWN0aW9uKGNtLmdldEN1cnNvcihcImFuY2hvclwiKSwgY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKSwgc2VsX2RvbnRTY3JvbGwpOyB9LFxuICAgIGtpbGxMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocmFuZ2UuaGVhZC5jaCA9PSBsZW4gJiYgcmFuZ2UuaGVhZC5saW5lIDwgY20ubGFzdExpbmUoKSlcbiAgICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUgKyAxLCAwKX0gfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyByZXR1cm4ge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBQb3MocmFuZ2UuaGVhZC5saW5lLCBsZW4pfSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCl9XG4gICAgICB9XG4gICAgfSk7IH0sXG4gICAgZGVsZXRlTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XG4gICAgICBmcm9tOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLFxuICAgICAgdG86IGNsaXBQb3MoY20uZG9jLCBQb3MocmFuZ2UudG8oKS5saW5lICsgMSwgMCkpXG4gICAgfSk7IH0pOyB9LFxuICAgIGRlbExpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcbiAgICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKClcbiAgICB9KTsgfSk7IH0sXG4gICAgZGVsV3JhcHBlZExpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciBsZWZ0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIHJldHVybiB7ZnJvbTogbGVmdFBvcywgdG86IHJhbmdlLmZyb20oKX1cbiAgICB9KTsgfSxcbiAgICBkZWxXcmFwcGVkTGluZVJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciByaWdodFBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmlnaHRQb3MgfVxuICAgIH0pOyB9LFxuICAgIHVuZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kbygpOyB9LFxuICAgIHJlZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkbygpOyB9LFxuICAgIHVuZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kb1NlbGVjdGlvbigpOyB9LFxuICAgIHJlZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkb1NlbGVjdGlvbigpOyB9LFxuICAgIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCkpOyB9LFxuICAgIGdvRG9jRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbihQb3MoY20ubGFzdExpbmUoKSkpOyB9LFxuICAgIGdvTGluZVN0YXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcbiAgICAgIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogMX1cbiAgICApOyB9LFxuICAgIGdvTGluZVN0YXJ0U21hcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0U21hcnQoY20sIHJhbmdlLmhlYWQpOyB9LFxuICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfVxuICAgICk7IH0sXG4gICAgZ29MaW5lRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVFbmQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXG4gICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IC0xfVxuICAgICk7IH0sXG4gICAgZ29MaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcImRpdlwiKVxuICAgIH0sIHNlbF9tb3ZlKTsgfSxcbiAgICBnb0xpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZUxlZnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIGlmIChwb3MuY2ggPCBjbS5nZXRMaW5lKHBvcy5saW5lKS5zZWFyY2goL1xcUy8pKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCkgfVxuICAgICAgcmV0dXJuIHBvc1xuICAgIH0sIHNlbF9tb3ZlKTsgfSxcbiAgICBnb0xpbmVVcDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigtMSwgXCJsaW5lXCIpOyB9LFxuICAgIGdvTGluZURvd246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoMSwgXCJsaW5lXCIpOyB9LFxuICAgIGdvUGFnZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcInBhZ2VcIik7IH0sXG4gICAgZ29QYWdlRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcInBhZ2VcIik7IH0sXG4gICAgZ29DaGFyTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJjaGFyXCIpOyB9LFxuICAgIGdvQ2hhclJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwiY2hhclwiKTsgfSxcbiAgICBnb0NvbHVtbkxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwiY29sdW1uXCIpOyB9LFxuICAgIGdvQ29sdW1uUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJjb2x1bW5cIik7IH0sXG4gICAgZ29Xb3JkTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGdvR3JvdXBSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcImdyb3VwXCIpOyB9LFxuICAgIGdvR3JvdXBMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImdyb3VwXCIpOyB9LFxuICAgIGdvV29yZFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxDaGFyQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwiY29kZXBvaW50XCIpOyB9LFxuICAgIGRlbENoYXJBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFwiY2hhclwiKTsgfSxcbiAgICBkZWxXb3JkQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxXb3JkQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcIndvcmRcIik7IH0sXG4gICAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJncm91cFwiKTsgfSxcbiAgICBkZWxHcm91cEFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJncm91cFwiKTsgfSxcbiAgICBpbmRlbnRBdXRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpOyB9LFxuICAgIGluZGVudE1vcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpOyB9LFxuICAgIGluZGVudExlc3M6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwic3VidHJhY3RcIik7IH0sXG4gICAgaW5zZXJ0VGFiOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIik7IH0sXG4gICAgaW5zZXJ0U29mdFRhYjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICB2YXIgc3BhY2VzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcG9zID0gcmFuZ2VzW2ldLmZyb20oKTtcbiAgICAgICAgdmFyIGNvbCA9IGNvdW50Q29sdW1uKGNtLmdldExpbmUocG9zLmxpbmUpLCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICBzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplIC0gY29sICUgdGFiU2l6ZSkpO1xuICAgICAgfVxuICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3BhY2VzKTtcbiAgICB9LFxuICAgIGRlZmF1bHRUYWI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgY20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpOyB9XG4gICAgICBlbHNlIHsgY20uZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIik7IH1cbiAgICB9LFxuICAgIC8vIFN3YXAgdGhlIHR3byBjaGFycyBsZWZ0IGFuZCByaWdodCBvZiBlYWNoIHNlbGVjdGlvbidzIGhlYWQuXG4gICAgLy8gTW92ZSBjdXJzb3IgYmVoaW5kIHRoZSB0d28gc3dhcHBlZCBjaGFyYWN0ZXJzIGFmdGVyd2FyZHMuXG4gICAgLy9cbiAgICAvLyBEb2Vzbid0IGNvbnNpZGVyIGxpbmUgZmVlZHMgYSBjaGFyYWN0ZXIuXG4gICAgLy8gRG9lc24ndCBzY2FuIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSB0byBmaW5kIGEgY2hhcmFjdGVyLlxuICAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgb24gYW4gZW1wdHkgbGluZS5cbiAgICAvLyBEb2Vzbid0IGRvIGFueXRoaW5nIHdpdGggbm9uLWVtcHR5IHNlbGVjdGlvbnMuXG4gICAgdHJhbnNwb3NlQ2hhcnM6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1NlbCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0uaGVhZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSkudGV4dDtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICBpZiAoY3VyLmNoID09IGxpbmUubGVuZ3RoKSB7IGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpOyB9XG4gICAgICAgICAgaWYgKGN1ci5jaCA+IDApIHtcbiAgICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KGN1ci5jaCAtIDEpICsgbGluZS5jaGFyQXQoY3VyLmNoIC0gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAyKSwgY3VyLCBcIit0cmFuc3Bvc2VcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIubGluZSA+IGNtLmRvYy5maXJzdCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUgLSAxKS50ZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgMSk7XG4gICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdCgwKSArIGNtLmRvYy5saW5lU2VwYXJhdG9yKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jaGFyQXQocHJldi5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSAtIDEsIHByZXYubGVuZ3RoIC0gMSksIGN1ciwgXCIrdHJhbnNwb3NlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTZWwucHVzaChuZXcgUmFuZ2UoY3VyLCBjdXIpKTtcbiAgICAgIH1cbiAgICAgIGNtLnNldFNlbGVjdGlvbnMobmV3U2VsKTtcbiAgICB9KTsgfSxcbiAgICBuZXdsaW5lQW5kSW5kZW50OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSBzZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7IGNtLnJlcGxhY2VSYW5nZShjbS5kb2MubGluZVNlcGFyYXRvcigpLCBzZWxzW2ldLmFuY2hvciwgc2Vsc1tpXS5oZWFkLCBcIitpbnB1dFwiKTsgfVxuICAgICAgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxzLmxlbmd0aDsgaSQxKyspXG4gICAgICAgIHsgY20uaW5kZW50TGluZShzZWxzW2kkMV0uZnJvbSgpLmxpbmUsIG51bGwsIHRydWUpOyB9XG4gICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICB9KTsgfSxcbiAgICBvcGVuTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXFxuXCIsIFwic3RhcnRcIik7IH0sXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9XG4gIH07XG5cblxuICBmdW5jdGlvbiBsaW5lU3RhcnQoY20sIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpOyB9XG4gICAgcmV0dXJuIGVuZE9mTGluZSh0cnVlLCBjbSwgdmlzdWFsLCBsaW5lTiwgMSlcbiAgfVxuICBmdW5jdGlvbiBsaW5lRW5kKGNtLCBsaW5lTikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKTtcbiAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZUVuZChsaW5lKTtcbiAgICBpZiAodmlzdWFsICE9IGxpbmUpIHsgbGluZU4gPSBsaW5lTm8odmlzdWFsKTsgfVxuICAgIHJldHVybiBlbmRPZkxpbmUodHJ1ZSwgY20sIGxpbmUsIGxpbmVOLCAtMSlcbiAgfVxuICBmdW5jdGlvbiBsaW5lU3RhcnRTbWFydChjbSwgcG9zKSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluZVN0YXJ0KGNtLCBwb3MubGluZSk7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgc3RhcnQubGluZSk7XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbik7XG4gICAgaWYgKCFvcmRlciB8fCBvcmRlclswXS5sZXZlbCA9PSAwKSB7XG4gICAgICB2YXIgZmlyc3ROb25XUyA9IE1hdGgubWF4KHN0YXJ0LmNoLCBsaW5lLnRleHQuc2VhcmNoKC9cXFMvKSk7XG4gICAgICB2YXIgaW5XUyA9IHBvcy5saW5lID09IHN0YXJ0LmxpbmUgJiYgcG9zLmNoIDw9IGZpcnN0Tm9uV1MgJiYgcG9zLmNoO1xuICAgICAgcmV0dXJuIFBvcyhzdGFydC5saW5lLCBpbldTID8gMCA6IGZpcnN0Tm9uV1MsIHN0YXJ0LnN0aWNreSlcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICAvLyBSdW4gYSBoYW5kbGVyIHRoYXQgd2FzIGJvdW5kIHRvIGEga2V5LlxuICBmdW5jdGlvbiBkb0hhbmRsZUJpbmRpbmcoY20sIGJvdW5kLCBkcm9wU2hpZnQpIHtcbiAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvdW5kID0gY29tbWFuZHNbYm91bmRdO1xuICAgICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICAvLyBFbnN1cmUgcHJldmlvdXMgaW5wdXQgaGFzIGJlZW4gcmVhZCwgc28gdGhhdCB0aGUgaGFuZGxlciBzZWVzIGFcbiAgICAvLyBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIGRvY3VtZW50XG4gICAgY20uZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICB2YXIgcHJldlNoaWZ0ID0gY20uZGlzcGxheS5zaGlmdCwgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY20uaXNSZWFkT25seSgpKSB7IGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlOyB9XG4gICAgICBpZiAoZHJvcFNoaWZ0KSB7IGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTsgfVxuICAgICAgZG9uZSA9IGJvdW5kKGNtKSAhPSBQYXNzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gcHJldlNoaWZ0O1xuICAgICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZG9uZVxuICB9XG5cbiAgZnVuY3Rpb24gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLnN0YXRlLmtleU1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkobmFtZSwgY20uc3RhdGUua2V5TWFwc1tpXSwgaGFuZGxlLCBjbSk7XG4gICAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxuICAgIH1cbiAgICByZXR1cm4gKGNtLm9wdGlvbnMuZXh0cmFLZXlzICYmIGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmV4dHJhS2V5cywgaGFuZGxlLCBjbSkpXG4gICAgICB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pXG4gIH1cblxuICAvLyBOb3RlIHRoYXQsIGRlc3BpdGUgdGhlIG5hbWUsIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIHRvIGNoZWNrXG4gIC8vIGZvciBib3VuZCBtb3VzZSBjbGlja3MuXG5cbiAgdmFyIHN0b3BTZXEgPSBuZXcgRGVsYXllZDtcblxuICBmdW5jdGlvbiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XG4gICAgdmFyIHNlcSA9IGNtLnN0YXRlLmtleVNlcTtcbiAgICBpZiAoc2VxKSB7XG4gICAgICBpZiAoaXNNb2RpZmllcktleShuYW1lKSkgeyByZXR1cm4gXCJoYW5kbGVkXCIgfVxuICAgICAgaWYgKC9cXCckLy50ZXN0KG5hbWUpKVxuICAgICAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG51bGw7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBzdG9wU2VxLnNldCg1MCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5rZXlTZXEgPT0gc2VxKSB7XG4gICAgICAgICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBudWxsO1xuICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IH1cbiAgICAgIGlmIChkaXNwYXRjaEtleUlubmVyKGNtLCBzZXEgKyBcIiBcIiArIG5hbWUsIGUsIGhhbmRsZSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZGlzcGF0Y2hLZXlJbm5lcihjbSwgbmFtZSwgZSwgaGFuZGxlKVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hLZXlJbm5lcihjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKTtcblxuICAgIGlmIChyZXN1bHQgPT0gXCJtdWx0aVwiKVxuICAgICAgeyBjbS5zdGF0ZS5rZXlTZXEgPSBuYW1lOyB9XG4gICAgaWYgKHJlc3VsdCA9PSBcImhhbmRsZWRcIilcbiAgICAgIHsgc2lnbmFsTGF0ZXIoY20sIFwia2V5SGFuZGxlZFwiLCBjbSwgbmFtZSwgZSk7IH1cblxuICAgIGlmIChyZXN1bHQgPT0gXCJoYW5kbGVkXCIgfHwgcmVzdWx0ID09IFwibXVsdGlcIikge1xuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHJlc3RhcnRCbGluayhjbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhcmVzdWx0XG4gIH1cblxuICAvLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5ZG93biBldmVudC5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5QmluZGluZyhjbSwgZSkge1xuICAgIHZhciBuYW1lID0ga2V5TmFtZShlLCB0cnVlKTtcbiAgICBpZiAoIW5hbWUpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChlLnNoaWZ0S2V5ICYmICFjbS5zdGF0ZS5rZXlTZXEpIHtcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xuICAgICAgLy8gdGhhdCwgc2VlIGlmIHRoZXJlIGlzIGEgY3Vyc29yLW1vdGlvbiBjb21tYW5kIChzdGFydGluZyB3aXRoXG4gICAgICAvLyAnZ28nKSBib3VuZCB0byB0aGUga2V5bmFtZSB3aXRob3V0ICdTaGlmdC0nLlxuICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcIlNoaWZ0LVwiICsgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXG4gICAgICAgICAgfHwgZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/IC9eZ29bQS1aXS8udGVzdChiKSA6IGIubW90aW9uKVxuICAgICAgICAgICAgICAgICB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpIH1cbiAgICAgICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpOyB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlwcmVzcyBldmVudFxuICBmdW5jdGlvbiBoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiJ1wiICsgY2ggKyBcIidcIiwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXG4gIH1cblxuICB2YXIgbGFzdFN0b3BwZWRLZXkgPSBudWxsO1xuICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0ICE9IGNtLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSkgeyByZXR1cm4gfVxuICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KHJvb3QoY20pKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgLy8gSUUgZG9lcyBzdHJhbmdlIHRoaW5ncyB3aXRoIGVzY2FwZS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExICYmIGUua2V5Q29kZSA9PSAyNykgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH1cbiAgICB2YXIgY29kZSA9IGUua2V5Q29kZTtcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5O1xuICAgIHZhciBoYW5kbGVkID0gaGFuZGxlS2V5QmluZGluZyhjbSwgZSk7XG4gICAgaWYgKHByZXN0bykge1xuICAgICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGw7XG4gICAgICAvLyBPcGVyYSBoYXMgbm8gY3V0IGV2ZW50Li4uIHdlIHRyeSB0byBhdCBsZWFzdCBjYXRjaCB0aGUga2V5IGNvbWJvXG4gICAgICBpZiAoIWhhbmRsZWQgJiYgY29kZSA9PSA4OCAmJiAhaGFzQ29weUV2ZW50ICYmIChtYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXkpKVxuICAgICAgICB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7IH1cbiAgICB9XG4gICAgaWYgKGdlY2tvICYmICFtYWMgJiYgIWhhbmRsZWQgJiYgY29kZSA9PSA0NiAmJiBlLnNoaWZ0S2V5ICYmICFlLmN0cmxLZXkgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQpXG4gICAgICB7IGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY3V0XCIpOyB9XG5cbiAgICAvLyBUdXJuIG1vdXNlIGludG8gY3Jvc3NoYWlyIHdoZW4gQWx0IGlzIGhlbGQgb24gTWFjLlxuICAgIGlmIChjb2RlID09IDE4ICYmICEvXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpXG4gICAgICB7IHNob3dDcm9zc0hhaXIoY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XG4gICAgdmFyIGxpbmVEaXYgPSBjbS5kaXNwbGF5LmxpbmVEaXY7XG4gICAgYWRkQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcblxuICAgIGZ1bmN0aW9uIHVwKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XG4gICAgICAgIHJtQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB1cCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlVcChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSAxNikgeyB0aGlzLmRvYy5zZWwuc2hpZnQgPSBmYWxzZTsgfVxuICAgIHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7IHJldHVybiB9XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgeyByZXR1cm4gfVxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLCBjaGFyQ29kZSA9IGUuY2hhckNvZGU7XG4gICAgaWYgKHByZXN0byAmJiBrZXlDb2RlID09IGxhc3RTdG9wcGVkS2V5KSB7bGFzdFN0b3BwZWRLZXkgPSBudWxsOyBlX3ByZXZlbnREZWZhdWx0KGUpOyByZXR1cm59XG4gICAgaWYgKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpICYmIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpKSB7IHJldHVybiB9XG4gICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSA9PSBudWxsID8ga2V5Q29kZSA6IGNoYXJDb2RlKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGZpcmUga2V5cHJlc3MgZXZlbnRzIGZvciBiYWNrc3BhY2VcbiAgICBpZiAoY2ggPT0gXCJcXHgwOFwiKSB7IHJldHVybiB9XG4gICAgaWYgKGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkpIHsgcmV0dXJuIH1cbiAgICBjbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSk7XG4gIH1cblxuICB2YXIgRE9VQkxFQ0xJQ0tfREVMQVkgPSA0MDA7XG5cbiAgdmFyIFBhc3RDbGljayA9IGZ1bmN0aW9uKHRpbWUsIHBvcywgYnV0dG9uKSB7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgfTtcblxuICBQYXN0Q2xpY2sucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodGltZSwgcG9zLCBidXR0b24pIHtcbiAgICByZXR1cm4gdGhpcy50aW1lICsgRE9VQkxFQ0xJQ0tfREVMQVkgPiB0aW1lICYmXG4gICAgICBjbXAocG9zLCB0aGlzLnBvcykgPT0gMCAmJiBidXR0b24gPT0gdGhpcy5idXR0b25cbiAgfTtcblxuICB2YXIgbGFzdENsaWNrLCBsYXN0RG91YmxlQ2xpY2s7XG4gIGZ1bmN0aW9uIGNsaWNrUmVwZWF0KHBvcywgYnV0dG9uKSB7XG4gICAgdmFyIG5vdyA9ICtuZXcgRGF0ZTtcbiAgICBpZiAobGFzdERvdWJsZUNsaWNrICYmIGxhc3REb3VibGVDbGljay5jb21wYXJlKG5vdywgcG9zLCBidXR0b24pKSB7XG4gICAgICBsYXN0Q2xpY2sgPSBsYXN0RG91YmxlQ2xpY2sgPSBudWxsO1xuICAgICAgcmV0dXJuIFwidHJpcGxlXCJcbiAgICB9IGVsc2UgaWYgKGxhc3RDbGljayAmJiBsYXN0Q2xpY2suY29tcGFyZShub3csIHBvcywgYnV0dG9uKSkge1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbmV3IFBhc3RDbGljayhub3csIHBvcywgYnV0dG9uKTtcbiAgICAgIGxhc3RDbGljayA9IG51bGw7XG4gICAgICByZXR1cm4gXCJkb3VibGVcIlxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2xpY2sgPSBuZXcgUGFzdENsaWNrKG5vdywgcG9zLCBidXR0b24pO1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgIHJldHVybiBcInNpbmdsZVwiXG4gICAgfVxuICB9XG5cbiAgLy8gQSBtb3VzZSBkb3duIGNhbiBiZSBhIHNpbmdsZSBjbGljaywgZG91YmxlIGNsaWNrLCB0cmlwbGUgY2xpY2ssXG4gIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiBkcmFnLCBzdGFydCBvZiB0ZXh0IGRyYWcsIG5ldyBjdXJzb3JcbiAgLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXG4gIC8vIG1pZGRsZS1jbGljay1wYXN0ZS4gT3IgaXQgbWlnaHQgYmUgYSBjbGljayBvbiBzb21ldGhpbmcgd2Ugc2hvdWxkXG4gIC8vIG5vdCBpbnRlcmZlcmUgd2l0aCwgc3VjaCBhcyBhIHNjcm9sbGJhciBvciB3aWRnZXQuXG4gIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGRpc3BsYXkuYWN0aXZlVG91Y2ggJiYgZGlzcGxheS5pbnB1dC5zdXBwb3J0c1RvdWNoKCkpIHsgcmV0dXJuIH1cbiAgICBkaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIGRpc3BsYXkuc2hpZnQgPSBlLnNoaWZ0S2V5O1xuXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHtcbiAgICAgIGlmICghd2Via2l0KSB7XG4gICAgICAgIC8vIEJyaWVmbHkgdHVybiBvZmYgZHJhZ2dhYmlsaXR5LCB0byBhbGxvdyB3aWRnZXRzIHRvIGRvXG4gICAgICAgIC8vIG5vcm1hbCBkcmFnZ2luZyB0aGluZ3MuXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9LCAxMDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjbGlja0luR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBidXR0b24gPSBlX2J1dHRvbihlKSwgcmVwZWF0ID0gcG9zID8gY2xpY2tSZXBlYXQocG9zLCBidXR0b24pIDogXCJzaW5nbGVcIjtcbiAgICB3aW4oY20pLmZvY3VzKCk7XG5cbiAgICAvLyAjMzI2MTogbWFrZSBzdXJlLCB0aGF0IHdlJ3JlIG5vdCBzdGFydGluZyBhIHNlY29uZCBzZWxlY3Rpb25cbiAgICBpZiAoYnV0dG9uID09IDEgJiYgY20uc3RhdGUuc2VsZWN0aW5nVGV4dClcbiAgICAgIHsgY20uc3RhdGUuc2VsZWN0aW5nVGV4dChlKTsgfVxuXG4gICAgaWYgKHBvcyAmJiBoYW5kbGVNYXBwZWRCdXR0b24oY20sIGJ1dHRvbiwgcG9zLCByZXBlYXQsIGUpKSB7IHJldHVybiB9XG5cbiAgICBpZiAoYnV0dG9uID09IDEpIHtcbiAgICAgIGlmIChwb3MpIHsgbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBlKTsgfVxuICAgICAgZWxzZSBpZiAoZV90YXJnZXQoZSkgPT0gZGlzcGxheS5zY3JvbGxlcikgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG4gICAgfSBlbHNlIGlmIChidXR0b24gPT0gMikge1xuICAgICAgaWYgKHBvcykgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBwb3MpOyB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApO1xuICAgIH0gZWxzZSBpZiAoYnV0dG9uID09IDMpIHtcbiAgICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykgeyBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7IH1cbiAgICAgIGVsc2UgeyBkZWxheUJsdXJFdmVudChjbSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNYXBwZWRCdXR0b24oY20sIGJ1dHRvbiwgcG9zLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgdmFyIG5hbWUgPSBcIkNsaWNrXCI7XG4gICAgaWYgKHJlcGVhdCA9PSBcImRvdWJsZVwiKSB7IG5hbWUgPSBcIkRvdWJsZVwiICsgbmFtZTsgfVxuICAgIGVsc2UgaWYgKHJlcGVhdCA9PSBcInRyaXBsZVwiKSB7IG5hbWUgPSBcIlRyaXBsZVwiICsgbmFtZTsgfVxuICAgIG5hbWUgPSAoYnV0dG9uID09IDEgPyBcIkxlZnRcIiA6IGJ1dHRvbiA9PSAyID8gXCJNaWRkbGVcIiA6IFwiUmlnaHRcIikgKyBuYW1lO1xuXG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCAgYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCksIGV2ZW50LCBmdW5jdGlvbiAoYm91bmQpIHtcbiAgICAgIGlmICh0eXBlb2YgYm91bmQgPT0gXCJzdHJpbmdcIikgeyBib3VuZCA9IGNvbW1hbmRzW2JvdW5kXTsgfVxuICAgICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7IH1cbiAgICAgICAgZG9uZSA9IGJvdW5kKGNtLCBwb3MpICE9IFBhc3M7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9uZVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCkge1xuICAgIHZhciBvcHRpb24gPSBjbS5nZXRPcHRpb24oXCJjb25maWd1cmVNb3VzZVwiKTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb24gPyBvcHRpb24oY20sIHJlcGVhdCwgZXZlbnQpIDoge307XG4gICAgaWYgKHZhbHVlLnVuaXQgPT0gbnVsbCkge1xuICAgICAgdmFyIHJlY3QgPSBjaHJvbWVPUyA/IGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50Lm1ldGFLZXkgOiBldmVudC5hbHRLZXk7XG4gICAgICB2YWx1ZS51bml0ID0gcmVjdCA/IFwicmVjdGFuZ2xlXCIgOiByZXBlYXQgPT0gXCJzaW5nbGVcIiA/IFwiY2hhclwiIDogcmVwZWF0ID09IFwiZG91YmxlXCIgPyBcIndvcmRcIiA6IFwibGluZVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUuZXh0ZW5kID09IG51bGwgfHwgY20uZG9jLmV4dGVuZCkgeyB2YWx1ZS5leHRlbmQgPSBjbS5kb2MuZXh0ZW5kIHx8IGV2ZW50LnNoaWZ0S2V5OyB9XG4gICAgaWYgKHZhbHVlLmFkZE5ldyA9PSBudWxsKSB7IHZhbHVlLmFkZE5ldyA9IG1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5OyB9XG4gICAgaWYgKHZhbHVlLm1vdmVPbkRyYWcgPT0gbnVsbCkgeyB2YWx1ZS5tb3ZlT25EcmFnID0gIShtYWMgPyBldmVudC5hbHRLZXkgOiBldmVudC5jdHJsS2V5KTsgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBldmVudCkge1xuICAgIGlmIChpZSkgeyBzZXRUaW1lb3V0KGJpbmQoZW5zdXJlRm9jdXMsIGNtKSwgMCk7IH1cbiAgICBlbHNlIHsgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQocm9vdChjbSkpOyB9XG5cbiAgICB2YXIgYmVoYXZpb3IgPSBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCk7XG5cbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbCwgY29udGFpbmVkO1xuICAgIGlmIChjbS5vcHRpb25zLmRyYWdEcm9wICYmIGRyYWdBbmREcm9wICYmICFjbS5pc1JlYWRPbmx5KCkgJiZcbiAgICAgICAgcmVwZWF0ID09IFwic2luZ2xlXCIgJiYgKGNvbnRhaW5lZCA9IHNlbC5jb250YWlucyhwb3MpKSA+IC0xICYmXG4gICAgICAgIChjbXAoKGNvbnRhaW5lZCA9IHNlbC5yYW5nZXNbY29udGFpbmVkXSkuZnJvbSgpLCBwb3MpIDwgMCB8fCBwb3MueFJlbCA+IDApICYmXG4gICAgICAgIChjbXAoY29udGFpbmVkLnRvKCksIHBvcykgPiAwIHx8IHBvcy54UmVsIDwgMCkpXG4gICAgICB7IGxlZnRCdXR0b25TdGFydERyYWcoY20sIGV2ZW50LCBwb3MsIGJlaGF2aW9yKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgbGVmdEJ1dHRvblNlbGVjdChjbSwgZXZlbnQsIHBvcywgYmVoYXZpb3IpOyB9XG4gIH1cblxuICAvLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcikge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbW92ZWQgPSBmYWxzZTtcbiAgICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZTsgfVxuICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZmFsc2U7XG4gICAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgICAgaWYgKGNtLmhhc0ZvY3VzKCkpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTsgfVxuICAgICAgICBlbHNlIHsgZGVsYXlCbHVyRXZlbnQoY20pOyB9XG4gICAgICB9XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcbiAgICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBkcmFnU3RhcnQpO1xuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcbiAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgaWYgKCFiZWhhdmlvci5hZGROZXcpXG4gICAgICAgICAgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBwb3MsIG51bGwsIG51bGwsIGJlaGF2aW9yLmV4dGVuZCk7IH1cbiAgICAgICAgLy8gV29yayBhcm91bmQgdW5leHBsYWluYWJsZSBmb2N1cyBwcm9ibGVtIGluIElFOSAoIzIxMjcpIGFuZCBDaHJvbWUgKCMzMDgxKVxuICAgICAgICBpZiAoKHdlYmtpdCAmJiAhc2FmYXJpKSB8fCBpZSAmJiBpZV92ZXJzaW9uID09IDkpXG4gICAgICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSk7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICBtb3ZlZCA9IG1vdmVkIHx8IE1hdGguYWJzKGV2ZW50LmNsaWVudFggLSBlMi5jbGllbnRYKSArIE1hdGguYWJzKGV2ZW50LmNsaWVudFkgLSBlMi5jbGllbnRZKSA+PSAxMDtcbiAgICB9O1xuICAgIHZhciBkcmFnU3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlZCA9IHRydWU7IH07XG4gICAgLy8gTGV0IHRoZSBkcmFnIGhhbmRsZXIgaGFuZGxlIHRoaXMuXG4gICAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7IH1cbiAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xuICAgIGRyYWdFbmQuY29weSA9ICFiZWhhdmlvci5tb3ZlT25EcmFnO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ0VuZCk7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZHJhZ1N0YXJ0KTtcbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZHJhZ0VuZCk7XG5cbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxuICAgIGlmIChkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2VGb3JVbml0KGNtLCBwb3MsIHVuaXQpIHtcbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIikgeyByZXR1cm4gbmV3IFJhbmdlKHBvcywgcG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJ3b3JkXCIpIHsgcmV0dXJuIGNtLmZpbmRXb3JkQXQocG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHsgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKSB9XG4gICAgdmFyIHJlc3VsdCA9IHVuaXQoY20sIHBvcyk7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHQuZnJvbSwgcmVzdWx0LnRvKVxuICB9XG5cbiAgLy8gTm9ybWFsIHNlbGVjdGlvbiwgYXMgb3Bwb3NlZCB0byB0ZXh0IGRyYWdnaW5nLlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBldmVudCwgc3RhcnQsIGJlaGF2aW9yKSB7XG4gICAgaWYgKGllKSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIGVfcHJldmVudERlZmF1bHQoZXZlbnQpO1xuXG4gICAgdmFyIG91clJhbmdlLCBvdXJJbmRleCwgc3RhcnRTZWwgPSBkb2Muc2VsLCByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXM7XG4gICAgaWYgKGJlaGF2aW9yLmFkZE5ldyAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBvdXJJbmRleCA9IGRvYy5zZWwuY29udGFpbnMoc3RhcnQpO1xuICAgICAgaWYgKG91ckluZGV4ID4gLTEpXG4gICAgICAgIHsgb3VyUmFuZ2UgPSByYW5nZXNbb3VySW5kZXhdOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXJSYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLnByaW1JbmRleDtcbiAgICB9XG5cbiAgICBpZiAoYmVoYXZpb3IudW5pdCA9PSBcInJlY3RhbmdsZVwiKSB7XG4gICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykgeyBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOyB9XG4gICAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZXZlbnQsIHRydWUsIHRydWUpO1xuICAgICAgb3VySW5kZXggPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ2VGb3JVbml0KGNtLCBzdGFydCwgYmVoYXZpb3IudW5pdCk7XG4gICAgICBpZiAoYmVoYXZpb3IuZXh0ZW5kKVxuICAgICAgICB7IG91clJhbmdlID0gZXh0ZW5kUmFuZ2Uob3VyUmFuZ2UsIHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCwgYmVoYXZpb3IuZXh0ZW5kKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG91clJhbmdlID0gcmFuZ2U7IH1cbiAgICB9XG5cbiAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykge1xuICAgICAgb3VySW5kZXggPSAwO1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbb3VyUmFuZ2VdLCAwKSwgc2VsX21vdXNlKTtcbiAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcbiAgICB9IGVsc2UgaWYgKG91ckluZGV4ID09IC0xKSB7XG4gICAgICBvdXJJbmRleCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcIiptb3VzZVwifSk7XG4gICAgfSBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID4gMSAmJiByYW5nZXNbb3VySW5kZXhdLmVtcHR5KCkgJiYgYmVoYXZpb3IudW5pdCA9PSBcImNoYXJcIiAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCArIDEpKSwgMCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XG4gICAgZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKSB7XG4gICAgICBpZiAoY21wKGxhc3RQb3MsIHBvcykgPT0gMCkgeyByZXR1cm4gfVxuICAgICAgbGFzdFBvcyA9IHBvcztcblxuICAgICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICB2YXIgcmFuZ2VzID0gW10sIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBwb3NDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQsIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4oc3RhcnRDb2wsIHBvc0NvbCksIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnRDb2wsIHBvc0NvbCk7XG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XG4gICAgICAgICAgICAgbGluZSA8PSBlbmQ7IGxpbmUrKykge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZ2V0TGluZShkb2MsIGxpbmUpLnRleHQsIGxlZnRQb3MgPSBmaW5kQ29sdW1uKHRleHQsIGxlZnQsIHRhYlNpemUpO1xuICAgICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxuICAgICAgICAgICAgeyByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgbGVmdFBvcykpKTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcbiAgICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKTsgfVxuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcyksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFwiKm1vdXNlXCIsIHNjcm9sbDogZmFsc2V9KTtcbiAgICAgICAgY20uc2Nyb2xsSW50b1ZpZXcocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbGRSYW5nZSA9IG91clJhbmdlO1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZUZvclVuaXQoY20sIHBvcywgYmVoYXZpb3IudW5pdCk7XG4gICAgICAgIHZhciBhbmNob3IgPSBvbGRSYW5nZS5hbmNob3IsIGhlYWQ7XG4gICAgICAgIGlmIChjbXAocmFuZ2UuYW5jaG9yLCBhbmNob3IpID4gMCkge1xuICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlLmFuY2hvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvcjtcbiAgICAgICAgICBhbmNob3IgPSBtYXhQb3Mob2xkUmFuZ2UudG8oKSwgcmFuZ2UuaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlcyQxID0gc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgICByYW5nZXMkMVtvdXJJbmRleF0gPSBiaWRpU2ltcGxpZnkoY20sIG5ldyBSYW5nZShjbGlwUG9zKGRvYywgYW5jaG9yKSwgaGVhZCkpO1xuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcyQxLCBvdXJJbmRleCksIHNlbF9tb3VzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gVXNlZCB0byBlbnN1cmUgdGltZW91dCByZS10cmllcyBkb24ndCBmaXJlIHdoZW4gYW5vdGhlciBleHRlbmRcbiAgICAvLyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWUgKGNsZWFyVGltZW91dCBpc24ndCByZWxpYWJsZSAtLSBhdFxuICAgIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcbiAgICAvLyBpZiB0aGUgY2xlYXIgaGFwcGVucyBhZnRlciB0aGVpciBzY2hlZHVsZWQgZmlyaW5nIHRpbWUpLlxuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dGVuZChlKSB7XG4gICAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXI7XG4gICAgICB2YXIgY3VyID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCBiZWhhdmlvci51bml0ID09IFwicmVjdGFuZ2xlXCIpO1xuICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XG4gICAgICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KHJvb3QoY20pKTtcbiAgICAgICAgZXh0ZW5kVG8oY3VyKTtcbiAgICAgICAgdmFyIHZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jKTtcbiAgICAgICAgaWYgKGN1ci5saW5lID49IHZpc2libGUudG8gfHwgY3VyLmxpbmUgPCB2aXNpYmxlLmZyb20pXG4gICAgICAgICAgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge2lmIChjb3VudGVyID09IGN1ckNvdW50KSB7IGV4dGVuZChlKTsgfX0pLCAxNTApOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3V0c2lkZSA9IGUuY2xpZW50WSA8IGVkaXRvclNpemUudG9wID8gLTIwIDogZS5jbGllbnRZID4gZWRpdG9yU2l6ZS5ib3R0b20gPyAyMCA6IDA7XG4gICAgICAgIGlmIChvdXRzaWRlKSB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNvdW50ZXIgIT0gY3VyQ291bnQpIHsgcmV0dXJuIH1cbiAgICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCArPSBvdXRzaWRlO1xuICAgICAgICAgIGV4dGVuZChlKTtcbiAgICAgICAgfSksIDUwKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbmUoZSkge1xuICAgICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IGZhbHNlO1xuICAgICAgY291bnRlciA9IEluZmluaXR5O1xuICAgICAgLy8gSWYgZSBpcyBudWxsIG9yIHVuZGVmaW5lZCB3ZSBpbnRlcnByZXQgdGhpcyBhcyBzb21lb25lIHRyeWluZ1xuICAgICAgLy8gdG8gZXhwbGljaXRseSBjYW5jZWwgdGhlIHNlbGVjdGlvbiByYXRoZXIgdGhhbiB0aGUgdXNlclxuICAgICAgLy8gbGV0dGluZyBnbyBvZiB0aGUgbW91c2UgYnV0dG9uLlxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgfVxuICAgICAgb2ZmKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgICAgIGRvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBtb3ZlID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUuYnV0dG9ucyA9PT0gMCB8fCAhZV9idXR0b24oZSkpIHsgZG9uZShlKTsgfVxuICAgICAgZWxzZSB7IGV4dGVuZChlKTsgfVxuICAgIH0pO1xuICAgIHZhciB1cCA9IG9wZXJhdGlvbihjbSwgZG9uZSk7XG4gICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IHVwO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiBtb3VzZS1zZWxlY3RpbmcgdG8gYWRqdXN0IHRoZSBhbmNob3IgdG8gdGhlIHByb3BlciBzaWRlXG4gIC8vIG9mIGEgYmlkaSBqdW1wIGRlcGVuZGluZyBvbiB0aGUgdmlzdWFsIHBvc2l0aW9uIG9mIHRoZSBoZWFkLlxuICBmdW5jdGlvbiBiaWRpU2ltcGxpZnkoY20sIHJhbmdlKSB7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcjtcbiAgICB2YXIgaGVhZCA9IHJhbmdlLmhlYWQ7XG4gICAgdmFyIGFuY2hvckxpbmUgPSBnZXRMaW5lKGNtLmRvYywgYW5jaG9yLmxpbmUpO1xuICAgIGlmIChjbXAoYW5jaG9yLCBoZWFkKSA9PSAwICYmIGFuY2hvci5zdGlja3kgPT0gaGVhZC5zdGlja3kpIHsgcmV0dXJuIHJhbmdlIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihhbmNob3JMaW5lKTtcbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiByYW5nZSB9XG4gICAgdmFyIGluZGV4ID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgYW5jaG9yLmNoLCBhbmNob3Iuc3RpY2t5KSwgcGFydCA9IG9yZGVyW2luZGV4XTtcbiAgICBpZiAocGFydC5mcm9tICE9IGFuY2hvci5jaCAmJiBwYXJ0LnRvICE9IGFuY2hvci5jaCkgeyByZXR1cm4gcmFuZ2UgfVxuICAgIHZhciBib3VuZGFyeSA9IGluZGV4ICsgKChwYXJ0LmZyb20gPT0gYW5jaG9yLmNoKSA9PSAocGFydC5sZXZlbCAhPSAxKSA/IDAgOiAxKTtcbiAgICBpZiAoYm91bmRhcnkgPT0gMCB8fCBib3VuZGFyeSA9PSBvcmRlci5sZW5ndGgpIHsgcmV0dXJuIHJhbmdlIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIHJlbGF0aXZlIHZpc3VhbCBwb3NpdGlvbiBvZiB0aGUgaGVhZCBjb21wYXJlZCB0byB0aGVcbiAgICAvLyBhbmNob3IgKDwwIGlzIHRvIHRoZSBsZWZ0LCA+MCB0byB0aGUgcmlnaHQpXG4gICAgdmFyIGxlZnRTaWRlO1xuICAgIGlmIChoZWFkLmxpbmUgIT0gYW5jaG9yLmxpbmUpIHtcbiAgICAgIGxlZnRTaWRlID0gKGhlYWQubGluZSAtIGFuY2hvci5saW5lKSAqIChjbS5kb2MuZGlyZWN0aW9uID09IFwibHRyXCIgPyAxIDogLTEpID4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhlYWRJbmRleCA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGhlYWQuY2gsIGhlYWQuc3RpY2t5KTtcbiAgICAgIHZhciBkaXIgPSBoZWFkSW5kZXggLSBpbmRleCB8fCAoaGVhZC5jaCAtIGFuY2hvci5jaCkgKiAocGFydC5sZXZlbCA9PSAxID8gLTEgOiAxKTtcbiAgICAgIGlmIChoZWFkSW5kZXggPT0gYm91bmRhcnkgLSAxIHx8IGhlYWRJbmRleCA9PSBib3VuZGFyeSlcbiAgICAgICAgeyBsZWZ0U2lkZSA9IGRpciA8IDA7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBsZWZ0U2lkZSA9IGRpciA+IDA7IH1cbiAgICB9XG5cbiAgICB2YXIgdXNlUGFydCA9IG9yZGVyW2JvdW5kYXJ5ICsgKGxlZnRTaWRlID8gLTEgOiAwKV07XG4gICAgdmFyIGZyb20gPSBsZWZ0U2lkZSA9PSAodXNlUGFydC5sZXZlbCA9PSAxKTtcbiAgICB2YXIgY2ggPSBmcm9tID8gdXNlUGFydC5mcm9tIDogdXNlUGFydC50bywgc3RpY2t5ID0gZnJvbSA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgcmV0dXJuIGFuY2hvci5jaCA9PSBjaCAmJiBhbmNob3Iuc3RpY2t5ID09IHN0aWNreSA/IHJhbmdlIDogbmV3IFJhbmdlKG5ldyBQb3MoYW5jaG9yLmxpbmUsIGNoLCBzdGlja3kpLCBoZWFkKVxuICB9XG5cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXZlbnQgaGFwcGVuZWQgaW4gdGhlIGd1dHRlciwgYW5kIGZpcmVzIHRoZVxuICAvLyBoYW5kbGVycyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gIGZ1bmN0aW9uIGd1dHRlckV2ZW50KGNtLCBlLCB0eXBlLCBwcmV2ZW50KSB7XG4gICAgdmFyIG1YLCBtWTtcbiAgICBpZiAoZS50b3VjaGVzKSB7XG4gICAgICBtWCA9IGUudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgbVkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHsgbVggPSBlLmNsaWVudFg7IG1ZID0gZS5jbGllbnRZOyB9XG4gICAgICBjYXRjaChlJDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgaWYgKG1YID49IE1hdGguZmxvb3IoY20uZGlzcGxheS5ndXR0ZXJzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChwcmV2ZW50KSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICB2YXIgbGluZUJveCA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChtWSA+IGxpbmVCb3guYm90dG9tIHx8ICFoYXNIYW5kbGVyKGNtLCB0eXBlKSkgeyByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIH1cbiAgICBtWSAtPSBsaW5lQm94LnRvcCAtIGRpc3BsYXkudmlld09mZnNldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGcgPSBkaXNwbGF5Lmd1dHRlcnMuY2hpbGROb2Rlc1tpXTtcbiAgICAgIGlmIChnICYmIGcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgPj0gbVgpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lQXRIZWlnaHQoY20uZG9jLCBtWSk7XG4gICAgICAgIHZhciBndXR0ZXIgPSBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzW2ldO1xuICAgICAgICBzaWduYWwoY20sIHR5cGUsIGNtLCBsaW5lLCBndXR0ZXIuY2xhc3NOYW1lLCBlKTtcbiAgICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsaWNrSW5HdXR0ZXIoY20sIGUpIHtcbiAgICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFwiZ3V0dGVyQ2xpY2tcIiwgdHJ1ZSlcbiAgfVxuXG4gIC8vIENPTlRFWFQgTUVOVSBIQU5ETElOR1xuXG4gIC8vIFRvIG1ha2UgdGhlIGNvbnRleHQgbWVudSB3b3JrLCB3ZSBuZWVkIHRvIGJyaWVmbHkgdW5oaWRlIHRoZVxuICAvLyB0ZXh0YXJlYSAobWFraW5nIGl0IGFzIHVub2J0cnVzaXZlIGFzIHBvc3NpYmxlKSB0byBsZXQgdGhlXG4gIC8vIHJpZ2h0LWNsaWNrIHRha2UgZWZmZWN0IG9uIGl0LlxuICBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGNtLCBlKSB7XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUsIFwiY29udGV4dG1lbnVcIikpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWNhcHR1cmVSaWdodENsaWNrKSB7IGNtLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShlKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkge1xuICAgIGlmICghaGFzSGFuZGxlcihjbSwgXCJndXR0ZXJDb250ZXh0TWVudVwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXCJndXR0ZXJDb250ZXh0TWVudVwiLCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRoZW1lQ2hhbmdlZChjbSkge1xuICAgIGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgPSBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lLnJlcGxhY2UoL1xccypjbS1zLVxcUysvZywgXCJcIikgK1xuICAgICAgY20ub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXHMpXFxzKi9nLCBcIiBjbS1zLVwiKTtcbiAgICBjbGVhckNhY2hlcyhjbSk7XG4gIH1cblxuICB2YXIgSW5pdCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXCJDb2RlTWlycm9yLkluaXRcIn19O1xuXG4gIHZhciBkZWZhdWx0cyA9IHt9O1xuICB2YXIgb3B0aW9uSGFuZGxlcnMgPSB7fTtcblxuICBmdW5jdGlvbiBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IpIHtcbiAgICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzO1xuXG4gICAgZnVuY3Rpb24gb3B0aW9uKG5hbWUsIGRlZmx0LCBoYW5kbGUsIG5vdE9uSW5pdCkge1xuICAgICAgQ29kZU1pcnJvci5kZWZhdWx0c1tuYW1lXSA9IGRlZmx0O1xuICAgICAgaWYgKGhhbmRsZSkgeyBvcHRpb25IYW5kbGVyc1tuYW1lXSA9XG4gICAgICAgIG5vdE9uSW5pdCA/IGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtpZiAob2xkICE9IEluaXQpIHsgaGFuZGxlKGNtLCB2YWwsIG9sZCk7IH19IDogaGFuZGxlOyB9XG4gICAgfVxuXG4gICAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24gPSBvcHRpb247XG5cbiAgICAvLyBQYXNzZWQgdG8gb3B0aW9uIGhhbmRsZXJzIHdoZW4gdGhlcmUgaXMgbm8gb2xkIHZhbHVlLlxuICAgIENvZGVNaXJyb3IuSW5pdCA9IEluaXQ7XG5cbiAgICAvLyBUaGVzZSB0d28gYXJlLCBvbiBpbml0LCBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3IgYmVjYXVzZSB0aGV5XG4gICAgLy8gaGF2ZSB0byBiZSBpbml0aWFsaXplZCBiZWZvcmUgdGhlIGVkaXRvciBjYW4gc3RhcnQgYXQgYWxsLlxuICAgIG9wdGlvbihcInZhbHVlXCIsIFwiXCIsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5zZXRWYWx1ZSh2YWwpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJtb2RlXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kb2MubW9kZU9wdGlvbiA9IHZhbDtcbiAgICAgIGxvYWRNb2RlKGNtKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIG9wdGlvbihcImluZGVudFVuaXRcIiwgMiwgbG9hZE1vZGUsIHRydWUpO1xuICAgIG9wdGlvbihcImluZGVudFdpdGhUYWJzXCIsIGZhbHNlKTtcbiAgICBvcHRpb24oXCJzbWFydEluZGVudFwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJ0YWJTaXplXCIsIDQsIGZ1bmN0aW9uIChjbSkge1xuICAgICAgcmVzZXRNb2RlU3RhdGUoY20pO1xuICAgICAgY2xlYXJDYWNoZXMoY20pO1xuICAgICAgcmVnQ2hhbmdlKGNtKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIG9wdGlvbihcImxpbmVTZXBhcmF0b3JcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRvYy5saW5lU2VwID0gdmFsO1xuICAgICAgaWYgKCF2YWwpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBuZXdCcmVha3MgPSBbXSwgbGluZU5vID0gY20uZG9jLmZpcnN0O1xuICAgICAgY20uZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgZm9yICh2YXIgcG9zID0gMDs7KSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gbGluZS50ZXh0LmluZGV4T2YodmFsLCBwb3MpO1xuICAgICAgICAgIGlmIChmb3VuZCA9PSAtMSkgeyBicmVhayB9XG4gICAgICAgICAgcG9zID0gZm91bmQgKyB2YWwubGVuZ3RoO1xuICAgICAgICAgIG5ld0JyZWFrcy5wdXNoKFBvcyhsaW5lTm8sIGZvdW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZU5vKys7XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSBuZXdCcmVha3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgdmFsLCBuZXdCcmVha3NbaV0sIFBvcyhuZXdCcmVha3NbaV0ubGluZSwgbmV3QnJlYWtzW2ldLmNoICsgdmFsLmxlbmd0aCkpOyB9XG4gICAgfSk7XG4gICAgb3B0aW9uKFwic3BlY2lhbENoYXJzXCIsIC9bXFx1MDAwMC1cXHUwMDFmXFx1MDA3Zi1cXHUwMDlmXFx1MDBhZFxcdTA2MWNcXHUyMDBiXFx1MjAwZVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdTIwMmRcXHUyMDJlXFx1MjA2NlxcdTIwNjdcXHUyMDY5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY10vZywgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xuICAgICAgY20uc3RhdGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cCh2YWwuc291cmNlICsgKHZhbC50ZXN0KFwiXFx0XCIpID8gXCJcIiA6IFwifFxcdFwiKSwgXCJnXCIpO1xuICAgICAgaWYgKG9sZCAhPSBJbml0KSB7IGNtLnJlZnJlc2goKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIiwgZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVmcmVzaCgpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJlbGVjdHJpY0NoYXJzXCIsIHRydWUpO1xuICAgIG9wdGlvbihcImlucHV0U3R5bGVcIiwgbW9iaWxlID8gXCJjb250ZW50ZWRpdGFibGVcIiA6IFwidGV4dGFyZWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclwiKSAvLyBGSVhNRVxuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcInNwZWxsY2hlY2tcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuc3BlbGxjaGVjayA9IHZhbDsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiYXV0b2NvcnJlY3RcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NvcnJlY3QgPSB2YWw7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcImF1dG9jYXBpdGFsaXplXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLmF1dG9jYXBpdGFsaXplID0gdmFsOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJydGxNb3ZlVmlzdWFsbHlcIiwgIXdpbmRvd3MpO1xuICAgIG9wdGlvbihcIndob2xlTGluZVVwZGF0ZUJlZm9yZVwiLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInRoZW1lXCIsIFwiZGVmYXVsdFwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHRoZW1lQ2hhbmdlZChjbSk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJrZXlNYXBcIiwgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtcbiAgICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbCk7XG4gICAgICB2YXIgcHJldiA9IG9sZCAhPSBJbml0ICYmIGdldEtleU1hcChvbGQpO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi5kZXRhY2gpIHsgcHJldi5kZXRhY2goY20sIG5leHQpOyB9XG4gICAgICBpZiAobmV4dC5hdHRhY2gpIHsgbmV4dC5hdHRhY2goY20sIHByZXYgfHwgbnVsbCk7IH1cbiAgICB9KTtcbiAgICBvcHRpb24oXCJleHRyYUtleXNcIiwgbnVsbCk7XG4gICAgb3B0aW9uKFwiY29uZmlndXJlTW91c2VcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJsaW5lV3JhcHBpbmdcIiwgZmFsc2UsIHdyYXBwaW5nQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZ3V0dGVyc1wiLCBbXSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKHZhbCwgY20ub3B0aW9ucy5saW5lTnVtYmVycyk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJmaXhlZEd1dHRlclwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSB2YWwgPyBjb21wZW5zYXRlRm9ySFNjcm9sbChjbS5kaXNwbGF5KSArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgY20ucmVmcmVzaCgpO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJzY3JvbGxiYXJTdHlsZVwiLCBcIm5hdGl2ZVwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIGluaXRTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20pO1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKTtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGNtLmRvYy5zY3JvbGxMZWZ0KTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyc1wiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKGNtLm9wdGlvbnMuZ3V0dGVycywgdmFsKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImZpcnN0TGluZU51bWJlclwiLCAxLCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsIGZ1bmN0aW9uIChpbnRlZ2VyKSB7IHJldHVybiBpbnRlZ2VyOyB9LCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZ1wiLCBmYWxzZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lV2lzZUNvcHlDdXRcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGFzdGVMaW5lc1BlclNlbGVjdGlvblwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzZWxlY3Rpb25zTWF5VG91Y2hcIiwgZmFsc2UpO1xuXG4gICAgb3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBpZiAodmFsID09IFwibm9jdXJzb3JcIikge1xuICAgICAgICBvbkJsdXIoY20pO1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJzY3JlZW5SZWFkZXJMYWJlbFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgdmFsID0gKHZhbCA9PT0gJycpID8gbnVsbCA6IHZhbDtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJkaXNhYmxlSW5wdXRcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7aWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpOyB9fSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZHJhZ0Ryb3BcIiwgdHJ1ZSwgZHJhZ0Ryb3BDaGFuZ2VkKTtcbiAgICBvcHRpb24oXCJhbGxvd0Ryb3BGaWxlVHlwZXNcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJjdXJzb3JCbGlua1JhdGVcIiwgNTMwKTtcbiAgICBvcHRpb24oXCJjdXJzb3JTY3JvbGxNYXJnaW5cIiwgMCk7XG4gICAgb3B0aW9uKFwiY3Vyc29ySGVpZ2h0XCIsIDEsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVwiLCB0cnVlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuICAgIG9wdGlvbihcIndvcmtUaW1lXCIsIDEwMCk7XG4gICAgb3B0aW9uKFwid29ya0RlbGF5XCIsIDEwMCk7XG4gICAgb3B0aW9uKFwiZmxhdHRlblNwYW5zXCIsIHRydWUsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJhZGRNb2RlQ2xhc3NcIiwgZmFsc2UsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJwb2xsSW50ZXJ2YWxcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJ1bmRvRGVwdGhcIiwgMjAwLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdmFsOyB9KTtcbiAgICBvcHRpb24oXCJoaXN0b3J5RXZlbnREZWxheVwiLCAxMjUwKTtcbiAgICBvcHRpb24oXCJ2aWV3cG9ydE1hcmdpblwiLCAxMCwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcIm1heEhpZ2hsaWdodExlbmd0aFwiLCAxMDAwMCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcIm1vdmVJbnB1dFdpdGhDdXJzb3JcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGlmICghdmFsKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpOyB9XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJ0YWJpbmRleFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4ID0gdmFsIHx8IFwiXCI7IH0pO1xuICAgIG9wdGlvbihcImF1dG9mb2N1c1wiLCBudWxsKTtcbiAgICBvcHRpb24oXCJkaXJlY3Rpb25cIiwgXCJsdHJcIiwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRvYy5zZXREaXJlY3Rpb24odmFsKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGhyYXNlc1wiLCBudWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWdEcm9wQ2hhbmdlZChjbSwgdmFsdWUsIG9sZCkge1xuICAgIHZhciB3YXNPbiA9IG9sZCAmJiBvbGQgIT0gSW5pdDtcbiAgICBpZiAoIXZhbHVlICE9ICF3YXNPbikge1xuICAgICAgdmFyIGZ1bmNzID0gY20uZGlzcGxheS5kcmFnRnVuY3Rpb25zO1xuICAgICAgdmFyIHRvZ2dsZSA9IHZhbHVlID8gb24gOiBvZmY7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZnVuY3Muc3RhcnQpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2VudGVyXCIsIGZ1bmNzLmVudGVyKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdvdmVyXCIsIGZ1bmNzLm92ZXIpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2xlYXZlXCIsIGZ1bmNzLmxlYXZlKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZnVuY3MuZHJvcCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBpbmdDaGFuZ2VkKGNtKSB7XG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci13cmFwXCIpO1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IFwiXCI7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICBmaW5kTWF4TGluZShjbSk7XG4gICAgfVxuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlU2Nyb2xsYmFycyhjbSk7IH0sIDEwMCk7XG4gIH1cblxuICAvLyBBIENvZGVNaXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50cyBhbiBlZGl0b3IuIFRoaXMgaXMgdGhlIG9iamVjdFxuICAvLyB0aGF0IHVzZXIgY29kZSBpcyB1c3VhbGx5IGRlYWxpbmcgd2l0aC5cblxuICBmdW5jdGlvbiBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvcikpIHsgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcbiAgICAvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIG9wdGlvbnMgYmFzZWQgb24gZ2l2ZW4gdmFsdWVzIGFuZCBkZWZhdWx0cy5cbiAgICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSk7XG5cbiAgICB2YXIgZG9jID0gb3B0aW9ucy52YWx1ZTtcbiAgICBpZiAodHlwZW9mIGRvYyA9PSBcInN0cmluZ1wiKSB7IGRvYyA9IG5ldyBEb2MoZG9jLCBvcHRpb25zLm1vZGUsIG51bGwsIG9wdGlvbnMubGluZVNlcGFyYXRvciwgb3B0aW9ucy5kaXJlY3Rpb24pOyB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5tb2RlKSB7IGRvYy5tb2RlT3B0aW9uID0gb3B0aW9ucy5tb2RlOyB9XG4gICAgdGhpcy5kb2MgPSBkb2M7XG5cbiAgICB2YXIgaW5wdXQgPSBuZXcgQ29kZU1pcnJvci5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO1xuICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5ID0gbmV3IERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQsIG9wdGlvbnMpO1xuICAgIGRpc3BsYXkud3JhcHBlci5Db2RlTWlycm9yID0gdGhpcztcbiAgICB0aGVtZUNoYW5nZWQodGhpcyk7XG4gICAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgKz0gXCIgQ29kZU1pcnJvci13cmFwXCI7IH1cbiAgICBpbml0U2Nyb2xsYmFycyh0aGlzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBrZXlNYXBzOiBbXSwgIC8vIHN0b3JlcyBtYXBzIGFkZGVkIGJ5IGFkZEtleU1hcFxuICAgICAgb3ZlcmxheXM6IFtdLCAvLyBoaWdobGlnaHRpbmcgb3ZlcmxheXMsIGFzIGFkZGVkIGJ5IGFkZE92ZXJsYXlcbiAgICAgIG1vZGVHZW46IDAsICAgLy8gYnVtcGVkIHdoZW4gbW9kZS9vdmVybGF5IGNoYW5nZXMsIHVzZWQgdG8gaW52YWxpZGF0ZSBoaWdobGlnaHRpbmcgaW5mb1xuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5aW5nQmx1ckV2ZW50OiBmYWxzZSxcbiAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NFZGl0czogZmFsc2UsIC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXG4gICAgICBwYXN0ZUluY29taW5nOiAtMSwgY3V0SW5jb21pbmc6IC0xLCAvLyBoZWxwIHJlY29nbml6ZSBwYXN0ZS9jdXQgZWRpdHMgaW4gaW5wdXQucG9sbFxuICAgICAgc2VsZWN0aW5nVGV4dDogZmFsc2UsXG4gICAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0OiBuZXcgRGVsYXllZCgpLCAvLyBzdG9yZXMgaGlnaGxpZ2h0IHdvcmtlciB0aW1lb3V0XG4gICAgICBrZXlTZXE6IG51bGwsICAvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxuICAgICAgc3BlY2lhbENoYXJzOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfVxuXG4gICAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcbiAgICAvLyBvbiBvdXIgaGlkZGVuIHRleHRhcmVhIG9uIHJlbG9hZFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApOyB9XG5cbiAgICByZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcyk7XG4gICAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKTtcblxuICAgIHN0YXJ0T3BlcmF0aW9uKHRoaXMpO1xuICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xuXG4gICAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCB0aGlzLmhhc0ZvY3VzKCkpXG4gICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyQxLmhhc0ZvY3VzKCkgJiYgIXRoaXMkMS5zdGF0ZS5mb2N1c2VkKSB7IG9uRm9jdXModGhpcyQxKTsgfVxuICAgICAgfSwgMjApOyB9XG4gICAgZWxzZVxuICAgICAgeyBvbkJsdXIodGhpcyk7IH1cblxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25IYW5kbGVycykgeyBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgb3B0aW9uSGFuZGxlcnNbb3B0XSh0aGlzLCBvcHRpb25zW29wdF0sIEluaXQpOyB9IH1cbiAgICBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5maW5pc2hJbml0KSB7IG9wdGlvbnMuZmluaXNoSW5pdCh0aGlzKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpKSB7IGluaXRIb29rc1tpXSh0aGlzKTsgfVxuICAgIGVuZE9wZXJhdGlvbih0aGlzKTtcbiAgICAvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxuICAgIC8vIG1lYXN1cmluZyBvbiBsaW5lIHdyYXBwaW5nIGJvdW5kYXJpZXMuXG4gICAgaWYgKHdlYmtpdCAmJiBvcHRpb25zLmxpbmVXcmFwcGluZyAmJlxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcIm9wdGltaXplbGVnaWJpbGl0eVwiKVxuICAgICAgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFwiYXV0b1wiOyB9XG4gIH1cblxuICAvLyBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gIENvZGVNaXJyb3IuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgLy8gRnVuY3Rpb25zIHRvIHJ1biB3aGVuIG9wdGlvbnMgYXJlIGNoYW5nZWQuXG4gIENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnMgPSBvcHRpb25IYW5kbGVycztcblxuICAvLyBBdHRhY2ggdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB3aGVuIGluaXRpYWxpemluZyB0aGUgZWRpdG9yXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICBvbihkLnNjcm9sbGVyLCBcIm1vdXNlZG93blwiLCBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKSk7XG4gICAgLy8gT2xkZXIgSUUncyB3aWxsIG5vdCBmaXJlIGEgc2Vjb25kIG1vdXNlZG93biBmb3IgYSBkb3VibGUgY2xpY2tcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKVxuICAgICAgeyBvbihkLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICAgICAgaWYgKCFwb3MgfHwgY2xpY2tJbkd1dHRlcihjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgeyByZXR1cm4gfVxuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgd29yZC5hbmNob3IsIHdvcmQuaGVhZCk7XG4gICAgICB9KSk7IH1cbiAgICBlbHNlXG4gICAgICB7IG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpOyB9KTsgfVxuICAgIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBjb250ZXh0bWVudSAqYWZ0ZXIqIG9wZW5pbmcgdGhlIG1lbnUsIGF0XG4gICAgLy8gd2hpY2ggcG9pbnQgd2UgY2FuJ3QgbWVzcyB3aXRoIGl0IGFueW1vcmUuIENvbnRleHQgbWVudSBpc1xuICAgIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQ29udGV4dE1lbnUoY20sIGUpOyB9KTtcbiAgICBvbihkLmlucHV0LmdldEZpZWxkKCksIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZC5zY3JvbGxlci5jb250YWlucyhlLnRhcmdldCkpIHsgb25Db250ZXh0TWVudShjbSwgZSk7IH1cbiAgICB9KTtcblxuICAgIC8vIFVzZWQgdG8gc3VwcHJlc3MgbW91c2UgZXZlbnQgaGFuZGxpbmcgd2hlbiBhIHRvdWNoIGhhcHBlbnNcbiAgICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0ge2VuZDogMH07XG4gICAgZnVuY3Rpb24gZmluaXNoVG91Y2goKSB7XG4gICAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xuICAgICAgICB0b3VjaEZpbmlzaGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkLmFjdGl2ZVRvdWNoID0gbnVsbDsgfSwgMTAwMCk7XG4gICAgICAgIHByZXZUb3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICAgIHByZXZUb3VjaC5lbmQgPSArbmV3IERhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPSAxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICByZXR1cm4gdG91Y2gucmFkaXVzWCA8PSAxICYmIHRvdWNoLnJhZGl1c1kgPD0gMVxuICAgIH1cbiAgICBmdW5jdGlvbiBmYXJBd2F5KHRvdWNoLCBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmxlZnQgPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICB2YXIgZHggPSBvdGhlci5sZWZ0IC0gdG91Y2gubGVmdCwgZHkgPSBvdGhlci50b3AgLSB0b3VjaC50b3A7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPiAyMCAqIDIwXG4gICAgfVxuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkgJiYgIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSAmJiAhY2xpY2tJbkd1dHRlcihjbSwgZSkpIHtcbiAgICAgICAgZC5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpO1xuICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlO1xuICAgICAgICBkLmFjdGl2ZVRvdWNoID0ge3N0YXJ0OiBub3csIG1vdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBub3cgLSBwcmV2VG91Y2guZW5kIDw9IDMwMCA/IHByZXZUb3VjaCA6IG51bGx9O1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC5sZWZ0ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgIGQuYWN0aXZlVG91Y2gudG9wID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIHsgZC5hY3RpdmVUb3VjaC5tb3ZlZCA9IHRydWU7IH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xuICAgICAgaWYgKHRvdWNoICYmICFldmVudEluV2lkZ2V0KGQsIGUpICYmIHRvdWNoLmxlZnQgIT0gbnVsbCAmJlxuICAgICAgICAgICF0b3VjaC5tb3ZlZCAmJiBuZXcgRGF0ZSAtIHRvdWNoLnN0YXJ0IDwgMzAwKSB7XG4gICAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKGQuYWN0aXZlVG91Y2gsIFwicGFnZVwiKSwgcmFuZ2U7XG4gICAgICAgIGlmICghdG91Y2gucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2KSkgLy8gU2luZ2xlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpOyB9XG4gICAgICAgIGVsc2UgaWYgKCF0b3VjaC5wcmV2LnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldi5wcmV2KSkgLy8gRG91YmxlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcyk7IH1cbiAgICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTsgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkKTtcbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaFRvdWNoKCk7XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaGNhbmNlbFwiLCBmaW5pc2hUb3VjaCk7XG5cbiAgICAvLyBTeW5jIHNjcm9sbGluZyBiZXR3ZWVuIGZha2Ugc2Nyb2xsYmFycyBhbmQgcmVhbCBzY3JvbGxhYmxlXG4gICAgLy8gYXJlYSwgZW5zdXJlIHZpZXdwb3J0IGlzIHVwZGF0ZWQgd2hlbiBzY3JvbGxpbmcuXG4gICAgb24oZC5zY3JvbGxlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbFRvcChjbSwgZC5zY3JvbGxlci5zY3JvbGxUb3ApO1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xuICAgICAgICBzaWduYWwoY20sIFwic2Nyb2xsXCIsIGNtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byB3aGVlbCBldmVudHMgaW4gb3JkZXIgdG8gdHJ5IGFuZCB1cGRhdGUgdGhlIHZpZXdwb3J0IG9uIHRpbWUuXG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZXdoZWVsXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJET01Nb3VzZVNjcm9sbFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pO1xuXG4gICAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcbiAgICBvbihkLndyYXBwZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQud3JhcHBlci5zY3JvbGxUb3AgPSBkLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7IH0pO1xuXG4gICAgZC5kcmFnRnVuY3Rpb25zID0ge1xuICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgZV9zdG9wKGUpOyB9fSxcbiAgICAgIG92ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgb25EcmFnT3ZlcihjbSwgZSk7IGVfc3RvcChlKTsgfX0sXG4gICAgICBzdGFydDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRHJhZ1N0YXJ0KGNtLCBlKTsgfSxcbiAgICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKSxcbiAgICAgIGxlYXZlOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGNsZWFyRHJhZ0N1cnNvcihjbSk7IH19XG4gICAgfTtcblxuICAgIHZhciBpbnAgPSBkLmlucHV0LmdldEZpZWxkKCk7XG4gICAgb24oaW5wLCBcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbktleVVwLmNhbGwoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwia2V5ZG93blwiLCBvcGVyYXRpb24oY20sIG9uS2V5RG93bikpO1xuICAgIG9uKGlucCwgXCJrZXlwcmVzc1wiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKTtcbiAgICBvbihpbnAsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRm9jdXMoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwiYmx1clwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25CbHVyKGNtLCBlKTsgfSk7XG4gIH1cblxuICB2YXIgaW5pdEhvb2tzID0gW107XG4gIENvZGVNaXJyb3IuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gaW5pdEhvb2tzLnB1c2goZik7IH07XG5cbiAgLy8gSW5kZW50IHRoZSBnaXZlbiBsaW5lLiBUaGUgaG93IHBhcmFtZXRlciBjYW4gYmUgXCJzbWFydFwiLFxuICAvLyBcImFkZFwiL251bGwsIFwic3VidHJhY3RcIiwgb3IgXCJwcmV2XCIuIFdoZW4gYWdncmVzc2l2ZSBpcyBmYWxzZVxuICAvLyAodHlwaWNhbGx5IHNldCB0byB0cnVlIGZvciBmb3JjZWQgc2luZ2xlLWxpbmUgaW5kZW50cyksIGVtcHR5XG4gIC8vIGxpbmVzIGFyZSBub3QgaW5kZW50ZWQsIGFuZCBwbGFjZXMgd2hlcmUgdGhlIG1vZGUgcmV0dXJucyBQYXNzXG4gIC8vIGFyZSBsZWZ0IGFsb25lLlxuICBmdW5jdGlvbiBpbmRlbnRMaW5lKGNtLCBuLCBob3csIGFnZ3Jlc3NpdmUpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBzdGF0ZTtcbiAgICBpZiAoaG93ID09IG51bGwpIHsgaG93ID0gXCJhZGRcIjsgfVxuICAgIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gXCJwcmV2XCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cbiAgICAgIC8vIG1ldGhvZC5cbiAgICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSB7IGhvdyA9IFwicHJldlwiOyB9XG4gICAgICBlbHNlIHsgc3RhdGUgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBuKS5zdGF0ZTsgfVxuICAgIH1cblxuICAgIHZhciB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIG4pLCBjdXJTcGFjZSA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgdGFiU2l6ZSk7XG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLCBpbmRlbnRhdGlvbjtcbiAgICBpZiAoIWFnZ3Jlc3NpdmUgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0KSkge1xuICAgICAgaW5kZW50YXRpb24gPSAwO1xuICAgICAgaG93ID0gXCJub3RcIjtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInNtYXJ0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gZG9jLm1vZGUuaW5kZW50KHN0YXRlLCBsaW5lLnRleHQuc2xpY2UoY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgbGluZS50ZXh0KTtcbiAgICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XG4gICAgICAgIGlmICghYWdncmVzc2l2ZSkgeyByZXR1cm4gfVxuICAgICAgICBob3cgPSBcInByZXZcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhvdyA9PSBcInByZXZcIikge1xuICAgICAgaWYgKG4gPiBkb2MuZmlyc3QpIHsgaW5kZW50YXRpb24gPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgbi0xKS50ZXh0LCBudWxsLCB0YWJTaXplKTsgfVxuICAgICAgZWxzZSB7IGluZGVudGF0aW9uID0gMDsgfVxuICAgIH0gZWxzZSBpZiAoaG93ID09IFwiYWRkXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzdWJ0cmFjdFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlIC0gY20ub3B0aW9ucy5pbmRlbnRVbml0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdyA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgaG93O1xuICAgIH1cbiAgICBpbmRlbnRhdGlvbiA9IE1hdGgubWF4KDAsIGluZGVudGF0aW9uKTtcblxuICAgIHZhciBpbmRlbnRTdHJpbmcgPSBcIlwiLCBwb3MgPSAwO1xuICAgIGlmIChjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKVxuICAgICAgeyBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFwiXFx0XCI7fSB9XG4gICAgaWYgKHBvcyA8IGluZGVudGF0aW9uKSB7IGluZGVudFN0cmluZyArPSBzcGFjZVN0cihpbmRlbnRhdGlvbiAtIHBvcyk7IH1cblxuICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShkb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXCIraW5wdXRcIik7XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIHRoYXQsIGlmIHRoZSBjdXJzb3Igd2FzIGluIHRoZSB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydFxuICAgICAgLy8gb2YgdGhlIGxpbmUsIGl0IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhhdCBzcGFjZS5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaSQxXTtcbiAgICAgICAgaWYgKHJhbmdlLmhlYWQubGluZSA9PSBuICYmIHJhbmdlLmhlYWQuY2ggPCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcG9zJDEgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSQxLCBuZXcgUmFuZ2UocG9zJDEsIHBvcyQxKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCBiZSBzZXQgdG8gYSB7bGluZVdpc2U6IGJvb2wsIHRleHQ6IFtzdHJpbmddfSBvYmplY3QsIHNvXG4gIC8vIHRoYXQsIHdoZW4gcGFzdGluZywgd2Uga25vdyB3aGF0IGtpbmQgb2Ygc2VsZWN0aW9ucyB0aGUgY29waWVkXG4gIC8vIHRleHQgd2FzIG1hZGUgb3V0IG9mLlxuICB2YXIgbGFzdENvcGllZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2V0TGFzdENvcGllZChuZXdMYXN0Q29waWVkKSB7XG4gICAgbGFzdENvcGllZCA9IG5ld0xhc3RDb3BpZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCwgb3JpZ2luKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgaWYgKCFzZWwpIHsgc2VsID0gZG9jLnNlbDsgfVxuXG4gICAgdmFyIHJlY2VudCA9ICtuZXcgRGF0ZSAtIDIwMDtcbiAgICB2YXIgcGFzdGUgPSBvcmlnaW4gPT0gXCJwYXN0ZVwiIHx8IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPiByZWNlbnQ7XG4gICAgdmFyIHRleHRMaW5lcyA9IHNwbGl0TGluZXNBdXRvKGluc2VydGVkKSwgbXVsdGlQYXN0ZSA9IG51bGw7XG4gICAgLy8gV2hlbiBwYXN0aW5nIE4gbGluZXMgaW50byBOIHNlbGVjdGlvbnMsIGluc2VydCBvbmUgbGluZSBwZXIgc2VsZWN0aW9uXG4gICAgaWYgKHBhc3RlICYmIHNlbC5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIikgPT0gaW5zZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgbXVsdGlQYXN0ZSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdENvcGllZC50ZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBtdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2ldKSk7IH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZXh0TGluZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmIGNtLm9wdGlvbnMucGFzdGVMaW5lc1BlclNlbGVjdGlvbikge1xuICAgICAgICBtdWx0aVBhc3RlID0gbWFwKHRleHRMaW5lcywgZnVuY3Rpb24gKGwpIHsgcmV0dXJuIFtsXTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUlucHV0ID0gY20uY3VyT3AudXBkYXRlSW5wdXQ7XG4gICAgLy8gTm9ybWFsIGJlaGF2aW9yIGlzIHRvIGluc2VydCB0aGUgbmV3IHRleHQgaW50byBldmVyeSBzZWxlY3Rpb25cbiAgICBmb3IgKHZhciBpJDEgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpJDFdO1xuICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgIGlmIChkZWxldGVkICYmIGRlbGV0ZWQgPiAwKSAvLyBIYW5kbGUgZGVsZXRpb25cbiAgICAgICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lLCBmcm9tLmNoIC0gZGVsZXRlZCk7IH1cbiAgICAgICAgZWxzZSBpZiAoY20uc3RhdGUub3ZlcndyaXRlICYmICFwYXN0ZSkgLy8gSGFuZGxlIG92ZXJ3cml0ZVxuICAgICAgICAgIHsgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpOyB9XG4gICAgICAgIGVsc2UgaWYgKHBhc3RlICYmIGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC5saW5lV2lzZSAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKSA9PSB0ZXh0TGluZXMuam9pbihcIlxcblwiKSlcbiAgICAgICAgICB7IGZyb20gPSB0byA9IFBvcyhmcm9tLmxpbmUsIDApOyB9XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpJDEgJSBtdWx0aVBhc3RlLmxlbmd0aF0gOiB0ZXh0TGluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4gfHwgKHBhc3RlID8gXCJwYXN0ZVwiIDogY20uc3RhdGUuY3V0SW5jb21pbmcgPiByZWNlbnQgPyBcImN1dFwiIDogXCIraW5wdXRcIil9O1xuICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZUV2ZW50KTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImlucHV0UmVhZFwiLCBjbSwgY2hhbmdlRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQgJiYgIXBhc3RlKVxuICAgICAgeyB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKTsgfVxuXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgaWYgKGNtLmN1ck9wLnVwZGF0ZUlucHV0IDwgMikgeyBjbS5jdXJPcC51cGRhdGVJbnB1dCA9IHVwZGF0ZUlucHV0OyB9XG4gICAgY20uY3VyT3AudHlwaW5nID0gdHJ1ZTtcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUsIGNtKSB7XG4gICAgdmFyIHBhc3RlZCA9IGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHBhc3RlZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFjbS5pc1JlYWRPbmx5KCkgJiYgIWNtLm9wdGlvbnMuZGlzYWJsZUlucHV0ICYmIGNtLmhhc0ZvY3VzKCkpXG4gICAgICAgIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBwbHlUZXh0SW5wdXQoY20sIHBhc3RlZCwgMCwgbnVsbCwgXCJwYXN0ZVwiKTsgfSk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCkge1xuICAgIC8vIFdoZW4gYW4gJ2VsZWN0cmljJyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGltbWVkaWF0ZWx5IHRyaWdnZXIgYSByZWluZGVudFxuICAgIGlmICghY20ub3B0aW9ucy5lbGVjdHJpY0NoYXJzIHx8ICFjbS5vcHRpb25zLnNtYXJ0SW5kZW50KSB7IHJldHVybiB9XG4gICAgdmFyIHNlbCA9IGNtLmRvYy5zZWw7XG5cbiAgICBmb3IgKHZhciBpID0gc2VsLnJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZS5oZWFkLmNoID4gMTAwIHx8IChpICYmIHNlbC5yYW5nZXNbaSAtIDFdLmhlYWQubGluZSA9PSByYW5nZS5oZWFkLmxpbmUpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBtb2RlID0gY20uZ2V0TW9kZUF0KHJhbmdlLmhlYWQpO1xuICAgICAgdmFyIGluZGVudGVkID0gZmFsc2U7XG4gICAgICBpZiAobW9kZS5lbGVjdHJpY0NoYXJzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW9kZS5lbGVjdHJpY0NoYXJzLmxlbmd0aDsgaisrKVxuICAgICAgICAgIHsgaWYgKGluc2VydGVkLmluZGV4T2YobW9kZS5lbGVjdHJpY0NoYXJzLmNoYXJBdChqKSkgPiAtMSkge1xuICAgICAgICAgICAgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFwic21hcnRcIik7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gfVxuICAgICAgfSBlbHNlIGlmIChtb2RlLmVsZWN0cmljSW5wdXQpIHtcbiAgICAgICAgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dC50ZXN0KGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQuc2xpY2UoMCwgcmFuZ2UuaGVhZC5jaCkpKVxuICAgICAgICAgIHsgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFwic21hcnRcIik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChpbmRlbnRlZCkgeyBzaWduYWxMYXRlcihjbSwgXCJlbGVjdHJpY0lucHV0XCIsIGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29weWFibGVSYW5nZXMoY20pIHtcbiAgICB2YXIgdGV4dCA9IFtdLCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2ldLmhlYWQubGluZTtcbiAgICAgIHZhciBsaW5lUmFuZ2UgPSB7YW5jaG9yOiBQb3MobGluZSwgMCksIGhlYWQ6IFBvcyhsaW5lICsgMSwgMCl9O1xuICAgICAgcmFuZ2VzLnB1c2gobGluZVJhbmdlKTtcbiAgICAgIHRleHQucHVzaChjbS5nZXRSYW5nZShsaW5lUmFuZ2UuYW5jaG9yLCBsaW5lUmFuZ2UuaGVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHQ6IHRleHQsIHJhbmdlczogcmFuZ2VzfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZUJyb3dzZXJNYWdpYyhmaWVsZCwgc3BlbGxjaGVjaywgYXV0b2NvcnJlY3QsIGF1dG9jYXBpdGFsaXplKSB7XG4gICAgZmllbGQuc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIiwgYXV0b2NvcnJlY3QgPyBcIm9uXCIgOiBcIm9mZlwiKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLCBhdXRvY2FwaXRhbGl6ZSA/IFwib25cIiA6IFwib2ZmXCIpO1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIiwgISFzcGVsbGNoZWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGRlblRleHRhcmVhKCkge1xuICAgIHZhciB0ZSA9IGVsdChcInRleHRhcmVhXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IC0xZW07IHBhZGRpbmc6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMWVtOyBtaW4taGVpZ2h0OiAxZW07IG91dGxpbmU6IG5vbmVcIik7XG4gICAgdmFyIGRpdiA9IGVsdChcImRpdlwiLCBbdGVdLCBudWxsLCBcIm92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgd2lkdGg6IDNweDsgaGVpZ2h0OiAwcHg7XCIpO1xuICAgIC8vIFRoZSB0ZXh0YXJlYSBpcyBrZXB0IHBvc2l0aW9uZWQgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gZmFjdCB0aGF0IGl0J2xsIGJlIHNjcm9sbGVkIGludG8gdmlldyBvbiBpbnB1dCBmcm9tIHNjcm9sbGluZ1xuICAgIC8vIG91ciBmYWtlIGN1cnNvciBvdXQgb2Ygdmlldy4gT24gd2Via2l0LCB3aGVuIHdyYXA9b2ZmLCBwYXN0ZSBpc1xuICAgIC8vIHZlcnkgc2xvdy4gU28gbWFrZSB0aGUgYXJlYSB3aWRlIGluc3RlYWQuXG4gICAgaWYgKHdlYmtpdCkgeyB0ZS5zdHlsZS53aWR0aCA9IFwiMTAwMHB4XCI7IH1cbiAgICBlbHNlIHsgdGUuc2V0QXR0cmlidXRlKFwid3JhcFwiLCBcIm9mZlwiKTsgfVxuICAgIC8vIElmIGJvcmRlcjogMDsgLS0gaU9TIGZhaWxzIHRvIG9wZW4ga2V5Ym9hcmQgKGlzc3VlICMxMjg3KVxuICAgIGlmIChpb3MpIHsgdGUuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgYmxhY2tcIjsgfVxuICAgIHJldHVybiBkaXZcbiAgfVxuXG4gIC8vIFRoZSBwdWJsaWNseSB2aXNpYmxlIEFQSS4gTm90ZSB0aGF0IG1ldGhvZE9wKGYpIG1lYW5zXG4gIC8vICd3cmFwIGYgaW4gYW4gb3BlcmF0aW9uLCBwZXJmb3JtZWQgb24gaXRzIGB0aGlzYCBwYXJhbWV0ZXInLlxuXG4gIC8vIFRoaXMgaXMgbm90IHRoZSBjb21wbGV0ZSBzZXQgb2YgZWRpdG9yIG1ldGhvZHMuIE1vc3Qgb2YgdGhlXG4gIC8vIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRG9jIHR5cGUgYXJlIGFsc28gaW5qZWN0ZWQgaW50b1xuICAvLyBDb2RlTWlycm9yLnByb3RvdHlwZSwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZFxuICAvLyBjb252ZW5pZW5jZS5cblxuICBmdW5jdGlvbiBhZGRFZGl0b3JNZXRob2RzKENvZGVNaXJyb3IpIHtcbiAgICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzO1xuXG4gICAgdmFyIGhlbHBlcnMgPSBDb2RlTWlycm9yLmhlbHBlcnMgPSB7fTtcblxuICAgIENvZGVNaXJyb3IucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IENvZGVNaXJyb3IsXG4gICAgICBmb2N1czogZnVuY3Rpb24oKXt3aW4odGhpcykuZm9jdXMoKTsgdGhpcy5kaXNwbGF5LmlucHV0LmZvY3VzKCk7fSxcblxuICAgICAgc2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLCBvbGQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgIGlmIChvcHRpb25zW29wdGlvbl0gPT0gdmFsdWUgJiYgb3B0aW9uICE9IFwibW9kZVwiKSB7IHJldHVybiB9XG4gICAgICAgIG9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgICBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSlcbiAgICAgICAgICB7IG9wZXJhdGlvbih0aGlzLCBvcHRpb25IYW5kbGVyc1tvcHRpb25dKSh0aGlzLCB2YWx1ZSwgb2xkKTsgfVxuICAgICAgICBzaWduYWwodGhpcywgXCJvcHRpb25DaGFuZ2VcIiwgdGhpcywgb3B0aW9uKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uKSB7cmV0dXJuIHRoaXMub3B0aW9uc1tvcHRpb25dfSxcbiAgICAgIGdldERvYzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZG9jfSxcblxuICAgICAgYWRkS2V5TWFwOiBmdW5jdGlvbihtYXAsIGJvdHRvbSkge1xuICAgICAgICB0aGlzLnN0YXRlLmtleU1hcHNbYm90dG9tID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl0oZ2V0S2V5TWFwKG1hcCkpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUtleU1hcDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBtYXBzID0gdGhpcy5zdGF0ZS5rZXlNYXBzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgeyBpZiAobWFwc1tpXSA9PSBtYXAgfHwgbWFwc1tpXS5uYW1lID09IG1hcCkge1xuICAgICAgICAgICAgbWFwcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gfVxuICAgICAgfSxcblxuICAgICAgYWRkT3ZlcmxheTogbWV0aG9kT3AoZnVuY3Rpb24oc3BlYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW9kZSA9IHNwZWMudG9rZW4gPyBzcGVjIDogQ29kZU1pcnJvci5nZXRNb2RlKHRoaXMub3B0aW9ucywgc3BlYyk7XG4gICAgICAgIGlmIChtb2RlLnN0YXJ0U3RhdGUpIHsgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcmxheXMgbWF5IG5vdCBiZSBzdGF0ZWZ1bC5cIikgfVxuICAgICAgICBpbnNlcnRTb3J0ZWQodGhpcy5zdGF0ZS5vdmVybGF5cyxcbiAgICAgICAgICAgICAgICAgICAgIHttb2RlOiBtb2RlLCBtb2RlU3BlYzogc3BlYywgb3BhcXVlOiBvcHRpb25zICYmIG9wdGlvbnMub3BhcXVlLFxuICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSB8fCAwfSxcbiAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvdmVybGF5KSB7IHJldHVybiBvdmVybGF5LnByaW9yaXR5OyB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgIH0pLFxuICAgICAgcmVtb3ZlT3ZlcmxheTogbWV0aG9kT3AoZnVuY3Rpb24oc3BlYykge1xuICAgICAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLnN0YXRlLm92ZXJsYXlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG92ZXJsYXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IG92ZXJsYXlzW2ldLm1vZGVTcGVjO1xuICAgICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIGN1ci5uYW1lID09IHNwZWMpIHtcbiAgICAgICAgICAgIG92ZXJsYXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xuICAgICAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgaW5kZW50TGluZTogbWV0aG9kT3AoZnVuY3Rpb24obiwgZGlyLCBhZ2dyZXNzaXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGlyICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGRpciAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKGRpciA9PSBudWxsKSB7IGRpciA9IHRoaXMub3B0aW9ucy5zbWFydEluZGVudCA/IFwic21hcnRcIiA6IFwicHJldlwiOyB9XG4gICAgICAgICAgZWxzZSB7IGRpciA9IGRpciA/IFwiYWRkXCIgOiBcInN1YnRyYWN0XCI7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaW5lKHRoaXMuZG9jLCBuKSkgeyBpbmRlbnRMaW5lKHRoaXMsIG4sIGRpciwgYWdncmVzc2l2ZSk7IH1cbiAgICAgIH0pLFxuICAgICAgaW5kZW50U2VsZWN0aW9uOiBtZXRob2RPcChmdW5jdGlvbihob3cpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZG9jLnNlbC5yYW5nZXMsIGVuZCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLCB0byA9IHJhbmdlLnRvKCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChlbmQsIGZyb20ubGluZSk7XG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmxhc3RMaW5lKCksIHRvLmxpbmUgLSAodG8uY2ggPyAwIDogMSkpICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8IGVuZDsgKytqKVxuICAgICAgICAgICAgICB7IGluZGVudExpbmUodGhpcywgaiwgaG93KTsgfVxuICAgICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMuZG9jLnNlbC5yYW5nZXM7XG4gICAgICAgICAgICBpZiAoZnJvbS5jaCA9PSAwICYmIHJhbmdlcy5sZW5ndGggPT0gbmV3UmFuZ2VzLmxlbmd0aCAmJiBuZXdSYW5nZXNbaV0uZnJvbSgpLmNoID4gMClcbiAgICAgICAgICAgICAgeyByZXBsYWNlT25lU2VsZWN0aW9uKHRoaXMuZG9jLCBpLCBuZXcgUmFuZ2UoZnJvbSwgbmV3UmFuZ2VzW2ldLnRvKCkpLCBzZWxfZG9udFNjcm9sbCk7IH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmhlYWQubGluZSA+IGVuZCkge1xuICAgICAgICAgICAgaW5kZW50TGluZSh0aGlzLCByYW5nZS5oZWFkLmxpbmUsIGhvdywgdHJ1ZSk7XG4gICAgICAgICAgICBlbmQgPSByYW5nZS5oZWFkLmxpbmU7XG4gICAgICAgICAgICBpZiAoaSA9PSB0aGlzLmRvYy5zZWwucHJpbUluZGV4KSB7IGVuc3VyZUN1cnNvclZpc2libGUodGhpcyk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICAvLyBGZXRjaCB0aGUgcGFyc2VyIHRva2VuIGZvciBhIGdpdmVuIGNoYXJhY3Rlci4gVXNlZnVsIGZvciBoYWNrc1xuICAgICAgLy8gdGhhdCB3YW50IHRvIGluc3BlY3QgdGhlIG1vZGUgc3RhdGUgKHNheSwgZm9yIGNvbXBsZXRpb24pLlxuICAgICAgZ2V0VG9rZW5BdDogZnVuY3Rpb24ocG9zLCBwcmVjaXNlKSB7XG4gICAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgcG9zLCBwcmVjaXNlKVxuICAgICAgfSxcblxuICAgICAgZ2V0TGluZVRva2VuczogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIFBvcyhsaW5lKSwgcHJlY2lzZSwgdHJ1ZSlcbiAgICAgIH0sXG5cbiAgICAgIGdldFRva2VuVHlwZUF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgcG9zKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGdldExpbmVTdHlsZXModGhpcywgZ2V0TGluZSh0aGlzLmRvYywgcG9zLmxpbmUpKTtcbiAgICAgICAgdmFyIGJlZm9yZSA9IDAsIGFmdGVyID0gKHN0eWxlcy5sZW5ndGggLSAxKSAvIDIsIGNoID0gcG9zLmNoO1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgaWYgKGNoID09IDApIHsgdHlwZSA9IHN0eWxlc1syXTsgfVxuICAgICAgICBlbHNlIHsgZm9yICg7Oykge1xuICAgICAgICAgIHZhciBtaWQgPSAoYmVmb3JlICsgYWZ0ZXIpID4+IDE7XG4gICAgICAgICAgaWYgKChtaWQgPyBzdHlsZXNbbWlkICogMiAtIDFdIDogMCkgPj0gY2gpIHsgYWZ0ZXIgPSBtaWQ7IH1cbiAgICAgICAgICBlbHNlIGlmIChzdHlsZXNbbWlkICogMiArIDFdIDwgY2gpIHsgYmVmb3JlID0gbWlkICsgMTsgfVxuICAgICAgICAgIGVsc2UgeyB0eXBlID0gc3R5bGVzW21pZCAqIDIgKyAyXTsgYnJlYWsgfVxuICAgICAgICB9IH1cbiAgICAgICAgdmFyIGN1dCA9IHR5cGUgPyB0eXBlLmluZGV4T2YoXCJvdmVybGF5IFwiKSA6IC0xO1xuICAgICAgICByZXR1cm4gY3V0IDwgMCA/IHR5cGUgOiBjdXQgPT0gMCA/IG51bGwgOiB0eXBlLnNsaWNlKDAsIGN1dCAtIDEpXG4gICAgICB9LFxuXG4gICAgICBnZXRNb2RlQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuZG9jLm1vZGU7XG4gICAgICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHsgcmV0dXJuIG1vZGUgfVxuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSwgdGhpcy5nZXRUb2tlbkF0KHBvcykuc3RhdGUpLm1vZGVcbiAgICAgIH0sXG5cbiAgICAgIGdldEhlbHBlcjogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlbHBlcnMocG9zLCB0eXBlKVswXVxuICAgICAgfSxcblxuICAgICAgZ2V0SGVscGVyczogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IFtdO1xuICAgICAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHsgcmV0dXJuIGZvdW5kIH1cbiAgICAgICAgdmFyIGhlbHAgPSBoZWxwZXJzW3R5cGVdLCBtb2RlID0gdGhpcy5nZXRNb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlW3R5cGVdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoaGVscFttb2RlW3R5cGVdXSkgeyBmb3VuZC5wdXNoKGhlbHBbbW9kZVt0eXBlXV0pOyB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZVt0eXBlXSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZVt0eXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGhlbHBbbW9kZVt0eXBlXVtpXV07XG4gICAgICAgICAgICBpZiAodmFsKSB7IGZvdW5kLnB1c2godmFsKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlLmhlbHBlclR5cGUgJiYgaGVscFttb2RlLmhlbHBlclR5cGVdKSB7XG4gICAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUuaGVscGVyVHlwZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGhlbHBbbW9kZS5uYW1lXSkge1xuICAgICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLm5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBoZWxwLl9nbG9iYWwubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBjdXIgPSBoZWxwLl9nbG9iYWxbaSQxXTtcbiAgICAgICAgICBpZiAoY3VyLnByZWQobW9kZSwgdGhpcykgJiYgaW5kZXhPZihmb3VuZCwgY3VyLnZhbCkgPT0gLTEpXG4gICAgICAgICAgICB7IGZvdW5kLnB1c2goY3VyLnZhbCk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRcbiAgICAgIH0sXG5cbiAgICAgIGdldFN0YXRlQWZ0ZXI6IGZ1bmN0aW9uKGxpbmUsIHByZWNpc2UpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jO1xuICAgICAgICBsaW5lID0gY2xpcExpbmUoZG9jLCBsaW5lID09IG51bGwgPyBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE6IGxpbmUpO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dEJlZm9yZSh0aGlzLCBsaW5lICsgMSwgcHJlY2lzZSkuc3RhdGVcbiAgICAgIH0sXG5cbiAgICAgIGN1cnNvckNvb3JkczogZnVuY3Rpb24oc3RhcnQsIG1vZGUpIHtcbiAgICAgICAgdmFyIHBvcywgcmFuZ2UgPSB0aGlzLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBwb3MgPSByYW5nZS5oZWFkOyB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGFydCA9PSBcIm9iamVjdFwiKSB7IHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHN0YXJ0KTsgfVxuICAgICAgICBlbHNlIHsgcG9zID0gc3RhcnQgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpOyB9XG4gICAgICAgIHJldHVybiBjdXJzb3JDb29yZHModGhpcywgcG9zLCBtb2RlIHx8IFwicGFnZVwiKVxuICAgICAgfSxcblxuICAgICAgY2hhckNvb3JkczogZnVuY3Rpb24ocG9zLCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcyksIG1vZGUgfHwgXCJwYWdlXCIpXG4gICAgICB9LFxuXG4gICAgICBjb29yZHNDaGFyOiBmdW5jdGlvbihjb29yZHMsIG1vZGUpIHtcbiAgICAgICAgY29vcmRzID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIGNvb3JkcywgbW9kZSB8fCBcInBhZ2VcIik7XG4gICAgICAgIHJldHVybiBjb29yZHNDaGFyKHRoaXMsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKVxuICAgICAgfSxcblxuICAgICAgbGluZUF0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIG1vZGUpIHtcbiAgICAgICAgaGVpZ2h0ID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIHt0b3A6IGhlaWdodCwgbGVmdDogMH0sIG1vZGUgfHwgXCJwYWdlXCIpLnRvcDtcbiAgICAgICAgcmV0dXJuIGxpbmVBdEhlaWdodCh0aGlzLmRvYywgaGVpZ2h0ICsgdGhpcy5kaXNwbGF5LnZpZXdPZmZzZXQpXG4gICAgICB9LFxuICAgICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbihsaW5lLCBtb2RlLCBpbmNsdWRlV2lkZ2V0cykge1xuICAgICAgICB2YXIgZW5kID0gZmFsc2UsIGxpbmVPYmo7XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmRvYy5maXJzdCArIHRoaXMuZG9jLnNpemUgLSAxO1xuICAgICAgICAgIGlmIChsaW5lIDwgdGhpcy5kb2MuZmlyc3QpIHsgbGluZSA9IHRoaXMuZG9jLmZpcnN0OyB9XG4gICAgICAgICAgZWxzZSBpZiAobGluZSA+IGxhc3QpIHsgbGluZSA9IGxhc3Q7IGVuZCA9IHRydWU7IH1cbiAgICAgICAgICBsaW5lT2JqID0gZ2V0TGluZSh0aGlzLmRvYywgbGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZU9iaiA9IGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbSh0aGlzLCBsaW5lT2JqLCB7dG9wOiAwLCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIiwgaW5jbHVkZVdpZGdldHMgfHwgZW5kKS50b3AgK1xuICAgICAgICAgIChlbmQgPyB0aGlzLmRvYy5oZWlnaHQgLSBoZWlnaHRBdExpbmUobGluZU9iaikgOiAwKVxuICAgICAgfSxcblxuICAgICAgZGVmYXVsdFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpIH0sXG4gICAgICBkZWZhdWx0Q2hhcldpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJXaWR0aCh0aGlzLmRpc3BsYXkpIH0sXG5cbiAgICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHtmcm9tOiB0aGlzLmRpc3BsYXkudmlld0Zyb20sIHRvOiB0aGlzLmRpc3BsYXkudmlld1RvfX0sXG5cbiAgICAgIGFkZFdpZGdldDogZnVuY3Rpb24ocG9zLCBub2RlLCBzY3JvbGwsIHZlcnQsIGhvcml6KSB7XG4gICAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5O1xuICAgICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSk7XG4gICAgICAgIHZhciB0b3AgPSBwb3MuYm90dG9tLCBsZWZ0ID0gcG9zLmxlZnQ7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpO1xuICAgICAgICBkaXNwbGF5LnNpemVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBpZiAodmVydCA9PSBcIm92ZXJcIikge1xuICAgICAgICAgIHRvcCA9IHBvcy50b3A7XG4gICAgICAgIH0gZWxzZSBpZiAodmVydCA9PSBcImFib3ZlXCIgfHwgdmVydCA9PSBcIm5lYXJcIikge1xuICAgICAgICAgIHZhciB2c3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB0aGlzLmRvYy5oZWlnaHQpLFxuICAgICAgICAgIGhzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGgsIGRpc3BsYXkubGluZVNwYWNlLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGFib3ZlIChpZiBzcGVjaWZpZWQgYW5kIHBvc3NpYmxlKTsgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gcG9zaXRpb25pbmcgYmVsb3dcbiAgICAgICAgICBpZiAoKHZlcnQgPT0gJ2Fib3ZlJyB8fCBwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPiB2c3BhY2UpICYmIHBvcy50b3AgPiBub2RlLm9mZnNldEhlaWdodClcbiAgICAgICAgICAgIHsgdG9wID0gcG9zLnRvcCAtIG5vZGUub2Zmc2V0SGVpZ2h0OyB9XG4gICAgICAgICAgZWxzZSBpZiAocG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0IDw9IHZzcGFjZSlcbiAgICAgICAgICAgIHsgdG9wID0gcG9zLmJvdHRvbTsgfVxuICAgICAgICAgIGlmIChsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCA+IGhzcGFjZSlcbiAgICAgICAgICAgIHsgbGVmdCA9IGhzcGFjZSAtIG5vZGUub2Zmc2V0V2lkdGg7IH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICAgIGlmIChob3JpeiA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBsZWZ0ID0gZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgbm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhvcml6ID09IFwibGVmdFwiKSB7IGxlZnQgPSAwOyB9XG4gICAgICAgICAgZWxzZSBpZiAoaG9yaXogPT0gXCJtaWRkbGVcIikgeyBsZWZ0ID0gKGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoKSAvIDI7IH1cbiAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGwpXG4gICAgICAgICAgeyBzY3JvbGxJbnRvVmlldyh0aGlzLCB7bGVmdDogbGVmdCwgdG9wOiB0b3AsIHJpZ2h0OiBsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCwgYm90dG9tOiB0b3AgKyBub2RlLm9mZnNldEhlaWdodH0pOyB9XG4gICAgICB9LFxuXG4gICAgICB0cmlnZ2VyT25LZXlEb3duOiBtZXRob2RPcChvbktleURvd24pLFxuICAgICAgdHJpZ2dlck9uS2V5UHJlc3M6IG1ldGhvZE9wKG9uS2V5UHJlc3MpLFxuICAgICAgdHJpZ2dlck9uS2V5VXA6IG9uS2V5VXAsXG4gICAgICB0cmlnZ2VyT25Nb3VzZURvd246IG1ldGhvZE9wKG9uTW91c2VEb3duKSxcblxuICAgICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNtZCkge1xuICAgICAgICBpZiAoY29tbWFuZHMuaGFzT3duUHJvcGVydHkoY21kKSlcbiAgICAgICAgICB7IHJldHVybiBjb21tYW5kc1tjbWRdLmNhbGwobnVsbCwgdGhpcykgfVxuICAgICAgfSxcblxuICAgICAgdHJpZ2dlckVsZWN0cmljOiBtZXRob2RPcChmdW5jdGlvbih0ZXh0KSB7IHRyaWdnZXJFbGVjdHJpYyh0aGlzLCB0ZXh0KTsgfSksXG5cbiAgICAgIGZpbmRQb3NIOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIHZpc3VhbGx5KSB7XG4gICAgICAgIHZhciBkaXIgPSAxO1xuICAgICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudDsgfVxuICAgICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgICBjdXIgPSBmaW5kUG9zSCh0aGlzLmRvYywgY3VyLCBkaXIsIHVuaXQsIHZpc3VhbGx5KTtcbiAgICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJcbiAgICAgIH0sXG5cbiAgICAgIG1vdmVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKHRoaXMkMS5kaXNwbGF5LnNoaWZ0IHx8IHRoaXMkMS5kb2MuZXh0ZW5kIHx8IHJhbmdlLmVtcHR5KCkpXG4gICAgICAgICAgICB7IHJldHVybiBmaW5kUG9zSCh0aGlzJDEuZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIHRoaXMkMS5vcHRpb25zLnJ0bE1vdmVWaXN1YWxseSkgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cbiAgICAgICAgfSwgc2VsX21vdmUpO1xuICAgICAgfSksXG5cbiAgICAgIGRlbGV0ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgICB2YXIgc2VsID0gdGhpcy5kb2Muc2VsLCBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgaWYgKHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpKVxuICAgICAgICAgIHsgZG9jLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCIrZGVsZXRlXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IGRlbGV0ZU5lYXJTZWxlY3Rpb24odGhpcywgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBmaW5kUG9zSChkb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyB7ZnJvbTogb3RoZXIsIHRvOiByYW5nZS5oZWFkfSA6IHtmcm9tOiByYW5nZS5oZWFkLCB0bzogb3RoZXJ9XG4gICAgICAgICAgfSk7IH1cbiAgICAgIH0pLFxuXG4gICAgICBmaW5kUG9zVjogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHZhciBkaXIgPSAxLCB4ID0gZ29hbENvbHVtbjtcbiAgICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cbiAgICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3Jkcyh0aGlzLCBjdXIsIFwiZGl2XCIpO1xuICAgICAgICAgIGlmICh4ID09IG51bGwpIHsgeCA9IGNvb3Jkcy5sZWZ0OyB9XG4gICAgICAgICAgZWxzZSB7IGNvb3Jkcy5sZWZ0ID0geDsgfVxuICAgICAgICAgIGN1ciA9IGZpbmRQb3NWKHRoaXMsIGNvb3JkcywgZGlyLCB1bml0KTtcbiAgICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJcbiAgICAgIH0sXG5cbiAgICAgIG1vdmVWOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBnb2FscyA9IFtdO1xuICAgICAgICB2YXIgY29sbGFwc2UgPSAhdGhpcy5kaXNwbGF5LnNoaWZ0ICYmICFkb2MuZXh0ZW5kICYmIGRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTtcbiAgICAgICAgZG9jLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoY29sbGFwc2UpXG4gICAgICAgICAgICB7IHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XG4gICAgICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHModGhpcyQxLCByYW5nZS5oZWFkLCBcImRpdlwiKTtcbiAgICAgICAgICBpZiAocmFuZ2UuZ29hbENvbHVtbiAhPSBudWxsKSB7IGhlYWRQb3MubGVmdCA9IHJhbmdlLmdvYWxDb2x1bW47IH1cbiAgICAgICAgICBnb2Fscy5wdXNoKGhlYWRQb3MubGVmdCk7XG4gICAgICAgICAgdmFyIHBvcyA9IGZpbmRQb3NWKHRoaXMkMSwgaGVhZFBvcywgZGlyLCB1bml0KTtcbiAgICAgICAgICBpZiAodW5pdCA9PSBcInBhZ2VcIiAmJiByYW5nZSA9PSBkb2Muc2VsLnByaW1hcnkoKSlcbiAgICAgICAgICAgIHsgYWRkVG9TY3JvbGxUb3AodGhpcyQxLCBjaGFyQ29vcmRzKHRoaXMkMSwgcG9zLCBcImRpdlwiKS50b3AgLSBoZWFkUG9zLnRvcCk7IH1cbiAgICAgICAgICByZXR1cm4gcG9zXG4gICAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICAgICAgaWYgKGdvYWxzLmxlbmd0aCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHsgZG9jLnNlbC5yYW5nZXNbaV0uZ29hbENvbHVtbiA9IGdvYWxzW2ldOyB9IH1cbiAgICAgIH0pLFxuXG4gICAgICAvLyBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiAoYXMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhcikuXG4gICAgICBmaW5kV29yZEF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0O1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3MuY2gsIGVuZCA9IHBvcy5jaDtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICB2YXIgaGVscGVyID0gdGhpcy5nZXRIZWxwZXIocG9zLCBcIndvcmRDaGFyc1wiKTtcbiAgICAgICAgICBpZiAoKHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiB8fCBlbmQgPT0gbGluZS5sZW5ndGgpICYmIHN0YXJ0KSB7IC0tc3RhcnQ7IH0gZWxzZSB7ICsrZW5kOyB9XG4gICAgICAgICAgdmFyIHN0YXJ0Q2hhciA9IGxpbmUuY2hhckF0KHN0YXJ0KTtcbiAgICAgICAgICB2YXIgY2hlY2sgPSBpc1dvcmRDaGFyKHN0YXJ0Q2hhciwgaGVscGVyKVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIGlzV29yZENoYXIoY2gsIGhlbHBlcik7IH1cbiAgICAgICAgICAgIDogL1xccy8udGVzdChzdGFydENoYXIpID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiAvXFxzLy50ZXN0KGNoKTsgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuICghL1xccy8udGVzdChjaCkgJiYgIWlzV29yZENoYXIoY2gpKTsgfTtcbiAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIGNoZWNrKGxpbmUuY2hhckF0KHN0YXJ0IC0gMSkpKSB7IC0tc3RhcnQ7IH1cbiAgICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgY2hlY2sobGluZS5jaGFyQXQoZW5kKSkpIHsgKytlbmQ7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgc3RhcnQpLCBQb3MocG9zLmxpbmUsIGVuZCkpXG4gICAgICB9LFxuXG4gICAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID09IHRoaXMuc3RhdGUub3ZlcndyaXRlKSB7IHJldHVybiB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm92ZXJ3cml0ZSA9ICF0aGlzLnN0YXRlLm92ZXJ3cml0ZSlcbiAgICAgICAgICB7IGFkZENsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgcm1DbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpOyB9XG5cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwib3ZlcndyaXRlVG9nZ2xlXCIsIHRoaXMsIHRoaXMuc3RhdGUub3ZlcndyaXRlKTtcbiAgICAgIH0sXG4gICAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSA9PSBhY3RpdmVFbHQocm9vdCh0aGlzKSkgfSxcbiAgICAgIGlzUmVhZE9ubHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISEodGhpcy5vcHRpb25zLnJlYWRPbmx5IHx8IHRoaXMuZG9jLmNhbnRFZGl0KSB9LFxuXG4gICAgICBzY3JvbGxUbzogbWV0aG9kT3AoZnVuY3Rpb24gKHgsIHkpIHsgc2Nyb2xsVG9Db29yZHModGhpcywgeCwgeSk7IH0pLFxuICAgICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZGlzcGxheS5zY3JvbGxlcjtcbiAgICAgICAgcmV0dXJuIHtsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGlzcGxheUhlaWdodCh0aGlzKSwgY2xpZW50V2lkdGg6IGRpc3BsYXlXaWR0aCh0aGlzKX1cbiAgICAgIH0sXG5cbiAgICAgIHNjcm9sbEludG9WaWV3OiBtZXRob2RPcChmdW5jdGlvbihyYW5nZSwgbWFyZ2luKSB7XG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmFuZ2UgPSB7ZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbH07XG4gICAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47IH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmFuZ2UgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICByYW5nZSA9IHtmcm9tOiByYW5nZSwgdG86IG51bGx9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UudG8pIHsgcmFuZ2UudG8gPSByYW5nZS5mcm9tOyB9XG4gICAgICAgIHJhbmdlLm1hcmdpbiA9IG1hcmdpbiB8fCAwO1xuXG4gICAgICAgIGlmIChyYW5nZS5mcm9tLmxpbmUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjcm9sbFRvUmFuZ2UodGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbFRvQ29vcmRzUmFuZ2UodGhpcywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLm1hcmdpbik7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBzZXRTaXplOiBtZXRob2RPcChmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB0eXBlb2YgdmFsID09IFwibnVtYmVyXCIgfHwgL15cXGQrJC8udGVzdChTdHJpbmcodmFsKSkgPyB2YWwgKyBcInB4XCIgOiB2YWw7IH07XG4gICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoID0gaW50ZXJwcmV0KHdpZHRoKTsgfVxuICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW50ZXJwcmV0KGhlaWdodCk7IH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKTsgfVxuICAgICAgICB2YXIgbGluZU5vID0gdGhpcy5kaXNwbGF5LnZpZXdGcm9tO1xuICAgICAgICB0aGlzLmRvYy5pdGVyKGxpbmVObywgdGhpcy5kaXNwbGF5LnZpZXdUbywgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBpZiAobGluZS53aWRnZXRzW2ldLm5vSFNjcm9sbCkgeyByZWdMaW5lQ2hhbmdlKHRoaXMkMSwgbGluZU5vLCBcIndpZGdldFwiKTsgYnJlYWsgfSB9IH1cbiAgICAgICAgICArK2xpbmVObztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzaWduYWwodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpO1xuICAgICAgfSksXG5cbiAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZil9LFxuICAgICAgc3RhcnRPcGVyYXRpb246IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YXJ0T3BlcmF0aW9uKHRoaXMpfSxcbiAgICAgIGVuZE9wZXJhdGlvbjogZnVuY3Rpb24oKXtyZXR1cm4gZW5kT3BlcmF0aW9uKHRoaXMpfSxcblxuICAgICAgcmVmcmVzaDogbWV0aG9kT3AoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodDtcbiAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHNjcm9sbFRvQ29vcmRzKHRoaXMsIHRoaXMuZG9jLnNjcm9sbExlZnQsIHRoaXMuZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKHRoaXMuZGlzcGxheSk7XG4gICAgICAgIGlmIChvbGRIZWlnaHQgPT0gbnVsbCB8fCBNYXRoLmFicyhvbGRIZWlnaHQgLSB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkpID4gLjUgfHwgdGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgICB7IGVzdGltYXRlTGluZUhlaWdodHModGhpcyk7IH1cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICAgIH0pLFxuXG4gICAgICBzd2FwRG9jOiBtZXRob2RPcChmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuZG9jO1xuICAgICAgICBvbGQuY20gPSBudWxsO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gaWYgYW55ICgjNTgyMSlcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCkgeyB0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQoKTsgfVxuICAgICAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICBzY3JvbGxUb0Nvb3Jkcyh0aGlzLCBkb2Muc2Nyb2xsTGVmdCwgZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VTY3JvbGwgPSB0cnVlO1xuICAgICAgICBzaWduYWxMYXRlcih0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgb2xkKTtcbiAgICAgICAgcmV0dXJuIG9sZFxuICAgICAgfSksXG5cbiAgICAgIHBocmFzZTogZnVuY3Rpb24ocGhyYXNlVGV4dCkge1xuICAgICAgICB2YXIgcGhyYXNlcyA9IHRoaXMub3B0aW9ucy5waHJhc2VzO1xuICAgICAgICByZXR1cm4gcGhyYXNlcyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGhyYXNlcywgcGhyYXNlVGV4dCkgPyBwaHJhc2VzW3BocmFzZVRleHRdIDogcGhyYXNlVGV4dFxuICAgICAgfSxcblxuICAgICAgZ2V0SW5wdXRGaWVsZDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCl9LFxuICAgICAgZ2V0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyfSxcbiAgICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyfSxcbiAgICAgIGdldEd1dHRlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5ndXR0ZXJzfVxuICAgIH07XG4gICAgZXZlbnRNaXhpbihDb2RlTWlycm9yKTtcblxuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IGhlbHBlcnNbdHlwZV0gPSBDb2RlTWlycm9yW3R5cGVdID0ge19nbG9iYWw6IFtdfTsgfVxuICAgICAgaGVscGVyc1t0eXBlXVtuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHByZWRpY2F0ZSwgdmFsdWUpIHtcbiAgICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIodHlwZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pO1xuICAgIH07XG4gIH1cblxuICAvLyBVc2VkIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdGlvbi4gRGlyIGlzIC0xIG9yIDEgKGxlZnQgb3JcbiAgLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcImNvZGVwb2ludFwiLCBcImNoYXJcIiwgXCJjb2x1bW5cIiAobGlrZSBjaGFyLCBidXRcbiAgLy8gZG9lc24ndCBjcm9zcyBsaW5lIGJvdW5kYXJpZXMpLCBcIndvcmRcIiAoYWNyb3NzIG5leHQgd29yZCksIG9yXG4gIC8vIFwiZ3JvdXBcIiAodG8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvclxuICAvLyBub24td29yZC1ub24td2hpdGVzcGFjZSBjaGFycykuIFRoZSB2aXN1YWxseSBwYXJhbSBjb250cm9sc1xuICAvLyB3aGV0aGVyLCBpbiByaWdodC10by1sZWZ0IHRleHQsIGRpcmVjdGlvbiAxIG1lYW5zIHRvIG1vdmUgdG93YXJkc1xuICAvLyB0aGUgbmV4dCBpbmRleCBpbiB0aGUgc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0XG4gIC8vIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhXG4gIC8vIGhpdFNpZGU9dHJ1ZSBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xuICAgIHZhciBvbGRQb3MgPSBwb3M7XG4gICAgdmFyIG9yaWdEaXIgPSBkaXI7XG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIHZhciBsaW5lRGlyID0gdmlzdWFsbHkgJiYgZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gLWRpciA6IGRpcjtcbiAgICBmdW5jdGlvbiBmaW5kTmV4dExpbmUoKSB7XG4gICAgICB2YXIgbCA9IHBvcy5saW5lICsgbGluZURpcjtcbiAgICAgIGlmIChsIDwgZG9jLmZpcnN0IHx8IGwgPj0gZG9jLmZpcnN0ICsgZG9jLnNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyA9IG5ldyBQb3MobCwgcG9zLmNoLCBwb3Muc3RpY2t5KTtcbiAgICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVPbmNlKGJvdW5kVG9MaW5lKSB7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIGlmICh1bml0ID09IFwiY29kZXBvaW50XCIpIHtcbiAgICAgICAgdmFyIGNoID0gbGluZU9iai50ZXh0LmNoYXJDb2RlQXQocG9zLmNoICsgKGRpciA+IDAgPyAwIDogLTEpKTtcbiAgICAgICAgaWYgKGlzTmFOKGNoKSkge1xuICAgICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhc3RyYWwgPSBkaXIgPiAwID8gY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwIDogY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhERkZGO1xuICAgICAgICAgIG5leHQgPSBuZXcgUG9zKHBvcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLm1pbihsaW5lT2JqLnRleHQubGVuZ3RoLCBwb3MuY2ggKyBkaXIgKiAoYXN0cmFsID8gMiA6IDEpKSksIC1kaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZpc3VhbGx5KSB7XG4gICAgICAgIG5leHQgPSBtb3ZlVmlzdWFsbHkoZG9jLmNtLCBsaW5lT2JqLCBwb3MsIGRpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gbW92ZUxvZ2ljYWxseShsaW5lT2JqLCBwb3MsIGRpcik7XG4gICAgICB9XG4gICAgICBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgIGlmICghYm91bmRUb0xpbmUgJiYgZmluZE5leHRMaW5lKCkpXG4gICAgICAgICAgeyBwb3MgPSBlbmRPZkxpbmUodmlzdWFsbHksIGRvYy5jbSwgbGluZU9iaiwgcG9zLmxpbmUsIGxpbmVEaXIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIiB8fCB1bml0ID09IFwiY29kZXBvaW50XCIpIHtcbiAgICAgIG1vdmVPbmNlKCk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwiY29sdW1uXCIpIHtcbiAgICAgIG1vdmVPbmNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcIndvcmRcIiB8fCB1bml0ID09IFwiZ3JvdXBcIikge1xuICAgICAgdmFyIHNhd1R5cGUgPSBudWxsLCBncm91cCA9IHVuaXQgPT0gXCJncm91cFwiO1xuICAgICAgdmFyIGhlbHBlciA9IGRvYy5jbSAmJiBkb2MuY20uZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cbiAgICAgICAgdmFyIGN1ciA9IGxpbmVPYmoudGV4dC5jaGFyQXQocG9zLmNoKSB8fCBcIlxcblwiO1xuICAgICAgICB2YXIgdHlwZSA9IGlzV29yZENoYXIoY3VyLCBoZWxwZXIpID8gXCJ3XCJcbiAgICAgICAgICA6IGdyb3VwICYmIGN1ciA9PSBcIlxcblwiID8gXCJuXCJcbiAgICAgICAgICA6ICFncm91cCB8fCAvXFxzLy50ZXN0KGN1cikgPyBudWxsXG4gICAgICAgICAgOiBcInBcIjtcbiAgICAgICAgaWYgKGdyb3VwICYmICFmaXJzdCAmJiAhdHlwZSkgeyB0eXBlID0gXCJzXCI7IH1cbiAgICAgICAgaWYgKHNhd1R5cGUgJiYgc2F3VHlwZSAhPSB0eXBlKSB7XG4gICAgICAgICAgaWYgKGRpciA8IDApIHtkaXIgPSAxOyBtb3ZlT25jZSgpOyBwb3Muc3RpY2t5ID0gXCJhZnRlclwiO31cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUpIHsgc2F3VHlwZSA9IHR5cGU7IH1cbiAgICAgICAgaWYgKGRpciA+IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBvcmlnRGlyLCB0cnVlKTtcbiAgICBpZiAoZXF1YWxDdXJzb3JQb3Mob2xkUG9zLCByZXN1bHQpKSB7IHJlc3VsdC5oaXRTaWRlID0gdHJ1ZTsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxuICAvLyBcInBhZ2VcIiBvciBcImxpbmVcIi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcbiAgLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgeCA9IHBvcy5sZWZ0LCB5O1xuICAgIGlmICh1bml0ID09IFwicGFnZVwiKSB7XG4gICAgICB2YXIgcGFnZVNpemUgPSBNYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB3aW4oY20pLmlubmVySGVpZ2h0IHx8IGRvYyhjbSkuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB2YXIgbW92ZUFtb3VudCA9IE1hdGgubWF4KHBhZ2VTaXplIC0gLjUgKiB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCAzKTtcbiAgICAgIHkgPSAoZGlyID4gMCA/IHBvcy5ib3R0b20gOiBwb3MudG9wKSArIGRpciAqIG1vdmVBbW91bnQ7XG5cbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHtcbiAgICAgIHkgPSBkaXIgPiAwID8gcG9zLmJvdHRvbSArIDMgOiBwb3MudG9wIC0gMztcbiAgICB9XG4gICAgdmFyIHRhcmdldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KTtcbiAgICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGRpciA8IDAgPyB5IDw9IDAgOiB5ID49IGRvYy5oZWlnaHQpIHsgdGFyZ2V0LmhpdFNpZGUgPSB0cnVlOyBicmVhayB9XG4gICAgICB5ICs9IGRpciAqIDU7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8vIENPTlRFTlRFRElUQUJMRSBJTlBVVCBTVFlMRVxuXG4gIHZhciBDb250ZW50RWRpdGFibGVJbnB1dCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHRoaXMubGFzdEFuY2hvck5vZGUgPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSB0aGlzLmxhc3RGb2N1c05vZGUgPSB0aGlzLmxhc3RGb2N1c09mZnNldCA9IG51bGw7XG4gICAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgdGhpcy5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBudWxsO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSBpbnB1dC5jbTtcbiAgICB2YXIgZGl2ID0gaW5wdXQuZGl2ID0gZGlzcGxheS5saW5lRGl2O1xuICAgIGRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGRpc2FibGVCcm93c2VyTWFnaWMoZGl2LCBjbS5vcHRpb25zLnNwZWxsY2hlY2ssIGNtLm9wdGlvbnMuYXV0b2NvcnJlY3QsIGNtLm9wdGlvbnMuYXV0b2NhcGl0YWxpemUpO1xuXG4gICAgZnVuY3Rpb24gYmVsb25nc1RvSW5wdXQoZSkge1xuICAgICAgZm9yICh2YXIgdCA9IGUudGFyZ2V0OyB0OyB0ID0gdC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICh0ID09IGRpdikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgIGlmICgvXFxiQ29kZU1pcnJvci0oPzpsaW5lKT93aWRnZXRcXGIvLnRlc3QodC5jbGFzc05hbWUpKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIG9uKGRpdiwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFiZWxvbmdzVG9JbnB1dChlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XG4gICAgICAvLyBJRSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnRzLCBzbyB3ZSBzY2hlZHVsZSBhIHJlYWQgZm9yIHRoZSBwYXN0ZWQgY29udGVudCBpbiB0aGlzIHdheVxuICAgICAgaWYgKGllX3ZlcnNpb24gPD0gMTEpIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS51cGRhdGVGcm9tRE9NKCk7IH0pLCAyMCk7IH1cbiAgICB9KTtcblxuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzJDEuY29tcG9zaW5nID0ge2RhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2V9O1xuICAgIH0pO1xuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnVwZGF0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCF0aGlzJDEuY29tcG9zaW5nKSB7IHRoaXMkMS5jb21wb3NpbmcgPSB7ZGF0YTogZS5kYXRhLCBkb25lOiBmYWxzZX07IH1cbiAgICB9KTtcbiAgICBvbihkaXYsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XG4gICAgICAgIGlmIChlLmRhdGEgIT0gdGhpcyQxLmNvbXBvc2luZy5kYXRhKSB7IHRoaXMkMS5yZWFkRnJvbURPTVNvb24oKTsgfVxuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgb24oZGl2LCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuZm9yY2VDb21wb3NpdGlvbkVuZCgpOyB9KTtcblxuICAgIG9uKGRpdiwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMkMS5jb21wb3NpbmcpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpOyB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNvcHlDdXQoZSkge1xuICAgICAgaWYgKCFiZWxvbmdzVG9JbnB1dChlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpOyB9XG4gICAgICB9IGVsc2UgaWYgKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCAwLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgICAgLy8gaU9TIGV4cG9zZXMgdGhlIGNsaXBib2FyZCBBUEksIGJ1dCBzZWVtcyB0byBkaXNjYXJkIGNvbnRlbnQgaW5zZXJ0ZWQgaW50byBpdFxuICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcIlRleHRcIiwgY29udGVudCk7XG4gICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIikgPT0gY29udGVudCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xuICAgICAgdmFyIGtsdWRnZSA9IGhpZGRlblRleHRhcmVhKCksIHRlID0ga2x1ZGdlLmZpcnN0Q2hpbGQ7XG4gICAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKHRlKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShrbHVkZ2UsIGNtLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO1xuICAgICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgIHZhciBoYWRGb2N1cyA9IGFjdGl2ZUVsdChyb290Tm9kZShkaXYpKTtcbiAgICAgIHNlbGVjdElucHV0KHRlKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpO1xuICAgICAgICBoYWRGb2N1cy5mb2N1cygpO1xuICAgICAgICBpZiAoaGFkRm9jdXMgPT0gZGl2KSB7IGlucHV0LnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7IH1cbiAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb24oZGl2LCBcImNvcHlcIiwgb25Db3B5Q3V0KTtcbiAgICBvbihkaXYsIFwiY3V0XCIsIG9uQ29weUN1dCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIC8vIExhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYobGFiZWwpIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKHRoaXMuY20sIGZhbHNlKTtcbiAgICByZXN1bHQuZm9jdXMgPSBhY3RpdmVFbHQocm9vdE5vZGUodGhpcy5kaXYpKSA9PSB0aGlzLmRpdjtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaW5mbywgdGFrZUZvY3VzKSB7XG4gICAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICBpZiAoaW5mby5mb2N1cyB8fCB0YWtlRm9jdXMpIHsgdGhpcy5zaG93UHJpbWFyeVNlbGVjdGlvbigpOyB9XG4gICAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKClcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1ByaW1hcnlTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksIGNtID0gdGhpcy5jbSwgcHJpbSA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgIHZhciBmcm9tID0gcHJpbS5mcm9tKCksIHRvID0gcHJpbS50bygpO1xuXG4gICAgaWYgKGNtLmRpc3BsYXkudmlld1RvID09IGNtLmRpc3BsYXkudmlld0Zyb20gfHwgZnJvbS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHRvLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyQW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICB2YXIgY3VyRm9jdXMgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcbiAgICAgICAgY21wKG1pblBvcyhjdXJBbmNob3IsIGN1ckZvY3VzKSwgZnJvbSkgPT0gMCAmJlxuICAgICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCB0bykgPT0gMClcbiAgICAgIHsgcmV0dXJuIH1cblxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIHZhciBzdGFydCA9IChmcm9tLmxpbmUgPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBwb3NUb0RPTShjbSwgZnJvbSkpIHx8XG4gICAgICAgIHtub2RlOiB2aWV3WzBdLm1lYXN1cmUubWFwWzJdLCBvZmZzZXQ6IDB9O1xuICAgIHZhciBlbmQgPSB0by5saW5lIDwgY20uZGlzcGxheS52aWV3VG8gJiYgcG9zVG9ET00oY20sIHRvKTtcbiAgICBpZiAoIWVuZCkge1xuICAgICAgdmFyIG1lYXN1cmUgPSB2aWV3W3ZpZXcubGVuZ3RoIC0gMV0ubWVhc3VyZTtcbiAgICAgIHZhciBtYXAgPSBtZWFzdXJlLm1hcHMgPyBtZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aCAtIDFdIDogbWVhc3VyZS5tYXA7XG4gICAgICBlbmQgPSB7bm9kZTogbWFwW21hcC5sZW5ndGggLSAxXSwgb2Zmc2V0OiBtYXBbbWFwLmxlbmd0aCAtIDJdIC0gbWFwW21hcC5sZW5ndGggLSAzXX07XG4gICAgfVxuXG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMCksIHJuZztcbiAgICB0cnkgeyBybmcgPSByYW5nZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQsIGVuZC5ub2RlKTsgfVxuICAgIGNhdGNoKGUpIHt9IC8vIE91ciBtb2RlbCBvZiB0aGUgRE9NIG1pZ2h0IGJlIG91dGRhdGVkLCBpbiB3aGljaCBjYXNlIHRoZSByYW5nZSB3ZSB0cnkgdG8gc2V0IGNhbiBiZSBpbXBvc3NpYmxlXG4gICAgaWYgKHJuZykge1xuICAgICAgaWYgKCFnZWNrbyAmJiBjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIHNlbC5jb2xsYXBzZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQpO1xuICAgICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICB9XG4gICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHsgc2VsLmFkZFJhbmdlKG9sZCk7IH1cbiAgICAgIGVsc2UgaWYgKGdlY2tvKSB7IHRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpOyB9XG4gICAgfVxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3RhcnRHcmFjZVBlcmlvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZ3JhY2VQZXJpb2QpO1xuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMkMS5zZWxlY3Rpb25DaGFuZ2VkKCkpXG4gICAgICAgIHsgdGhpcyQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XG4gICAgfSwgMjApO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93TXVsdGlwbGVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsIGluZm8uc2VsZWN0aW9uKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVtZW1iZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgIHRoaXMubGFzdEZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25JbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbC5yYW5nZUNvdW50KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5vZGUgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICByZXR1cm4gY29udGFpbnModGhpcy5kaXYsIG5vZGUpXG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiKSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSB8fCBhY3RpdmVFbHQocm9vdE5vZGUodGhpcy5kaXYpKSAhPSB0aGlzLmRpdilcbiAgICAgICAgeyB0aGlzLnNob3dTZWxlY3Rpb24odGhpcy5wcmVwYXJlU2VsZWN0aW9uKCksIHRydWUpOyB9XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZGl2LmJsdXIoKTsgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXYgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpKVxuICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5wb2xsU2VsZWN0aW9uKCk7IH0sIDIwKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcnVuSW5PcCh0aGlzLmNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSk7IH1cblxuICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgICBpZiAoaW5wdXQuY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICBpbnB1dC5wb2xsU2VsZWN0aW9uKCk7XG4gICAgICAgIGlucHV0LnBvbGxpbmcuc2V0KGlucHV0LmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxuICAgICAgc2VsLmZvY3VzTm9kZSAhPSB0aGlzLmxhc3RGb2N1c05vZGUgfHwgc2VsLmZvY3VzT2Zmc2V0ICE9IHRoaXMubGFzdEZvY3VzT2Zmc2V0XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnBvbGxTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCB8fCB0aGlzLmdyYWNlUGVyaW9kIHx8ICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSkgeyByZXR1cm4gfVxuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY207XG4gICAgLy8gT24gQW5kcm9pZCBDaHJvbWUgKHZlcnNpb24gNTYsIGF0IGxlYXN0KSwgYmFja3NwYWNpbmcgaW50byBhblxuICAgIC8vIHVuZWRpdGFibGUgYmxvY2sgZWxlbWVudCB3aWxsIHB1dCB0aGUgY3Vyc29yIGluIHRoYXQgZWxlbWVudCxcbiAgICAvLyBhbmQgdGhlbiwgYmVjYXVzZSBpdCdzIG5vdCBlZGl0YWJsZSwgaGlkZSB0aGUgdmlydHVhbCBrZXlib2FyZC5cbiAgICAvLyBCZWNhdXNlIEFuZHJvaWQgZG9lc24ndCBhbGxvdyB1cyB0byBhY3R1YWxseSBkZXRlY3QgYmFja3NwYWNlXG4gICAgLy8gcHJlc3NlcyBpbiBhIHNhbmUgd2F5LCB0aGlzIGNvZGUgY2hlY2tzIGZvciB3aGVuIHRoYXQgaGFwcGVuc1xuICAgIC8vIGFuZCBzaW11bGF0ZXMgYSBiYWNrc3BhY2UgcHJlc3MgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiB0aGlzLmNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoICYmIGlzSW5HdXR0ZXIoc2VsLmFuY2hvck5vZGUpKSB7XG4gICAgICB0aGlzLmNtLnRyaWdnZXJPbktleURvd24oe3R5cGU6IFwia2V5ZG93blwiLCBrZXlDb2RlOiA4LCBwcmV2ZW50RGVmYXVsdDogTWF0aC5hYnN9KTtcbiAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgICB2YXIgYW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmIChhbmNob3IgJiYgaGVhZCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgaWYgKGFuY2hvci5iYWQgfHwgaGVhZC5iYWQpIHsgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH1cbiAgICB9KTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCk7XG4gICAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2VsID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgdmFyIGZyb20gPSBzZWwuZnJvbSgpLCB0byA9IHNlbC50bygpO1xuICAgIGlmIChmcm9tLmNoID09IDAgJiYgZnJvbS5saW5lID4gY20uZmlyc3RMaW5lKCkpXG4gICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lIC0gMSwgZ2V0TGluZShjbS5kb2MsIGZyb20ubGluZSAtIDEpLmxlbmd0aCk7IH1cbiAgICBpZiAodG8uY2ggPT0gZ2V0TGluZShjbS5kb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoICYmIHRvLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxuICAgICAgeyB0byA9IFBvcyh0by5saW5lICsgMSwgMCk7IH1cbiAgICBpZiAoZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCB0by5saW5lID4gZGlzcGxheS52aWV3VG8gLSAxKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICB2YXIgZnJvbUluZGV4LCBmcm9tTGluZSwgZnJvbU5vZGU7XG4gICAgaWYgKGZyb20ubGluZSA9PSBkaXNwbGF5LnZpZXdGcm9tIHx8IChmcm9tSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBmcm9tLmxpbmUpKSA9PSAwKSB7XG4gICAgICBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbMF0ubGluZSk7XG4gICAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1swXS5ub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbZnJvbUluZGV4XS5saW5lKTtcbiAgICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHZhciB0b0luZGV4ID0gZmluZFZpZXdJbmRleChjbSwgdG8ubGluZSk7XG4gICAgdmFyIHRvTGluZSwgdG9Ob2RlO1xuICAgIGlmICh0b0luZGV4ID09IGRpc3BsYXkudmlldy5sZW5ndGggLSAxKSB7XG4gICAgICB0b0xpbmUgPSBkaXNwbGF5LnZpZXdUbyAtIDE7XG4gICAgICB0b05vZGUgPSBkaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b0xpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W3RvSW5kZXggKyAxXS5saW5lKSAtIDE7XG4gICAgICB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cblxuICAgIGlmICghZnJvbU5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbmV3VGV4dCA9IGNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tTm9kZSwgdG9Ob2RlLCBmcm9tTGluZSwgdG9MaW5lKSk7XG4gICAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKTtcbiAgICB3aGlsZSAobmV3VGV4dC5sZW5ndGggPiAxICYmIG9sZFRleHQubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGxzdChuZXdUZXh0KSA9PSBsc3Qob2xkVGV4dCkpIHsgbmV3VGV4dC5wb3AoKTsgb2xkVGV4dC5wb3AoKTsgdG9MaW5lLS07IH1cbiAgICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKzsgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9XG5cbiAgICB2YXIgY3V0RnJvbnQgPSAwLCBjdXRFbmQgPSAwO1xuICAgIHZhciBuZXdUb3AgPSBuZXdUZXh0WzBdLCBvbGRUb3AgPSBvbGRUZXh0WzBdLCBtYXhDdXRGcm9udCA9IE1hdGgubWluKG5ld1RvcC5sZW5ndGgsIG9sZFRvcC5sZW5ndGgpO1xuICAgIHdoaWxlIChjdXRGcm9udCA8IG1heEN1dEZyb250ICYmIG5ld1RvcC5jaGFyQ29kZUF0KGN1dEZyb250KSA9PSBvbGRUb3AuY2hhckNvZGVBdChjdXRGcm9udCkpXG4gICAgICB7ICsrY3V0RnJvbnQ7IH1cbiAgICB2YXIgbmV3Qm90ID0gbHN0KG5ld1RleHQpLCBvbGRCb3QgPSBsc3Qob2xkVGV4dCk7XG4gICAgdmFyIG1heEN1dEVuZCA9IE1hdGgubWluKG5ld0JvdC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEJvdC5sZW5ndGggLSAob2xkVGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCkpO1xuICAgIHdoaWxlIChjdXRFbmQgPCBtYXhDdXRFbmQgJiZcbiAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSlcbiAgICAgIHsgKytjdXRFbmQ7IH1cbiAgICAvLyBUcnkgdG8gbW92ZSBzdGFydCBvZiBjaGFuZ2UgdG8gc3RhcnQgb2Ygc2VsZWN0aW9uIGlmIGFtYmlndW91c1xuICAgIGlmIChuZXdUZXh0Lmxlbmd0aCA9PSAxICYmIG9sZFRleHQubGVuZ3RoID09IDEgJiYgZnJvbUxpbmUgPT0gZnJvbS5saW5lKSB7XG4gICAgICB3aGlsZSAoY3V0RnJvbnQgJiYgY3V0RnJvbnQgPiBmcm9tLmNoICYmXG4gICAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSkge1xuICAgICAgICBjdXRGcm9udC0tO1xuICAgICAgICBjdXRFbmQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdUZXh0W25ld1RleHQubGVuZ3RoIC0gMV0gPSBuZXdCb3Quc2xpY2UoMCwgbmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCkucmVwbGFjZSgvXlxcdTIwMGIrLywgXCJcIik7XG4gICAgbmV3VGV4dFswXSA9IG5ld1RleHRbMF0uc2xpY2UoY3V0RnJvbnQpLnJlcGxhY2UoL1xcdTIwMGIrJC8sIFwiXCIpO1xuXG4gICAgdmFyIGNoRnJvbSA9IFBvcyhmcm9tTGluZSwgY3V0RnJvbnQpO1xuICAgIHZhciBjaFRvID0gUG9zKHRvTGluZSwgb2xkVGV4dC5sZW5ndGggPyBsc3Qob2xkVGV4dCkubGVuZ3RoIC0gY3V0RW5kIDogMCk7XG4gICAgaWYgKG5ld1RleHQubGVuZ3RoID4gMSB8fCBuZXdUZXh0WzBdIHx8IGNtcChjaEZyb20sIGNoVG8pKSB7XG4gICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBuZXdUZXh0LCBjaEZyb20sIGNoVG8sIFwiK2lucHV0XCIpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZm9yY2VDb21wb3NpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUZyb21ET00oKTtcbiAgICB0aGlzLmRpdi5ibHVyKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCkgeyByZXR1cm4gfVxuICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5yZWFkRE9NVGltZW91dCA9IG51bGw7XG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xuICAgICAgICBpZiAodGhpcyQxLmNvbXBvc2luZy5kb25lKSB7IHRoaXMkMS5jb21wb3NpbmcgPSBudWxsOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gfVxuICAgICAgfVxuICAgICAgdGhpcyQxLnVwZGF0ZUZyb21ET00oKTtcbiAgICB9LCA4MCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnVwZGF0ZUZyb21ET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmNtLmlzUmVhZE9ubHkoKSB8fCAhdGhpcy5wb2xsQ29udGVudCgpKVxuICAgICAgeyBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ0NoYW5nZSh0aGlzJDEuY20pOyB9KTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUuY2hhckNvZGUgPT0gMCB8fCB0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMuY20uaXNSZWFkT25seSgpKVxuICAgICAgeyBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApOyB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmRpdi5jb250ZW50RWRpdGFibGUgPSBTdHJpbmcodmFsICE9IFwibm9jdXJzb3JcIik7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBwb3NUb0RPTShjbSwgcG9zKSB7XG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIHBvcy5saW5lKTtcbiAgICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSk7XG5cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKSwgc2lkZSA9IFwibGVmdFwiO1xuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MuY2gpO1xuICAgICAgc2lkZSA9IHBhcnRQb3MgJSAyID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpO1xuICAgIHJlc3VsdC5vZmZzZXQgPSByZXN1bHQuY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVzdWx0LmVuZCA6IHJlc3VsdC5zdGFydDtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBpc0luR3V0dGVyKG5vZGUpIHtcbiAgICBmb3IgKHZhciBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSlcbiAgICAgIHsgaWYgKC9Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyLy50ZXN0KHNjYW4uY2xhc3NOYW1lKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkgeyBpZiAoYmFkKSB7IHBvcy5iYWQgPSB0cnVlOyB9IHJldHVybiBwb3MgfVxuXG4gIGZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xuICAgIHZhciB0ZXh0ID0gXCJcIiwgY2xvc2luZyA9IGZhbHNlLCBsaW5lU2VwID0gY20uZG9jLmxpbmVTZXBhcmF0b3IoKSwgZXh0cmFMaW5lYnJlYWsgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiByZWNvZ25pemVNYXJrZXIoaWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pZCA9PSBpZDsgfSB9XG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoY2xvc2luZykge1xuICAgICAgICB0ZXh0ICs9IGxpbmVTZXA7XG4gICAgICAgIGlmIChleHRyYUxpbmVicmVhaykgeyB0ZXh0ICs9IGxpbmVTZXA7IH1cbiAgICAgICAgY2xvc2luZyA9IGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFRleHQoc3RyKSB7XG4gICAgICBpZiAoc3RyKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHRleHQgKz0gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgdmFyIGNtVGV4dCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY20tdGV4dFwiKTtcbiAgICAgICAgaWYgKGNtVGV4dCkge1xuICAgICAgICAgIGFkZFRleHQoY21UZXh0KTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2VySUQgPSBub2RlLmdldEF0dHJpYnV0ZShcImNtLW1hcmtlclwiKSwgcmFuZ2U7XG4gICAgICAgIGlmIChtYXJrZXJJRCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGNtLmZpbmRNYXJrcyhQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lICsgMSwgMCksIHJlY29nbml6ZU1hcmtlcigrbWFya2VySUQpKTtcbiAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoICYmIChyYW5nZSA9IGZvdW5kWzBdLmZpbmQoMCkpKVxuICAgICAgICAgICAgeyBhZGRUZXh0KGdldEJldHdlZW4oY20uZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bykuam9pbihsaW5lU2VwKSk7IH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgPT0gXCJmYWxzZVwiKSB7IHJldHVybiB9XG4gICAgICAgIHZhciBpc0Jsb2NrID0gL14ocHJlfGRpdnxwfGxpfHRhYmxlfGJyKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpO1xuICAgICAgICBpZiAoIS9eYnIkL2kudGVzdChub2RlLm5vZGVOYW1lKSAmJiBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA9PSAwKSB7IHJldHVybiB9XG5cbiAgICAgICAgaWYgKGlzQmxvY2spIHsgY2xvc2UoKTsgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IHdhbGsobm9kZS5jaGlsZE5vZGVzW2ldKTsgfVxuXG4gICAgICAgIGlmICgvXihwcmV8cCkkL2kudGVzdChub2RlLm5vZGVOYW1lKSkgeyBleHRyYUxpbmVicmVhayA9IHRydWU7IH1cbiAgICAgICAgaWYgKGlzQmxvY2spIHsgY2xvc2luZyA9IHRydWU7IH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIGFkZFRleHQobm9kZS5ub2RlVmFsdWUucmVwbGFjZSgvXFx1MjAwYi9nLCBcIlwiKS5yZXBsYWNlKC9cXHUwMGEwL2csIFwiIFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIHdhbGsoZnJvbSk7XG4gICAgICBpZiAoZnJvbSA9PSB0bykgeyBicmVhayB9XG4gICAgICBmcm9tID0gZnJvbS5uZXh0U2libGluZztcbiAgICAgIGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICBmdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGxpbmVOb2RlO1xuICAgIGlmIChub2RlID09IGNtLmRpc3BsYXkubGluZURpdikge1xuICAgICAgbGluZU5vZGUgPSBjbS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgaWYgKCFsaW5lTm9kZSkgeyByZXR1cm4gYmFkUG9zKGNtLmNsaXBQb3MoUG9zKGNtLmRpc3BsYXkudmlld1RvIC0gMSkpLCB0cnVlKSB9XG4gICAgICBub2RlID0gbnVsbDsgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsaW5lTm9kZSA9IG5vZGU7OyBsaW5lTm9kZSA9IGxpbmVOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKCFsaW5lTm9kZSB8fCBsaW5lTm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICBpZiAobGluZU5vZGUucGFyZW50Tm9kZSAmJiBsaW5lTm9kZS5wYXJlbnROb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSBjbS5kaXNwbGF5LnZpZXdbaV07XG4gICAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lTm9kZSlcbiAgICAgICAgeyByZXR1cm4gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIHtcbiAgICB2YXIgd3JhcHBlciA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZCwgYmFkID0gZmFsc2U7XG4gICAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgeyByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZVZpZXcubGluZSksIDApLCB0cnVlKSB9XG4gICAgaWYgKG5vZGUgPT0gd3JhcHBlcikge1xuICAgICAgYmFkID0gdHJ1ZTtcbiAgICAgIG5vZGUgPSB3cmFwcGVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZTtcbiAgICAgICAgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmUpLCBsaW5lLnRleHQubGVuZ3RoKSwgYmFkKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUgOiBudWxsLCB0b3BOb2RlID0gbm9kZTtcbiAgICBpZiAoIXRleHROb2RlICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMykge1xuICAgICAgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAob2Zmc2V0KSB7IG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7IH1cbiAgICB9XG4gICAgd2hpbGUgKHRvcE5vZGUucGFyZW50Tm9kZSAhPSB3cmFwcGVyKSB7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGU7IH1cbiAgICB2YXIgbWVhc3VyZSA9IGxpbmVWaWV3Lm1lYXN1cmUsIG1hcHMgPSBtZWFzdXJlLm1hcHM7XG5cbiAgICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAtMTsgaSA8IChtYXBzID8gbWFwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgIHZhciBtYXAgPSBpIDwgMCA/IG1lYXN1cmUubWFwIDogbWFwc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqICs9IDMpIHtcbiAgICAgICAgICB2YXIgY3VyTm9kZSA9IG1hcFtqICsgMl07XG4gICAgICAgICAgaWYgKGN1ck5vZGUgPT0gdGV4dE5vZGUgfHwgY3VyTm9kZSA9PSB0b3BOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVObyhpIDwgMCA/IGxpbmVWaWV3LmxpbmUgOiBsaW5lVmlldy5yZXN0W2ldKTtcbiAgICAgICAgICAgIHZhciBjaCA9IG1hcFtqXSArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGN1ck5vZGUgIT0gdGV4dE5vZGUpIHsgY2ggPSBtYXBbaiArIChvZmZzZXQgPyAxIDogMCldOyB9XG4gICAgICAgICAgICByZXR1cm4gUG9zKGxpbmUsIGNoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm91bmQgPSBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpO1xuICAgIGlmIChmb3VuZCkgeyByZXR1cm4gYmFkUG9zKGZvdW5kLCBiYWQpIH1cblxuICAgIC8vIEZJWE1FIHRoaXMgaXMgYWxsIHJlYWxseSBzaGFreS4gbWlnaHQgaGFuZGxlIHRoZSBmZXcgY2FzZXMgaXQgbmVlZHMgdG8gaGFuZGxlLCBidXQgbGlrZWx5IHRvIGNhdXNlIHByb2JsZW1zXG4gICAgZm9yICh2YXIgYWZ0ZXIgPSB0b3BOb2RlLm5leHRTaWJsaW5nLCBkaXN0ID0gdGV4dE5vZGUgPyB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gb2Zmc2V0IDogMDsgYWZ0ZXI7IGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmcpIHtcbiAgICAgIGZvdW5kID0gZmluZChhZnRlciwgYWZ0ZXIuZmlyc3RDaGlsZCwgMCk7XG4gICAgICBpZiAoZm91bmQpXG4gICAgICAgIHsgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggLSBkaXN0KSwgYmFkKSB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgZGlzdCArPSBhZnRlci50ZXh0Q29udGVudC5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgYmVmb3JlID0gdG9wTm9kZS5wcmV2aW91c1NpYmxpbmcsIGRpc3QkMSA9IG9mZnNldDsgYmVmb3JlOyBiZWZvcmUgPSBiZWZvcmUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICBmb3VuZCA9IGZpbmQoYmVmb3JlLCBiZWZvcmUuZmlyc3RDaGlsZCwgLTEpO1xuICAgICAgaWYgKGZvdW5kKVxuICAgICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoICsgZGlzdCQxKSwgYmFkKSB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgZGlzdCQxICs9IGJlZm9yZS50ZXh0Q29udGVudC5sZW5ndGg7IH1cbiAgICB9XG4gIH1cblxuICAvLyBURVhUQVJFQSBJTlBVVCBTVFlMRVxuXG4gIHZhciBUZXh0YXJlYUlucHV0ID0gZnVuY3Rpb24oY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgLy8gU2VlIGlucHV0LnBvbGwgYW5kIGlucHV0LnJlc2V0XG4gICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuXG4gICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGV4cGVjdCBpbnB1dCB0byBhcHBlYXIgcmVhbCBzb29uXG4gICAgLy8gbm93IChhZnRlciBzb21lIGV2ZW50IGxpa2UgJ2tleXByZXNzJyBvciAnaW5wdXQnKSBhbmQgYXJlXG4gICAgLy8gcG9sbGluZyBpbnRlbnNpdmVseS5cbiAgICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XG4gICAgLy8gU2VsZi1yZXNldHRpbmcgdGltZW91dCBmb3IgdGhlIHBvbGxlclxuICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBJRSBpc3N1ZSB3aXRoIHNlbGVjdGlvbiBiZWluZyBmb3Jnb3R0ZW4gd2hlbiBmb2N1cyBtb3ZlcyBhd2F5IGZyb20gdGV4dGFyZWFcbiAgICB0aGlzLmhhc1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0dGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IHRoaXMuY207XG4gICAgdGhpcy5jcmVhdGVGaWVsZChkaXNwbGF5KTtcbiAgICB2YXIgdGUgPSB0aGlzLnRleHRhcmVhO1xuXG4gICAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZSh0aGlzLndyYXBwZXIsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKTtcblxuICAgIC8vIE5lZWRlZCB0byBoaWRlIGJpZyBibHVlIGJsaW5raW5nIGN1cnNvciBvbiBNb2JpbGUgU2FmYXJpIChkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBpT1MgOCBhbnltb3JlKVxuICAgIGlmIChpb3MpIHsgdGUuc3R5bGUud2lkdGggPSBcIjBweFwiOyB9XG5cbiAgICBvbih0ZSwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMkMS5oYXNTZWxlY3Rpb24pIHsgdGhpcyQxLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cbiAgICAgIGlucHV0LnBvbGwoKTtcbiAgICB9KTtcblxuICAgIG9uKHRlLCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxuXG4gICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gK25ldyBEYXRlO1xuICAgICAgaW5wdXQuZmFzdFBvbGwoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb3B5Q3V0KGUpIHtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSk7XG4gICAgICB9IGVsc2UgaWYgKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIG51bGwsIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgICAgIHRlLnZhbHVlID0gcmFuZ2VzLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgICAgICBzZWxlY3RJbnB1dCh0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgeyBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9ICtuZXcgRGF0ZTsgfVxuICAgIH1cbiAgICBvbih0ZSwgXCJjdXRcIiwgcHJlcGFyZUNvcHlDdXQpO1xuICAgIG9uKHRlLCBcImNvcHlcIiwgcHJlcGFyZUNvcHlDdXQpO1xuXG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICBpZiAoIXRlLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9ICtuZXcgRGF0ZTtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhlIGBwYXN0ZWAgZXZlbnQgdG8gdGhlIHRleHRhcmVhIHNvIGl0J3MgaGFuZGxlZCBieSBpdHMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJwYXN0ZVwiKTtcbiAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEgPSBlLmNsaXBib2FyZERhdGE7XG4gICAgICB0ZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9KTtcblxuICAgIC8vIFByZXZlbnQgbm9ybWFsIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yICh3ZSBoYW5kbGUgb3VyIG93bilcbiAgICBvbihkaXNwbGF5LmxpbmVTcGFjZSwgXCJzZWxlY3RzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICB9KTtcblxuICAgIG9uKHRlLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFwiZnJvbVwiKTtcbiAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHsgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7IH1cbiAgICAgIGlucHV0LmNvbXBvc2luZyA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICByYW5nZTogY20ubWFya1RleHQoc3RhcnQsIGNtLmdldEN1cnNvcihcInRvXCIpLCB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBvbih0ZSwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7XG4gICAgICAgIGlucHV0LnBvbGwoKTtcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgIGlucHV0LmNvbXBvc2luZyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuY3JlYXRlRmllbGQgPSBmdW5jdGlvbiAoX2Rpc3BsYXkpIHtcbiAgICAvLyBXcmFwcyBhbmQgaGlkZXMgaW5wdXQgdGV4dGFyZWFcbiAgICB0aGlzLndyYXBwZXIgPSBoaWRkZW5UZXh0YXJlYSgpO1xuICAgIC8vIFRoZSBzZW1paGlkZGVuIHRleHRhcmVhIHRoYXQgaXMgZm9jdXNlZCB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAvLyBmb2N1c2VkLCBhbmQgcmVjZWl2ZXMgaW5wdXQuXG4gICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMud3JhcHBlci5maXJzdENoaWxkO1xuICAgIHZhciBvcHRzID0gdGhpcy5jbS5vcHRpb25zO1xuICAgIGRpc2FibGVCcm93c2VyTWFnaWModGhpcy50ZXh0YXJlYSwgb3B0cy5zcGVsbGNoZWNrLCBvcHRzLmF1dG9jb3JyZWN0LCBvcHRzLmF1dG9jYXBpdGFsaXplKTtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAvLyBMYWJlbCBmb3Igc2NyZWVucmVhZGVycywgYWNjZXNzaWJpbGl0eVxuICAgIGlmKGxhYmVsKSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZWRyYXcgdGhlIHNlbGVjdGlvbiBhbmQvb3IgY3Vyc29yXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbihjbSk7XG5cbiAgICAvLyBNb3ZlIHRoZSBoaWRkZW4gdGV4dGFyZWEgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgc2Nyb2xsaW5nIGFydGlmYWN0c1xuICAgIGlmIChjbS5vcHRpb25zLm1vdmVJbnB1dFdpdGhDdXJzb3IpIHtcbiAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkLCBcImRpdlwiKTtcbiAgICAgIHZhciB3cmFwT2ZmID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsaW5lT2ZmID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmVzdWx0LnRlVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy50b3AgKyBsaW5lT2ZmLnRvcCAtIHdyYXBPZmYudG9wKSk7XG4gICAgICByZXN1bHQudGVMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoIC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy5sZWZ0ICsgbGluZU9mZi5sZWZ0IC0gd3JhcE9mZi5sZWZ0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZHJhd24pIHtcbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LmN1cnNvckRpdiwgZHJhd24uY3Vyc29ycyk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbik7XG4gICAgaWYgKGRyYXduLnRlVG9wICE9IG51bGwpIHtcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSBkcmF3bi50ZVRvcCArIFwicHhcIjtcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gZHJhd24udGVMZWZ0ICsgXCJweFwiO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXNldCB0aGUgaW5wdXQgdG8gY29ycmVzcG9uZCB0byB0aGUgc2VsZWN0aW9uIChvciB0byBiZSBlbXB0eSxcbiAgLy8gd2hlbiBub3QgdHlwaW5nIGFuZCBub3RoaW5nIGlzIHNlbGVjdGVkKVxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh0eXBpbmcpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgdGhpcy5jb21wb3NpbmcgJiYgdHlwaW5nKSB7IHJldHVybiB9XG4gICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICB0aGlzLnJlc2V0dGluZyA9IHRydWU7XG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcbiAgICAgIHZhciBjb250ZW50ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gY29udGVudDtcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IHNlbGVjdElucHV0KHRoaXMudGV4dGFyZWEpOyB9XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gY29udGVudDsgfVxuICAgIH0gZWxzZSBpZiAoIXR5cGluZykge1xuICAgICAgdGhpcy5wcmV2SW5wdXQgPSB0aGlzLnRleHRhcmVhLnZhbHVlID0gXCJcIjtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsOyB9XG4gICAgfVxuICAgIHRoaXMucmVzZXR0aW5nID0gZmFsc2U7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRleHRhcmVhIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIgJiYgKCFtb2JpbGUgfHwgYWN0aXZlRWx0KHJvb3ROb2RlKHRoaXMudGV4dGFyZWEpKSAhPSB0aGlzLnRleHRhcmVhKSkge1xuICAgICAgdHJ5IHsgdGhpcy50ZXh0YXJlYS5mb2N1cygpOyB9XG4gICAgICBjYXRjaCAoZSkge30gLy8gSUU4IHdpbGwgdGhyb3cgaWYgdGhlIHRleHRhcmVhIGlzIGRpc3BsYXk6IG5vbmUgb3Igbm90IGluIERPTVxuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLnRleHRhcmVhLmJsdXIoKTsgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IDA7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zbG93UG9sbCgpOyB9O1xuXG4gIC8vIFBvbGwgZm9yIGlucHV0IGNoYW5nZXMsIHVzaW5nIHRoZSBub3JtYWwgcmF0ZSBvZiBwb2xsaW5nLiBUaGlzXG4gIC8vIHJ1bnMgYXMgbG9uZyBhcyB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNsb3dQb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nRmFzdCkgeyByZXR1cm4gfVxuICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLnBvbGwoKTtcbiAgICAgIGlmICh0aGlzJDEuY20uc3RhdGUuZm9jdXNlZCkgeyB0aGlzJDEuc2xvd1BvbGwoKTsgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFdoZW4gYW4gZXZlbnQgaGFzIGp1c3QgY29tZSBpbiB0aGF0IGlzIGxpa2VseSB0byBhZGQgb3IgY2hhbmdlXG4gIC8vIHNvbWV0aGluZyBpbiB0aGUgaW5wdXQgdGV4dGFyZWEsIHdlIHBvbGwgZmFzdGVyLCB0byBlbnN1cmUgdGhhdFxuICAvLyB0aGUgY2hhbmdlIGFwcGVhcnMgb24gdGhlIHNjcmVlbiBxdWlja2x5LlxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mYXN0UG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWlzc2VkID0gZmFsc2UsIGlucHV0ID0gdGhpcztcbiAgICBpbnB1dC5wb2xsaW5nRmFzdCA9IHRydWU7XG4gICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gaW5wdXQucG9sbCgpO1xuICAgICAgaWYgKCFjaGFuZ2VkICYmICFtaXNzZWQpIHttaXNzZWQgPSB0cnVlOyBpbnB1dC5wb2xsaW5nLnNldCg2MCwgcCk7fVxuICAgICAgZWxzZSB7aW5wdXQucG9sbGluZ0Zhc3QgPSBmYWxzZTsgaW5wdXQuc2xvd1BvbGwoKTt9XG4gICAgfVxuICAgIGlucHV0LnBvbGxpbmcuc2V0KDIwLCBwKTtcbiAgfTtcblxuICAvLyBSZWFkIGlucHV0IGZyb20gdGhlIHRleHRhcmVhLCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCB0byBtYXRjaC5cbiAgLy8gV2hlbiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsIGl0IGlzIHByZXNlbnQgaW4gdGhlIHRleHRhcmVhLCBhbmRcbiAgLy8gc2VsZWN0ZWQgKHVubGVzcyBpdCBpcyBodWdlLCBpbiB3aGljaCBjYXNlIGEgcGxhY2Vob2xkZXIgaXNcbiAgLy8gdXNlZCkuIFdoZW4gbm90aGluZyBpcyBzZWxlY3RlZCwgdGhlIGN1cnNvciBzaXRzIGFmdGVyIHByZXZpb3VzbHlcbiAgLy8gc2VlbiB0ZXh0IChjYW4gYmUgZW1wdHkpLCB3aGljaCBpcyBzdG9yZWQgaW4gcHJldklucHV0ICh3ZSBtdXN0XG4gIC8vIG5vdCByZXNldCB0aGUgdGV4dGFyZWEgd2hlbiB0eXBpbmcsIGJlY2F1c2UgdGhhdCBicmVha3MgSU1FKS5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgaW5wdXQgPSB0aGlzLnRleHRhcmVhLCBwcmV2SW5wdXQgPSB0aGlzLnByZXZJbnB1dDtcbiAgICAvLyBTaW5jZSB0aGlzIGlzIGNhbGxlZCBhICpsb3QqLCB0cnkgdG8gYmFpbCBvdXQgYXMgY2hlYXBseSBhc1xuICAgIC8vIHBvc3NpYmxlIHdoZW4gaXQgaXMgY2xlYXIgdGhhdCBub3RoaW5nIGhhcHBlbmVkLiBoYXNTZWxlY3Rpb25cbiAgICAvLyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBsb3Qgb2YgdGV4dCBpbiB0aGUgdGV4dGFyZWEsXG4gICAgLy8gaW4gd2hpY2ggY2FzZSByZWFkaW5nIGl0cyB2YWx1ZSB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nIHx8IHRoaXMucmVzZXR0aW5nIHx8ICFjbS5zdGF0ZS5mb2N1c2VkIHx8XG4gICAgICAgIChoYXNTZWxlY3Rpb24oaW5wdXQpICYmICFwcmV2SW5wdXQgJiYgIXRoaXMuY29tcG9zaW5nKSB8fFxuICAgICAgICBjbS5pc1JlYWRPbmx5KCkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgfHwgY20uc3RhdGUua2V5U2VxKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZTtcbiAgICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIGJhaWwuXG4gICAgaWYgKHRleHQgPT0gcHJldklucHV0ICYmICFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2ljYWwgc2VsZWN0aW9uIHJlc2V0dGluZyBpbiBJRTkvMTAsIGFuZFxuICAgIC8vIGluZXhwbGljYWJsZSBhcHBlYXJhbmNlIG9mIHByaXZhdGUgYXJlYSB1bmljb2RlIGNoYXJhY3RlcnMgb25cbiAgICAvLyBzb21lIGtleSBjb21ib3MgaW4gTWFjICgjMjY4OSkuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzLmhhc1NlbGVjdGlvbiA9PT0gdGV4dCB8fFxuICAgICAgICBtYWMgJiYgL1tcXHVmNzAwLVxcdWY3ZmZdLy50ZXN0KHRleHQpKSB7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoY20uZG9jLnNlbCA9PSBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51KSB7XG4gICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZmlyc3QgPT0gMHgyMDBiICYmICFwcmV2SW5wdXQpIHsgcHJldklucHV0ID0gXCJcXHUyMDBiXCI7IH1cbiAgICAgIGlmIChmaXJzdCA9PSAweDIxZGEpIHsgdGhpcy5yZXNldCgpOyByZXR1cm4gdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIikgfVxuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xuICAgIHZhciBzYW1lID0gMCwgbCA9IE1hdGgubWluKHByZXZJbnB1dC5sZW5ndGgsIHRleHQubGVuZ3RoKTtcbiAgICB3aGlsZSAoc2FtZSA8IGwgJiYgcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSkgPT0gdGV4dC5jaGFyQ29kZUF0KHNhbWUpKSB7ICsrc2FtZTsgfVxuXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHlUZXh0SW5wdXQoY20sIHRleHQuc2xpY2Uoc2FtZSksIHByZXZJbnB1dC5sZW5ndGggLSBzYW1lLFxuICAgICAgICAgICAgICAgICAgICAgbnVsbCwgdGhpcyQxLmNvbXBvc2luZyA/IFwiKmNvbXBvc2VcIiA6IG51bGwpO1xuXG4gICAgICAvLyBEb24ndCBsZWF2ZSBsb25nIHRleHQgaW4gdGhlIHRleHRhcmVhLCBzaW5jZSBpdCBtYWtlcyBmdXJ0aGVyIHBvbGxpbmcgc2xvd1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMTAwMCB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSkgeyBpbnB1dC52YWx1ZSA9IHRoaXMkMS5wcmV2SW5wdXQgPSBcIlwiOyB9XG4gICAgICBlbHNlIHsgdGhpcyQxLnByZXZJbnB1dCA9IHRleHQ7IH1cblxuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO1xuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlID0gY20ubWFya1RleHQodGhpcyQxLmNvbXBvc2luZy5zdGFydCwgY20uZ2V0Q3Vyc29yKFwidG9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5lbnN1cmVQb2xsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QgJiYgdGhpcy5wb2xsKCkpIHsgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlOyB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxuICAgIHRoaXMuZmFzdFBvbGwoKTtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgdGUgPSBpbnB1dC50ZXh0YXJlYTtcbiAgICBpZiAoaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nKSB7IGlucHV0LmNvbnRleHRNZW51UGVuZGluZygpOyB9XG4gICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSksIHNjcm9sbFBvcyA9IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIGlmICghcG9zIHx8IHByZXN0bykgeyByZXR1cm4gfSAvLyBPcGVyYSBpcyBkaWZmaWN1bHQuXG5cbiAgICAvLyBSZXNldCB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBvbmx5IGlmIHRoZSBjbGljayBpcyBkb25lIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvblxuICAgIC8vIGFuZCAncmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51JyBvcHRpb24gaXMgdHJ1ZS5cbiAgICB2YXIgcmVzZXQgPSBjbS5vcHRpb25zLnJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudTtcbiAgICBpZiAocmVzZXQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID09IC0xKVxuICAgICAgeyBvcGVyYXRpb24oY20sIHNldFNlbGVjdGlvbikoY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zKSwgc2VsX2RvbnRTY3JvbGwpOyB9XG5cbiAgICB2YXIgb2xkQ1NTID0gdGUuc3R5bGUuY3NzVGV4dCwgb2xkV3JhcHBlckNTUyA9IGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dDtcbiAgICB2YXIgd3JhcHBlckJveCA9IGlucHV0LndyYXBwZXIub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IHN0YXRpY1wiO1xuICAgIHRlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDtcXG4gICAgICB0b3A6IFwiICsgKGUuY2xpZW50WSAtIHdyYXBwZXJCb3gudG9wIC0gNSkgKyBcInB4OyBsZWZ0OiBcIiArIChlLmNsaWVudFggLSB3cmFwcGVyQm94LmxlZnQgLSA1KSArIFwicHg7XFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIgKyAoaWUgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArIFwiO1xcbiAgICAgIG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XCI7XG4gICAgdmFyIG9sZFNjcm9sbFk7XG4gICAgaWYgKHdlYmtpdCkgeyBvbGRTY3JvbGxZID0gdGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5zY3JvbGxZOyB9IC8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSAoIzI3MTIpXG4gICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgIGlmICh3ZWJraXQpIHsgdGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5zY3JvbGxUbyhudWxsLCBvbGRTY3JvbGxZKTsgfVxuICAgIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAvLyBBZGRzIFwiU2VsZWN0IGFsbFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxuICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyB0ZS52YWx1ZSA9IGlucHV0LnByZXZJbnB1dCA9IFwiIFwiOyB9XG4gICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gcmVoaWRlO1xuICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgIGNsZWFyVGltZW91dChkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCk7XG5cbiAgICAvLyBTZWxlY3QtYWxsIHdpbGwgYmUgZ3JleWVkIG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2VsZWN0LCBzb1xuICAgIC8vIHRoaXMgYWRkcyBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB3ZSBjYW4gbGF0ZXIgY2hlY2sgd2hldGhlclxuICAgIC8vIGl0IGdvdCBzZWxlY3RlZC5cbiAgICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIHtcbiAgICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgIHZhciBleHR2YWwgPSBcIlxcdTIwMGJcIiArIChzZWxlY3RlZCA/IHRlLnZhbHVlIDogXCJcIik7XG4gICAgICAgIHRlLnZhbHVlID0gXCJcXHUyMWRhXCI7IC8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cbiAgICAgICAgdGUudmFsdWUgPSBleHR2YWw7XG4gICAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXCJcIiA6IFwiXFx1MjAwYlwiO1xuICAgICAgICB0ZS5zZWxlY3Rpb25TdGFydCA9IDE7IHRlLnNlbGVjdGlvbkVuZCA9IGV4dHZhbC5sZW5ndGg7XG4gICAgICAgIC8vIFJlLXNldCB0aGlzLCBpbiBjYXNlIHNvbWUgb3RoZXIgaGFuZGxlciB0b3VjaGVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gY20uZG9jLnNlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVoaWRlKCkge1xuICAgICAgaWYgKGlucHV0LmNvbnRleHRNZW51UGVuZGluZyAhPSByZWhpZGUpIHsgcmV0dXJuIH1cbiAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlO1xuICAgICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gb2xkV3JhcHBlckNTUztcbiAgICAgIHRlLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFBvcyk7IH1cblxuICAgICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgdXNlciBjaG9vc2luZyBzZWxlY3QtYWxsXG4gICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIWllIHx8IChpZSAmJiBpZV92ZXJzaW9uIDwgOSkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTsgfVxuICAgICAgICB2YXIgaSA9IDAsIHBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPT0gY20uZG9jLnNlbCAmJiB0ZS5zZWxlY3Rpb25TdGFydCA9PSAwICYmXG4gICAgICAgICAgICAgIHRlLnNlbGVjdGlvbkVuZCA+IDAgJiYgaW5wdXQucHJldklucHV0ID09IFwiXFx1MjAwYlwiKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24oY20sIHNlbGVjdEFsbCkoY20pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSsrIDwgMTApIHtcbiAgICAgICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCA1MDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCAyMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTsgfVxuICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xuICAgICAgZV9zdG9wKGUpO1xuICAgICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9mZih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcbiAgICAgICAgc2V0VGltZW91dChyZWhpZGUsIDIwKTtcbiAgICAgIH07XG4gICAgICBvbih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChyZWhpZGUsIDUwKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICghdmFsKSB7IHRoaXMucmVzZXQoKTsgfVxuICAgIHRoaXMudGV4dGFyZWEuZGlzYWJsZWQgPSB2YWwgPT0gXCJub2N1cnNvclwiO1xuICAgIHRoaXMudGV4dGFyZWEucmVhZE9ubHkgPSAhIXZhbDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlID0gZnVuY3Rpb24gKCkge307XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZnJvbVRleHRBcmVhKHRleHRhcmVhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XG4gICAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlO1xuICAgIGlmICghb3B0aW9ucy50YWJpbmRleCAmJiB0ZXh0YXJlYS50YWJJbmRleClcbiAgICAgIHsgb3B0aW9ucy50YWJpbmRleCA9IHRleHRhcmVhLnRhYkluZGV4OyB9XG4gICAgaWYgKCFvcHRpb25zLnBsYWNlaG9sZGVyICYmIHRleHRhcmVhLnBsYWNlaG9sZGVyKVxuICAgICAgeyBvcHRpb25zLnBsYWNlaG9sZGVyID0gdGV4dGFyZWEucGxhY2Vob2xkZXI7IH1cbiAgICAvLyBTZXQgYXV0b2ZvY3VzIHRvIHRydWUgaWYgdGhpcyB0ZXh0YXJlYSBpcyBmb2N1c2VkLCBvciBpZiBpdCBoYXNcbiAgICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgPT0gbnVsbCkge1xuICAgICAgdmFyIGhhc0ZvY3VzID0gYWN0aXZlRWx0KHJvb3ROb2RlKHRleHRhcmVhKSk7XG4gICAgICBvcHRpb25zLmF1dG9mb2N1cyA9IGhhc0ZvY3VzID09IHRleHRhcmVhIHx8XG4gICAgICAgIHRleHRhcmVhLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSAhPSBudWxsICYmIGhhc0ZvY3VzID09IGRvY3VtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZSgpIHt0ZXh0YXJlYS52YWx1ZSA9IGNtLmdldFZhbHVlKCk7fVxuXG4gICAgdmFyIHJlYWxTdWJtaXQ7XG4gICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcbiAgICAgIG9uKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgLy8gRGVwbG9yYWJsZSBoYWNrIHRvIG1ha2UgdGhlIHN1Ym1pdCBtZXRob2QgZG8gdGhlIHJpZ2h0IHRoaW5nLlxuICAgICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpIHtcbiAgICAgICAgdmFyIGZvcm0gPSB0ZXh0YXJlYS5mb3JtO1xuICAgICAgICByZWFsU3VibWl0ID0gZm9ybS5zdWJtaXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHdyYXBwZWRTdWJtaXQgPSBmb3JtLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHdyYXBwZWRTdWJtaXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuZmluaXNoSW5pdCA9IGZ1bmN0aW9uIChjbSkge1xuICAgICAgY20uc2F2ZSA9IHNhdmU7XG4gICAgICBjbS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRleHRhcmVhOyB9O1xuICAgICAgY20udG9UZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20udG9UZXh0QXJlYSA9IGlzTmFOOyAvLyBQcmV2ZW50IHRoaXMgZnJvbSBiZWluZyByYW4gdHdpY2VcbiAgICAgICAgc2F2ZSgpO1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtLmdldFdyYXBwZXJFbGVtZW50KCkpO1xuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcbiAgICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUgJiYgdHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHsgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0OyB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB2YXIgY20gPSBDb2RlTWlycm9yKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0ZXh0YXJlYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0ZXh0YXJlYS5uZXh0U2libGluZyk7IH0sXG4gICAgICBvcHRpb25zKTtcbiAgICByZXR1cm4gY21cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpIHtcbiAgICBDb2RlTWlycm9yLm9mZiA9IG9mZjtcbiAgICBDb2RlTWlycm9yLm9uID0gb247XG4gICAgQ29kZU1pcnJvci53aGVlbEV2ZW50UGl4ZWxzID0gd2hlZWxFdmVudFBpeGVscztcbiAgICBDb2RlTWlycm9yLkRvYyA9IERvYztcbiAgICBDb2RlTWlycm9yLnNwbGl0TGluZXMgPSBzcGxpdExpbmVzQXV0bztcbiAgICBDb2RlTWlycm9yLmNvdW50Q29sdW1uID0gY291bnRDb2x1bW47XG4gICAgQ29kZU1pcnJvci5maW5kQ29sdW1uID0gZmluZENvbHVtbjtcbiAgICBDb2RlTWlycm9yLmlzV29yZENoYXIgPSBpc1dvcmRDaGFyQmFzaWM7XG4gICAgQ29kZU1pcnJvci5QYXNzID0gUGFzcztcbiAgICBDb2RlTWlycm9yLnNpZ25hbCA9IHNpZ25hbDtcbiAgICBDb2RlTWlycm9yLkxpbmUgPSBMaW5lO1xuICAgIENvZGVNaXJyb3IuY2hhbmdlRW5kID0gY2hhbmdlRW5kO1xuICAgIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwgPSBzY3JvbGxiYXJNb2RlbDtcbiAgICBDb2RlTWlycm9yLlBvcyA9IFBvcztcbiAgICBDb2RlTWlycm9yLmNtcFBvcyA9IGNtcDtcbiAgICBDb2RlTWlycm9yLm1vZGVzID0gbW9kZXM7XG4gICAgQ29kZU1pcnJvci5taW1lTW9kZXMgPSBtaW1lTW9kZXM7XG4gICAgQ29kZU1pcnJvci5yZXNvbHZlTW9kZSA9IHJlc29sdmVNb2RlO1xuICAgIENvZGVNaXJyb3IuZ2V0TW9kZSA9IGdldE1vZGU7XG4gICAgQ29kZU1pcnJvci5tb2RlRXh0ZW5zaW9ucyA9IG1vZGVFeHRlbnNpb25zO1xuICAgIENvZGVNaXJyb3IuZXh0ZW5kTW9kZSA9IGV4dGVuZE1vZGU7XG4gICAgQ29kZU1pcnJvci5jb3B5U3RhdGUgPSBjb3B5U3RhdGU7XG4gICAgQ29kZU1pcnJvci5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICBDb2RlTWlycm9yLmlubmVyTW9kZSA9IGlubmVyTW9kZTtcbiAgICBDb2RlTWlycm9yLmNvbW1hbmRzID0gY29tbWFuZHM7XG4gICAgQ29kZU1pcnJvci5rZXlNYXAgPSBrZXlNYXA7XG4gICAgQ29kZU1pcnJvci5rZXlOYW1lID0ga2V5TmFtZTtcbiAgICBDb2RlTWlycm9yLmlzTW9kaWZpZXJLZXkgPSBpc01vZGlmaWVyS2V5O1xuICAgIENvZGVNaXJyb3IubG9va3VwS2V5ID0gbG9va3VwS2V5O1xuICAgIENvZGVNaXJyb3Iubm9ybWFsaXplS2V5TWFwID0gbm9ybWFsaXplS2V5TWFwO1xuICAgIENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtID0gU3RyaW5nU3RyZWFtO1xuICAgIENvZGVNaXJyb3IuU2hhcmVkVGV4dE1hcmtlciA9IFNoYXJlZFRleHRNYXJrZXI7XG4gICAgQ29kZU1pcnJvci5UZXh0TWFya2VyID0gVGV4dE1hcmtlcjtcbiAgICBDb2RlTWlycm9yLkxpbmVXaWRnZXQgPSBMaW5lV2lkZ2V0O1xuICAgIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdCA9IGVfcHJldmVudERlZmF1bHQ7XG4gICAgQ29kZU1pcnJvci5lX3N0b3BQcm9wYWdhdGlvbiA9IGVfc3RvcFByb3BhZ2F0aW9uO1xuICAgIENvZGVNaXJyb3IuZV9zdG9wID0gZV9zdG9wO1xuICAgIENvZGVNaXJyb3IuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgICBDb2RlTWlycm9yLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgQ29kZU1pcnJvci5ybUNsYXNzID0gcm1DbGFzcztcbiAgICBDb2RlTWlycm9yLmtleU5hbWVzID0ga2V5TmFtZXM7XG4gIH1cblxuICAvLyBFRElUT1IgQ09OU1RSVUNUT1JcblxuICBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IpO1xuXG4gIGFkZEVkaXRvck1ldGhvZHMoQ29kZU1pcnJvcik7XG5cbiAgLy8gU2V0IHVwIG1ldGhvZHMgb24gQ29kZU1pcnJvcidzIHByb3RvdHlwZSB0byByZWRpcmVjdCB0byB0aGUgZWRpdG9yJ3MgZG9jdW1lbnQuXG4gIHZhciBkb250RGVsZWdhdGUgPSBcIml0ZXIgaW5zZXJ0IHJlbW92ZSBjb3B5IGdldEVkaXRvciBjb25zdHJ1Y3RvclwiLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBEb2MucHJvdG90eXBlKSB7IGlmIChEb2MucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApICYmIGluZGV4T2YoZG9udERlbGVnYXRlLCBwcm9wKSA8IDApXG4gICAgeyBDb2RlTWlycm9yLnByb3RvdHlwZVtwcm9wXSA9IChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMuZG9jLCBhcmd1bWVudHMpfVxuICAgIH0pKERvYy5wcm90b3R5cGVbcHJvcF0pOyB9IH1cblxuICBldmVudE1peGluKERvYyk7XG4gIENvZGVNaXJyb3IuaW5wdXRTdHlsZXMgPSB7XCJ0ZXh0YXJlYVwiOiBUZXh0YXJlYUlucHV0LCBcImNvbnRlbnRlZGl0YWJsZVwiOiBDb250ZW50RWRpdGFibGVJbnB1dH07XG5cbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcbiAgLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZSA9IGZ1bmN0aW9uKG5hbWUvKiwgbW9kZSwg4oCmKi8pIHtcbiAgICBpZiAoIUNvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSAmJiBuYW1lICE9IFwibnVsbFwiKSB7IENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWU7IH1cbiAgICBkZWZpbmVNb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FID0gZGVmaW5lTUlNRTtcblxuICAvLyBNaW5pbWFsIGRlZmF1bHQgbW9kZS5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibnVsbFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoe3Rva2VuOiBmdW5jdGlvbiAoc3RyZWFtKSB7IHJldHVybiBzdHJlYW0uc2tpcFRvRW5kKCk7IH19KTsgfSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvcGxhaW5cIiwgXCJudWxsXCIpO1xuXG4gIC8vIEVYVEVOU0lPTlNcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICB9O1xuICBDb2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgRG9jLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEgPSBmcm9tVGV4dEFyZWE7XG5cbiAgYWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcik7XG5cbiAgQ29kZU1pcnJvci52ZXJzaW9uID0gXCI1LjY1LjIwXCI7XG5cbiAgcmV0dXJuIENvZGVNaXJyb3I7XG5cbn0pKSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJzZWxmIiwiQ29kZU1pcnJvciIsInVzZXJBZ2VudCIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiZ2Vja28iLCJ0ZXN0IiwiaWVfdXB0bzEwIiwiaWVfMTF1cCIsImV4ZWMiLCJlZGdlIiwiaWUiLCJpZV92ZXJzaW9uIiwiZG9jdW1lbnQiLCJkb2N1bWVudE1vZGUiLCJ3ZWJraXQiLCJxdHdlYmtpdCIsImNocm9tZSIsImNocm9tZV92ZXJzaW9uIiwicHJlc3RvIiwic2FmYXJpIiwidmVuZG9yIiwibWFjX2dlTW91bnRhaW5MaW9uIiwicGhhbnRvbSIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwiYW5kcm9pZCIsIm1vYmlsZSIsIm1hYyIsImNocm9tZU9TIiwid2luZG93cyIsInByZXN0b192ZXJzaW9uIiwibWF0Y2giLCJOdW1iZXIiLCJmbGlwQ3RybENtZCIsImNhcHR1cmVSaWdodENsaWNrIiwiY2xhc3NUZXN0IiwiY2xzIiwiUmVnRXhwIiwicm1DbGFzcyIsIm5vZGUiLCJjdXJyZW50IiwiY2xhc3NOYW1lIiwiYWZ0ZXIiLCJzbGljZSIsImluZGV4IiwibGVuZ3RoIiwicmVtb3ZlQ2hpbGRyZW4iLCJlIiwiY291bnQiLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGRyZW5BbmRBZGQiLCJwYXJlbnQiLCJhcHBlbmRDaGlsZCIsImVsdCIsInRhZyIsImNvbnRlbnQiLCJzdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJpIiwiZWx0UCIsInNldEF0dHJpYnV0ZSIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzdGFydCIsImVuZCIsImVuZE5vZGUiLCJyIiwic2V0RW5kIiwic2V0U3RhcnQiLCJib2R5IiwiY3JlYXRlVGV4dFJhbmdlIiwibW92ZVRvRWxlbWVudFRleHQiLCJwYXJlbnROb2RlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwibW92ZVN0YXJ0IiwiY29udGFpbnMiLCJjaGlsZCIsIm5vZGVUeXBlIiwiaG9zdCIsImFjdGl2ZUVsdCIsInJvb3ROb2RlIiwiZG9jIiwib3duZXJEb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiYWRkQ2xhc3MiLCJqb2luQ2xhc3NlcyIsImEiLCJiIiwiYXMiLCJzcGxpdCIsInNlbGVjdElucHV0Iiwic2VsZWN0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJ2YWx1ZSIsIl9lIiwiY20iLCJkaXNwbGF5Iiwid3JhcHBlciIsInJvb3QiLCJlbGVtZW50IiwiZ2V0Um9vdE5vZGUiLCJ3aW4iLCJkZWZhdWx0VmlldyIsImJpbmQiLCJmIiwiYXJncyIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsImFyZ3VtZW50cyIsImFwcGx5IiwiY29weU9iaiIsIm9iaiIsInRhcmdldCIsIm92ZXJ3cml0ZSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImNvdW50Q29sdW1uIiwic3RyaW5nIiwidGFiU2l6ZSIsInN0YXJ0SW5kZXgiLCJzdGFydFZhbHVlIiwic2VhcmNoIiwibiIsIm5leHRUYWIiLCJpbmRleE9mIiwiRGVsYXllZCIsImlkIiwidGltZSIsImhhbmRsZXIiLCJvblRpbWVvdXQiLCJEYXRlIiwic2V0VGltZW91dCIsInNldCIsIm1zIiwiY2xlYXJUaW1lb3V0IiwiYXJyYXkiLCJzY3JvbGxlckdhcCIsIlBhc3MiLCJ0b1N0cmluZyIsInNlbF9kb250U2Nyb2xsIiwic2Nyb2xsIiwic2VsX21vdXNlIiwib3JpZ2luIiwic2VsX21vdmUiLCJmaW5kQ29sdW1uIiwiZ29hbCIsInBvcyIsImNvbCIsInNraXBwZWQiLCJNYXRoIiwibWluIiwic3BhY2VTdHJzIiwic3BhY2VTdHIiLCJwdXNoIiwibHN0IiwiYXJyIiwibWFwIiwib3V0IiwiaW5zZXJ0U29ydGVkIiwic2NvcmUiLCJwcmlvcml0eSIsInNwbGljZSIsIm5vdGhpbmciLCJjcmVhdGVPYmoiLCJiYXNlIiwicHJvcHMiLCJpbnN0IiwiT2JqZWN0IiwiY3JlYXRlIiwibm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIiLCJpc1dvcmRDaGFyQmFzaWMiLCJjaCIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJpc1dvcmRDaGFyIiwiaGVscGVyIiwic291cmNlIiwiaXNFbXB0eSIsImV4dGVuZGluZ0NoYXJzIiwiaXNFeHRlbmRpbmdDaGFyIiwiY2hhckNvZGVBdCIsInNraXBFeHRlbmRpbmdDaGFycyIsInN0ciIsImRpciIsImNoYXJBdCIsImZpbmRGaXJzdCIsInByZWQiLCJmcm9tIiwidG8iLCJtaWRGIiwibWlkIiwiY2VpbCIsImZsb29yIiwiaXRlcmF0ZUJpZGlTZWN0aW9ucyIsIm9yZGVyIiwiZm91bmQiLCJwYXJ0IiwibWF4IiwibGV2ZWwiLCJiaWRpT3RoZXIiLCJnZXRCaWRpUGFydEF0Iiwic3RpY2t5IiwiY3VyIiwiYmlkaU9yZGVyaW5nIiwibG93VHlwZXMiLCJhcmFiaWNUeXBlcyIsImNoYXJUeXBlIiwiY29kZSIsImJpZGlSRSIsImlzTmV1dHJhbCIsImlzU3Ryb25nIiwiY291bnRzQXNMZWZ0IiwiY291bnRzQXNOdW0iLCJCaWRpU3BhbiIsImRpcmVjdGlvbiIsIm91dGVyVHlwZSIsImxlbiIsInR5cGVzIiwiaSQxIiwicHJldiIsInR5cGUiLCJpJDIiLCJ0eXBlJDEiLCJpJDMiLCJwcmV2JDEiLCJ0eXBlJDIiLCJpJDQiLCJ0eXBlJDMiLCJyZXBsYWNlIiwiaiIsImkkNSIsImN1ciQxIiwidHlwZSQ0IiwiaSQ2IiwiZW5kJDEiLCJiZWZvcmUiLCJyZXBsYWNlJDEiLCJqJDEiLCJtIiwiaSQ3IiwiYXQiLCJpc1JUTCIsImokMiIsIm5zdGFydCIsInVuc2hpZnQiLCJyZXZlcnNlIiwiZ2V0T3JkZXIiLCJsaW5lIiwidGV4dCIsIm5vSGFuZGxlcnMiLCJvbiIsImVtaXR0ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJfaGFuZGxlcnMiLCJjb25jYXQiLCJnZXRIYW5kbGVycyIsIm9mZiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsInNpZ25hbCIsImhhbmRsZXJzIiwic2lnbmFsRE9NRXZlbnQiLCJvdmVycmlkZSIsInByZXZlbnREZWZhdWx0IiwiZGVmYXVsdFByZXZlbnRlZCIsImVfZGVmYXVsdFByZXZlbnRlZCIsImNvZGVtaXJyb3JJZ25vcmUiLCJzaWduYWxDdXJzb3JBY3Rpdml0eSIsImN1cnNvckFjdGl2aXR5IiwiY3VyT3AiLCJjdXJzb3JBY3Rpdml0eUhhbmRsZXJzIiwiaGFzSGFuZGxlciIsImV2ZW50TWl4aW4iLCJjdG9yIiwiZV9wcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwiZV9zdG9wUHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJlX3N0b3AiLCJlX3RhcmdldCIsInNyY0VsZW1lbnQiLCJlX2J1dHRvbiIsIndoaWNoIiwiYnV0dG9uIiwiY3RybEtleSIsImRyYWdBbmREcm9wIiwiZGl2IiwiendzcFN1cHBvcnRlZCIsInplcm9XaWR0aEVsZW1lbnQiLCJtZWFzdXJlIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJiYWRCaWRpUmVjdHMiLCJoYXNCYWRCaWRpUmVjdHMiLCJ0eHQiLCJyMCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInIxIiwibGVmdCIsInJpZ2h0Iiwic3BsaXRMaW5lc0F1dG8iLCJyZXN1bHQiLCJsIiwibmwiLCJydCIsImhhc1NlbGVjdGlvbiIsIndpbmRvdyIsImdldFNlbGVjdGlvbiIsInRlIiwic2VsZWN0aW9uIiwicGFyZW50RWxlbWVudCIsImNvbXBhcmVFbmRQb2ludHMiLCJoYXNDb3B5RXZlbnQiLCJvbmNvcHkiLCJiYWRab29tZWRSZWN0cyIsImhhc0JhZFpvb21lZFJlY3RzIiwibm9ybWFsIiwiZnJvbVJhbmdlIiwiYWJzIiwibW9kZXMiLCJtaW1lTW9kZXMiLCJkZWZpbmVNb2RlIiwibmFtZSIsIm1vZGUiLCJkZXBlbmRlbmNpZXMiLCJkZWZpbmVNSU1FIiwibWltZSIsInNwZWMiLCJyZXNvbHZlTW9kZSIsImdldE1vZGUiLCJvcHRpb25zIiwibWZhY3RvcnkiLCJtb2RlT2JqIiwibW9kZUV4dGVuc2lvbnMiLCJleHRzIiwiaGVscGVyVHlwZSIsIm1vZGVQcm9wcyIsInByb3AkMSIsImV4dGVuZE1vZGUiLCJwcm9wZXJ0aWVzIiwiY29weVN0YXRlIiwic3RhdGUiLCJuc3RhdGUiLCJ2YWwiLCJpbm5lck1vZGUiLCJpbmZvIiwic3RhcnRTdGF0ZSIsImExIiwiYTIiLCJTdHJpbmdTdHJlYW0iLCJsaW5lT3JhY2xlIiwibGFzdENvbHVtblBvcyIsImxhc3RDb2x1bW5WYWx1ZSIsImxpbmVTdGFydCIsImVvbCIsInNvbCIsInBlZWsiLCJ1bmRlZmluZWQiLCJuZXh0IiwiZWF0Iiwib2siLCJlYXRXaGlsZSIsImVhdFNwYWNlIiwic2tpcFRvRW5kIiwic2tpcFRvIiwiYmFja1VwIiwiY29sdW1uIiwiaW5kZW50YXRpb24iLCJwYXR0ZXJuIiwiY29uc3VtZSIsImNhc2VJbnNlbnNpdGl2ZSIsImNhc2VkIiwic3Vic3RyIiwiaGlkZUZpcnN0Q2hhcnMiLCJpbm5lciIsImxvb2tBaGVhZCIsIm9yYWNsZSIsImJhc2VUb2tlbiIsImdldExpbmUiLCJmaXJzdCIsInNpemUiLCJFcnJvciIsImNodW5rIiwibGluZXMiLCJjaGlsZHJlbiIsInN6IiwiY2h1bmtTaXplIiwiZ2V0QmV0d2VlbiIsIml0ZXIiLCJnZXRMaW5lcyIsInVwZGF0ZUxpbmVIZWlnaHQiLCJoZWlnaHQiLCJkaWZmIiwibGluZU5vIiwibm8iLCJsaW5lQXRIZWlnaHQiLCJoIiwib3V0ZXIiLCJsaCIsImlzTGluZSIsImxpbmVOdW1iZXJGb3IiLCJTdHJpbmciLCJsaW5lTnVtYmVyRm9ybWF0dGVyIiwiZmlyc3RMaW5lTnVtYmVyIiwiUG9zIiwiY21wIiwiZXF1YWxDdXJzb3JQb3MiLCJjb3B5UG9zIiwieCIsIm1heFBvcyIsIm1pblBvcyIsImNsaXBMaW5lIiwiY2xpcFBvcyIsImxhc3QiLCJjbGlwVG9MZW4iLCJsaW5lbGVuIiwiY2xpcFBvc0FycmF5IiwiU2F2ZWRDb250ZXh0IiwiQ29udGV4dCIsIm1heExvb2tBaGVhZCIsImJhc2VUb2tlbnMiLCJiYXNlVG9rZW5Qb3MiLCJuZXh0TGluZSIsImZyb21TYXZlZCIsInNhdmVkIiwic2F2ZSIsImNvcHkiLCJoaWdobGlnaHRMaW5lIiwiY29udGV4dCIsImZvcmNlVG9FbmQiLCJzdCIsIm1vZGVHZW4iLCJsaW5lQ2xhc3NlcyIsInJ1bk1vZGUiLCJsb29wIiwibyIsIm92ZXJsYXkiLCJvdmVybGF5cyIsImlfZW5kIiwib3BhcXVlIiwic3R5bGVzIiwiY2xhc3NlcyIsImJnQ2xhc3MiLCJ0ZXh0Q2xhc3MiLCJnZXRMaW5lU3R5bGVzIiwidXBkYXRlRnJvbnRpZXIiLCJnZXRDb250ZXh0QmVmb3JlIiwicmVzZXRTdGF0ZSIsIm1heEhpZ2hsaWdodExlbmd0aCIsInN0YXRlQWZ0ZXIiLCJzdHlsZUNsYXNzZXMiLCJoaWdobGlnaHRGcm9udGllciIsIm1vZGVGcm9udGllciIsInByZWNpc2UiLCJmaW5kU3RhcnRMaW5lIiwicHJvY2Vzc0xpbmUiLCJ2aWV3RnJvbSIsInZpZXdUbyIsInN0YXJ0QXQiLCJzdHJlYW0iLCJjYWxsQmxhbmtMaW5lIiwicmVhZFRva2VuIiwiYmxhbmtMaW5lIiwidG9rZW4iLCJUb2tlbiIsInRha2VUb2tlbiIsImFzQXJyYXkiLCJ0b2tlbnMiLCJleHRyYWN0TGluZUNsYXNzZXMiLCJvdXRwdXQiLCJsaW5lQ2xhc3MiLCJmbGF0dGVuU3BhbnMiLCJjdXJTdGFydCIsImN1clN0eWxlIiwiYWRkTW9kZUNsYXNzIiwibU5hbWUiLCJtaW5pbmRlbnQiLCJtaW5saW5lIiwibGltIiwiaW5kZW50ZWQiLCJyZXRyZWF0RnJvbnRpZXIiLCJzYXdSZWFkT25seVNwYW5zIiwic2F3Q29sbGFwc2VkU3BhbnMiLCJzZWVSZWFkT25seVNwYW5zIiwic2VlQ29sbGFwc2VkU3BhbnMiLCJNYXJrZWRTcGFuIiwibWFya2VyIiwiZ2V0TWFya2VkU3BhbkZvciIsInNwYW5zIiwic3BhbiIsInJlbW92ZU1hcmtlZFNwYW4iLCJhZGRNYXJrZWRTcGFuIiwib3AiLCJpblRoaXNPcCIsIldlYWtTZXQiLCJtYXJrZWRTcGFucyIsImhhcyIsImFkZCIsImF0dGFjaExpbmUiLCJtYXJrZWRTcGFuc0JlZm9yZSIsIm9sZCIsInN0YXJ0Q2giLCJpc0luc2VydCIsIm53Iiwic3RhcnRzQmVmb3JlIiwiaW5jbHVzaXZlTGVmdCIsImluc2VydExlZnQiLCJlbmRzQWZ0ZXIiLCJpbmNsdXNpdmVSaWdodCIsIm1hcmtlZFNwYW5zQWZ0ZXIiLCJlbmRDaCIsInN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UiLCJjaGFuZ2UiLCJmdWxsIiwib2xkRmlyc3QiLCJvbGRMYXN0Iiwic2FtZUxpbmUiLCJvZmZzZXQiLCJzcGFuJDEiLCJmb3VuZCQxIiwiY2xlYXJFbXB0eVNwYW5zIiwibmV3TWFya2VycyIsImdhcCIsImdhcE1hcmtlcnMiLCJjbGVhcldoZW5FbXB0eSIsInJlbW92ZVJlYWRPbmx5UmFuZ2VzIiwibWFya2VycyIsIm1hcmsiLCJyZWFkT25seSIsInBhcnRzIiwibWsiLCJmaW5kIiwicCIsIm5ld1BhcnRzIiwiZGZyb20iLCJkdG8iLCJkZXRhY2hNYXJrZWRTcGFucyIsImRldGFjaExpbmUiLCJhdHRhY2hNYXJrZWRTcGFucyIsImV4dHJhTGVmdCIsImV4dHJhUmlnaHQiLCJjb21wYXJlQ29sbGFwc2VkTWFya2VycyIsImxlbkRpZmYiLCJhUG9zIiwiYlBvcyIsImZyb21DbXAiLCJ0b0NtcCIsImNvbGxhcHNlZFNwYW5BdFNpZGUiLCJzcHMiLCJzcCIsImNvbGxhcHNlZCIsImNvbGxhcHNlZFNwYW5BdFN0YXJ0IiwiY29sbGFwc2VkU3BhbkF0RW5kIiwiY29sbGFwc2VkU3BhbkFyb3VuZCIsImNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UiLCJ2aXN1YWxMaW5lIiwibWVyZ2VkIiwidmlzdWFsTGluZUVuZCIsInZpc3VhbExpbmVDb250aW51ZWQiLCJ2aXN1YWxMaW5lTm8iLCJsaW5lTiIsInZpcyIsInZpc3VhbExpbmVFbmRObyIsImxhc3RMaW5lIiwibGluZUlzSGlkZGVuIiwid2lkZ2V0Tm9kZSIsImxpbmVJc0hpZGRlbklubmVyIiwiaGVpZ2h0QXRMaW5lIiwibGluZU9iaiIsImxpbmVMZW5ndGgiLCJmaW5kTWF4TGluZSIsImQiLCJtYXhMaW5lIiwibWF4TGluZUxlbmd0aCIsIm1heExpbmVDaGFuZ2VkIiwiTGluZSIsImVzdGltYXRlSGVpZ2h0IiwidXBkYXRlTGluZSIsImVzdEhlaWdodCIsImNsZWFuVXBMaW5lIiwic3R5bGVUb0NsYXNzQ2FjaGUiLCJzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlIiwiaW50ZXJwcmV0VG9rZW5TdHlsZSIsImNhY2hlIiwiYnVpbGRMaW5lQ29udGVudCIsImxpbmVWaWV3IiwiYnVpbGRlciIsInByZSIsInRyYWlsaW5nU3BhY2UiLCJzcGxpdFNwYWNlcyIsImdldE9wdGlvbiIsInJlc3QiLCJhZGRUb2tlbiIsImJ1aWxkVG9rZW4iLCJidWlsZFRva2VuQmFkQmlkaSIsImFsbG93RnJvbnRpZXJVcGRhdGUiLCJleHRlcm5hbE1lYXN1cmVkIiwiaW5zZXJ0TGluZUNvbnRlbnQiLCJtYXBzIiwiY2FjaGVzIiwibGFzdENoaWxkIiwicXVlcnlTZWxlY3RvciIsImRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyIiwidGl0bGUiLCJzdGFydFN0eWxlIiwiZW5kU3R5bGUiLCJjc3MiLCJhdHRyaWJ1dGVzIiwiZGlzcGxheVRleHQiLCJzcGVjaWFsIiwic3BlY2lhbENoYXJzIiwibXVzdFdyYXAiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwibGFzdEluZGV4IiwidHh0JDEiLCJ0YWJXaWR0aCIsInNwZWNpYWxDaGFyUGxhY2Vob2xkZXIiLCJmdWxsU3R5bGUiLCJhdHRyIiwidHJhaWxpbmdCZWZvcmUiLCJzcGFjZUJlZm9yZSIsImJ1aWxkQ29sbGFwc2VkU3BhbiIsImlnbm9yZVdpZGdldCIsIndpZGdldCIsImlucHV0IiwibmVlZHNDb250ZW50QXR0cmlidXRlIiwic2V0VW5lZGl0YWJsZSIsImFsbFRleHQiLCJuZXh0Q2hhbmdlIiwic3BhblN0eWxlIiwic3BhbkVuZFN0eWxlIiwic3BhblN0YXJ0U3R5bGUiLCJJbmZpbml0eSIsImZvdW5kQm9va21hcmtzIiwiZW5kU3R5bGVzIiwidXB0byIsInRva2VuVGV4dCIsIkxpbmVWaWV3IiwiaGlkZGVuIiwiYnVpbGRWaWV3QXJyYXkiLCJuZXh0UG9zIiwidmlldyIsIm9wZXJhdGlvbkdyb3VwIiwicHVzaE9wZXJhdGlvbiIsIm9wcyIsIm93bnNHcm91cCIsImRlbGF5ZWRDYWxsYmFja3MiLCJmaXJlQ2FsbGJhY2tzRm9yT3BzIiwiZ3JvdXAiLCJjYWxsYmFja3MiLCJjdXJzb3JBY3Rpdml0eUNhbGxlZCIsImZpbmlzaE9wZXJhdGlvbiIsImVuZENiIiwib3JwaGFuRGVsYXllZENhbGxiYWNrcyIsInNpZ25hbExhdGVyIiwibGlzdCIsImZpcmVPcnBoYW5EZWxheWVkIiwiZGVsYXllZCIsInVwZGF0ZUxpbmVGb3JDaGFuZ2VzIiwiZGltcyIsImNoYW5nZXMiLCJ1cGRhdGVMaW5lVGV4dCIsInVwZGF0ZUxpbmVHdXR0ZXIiLCJ1cGRhdGVMaW5lQ2xhc3NlcyIsInVwZGF0ZUxpbmVXaWRnZXRzIiwiZW5zdXJlTGluZVdyYXBwZWQiLCJyZXBsYWNlQ2hpbGQiLCJ6SW5kZXgiLCJ1cGRhdGVMaW5lQmFja2dyb3VuZCIsImJhY2tncm91bmQiLCJ3cmFwIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0TGluZUNvbnRlbnQiLCJleHQiLCJidWlsdCIsIndyYXBDbGFzcyIsImd1dHRlciIsImd1dHRlckJhY2tncm91bmQiLCJndXR0ZXJDbGFzcyIsImZpeGVkR3V0dGVyIiwiZml4ZWRQb3MiLCJndXR0ZXJUb3RhbFdpZHRoIiwiZ3V0dGVyTWFya2VycyIsImxpbmVOdW1iZXJzIiwid3JhcCQxIiwiZ3V0dGVyV3JhcCIsImxpbmVOdW1iZXIiLCJndXR0ZXJMZWZ0IiwibGluZU51bUlubmVyV2lkdGgiLCJrIiwiZ3V0dGVyU3BlY3MiLCJndXR0ZXJXaWR0aCIsImFsaWduYWJsZSIsImlzV2lkZ2V0IiwibmV4dFNpYmxpbmciLCJpbnNlcnRMaW5lV2lkZ2V0cyIsImJ1aWxkTGluZUVsZW1lbnQiLCJpbnNlcnRMaW5lV2lkZ2V0c0ZvciIsImFsbG93QWJvdmUiLCJ3aWRnZXRzIiwid3MiLCJoYW5kbGVNb3VzZUV2ZW50cyIsInBvc2l0aW9uTGluZVdpZGdldCIsImFib3ZlIiwibm9IU2Nyb2xsIiwid2lkdGgiLCJ3cmFwcGVyV2lkdGgiLCJjb3Zlckd1dHRlciIsInBhZGRpbmdMZWZ0IiwicG9zaXRpb24iLCJtYXJnaW5MZWZ0Iiwid2lkZ2V0SGVpZ2h0IiwicGFyZW50U3R5bGUiLCJndXR0ZXJzIiwiY2xpZW50V2lkdGgiLCJldmVudEluV2lkZ2V0IiwiZ2V0QXR0cmlidXRlIiwic2l6ZXIiLCJtb3ZlciIsInBhZGRpbmdUb3AiLCJsaW5lU3BhY2UiLCJvZmZzZXRUb3AiLCJwYWRkaW5nVmVydCIsInBhZGRpbmdIIiwiY2FjaGVkUGFkZGluZ0giLCJnZXRDb21wdXRlZFN0eWxlIiwiY3VycmVudFN0eWxlIiwiZGF0YSIsInBhcnNlSW50IiwicGFkZGluZ1JpZ2h0IiwiaXNOYU4iLCJzY3JvbGxHYXAiLCJuYXRpdmVCYXJXaWR0aCIsImRpc3BsYXlXaWR0aCIsInNjcm9sbGVyIiwiYmFyV2lkdGgiLCJkaXNwbGF5SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiYmFySGVpZ2h0IiwiZW5zdXJlTGluZUhlaWdodHMiLCJyZWN0Iiwid3JhcHBpbmciLCJsaW5lV3JhcHBpbmciLCJjdXJXaWR0aCIsImhlaWdodHMiLCJyZWN0cyIsImdldENsaWVudFJlY3RzIiwiYm90dG9tIiwidG9wIiwibWFwRnJvbUxpbmVWaWV3IiwidXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudCIsImxpbmVNZWFzdXJlIiwibWVhc3VyZUNoYXIiLCJiaWFzIiwibWVhc3VyZUNoYXJQcmVwYXJlZCIsInByZXBhcmVNZWFzdXJlRm9yTGluZSIsImZpbmRWaWV3Rm9yTGluZSIsImZpbmRWaWV3SW5kZXgiLCJnZXREaW1lbnNpb25zIiwiZm9yY2VVcGRhdGUiLCJoYXNIZWlnaHRzIiwicHJlcGFyZWQiLCJ2YXJIZWlnaHQiLCJrZXkiLCJtZWFzdXJlQ2hhcklubmVyIiwiYm9ndXMiLCJydG9wIiwicmJvdHRvbSIsIm51bGxSZWN0Iiwibm9kZUFuZE9mZnNldEluTGluZU1hcCIsIm1TdGFydCIsIm1FbmQiLCJjb3ZlclN0YXJ0IiwiY292ZXJFbmQiLCJnZXRVc2VmdWxSZWN0IiwicGxhY2UiLCJtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nIiwiclNwYW4iLCJjaGFyV2lkdGgiLCJyYm90IiwiYm90Iiwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSIsInNjcmVlbiIsImxvZ2ljYWxYRFBJIiwiZGV2aWNlWERQSSIsInNjYWxlWCIsInNjYWxlWSIsImxvZ2ljYWxZRFBJIiwiZGV2aWNlWURQSSIsImNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IiLCJjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlIiwiZXh0ZXJuYWxNZWFzdXJlIiwiY2xlYXJDYWNoZXMiLCJjYWNoZWRDaGFyV2lkdGgiLCJjYWNoZWRUZXh0SGVpZ2h0IiwibGluZU51bUNoYXJzIiwicGFnZVNjcm9sbFgiLCJwYWdlWE9mZnNldCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbExlZnQiLCJwYWdlU2Nyb2xsWSIsIm1hcmdpblRvcCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwid2lkZ2V0VG9wSGVpZ2h0IiwicmVmIiwiaW50b0Nvb3JkU3lzdGVtIiwiaW5jbHVkZVdpZGdldHMiLCJ5T2ZmIiwidmlld09mZnNldCIsImxPZmYiLCJ4T2ZmIiwiZnJvbUNvb3JkU3lzdGVtIiwiY29vcmRzIiwibG9jYWxCb3giLCJsaW5lU3BhY2VCb3giLCJjaGFyQ29vcmRzIiwiY3Vyc29yQ29vcmRzIiwicHJlcGFyZWRNZWFzdXJlIiwiZ2V0IiwiZ2V0QmlkaSIsInBhcnRQb3MiLCJpbnZlcnQiLCJvdGhlciIsImVzdGltYXRlQ29vcmRzIiwiUG9zV2l0aEluZm8iLCJvdXRzaWRlIiwieFJlbCIsImNvb3Jkc0NoYXIiLCJ5IiwiY29vcmRzQ2hhcklubmVyIiwicmFuZ2VFbmQiLCJ3cmFwcGVkTGluZUV4dGVudCIsImJlZ2luIiwid3JhcHBlZExpbmVFeHRlbnRDaGFyIiwidGFyZ2V0VG9wIiwiYm94SXNBZnRlciIsImJveCIsImx0ciIsImNvb3Jkc0JpZGlQYXJ0V3JhcHBlZCIsImNvb3Jkc0JpZGlQYXJ0IiwiY2hBcm91bmQiLCJib3hBcm91bmQiLCJiYXNlWCIsImF0TGVmdCIsImF0U3RhcnQiLCJfbGluZU5vIiwiY2xvc2VzdERpc3QiLCJlbmRYIiwiZGlzdCIsIm1lYXN1cmVUZXh0IiwidGV4dEhlaWdodCIsImFuY2hvciIsImNsaWVudExlZnQiLCJvZmZzZXRMZWZ0IiwiY29tcGVuc2F0ZUZvckhTY3JvbGwiLCJ0aCIsInBlckxpbmUiLCJ3aWRnZXRzSGVpZ2h0IiwiZXN0aW1hdGVMaW5lSGVpZ2h0cyIsImVzdCIsInBvc0Zyb21Nb3VzZSIsImxpYmVyYWwiLCJmb3JSZWN0Iiwic3BhY2UiLCJjbGllbnRYIiwiY2xpZW50WSIsImUkMSIsImNvbERpZmYiLCJyb3VuZCIsInJlZ0NoYW5nZSIsImxlbmRpZmYiLCJ1cGRhdGVMaW5lTnVtYmVycyIsInZpZXdDaGFuZ2VkIiwicmVzZXRWaWV3IiwiY3V0Iiwidmlld0N1dHRpbmdQb2ludCIsImN1dCQxIiwiY3V0VG9wIiwiY3V0Qm90IiwicmVnTGluZUNoYW5nZSIsIm9sZE4iLCJuZXdOIiwiYWRqdXN0VmlldyIsImNvdW50RGlydHlWaWV3IiwiZGlydHkiLCJ1cGRhdGVTZWxlY3Rpb24iLCJzaG93U2VsZWN0aW9uIiwicHJlcGFyZVNlbGVjdGlvbiIsInByaW1hcnkiLCJjdXJGcmFnbWVudCIsImN1cnNvcnMiLCJzZWxGcmFnbWVudCIsImN1c3RvbUN1cnNvciIsIiRjdXN0b21DdXJzb3IiLCJzZWwiLCJyYW5nZXMiLCJwcmltSW5kZXgiLCJlbXB0eSIsImhlYWQiLCJkcmF3U2VsZWN0aW9uQ3Vyc29yIiwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmciLCJkcmF3U2VsZWN0aW9uUmFuZ2UiLCJjdXJzb3IiLCJjdXJzb3JIZWlnaHQiLCJnZXRXcmFwcGVyRWxlbWVudCIsImNoYXJQb3MiLCJkZWZhdWx0Q2hhcldpZHRoIiwib3RoZXJDdXJzb3IiLCJjbXBDb29yZHMiLCJmcmFnbWVudCIsInBhZGRpbmciLCJsZWZ0U2lkZSIsInJpZ2h0U2lkZSIsInNpemVyV2lkdGgiLCJkb2NMVFIiLCJkcmF3Rm9yTGluZSIsImZyb21BcmciLCJ0b0FyZyIsImxpbmVMZW4iLCJ3cmFwWCIsInNpZGUiLCJleHRlbnQiLCJmcm9tUG9zIiwidG9Qb3MiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib3BlbkxlZnQiLCJvcGVuUmlnaHQiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3RMZWZ0IiwiYm90UmlnaHQiLCJzRnJvbSIsInNUbyIsImZyb21MaW5lIiwidG9MaW5lIiwic2luZ2xlVkxpbmUiLCJsZWZ0RW5kIiwicmlnaHRTdGFydCIsInJlc3RhcnRCbGluayIsImZvY3VzZWQiLCJjbGVhckludGVydmFsIiwiYmxpbmtlciIsImN1cnNvckRpdiIsInZpc2liaWxpdHkiLCJjdXJzb3JCbGlua1JhdGUiLCJzZXRJbnRlcnZhbCIsImhhc0ZvY3VzIiwib25CbHVyIiwiZW5zdXJlRm9jdXMiLCJmb2N1cyIsIm9uRm9jdXMiLCJkZWxheUJsdXJFdmVudCIsImRlbGF5aW5nQmx1ckV2ZW50IiwiZHJhZ2dpbmdUZXh0Iiwic2VsRm9yQ29udGV4dE1lbnUiLCJyZXNldCIsInJlY2VpdmVkRm9jdXMiLCJzaGlmdCIsInVwZGF0ZUhlaWdodHNJblZpZXdwb3J0IiwicHJldkJvdHRvbSIsImxpbmVEaXYiLCJ2aWV3VG9wIiwib2xkSGVpZ2h0IiwibXVzdFNjcm9sbCIsInVwZGF0ZVdpZGdldEhlaWdodCIsImNoV2lkdGgiLCJ3IiwidmlzaWJsZUxpbmVzIiwidmlld3BvcnQiLCJlbnN1cmUiLCJlbnN1cmVGcm9tIiwiZW5zdXJlVG8iLCJtYXliZVNjcm9sbFdpbmRvdyIsImRvU2Nyb2xsIiwiaW5uZXJIZWlnaHQiLCJzY3JvbGxOb2RlIiwic2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxQb3NJbnRvVmlldyIsIm1hcmdpbiIsImxpbWl0IiwiY2hhbmdlZCIsImVuZENvb3JkcyIsInNjcm9sbFBvcyIsImNhbGN1bGF0ZVNjcm9sbFBvcyIsInN0YXJ0VG9wIiwic3RhcnRMZWZ0IiwidXBkYXRlU2Nyb2xsVG9wIiwic2V0U2Nyb2xsTGVmdCIsInNuYXBNYXJnaW4iLCJzY3JlZW50b3AiLCJkb2NCb3R0b20iLCJhdFRvcCIsImF0Qm90dG9tIiwibmV3VG9wIiwiZ3V0dGVyU3BhY2UiLCJzY3JlZW5sZWZ0Iiwic2NyZWVudyIsInRvb1dpZGUiLCJhZGRUb1Njcm9sbFRvcCIsInJlc29sdmVTY3JvbGxUb1BvcyIsImVuc3VyZUN1cnNvclZpc2libGUiLCJnZXRDdXJzb3IiLCJzY3JvbGxUb1BvcyIsImN1cnNvclNjcm9sbE1hcmdpbiIsInNjcm9sbFRvQ29vcmRzIiwic2Nyb2xsVG9SYW5nZSIsInNjcm9sbFRvQ29vcmRzUmFuZ2UiLCJzUG9zIiwidXBkYXRlRGlzcGxheVNpbXBsZSIsInNldFNjcm9sbFRvcCIsInN0YXJ0V29ya2VyIiwiZm9yY2VTY3JvbGwiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxiYXJzIiwiaXNTY3JvbGxlciIsInNjcm9sbFdpZHRoIiwiYWxpZ25Ib3Jpem9udGFsbHkiLCJtZWFzdXJlRm9yU2Nyb2xsYmFycyIsImd1dHRlclciLCJkb2NIIiwidmlld0hlaWdodCIsInZpZXdXaWR0aCIsImJhckxlZnQiLCJkb2NIZWlnaHQiLCJOYXRpdmVTY3JvbGxiYXJzIiwidmVydCIsImhvcml6IiwidGFiSW5kZXgiLCJjaGVja2VkWmVyb1dpZHRoIiwibWluSGVpZ2h0IiwibWluV2lkdGgiLCJ1cGRhdGUiLCJuZWVkc0giLCJuZWVkc1YiLCJzV2lkdGgiLCJ0b3RhbEhlaWdodCIsInRvdGFsV2lkdGgiLCJ6ZXJvV2lkdGhIYWNrIiwiZGlzYWJsZUhvcml6IiwiZW5hYmxlWmVyb1dpZHRoQmFyIiwiZGlzYWJsZVZlcnQiLCJiYXIiLCJkZWxheSIsIm1heWJlRGlzYWJsZSIsImVsZW1lbnRGcm9tUG9pbnQiLCJjbGVhciIsIk51bGxTY3JvbGxiYXJzIiwidXBkYXRlU2Nyb2xsYmFycyIsInN0YXJ0V2lkdGgiLCJzdGFydEhlaWdodCIsInVwZGF0ZVNjcm9sbGJhcnNJbm5lciIsInNpemVzIiwicGFkZGluZ0JvdHRvbSIsImhlaWdodEZvcmNlciIsImJvcmRlckJvdHRvbSIsInNjcm9sbGJhckZpbGxlciIsImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyIiwiZ3V0dGVyRmlsbGVyIiwic2Nyb2xsYmFyTW9kZWwiLCJpbml0U2Nyb2xsYmFycyIsInNjcm9sbGJhclN0eWxlIiwiYXhpcyIsIm5leHRPcElkIiwic3RhcnRPcGVyYXRpb24iLCJ1cGRhdGVJbnB1dCIsInR5cGluZyIsImNoYW5nZU9ianMiLCJzZWxlY3Rpb25DaGFuZ2VkIiwidXBkYXRlTWF4TGluZSIsIm1hcmtBcnJheXMiLCJlbmRPcGVyYXRpb24iLCJlbmRPcGVyYXRpb25zIiwiZW5kT3BlcmF0aW9uX1IxIiwiZW5kT3BlcmF0aW9uX1cxIiwiZW5kT3BlcmF0aW9uX1IyIiwiZW5kT3BlcmF0aW9uX1cyIiwiZW5kT3BlcmF0aW9uX2ZpbmlzaCIsIm1heWJlQ2xpcFNjcm9sbGJhcnMiLCJtdXN0VXBkYXRlIiwiRGlzcGxheVVwZGF0ZSIsInVwZGF0ZWREaXNwbGF5IiwidXBkYXRlRGlzcGxheUlmTmVlZGVkIiwiYmFyTWVhc3VyZSIsImFkanVzdFdpZHRoVG8iLCJtYXhTY3JvbGxMZWZ0IiwicHJlcGFyZWRTZWxlY3Rpb24iLCJ0YWtlRm9jdXMiLCJzZXREb2N1bWVudEhlaWdodCIsInBvc3RVcGRhdGVEaXNwbGF5Iiwid2hlZWxTdGFydFgiLCJ3aGVlbFN0YXJ0WSIsIm1heWJlSGlkZGVuTWFya2VycyIsInVuaGlkZGVuIiwibWF5YmVVbmhpZGRlbk1hcmtlcnMiLCJmaW5pc2giLCJydW5Jbk9wIiwib3BlcmF0aW9uIiwibWV0aG9kT3AiLCJkb2NNZXRob2RPcCIsImhpZ2hsaWdodCIsImhpZ2hsaWdodFdvcmtlciIsIndvcmtUaW1lIiwiY2hhbmdlZExpbmVzIiwib2xkU3R5bGVzIiwiaGlnaGxpZ2h0ZWQiLCJvbGRDbHMiLCJuZXdDbHMiLCJpc2NoYW5nZSIsIndvcmtEZWxheSIsImZvcmNlIiwidmlzaWJsZSIsImVkaXRvcklzSGlkZGVuIiwid3JhcHBlckhlaWdodCIsIm9sZERpc3BsYXlXaWR0aCIsImV2ZW50cyIsInNjcm9sbGJhcnNDbGlwcGVkIiwibWFyZ2luQm90dG9tIiwiYm9yZGVyUmlnaHRXaWR0aCIsInNlbGVjdGlvblNuYXBzaG90IiwiYWN0aXZlIiwiYW5jaG9yTm9kZSIsImV4dGVuZCIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwicmVzdG9yZVNlbGVjdGlvbiIsInNuYXBzaG90Iiwibm9kZU5hbWUiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInJlbmRlcmVkVmlldyIsIm1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoIiwidmlld3BvcnRNYXJnaW4iLCJkaWZmZXJlbnQiLCJsYXN0V3JhcEhlaWdodCIsImxhc3RXcmFwV2lkdGgiLCJ0b1VwZGF0ZSIsInNlbFNuYXBzaG90IiwicGF0Y2hEaXNwbGF5Iiwic2VsZWN0aW9uRGl2IiwicmVwb3J0ZWRWaWV3RnJvbSIsInJlcG9ydGVkVmlld1RvIiwidXBkYXRlTnVtYmVyc0Zyb20iLCJjb250YWluZXIiLCJybSIsImN1cnJlbnRXaGVlbFRhcmdldCIsInVwZGF0ZU51bWJlciIsInVwZGF0ZUd1dHRlclNwYWNlIiwiYWxpZ25XaWRnZXRzIiwiY29tcCIsImFsaWduIiwiaW5uZXJXIiwibGluZUd1dHRlciIsImxpbmVOdW1XaWR0aCIsImdldEd1dHRlcnMiLCJzYXdMaW5lTnVtYmVycyIsInJlbmRlckd1dHRlcnMiLCJzcGVjcyIsImdFbHQiLCJ1cGRhdGVHdXR0ZXJzIiwiRGlzcGxheSIsImNsaXBQYXRoIiwiZHJhZ2dhYmxlIiwid2hlZWxEWCIsIndoZWVsRFkiLCJhY3RpdmVUb3VjaCIsImluaXQiLCJ3aGVlbFNhbXBsZXMiLCJ3aGVlbFBpeGVsc1BlclVuaXQiLCJ3aGVlbEV2ZW50RGVsdGEiLCJkeCIsIndoZWVsRGVsdGFYIiwiZHkiLCJ3aGVlbERlbHRhWSIsImRldGFpbCIsIkhPUklaT05UQUxfQVhJUyIsIlZFUlRJQ0FMX0FYSVMiLCJ3aGVlbERlbHRhIiwid2hlZWxFdmVudFBpeGVscyIsImRlbHRhIiwib25TY3JvbGxXaGVlbCIsImNocm9tZVNjcm9sbEhhY2siLCJwb2ludGVyRXZlbnRzIiwicGl4ZWxzUGVyVW5pdCIsImRlbHRhTW9kZSIsImRlbHRhWCIsImRlbHRhWSIsImNhblNjcm9sbFgiLCJjYW5TY3JvbGxZIiwicGl4ZWxzIiwibW92ZWRYIiwibW92ZWRZIiwic2FtcGxlIiwiU2VsZWN0aW9uIiwiZXF1YWxzIiwiaGVyZSIsInRoZXJlIiwiZGVlcENvcHkiLCJSYW5nZSIsInNvbWV0aGluZ1NlbGVjdGVkIiwibm9ybWFsaXplU2VsZWN0aW9uIiwibWF5VG91Y2giLCJzZWxlY3Rpb25zTWF5VG91Y2giLCJwcmltIiwic29ydCIsImludiIsInNpbXBsZVNlbGVjdGlvbiIsImNoYW5nZUVuZCIsImFkanVzdEZvckNoYW5nZSIsImNvbXB1dGVTZWxBZnRlckNoYW5nZSIsIm9mZnNldFBvcyIsImNvbXB1dGVSZXBsYWNlZFNlbCIsImhpbnQiLCJvbGRQcmV2IiwibmV3UHJldiIsImxvYWRNb2RlIiwibW9kZU9wdGlvbiIsInJlc2V0TW9kZVN0YXRlIiwiaXNXaG9sZUxpbmVVcGRhdGUiLCJ3aG9sZUxpbmVVcGRhdGVCZWZvcmUiLCJ1cGRhdGVEb2MiLCJzcGFuc0ZvciIsImxpbmVzRm9yIiwiZmlyc3RMaW5lIiwibGFzdFRleHQiLCJsYXN0U3BhbnMiLCJubGluZXMiLCJpbnNlcnQiLCJyZW1vdmUiLCJhZGRlZCIsImFkZGVkJDEiLCJhZGRlZCQyIiwibGlua2VkRG9jcyIsInNoYXJlZEhpc3RPbmx5IiwicHJvcGFnYXRlIiwic2tpcCIsInNoYXJlZEhpc3QiLCJsaW5rZWQiLCJyZWwiLCJzaGFyZWQiLCJhdHRhY2hEb2MiLCJzZXREaXJlY3Rpb25DbGFzcyIsImRpcmVjdGlvbkNoYW5nZWQiLCJIaXN0b3J5IiwiZG9uZSIsInVuZG9uZSIsInVuZG9EZXB0aCIsImxhc3RNb2RUaW1lIiwibGFzdFNlbFRpbWUiLCJsYXN0T3AiLCJsYXN0U2VsT3AiLCJsYXN0T3JpZ2luIiwibGFzdFNlbE9yaWdpbiIsImdlbmVyYXRpb24iLCJtYXhHZW5lcmF0aW9uIiwiaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UiLCJoaXN0Q2hhbmdlIiwiYXR0YWNoTG9jYWxTcGFucyIsImNsZWFyU2VsZWN0aW9uRXZlbnRzIiwicG9wIiwibGFzdENoYW5nZUV2ZW50IiwiaGlzdCIsImFkZENoYW5nZVRvSGlzdG9yeSIsInNlbEFmdGVyIiwib3BJZCIsImhpc3RvcnkiLCJoaXN0b3J5RXZlbnREZWxheSIsInB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkiLCJzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkIiwiYWRkU2VsZWN0aW9uVG9IaXN0b3J5IiwiY2xlYXJSZWRvIiwiZGVzdCIsImV4aXN0aW5nIiwicmVtb3ZlQ2xlYXJlZFNwYW5zIiwiZXhwbGljaXRseUNsZWFyZWQiLCJnZXRPbGRTcGFucyIsIm1lcmdlT2xkU3BhbnMiLCJzdHJldGNoZWQiLCJvbGRDdXIiLCJzdHJldGNoQ3VyIiwiY29weUhpc3RvcnlBcnJheSIsIm5ld0dyb3VwIiwiaW5zdGFudGlhdGVTZWwiLCJldmVudCIsIm5ld0NoYW5nZXMiLCJleHRlbmRSYW5nZSIsInBvc0JlZm9yZSIsImV4dGVuZFNlbGVjdGlvbiIsInNldFNlbGVjdGlvbiIsImV4dGVuZFNlbGVjdGlvbnMiLCJoZWFkcyIsIm5ld1NlbCIsInJlcGxhY2VPbmVTZWxlY3Rpb24iLCJzZXRTaW1wbGVTZWxlY3Rpb24iLCJmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UiLCJzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSIsInNldFNlbGVjdGlvbk5vVW5kbyIsIk5hTiIsInNldFNlbGVjdGlvbklubmVyIiwic2tpcEF0b21pY0luU2VsZWN0aW9uIiwicmVDaGVja1NlbGVjdGlvbiIsIm1heUNsZWFyIiwibmV3QW5jaG9yIiwic2tpcEF0b21pYyIsIm5ld0hlYWQiLCJza2lwQXRvbWljSW5uZXIiLCJvbGRQb3MiLCJwcmV2ZW50Q3Vyc29yTGVmdCIsInNlbGVjdExlZnQiLCJwcmV2ZW50Q3Vyc29yUmlnaHQiLCJzZWxlY3RSaWdodCIsImF0b21pYyIsIm5lYXIiLCJtb3ZlUG9zIiwiZmFyIiwiY2FudEVkaXQiLCJzZWxlY3RBbGwiLCJmaWx0ZXJDaGFuZ2UiLCJjYW5jZWxlZCIsImNhbmNlbCIsIm1ha2VDaGFuZ2UiLCJpZ25vcmVSZWFkT25seSIsInN1cHByZXNzRWRpdHMiLCJtYWtlQ2hhbmdlSW5uZXIiLCJtYWtlQ2hhbmdlU2luZ2xlRG9jIiwicmViYXNlZCIsInJlYmFzZUhpc3QiLCJtYWtlQ2hhbmdlRnJvbUhpc3RvcnkiLCJhbGxvd1NlbGVjdGlvbk9ubHkiLCJzdXBwcmVzcyIsImFudGlDaGFuZ2VzIiwiZmlsdGVyIiwicmV0dXJuZWQiLCJ2Iiwic2hpZnREb2MiLCJkaXN0YW5jZSIsInJlbW92ZWQiLCJtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IiLCJyZWNvbXB1dGVNYXhMZW5ndGgiLCJjaGVja1dpZHRoU3RhcnQiLCJjaGFuZ2VzSGFuZGxlciIsImNoYW5nZUhhbmRsZXIiLCJyZXBsYWNlUmFuZ2UiLCJhc3NpZ24iLCJzcGxpdExpbmVzIiwicmViYXNlSGlzdFNlbFNpbmdsZSIsInJlYmFzZUhpc3RBcnJheSIsInN1YiIsImNvcGllZCIsImNoYW5nZUxpbmUiLCJoYW5kbGUiLCJjaGFuZ2VUeXBlIiwiTGVhZkNodW5rIiwicmVtb3ZlSW5uZXIiLCJpbnNlcnRJbm5lciIsIml0ZXJOIiwiQnJhbmNoQ2h1bmsiLCJyZW1haW5pbmciLCJsZWFmIiwibWF5YmVTcGlsbCIsIm1lIiwic3BpbGxlZCIsInNpYmxpbmciLCJteUluZGV4IiwidXNlZCIsIkxpbmVXaWRnZXQiLCJvcHQiLCJhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlIiwidGhpcyQxIiwib2xkSCIsImFkZExpbmVXaWRnZXQiLCJpbnNlcnRBdCIsImFib3ZlVmlzaWJsZSIsIm5leHRNYXJrZXJJZCIsIlRleHRNYXJrZXIiLCJ3aXRoT3AiLCJ2aXN1YWwiLCJkSGVpZ2h0IiwibWFya1RleHQiLCJtYXJrVGV4dFNoYXJlZCIsInJlcGxhY2VkV2l0aCIsImFkZFRvSGlzdG9yeSIsImN1ckxpbmUiLCJjbGVhck9uRW50ZXIiLCJjbGVhckhpc3RvcnkiLCJTaGFyZWRUZXh0TWFya2VyIiwiY2xvbmVOb2RlIiwiaXNQYXJlbnQiLCJmaW5kU2hhcmVkTWFya2VycyIsImZpbmRNYXJrcyIsImNvcHlTaGFyZWRNYXJrZXJzIiwibUZyb20iLCJtVG8iLCJzdWJNYXJrIiwiZGV0YWNoU2hhcmVkTWFya2VycyIsInN1Yk1hcmtlciIsIm5leHREb2NJZCIsIkRvYyIsImxpbmVTZXAiLCJjbGVhbkdlbmVyYXRpb24iLCJjb25zdHJ1Y3RvciIsImdldFZhbHVlIiwiam9pbiIsImxpbmVTZXBhcmF0b3IiLCJzZXRWYWx1ZSIsImdldFJhbmdlIiwiZ2V0TGluZUhhbmRsZSIsImdldExpbmVOdW1iZXIiLCJnZXRMaW5lSGFuZGxlVmlzdWFsU3RhcnQiLCJsaW5lQ291bnQiLCJsaXN0U2VsZWN0aW9ucyIsInNldEN1cnNvciIsImV4dGVuZFNlbGVjdGlvbnNCeSIsInNldFNlbGVjdGlvbnMiLCJhZGRTZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb25zIiwicmVwbGFjZVNlbGVjdGlvbiIsImR1cCIsInJlcGxhY2VTZWxlY3Rpb25zIiwidW5kbyIsInJlZG8iLCJ1bmRvU2VsZWN0aW9uIiwicmVkb1NlbGVjdGlvbiIsInNldEV4dGVuZGluZyIsImdldEV4dGVuZGluZyIsImhpc3RvcnlTaXplIiwibWFya0NsZWFuIiwiY2hhbmdlR2VuZXJhdGlvbiIsImZvcmNlU3BsaXQiLCJpc0NsZWFuIiwiZ2VuIiwiZ2V0SGlzdG9yeSIsInNldEhpc3RvcnkiLCJoaXN0RGF0YSIsInNldEd1dHRlck1hcmtlciIsImd1dHRlcklEIiwiY2xlYXJHdXR0ZXIiLCJsaW5lSW5mbyIsImFkZExpbmVDbGFzcyIsIndoZXJlIiwicmVtb3ZlTGluZUNsYXNzIiwicmVtb3ZlTGluZVdpZGdldCIsInNldEJvb2ttYXJrIiwicmVhbE9wdHMiLCJmaW5kTWFya3NBdCIsImdldEFsbE1hcmtzIiwicG9zRnJvbUluZGV4Iiwic2VwU2l6ZSIsImluZGV4RnJvbVBvcyIsImNvcHlIaXN0b3J5IiwibGlua2VkRG9jIiwidW5saW5rRG9jIiwibGluayIsInNwbGl0SWRzIiwiaXRlckxpbmtlZERvY3MiLCJnZXRFZGl0b3IiLCJzZXREaXJlY3Rpb24iLCJlYWNoTGluZSIsImxhc3REcm9wIiwib25Ecm9wIiwiY2xlYXJEcmFnQ3Vyc29yIiwiZmlsZXMiLCJkYXRhVHJhbnNmZXIiLCJpc1JlYWRPbmx5IiwiRmlsZVJlYWRlciIsIkZpbGUiLCJyZWFkIiwibWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQiLCJ0IiwicmVhZFRleHRGcm9tRmlsZSIsImZpbGUiLCJhbGxvd0Ryb3BGaWxlVHlwZXMiLCJyZWFkZXIiLCJvbmVycm9yIiwib25sb2FkIiwicmVhZEFzVGV4dCIsInRleHQkMSIsImdldERhdGEiLCJzZWxlY3RlZCIsIm9uRHJhZ1N0YXJ0Iiwic2V0RGF0YSIsImVmZmVjdEFsbG93ZWQiLCJzZXREcmFnSW1hZ2UiLCJpbWciLCJzcmMiLCJfdG9wIiwib25EcmFnT3ZlciIsImZyYWciLCJkcmFnQ3Vyc29yIiwiZm9yRWFjaENvZGVNaXJyb3IiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiYnlDbGFzcyIsImVkaXRvcnMiLCJnbG9iYWxzUmVnaXN0ZXJlZCIsImVuc3VyZUdsb2JhbEhhbmRsZXJzIiwicmVnaXN0ZXJHbG9iYWxIYW5kbGVycyIsInJlc2l6ZVRpbWVyIiwib25SZXNpemUiLCJzZXRTaXplIiwia2V5TmFtZXMiLCJmcm9tQ2hhckNvZGUiLCJrZXlNYXAiLCJiYXNpYyIsInBjRGVmYXVsdCIsImVtYWNzeSIsIm1hY0RlZmF1bHQiLCJub3JtYWxpemVLZXlOYW1lIiwiYWx0IiwiY3RybCIsImNtZCIsIm1vZCIsIm5vcm1hbGl6ZUtleU1hcCIsImtleW1hcCIsImtleW5hbWUiLCJrZXlzIiwibG9va3VwS2V5IiwiZ2V0S2V5TWFwIiwiZmFsbHRocm91Z2giLCJpc01vZGlmaWVyS2V5Iiwia2V5Q29kZSIsImFkZE1vZGlmaWVyTmFtZXMiLCJub1NoaWZ0IiwiYWx0S2V5IiwibWV0YUtleSIsInNoaWZ0S2V5Iiwia2V5TmFtZSIsImFsdEdyYXBoS2V5IiwiZGVsZXRlTmVhclNlbGVjdGlvbiIsImNvbXB1dGUiLCJraWxsIiwidG9LaWxsIiwicmVwbGFjZWQiLCJtb3ZlQ2hhckxvZ2ljYWxseSIsIm1vdmVMb2dpY2FsbHkiLCJlbmRPZkxpbmUiLCJ2aXN1YWxseSIsIm1vdmVJblN0b3JhZ2VPcmRlciIsInByZXAiLCJtb3ZlVmlzdWFsbHkiLCJiaWRpIiwibXYiLCJnZXRXcmFwcGVkTGluZUV4dGVudCIsInNlYXJjaEluVmlzdWFsTGluZSIsImdldFJlcyIsInJlcyIsIm5leHRDaCIsImNvbW1hbmRzIiwic2luZ2xlU2VsZWN0aW9uIiwia2lsbExpbmUiLCJkZWxldGVMaW5lIiwiZGVsTGluZUxlZnQiLCJkZWxXcmFwcGVkTGluZUxlZnQiLCJsZWZ0UG9zIiwiZGVsV3JhcHBlZExpbmVSaWdodCIsInJpZ2h0UG9zIiwiZ29Eb2NTdGFydCIsImdvRG9jRW5kIiwiZ29MaW5lU3RhcnQiLCJnb0xpbmVTdGFydFNtYXJ0IiwibGluZVN0YXJ0U21hcnQiLCJnb0xpbmVFbmQiLCJsaW5lRW5kIiwiZ29MaW5lUmlnaHQiLCJnb0xpbmVMZWZ0IiwiZ29MaW5lTGVmdFNtYXJ0IiwiZ29MaW5lVXAiLCJtb3ZlViIsImdvTGluZURvd24iLCJnb1BhZ2VVcCIsImdvUGFnZURvd24iLCJnb0NoYXJMZWZ0IiwibW92ZUgiLCJnb0NoYXJSaWdodCIsImdvQ29sdW1uTGVmdCIsImdvQ29sdW1uUmlnaHQiLCJnb1dvcmRMZWZ0IiwiZ29Hcm91cFJpZ2h0IiwiZ29Hcm91cExlZnQiLCJnb1dvcmRSaWdodCIsImRlbENoYXJCZWZvcmUiLCJkZWxldGVIIiwiZGVsQ2hhckFmdGVyIiwiZGVsV29yZEJlZm9yZSIsImRlbFdvcmRBZnRlciIsImRlbEdyb3VwQmVmb3JlIiwiZGVsR3JvdXBBZnRlciIsImluZGVudEF1dG8iLCJpbmRlbnRTZWxlY3Rpb24iLCJpbmRlbnRNb3JlIiwiaW5kZW50TGVzcyIsImluc2VydFRhYiIsImluc2VydFNvZnRUYWIiLCJzcGFjZXMiLCJkZWZhdWx0VGFiIiwiZXhlY0NvbW1hbmQiLCJ0cmFuc3Bvc2VDaGFycyIsIm5ld2xpbmVBbmRJbmRlbnQiLCJzZWxzIiwiaW5kZW50TGluZSIsIm9wZW5MaW5lIiwidG9nZ2xlT3ZlcndyaXRlIiwiZmlyc3ROb25XUyIsImluV1MiLCJkb0hhbmRsZUJpbmRpbmciLCJib3VuZCIsImRyb3BTaGlmdCIsImVuc3VyZVBvbGxlZCIsInByZXZTaGlmdCIsImxvb2t1cEtleUZvckVkaXRvciIsImtleU1hcHMiLCJleHRyYUtleXMiLCJzdG9wU2VxIiwiZGlzcGF0Y2hLZXkiLCJzZXEiLCJrZXlTZXEiLCJkaXNwYXRjaEtleUlubmVyIiwiaGFuZGxlS2V5QmluZGluZyIsIm1vdGlvbiIsImhhbmRsZUNoYXJCaW5kaW5nIiwibGFzdFN0b3BwZWRLZXkiLCJvbktleURvd24iLCJnZXRGaWVsZCIsImhhbmRsZWQiLCJzaG93Q3Jvc3NIYWlyIiwidXAiLCJvbktleVVwIiwib25LZXlQcmVzcyIsImNoYXJDb2RlIiwiRE9VQkxFQ0xJQ0tfREVMQVkiLCJQYXN0Q2xpY2siLCJjb21wYXJlIiwibGFzdENsaWNrIiwibGFzdERvdWJsZUNsaWNrIiwiY2xpY2tSZXBlYXQiLCJub3ciLCJvbk1vdXNlRG93biIsInN1cHBvcnRzVG91Y2giLCJjbGlja0luR3V0dGVyIiwicmVwZWF0Iiwic2VsZWN0aW5nVGV4dCIsImhhbmRsZU1hcHBlZEJ1dHRvbiIsImxlZnRCdXR0b25Eb3duIiwib25Db250ZXh0TWVudSIsImNvbmZpZ3VyZU1vdXNlIiwib3B0aW9uIiwidW5pdCIsImFkZE5ldyIsIm1vdmVPbkRyYWciLCJiZWhhdmlvciIsImNvbnRhaW5lZCIsImRyYWdEcm9wIiwibGVmdEJ1dHRvblN0YXJ0RHJhZyIsImxlZnRCdXR0b25TZWxlY3QiLCJtb3ZlZCIsImRyYWdFbmQiLCJtb3VzZU1vdmUiLCJkcmFnU3RhcnQiLCJwcmV2ZW50U2Nyb2xsIiwiZTIiLCJyYW5nZUZvclVuaXQiLCJmaW5kV29yZEF0Iiwib3VyUmFuZ2UiLCJvdXJJbmRleCIsInN0YXJ0U2VsIiwibGFzdFBvcyIsImV4dGVuZFRvIiwic3RhcnRDb2wiLCJwb3NDb2wiLCJvbGRSYW5nZSIsInJhbmdlcyQxIiwiYmlkaVNpbXBsaWZ5IiwiZWRpdG9yU2l6ZSIsImNvdW50ZXIiLCJjdXJDb3VudCIsIm1vdmUiLCJidXR0b25zIiwiYW5jaG9yTGluZSIsImJvdW5kYXJ5IiwiaGVhZEluZGV4IiwidXNlUGFydCIsImd1dHRlckV2ZW50IiwicHJldmVudCIsIm1YIiwibVkiLCJ0b3VjaGVzIiwibGluZUJveCIsImciLCJjb250ZXh0TWVudUluR3V0dGVyIiwidGhlbWVDaGFuZ2VkIiwidGhlbWUiLCJJbml0IiwiZGVmYXVsdHMiLCJvcHRpb25IYW5kbGVycyIsImRlZmluZU9wdGlvbnMiLCJkZWZsdCIsIm5vdE9uSW5pdCIsImRlZmluZU9wdGlvbiIsIm5ld0JyZWFrcyIsInJlZnJlc2giLCJnZXRJbnB1dEZpZWxkIiwic3BlbGxjaGVjayIsImF1dG9jb3JyZWN0IiwiYXV0b2NhcGl0YWxpemUiLCJkZXRhY2giLCJhdHRhY2giLCJ3cmFwcGluZ0NoYW5nZWQiLCJpbnRlZ2VyIiwiYmx1ciIsInJlYWRPbmx5Q2hhbmdlZCIsInNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCIsImRyYWdEcm9wQ2hhbmdlZCIsInJlc2V0UG9zaXRpb24iLCJ3YXNPbiIsImZ1bmNzIiwiZHJhZ0Z1bmN0aW9ucyIsInRvZ2dsZSIsImVudGVyIiwib3ZlciIsImxlYXZlIiwiZHJvcCIsImlucHV0U3R5bGVzIiwiaW5wdXRTdHlsZSIsInBhc3RlSW5jb21pbmciLCJjdXRJbmNvbWluZyIsImF1dG9mb2N1cyIsInJlZ2lzdGVyRXZlbnRIYW5kbGVycyIsImZpbmlzaEluaXQiLCJpbml0SG9va3MiLCJ0ZXh0UmVuZGVyaW5nIiwid29yZCIsInRvdWNoRmluaXNoZWQiLCJwcmV2VG91Y2giLCJmaW5pc2hUb3VjaCIsImlzTW91c2VMaWtlVG91Y2hFdmVudCIsInRvdWNoIiwicmFkaXVzWCIsInJhZGl1c1kiLCJmYXJBd2F5IiwicGFnZVgiLCJwYWdlWSIsImlucCIsImRlZmluZUluaXRIb29rIiwiaG93IiwiYWdncmVzc2l2ZSIsImluZGVudCIsImN1clNwYWNlIiwiY3VyU3BhY2VTdHJpbmciLCJpbmRlbnRVbml0IiwiaW5kZW50U3RyaW5nIiwiaW5kZW50V2l0aFRhYnMiLCJwb3MkMSIsImxhc3RDb3BpZWQiLCJzZXRMYXN0Q29waWVkIiwibmV3TGFzdENvcGllZCIsImFwcGx5VGV4dElucHV0IiwiaW5zZXJ0ZWQiLCJkZWxldGVkIiwicmVjZW50IiwicGFzdGUiLCJ0ZXh0TGluZXMiLCJtdWx0aVBhc3RlIiwicGFzdGVMaW5lc1BlclNlbGVjdGlvbiIsImxpbmVXaXNlIiwiY2hhbmdlRXZlbnQiLCJ0cmlnZ2VyRWxlY3RyaWMiLCJoYW5kbGVQYXN0ZSIsInBhc3RlZCIsImNsaXBib2FyZERhdGEiLCJkaXNhYmxlSW5wdXQiLCJlbGVjdHJpY0NoYXJzIiwic21hcnRJbmRlbnQiLCJnZXRNb2RlQXQiLCJlbGVjdHJpY0lucHV0IiwiY29weWFibGVSYW5nZXMiLCJsaW5lUmFuZ2UiLCJkaXNhYmxlQnJvd3Nlck1hZ2ljIiwiZmllbGQiLCJoaWRkZW5UZXh0YXJlYSIsImJvcmRlciIsImFkZEVkaXRvck1ldGhvZHMiLCJoZWxwZXJzIiwic2V0T3B0aW9uIiwiZ2V0RG9jIiwiYWRkS2V5TWFwIiwicmVtb3ZlS2V5TWFwIiwiYWRkT3ZlcmxheSIsIm1vZGVTcGVjIiwicmVtb3ZlT3ZlcmxheSIsIm5ld1JhbmdlcyIsImdldFRva2VuQXQiLCJnZXRMaW5lVG9rZW5zIiwiZ2V0VG9rZW5UeXBlQXQiLCJnZXRIZWxwZXIiLCJnZXRIZWxwZXJzIiwiaGVscCIsIl9nbG9iYWwiLCJnZXRTdGF0ZUFmdGVyIiwiZGVmYXVsdFRleHRIZWlnaHQiLCJnZXRWaWV3cG9ydCIsImFkZFdpZGdldCIsInZzcGFjZSIsImhzcGFjZSIsInRyaWdnZXJPbktleURvd24iLCJ0cmlnZ2VyT25LZXlQcmVzcyIsInRyaWdnZXJPbktleVVwIiwidHJpZ2dlck9uTW91c2VEb3duIiwiZmluZFBvc0giLCJhbW91bnQiLCJoaXRTaWRlIiwicnRsTW92ZVZpc3VhbGx5IiwiZmluZFBvc1YiLCJnb2FsQ29sdW1uIiwiZ29hbHMiLCJoZWFkUG9zIiwic3RhcnRDaGFyIiwiY2hlY2siLCJzY3JvbGxUbyIsImdldFNjcm9sbEluZm8iLCJpbnRlcnByZXQiLCJzd2FwRG9jIiwicGhyYXNlIiwicGhyYXNlVGV4dCIsInBocmFzZXMiLCJnZXRTY3JvbGxlckVsZW1lbnQiLCJnZXRHdXR0ZXJFbGVtZW50IiwicmVnaXN0ZXJIZWxwZXIiLCJyZWdpc3Rlckdsb2JhbEhlbHBlciIsInByZWRpY2F0ZSIsIm9yaWdEaXIiLCJsaW5lRGlyIiwiZmluZE5leHRMaW5lIiwibW92ZU9uY2UiLCJib3VuZFRvTGluZSIsImFzdHJhbCIsInNhd1R5cGUiLCJwYWdlU2l6ZSIsIm1vdmVBbW91bnQiLCJDb250ZW50RWRpdGFibGVJbnB1dCIsImxhc3RBbmNob3JOb2RlIiwibGFzdEFuY2hvck9mZnNldCIsImxhc3RGb2N1c05vZGUiLCJsYXN0Rm9jdXNPZmZzZXQiLCJwb2xsaW5nIiwiY29tcG9zaW5nIiwiZ3JhY2VQZXJpb2QiLCJyZWFkRE9NVGltZW91dCIsImNvbnRlbnRFZGl0YWJsZSIsImJlbG9uZ3NUb0lucHV0IiwidXBkYXRlRnJvbURPTSIsInJlYWRGcm9tRE9NU29vbiIsImZvcmNlQ29tcG9zaXRpb25FbmQiLCJvbkNvcHlDdXQiLCJsaW5lV2lzZUNvcHlDdXQiLCJjbGVhckRhdGEiLCJrbHVkZ2UiLCJoYWRGb2N1cyIsInNob3dQcmltYXJ5U2VsZWN0aW9uIiwibGFiZWwiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzaG93TXVsdGlwbGVTZWxlY3Rpb25zIiwiY3VyQW5jaG9yIiwiZG9tVG9Qb3MiLCJjdXJGb2N1cyIsImJhZCIsInBvc1RvRE9NIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJybmciLCJzdGFydEdyYWNlUGVyaW9kIiwicmVtZW1iZXJTZWxlY3Rpb24iLCJzZWxlY3Rpb25JbkVkaXRvciIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwicG9sbFNlbGVjdGlvbiIsInBvbGwiLCJwb2xsSW50ZXJ2YWwiLCJpc0luR3V0dGVyIiwicG9sbENvbnRlbnQiLCJmcm9tSW5kZXgiLCJmcm9tTm9kZSIsInRvSW5kZXgiLCJ0b05vZGUiLCJwcmV2aW91c1NpYmxpbmciLCJuZXdUZXh0IiwiZG9tVGV4dEJldHdlZW4iLCJvbGRUZXh0IiwiY3V0RnJvbnQiLCJjdXRFbmQiLCJvbGRUb3AiLCJtYXhDdXRGcm9udCIsIm5ld0JvdCIsIm9sZEJvdCIsIm1heEN1dEVuZCIsImNoRnJvbSIsImNoVG8iLCJzY2FuIiwiYmFkUG9zIiwiY2xvc2luZyIsImV4dHJhTGluZWJyZWFrIiwicmVjb2duaXplTWFya2VyIiwiY2xvc2UiLCJhZGRUZXh0Iiwid2FsayIsImNtVGV4dCIsIm1hcmtlcklEIiwiaXNCbG9jayIsInRleHRDb250ZW50Iiwibm9kZVZhbHVlIiwibGluZU5vZGUiLCJsb2NhdGVOb2RlSW5MaW5lVmlldyIsInRleHROb2RlIiwidG9wTm9kZSIsImN1ck5vZGUiLCJkaXN0JDEiLCJUZXh0YXJlYUlucHV0IiwicHJldklucHV0IiwicG9sbGluZ0Zhc3QiLCJyZXNldHRpbmciLCJjcmVhdGVGaWVsZCIsInRleHRhcmVhIiwiZmFzdFBvbGwiLCJwcmVwYXJlQ29weUN1dCIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIl9kaXNwbGF5Iiwib3B0cyIsIm1vdmVJbnB1dFdpdGhDdXJzb3IiLCJ3cmFwT2ZmIiwibGluZU9mZiIsInRlVG9wIiwidGVMZWZ0IiwiZHJhd24iLCJjb250ZXh0TWVudVBlbmRpbmciLCJzbG93UG9sbCIsIm1pc3NlZCIsInNhbWUiLCJyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUiLCJvbGRDU1MiLCJvbGRXcmFwcGVyQ1NTIiwid3JhcHBlckJveCIsIm9mZnNldFBhcmVudCIsIm9sZFNjcm9sbFkiLCJzY3JvbGxZIiwicmVoaWRlIiwiZGV0ZWN0aW5nU2VsZWN0QWxsIiwicHJlcGFyZVNlbGVjdEFsbEhhY2siLCJleHR2YWwiLCJtb3VzZXVwIiwiZGlzYWJsZWQiLCJmcm9tVGV4dEFyZWEiLCJ0YWJpbmRleCIsInBsYWNlaG9sZGVyIiwicmVhbFN1Ym1pdCIsImZvcm0iLCJsZWF2ZVN1Ym1pdE1ldGhvZEFsb25lIiwic3VibWl0Iiwid3JhcHBlZFN1Ym1pdCIsImdldFRleHRBcmVhIiwidG9UZXh0QXJlYSIsImFkZExlZ2FjeVByb3BzIiwiY21wUG9zIiwiZG9udERlbGVnYXRlIiwibWV0aG9kIiwiZGVmaW5lRXh0ZW5zaW9uIiwiZnVuYyIsImRlZmluZURvY0V4dGVuc2lvbiIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/mode/gfm/gfm.js":
/*!*************************************************!*\
  !*** ./node_modules/codemirror/mode/gfm/gfm.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"), __webpack_require__(/*! ../markdown/markdown */ \"(app-pages-browser)/./node_modules/codemirror/mode/markdown/markdown.js\"), __webpack_require__(/*! ../../addon/mode/overlay */ \"(app-pages-browser)/./node_modules/codemirror/addon/mode/overlay.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\\.beep|\\.lwz|\\.xpc|\\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\\.beeps?|xmpp|xri|ymsgr|z39\\.50[rs]?):(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]|\\([^\\s()<>]*\\))+(?:\\([^\\s()<>]*\\)|[^\\s`*!()\\[\\]{};:'\".,<>?]))/i;\n    CodeMirror1.defineMode(\"gfm\", function(config, modeConfig) {\n        var codeDepth = 0;\n        function blankLine(state) {\n            state.code = false;\n            return null;\n        }\n        var gfmOverlay = {\n            startState: function() {\n                return {\n                    code: false,\n                    codeBlock: false,\n                    ateSpace: false\n                };\n            },\n            copyState: function(s) {\n                return {\n                    code: s.code,\n                    codeBlock: s.codeBlock,\n                    ateSpace: s.ateSpace\n                };\n            },\n            token: function(stream, state) {\n                state.combineTokens = null;\n                // Hack to prevent formatting override inside code blocks (block and inline)\n                if (state.codeBlock) {\n                    if (stream.match(/^```+/)) {\n                        state.codeBlock = false;\n                        return null;\n                    }\n                    stream.skipToEnd();\n                    return null;\n                }\n                if (stream.sol()) {\n                    state.code = false;\n                }\n                if (stream.sol() && stream.match(/^```+/)) {\n                    stream.skipToEnd();\n                    state.codeBlock = true;\n                    return null;\n                }\n                // If this block is changed, it may need to be updated in Markdown mode\n                if (stream.peek() === \"`\") {\n                    stream.next();\n                    var before = stream.pos;\n                    stream.eatWhile(\"`\");\n                    var difference = 1 + stream.pos - before;\n                    if (!state.code) {\n                        codeDepth = difference;\n                        state.code = true;\n                    } else {\n                        if (difference === codeDepth) {\n                            state.code = false;\n                        }\n                    }\n                    return null;\n                } else if (state.code) {\n                    stream.next();\n                    return null;\n                }\n                // Check if space. If so, links can be formatted later on\n                if (stream.eatSpace()) {\n                    state.ateSpace = true;\n                    return null;\n                }\n                if (stream.sol() || state.ateSpace) {\n                    state.ateSpace = false;\n                    if (modeConfig.gitHubSpice !== false) {\n                        if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+@)?(?=.{0,6}\\d)(?:[a-f0-9]{7,40}\\b)/)) {\n                            // User/Project@SHA\n                            // User@SHA\n                            // SHA\n                            state.combineTokens = true;\n                            return \"link\";\n                        } else if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+)?#[0-9]+\\b/)) {\n                            // User/Project#Num\n                            // User#Num\n                            // #Num\n                            state.combineTokens = true;\n                            return \"link\";\n                        }\n                    }\n                }\n                if (stream.match(urlRE) && stream.string.slice(stream.start - 2, stream.start) != \"](\" && (stream.start == 0 || /\\W/.test(stream.string.charAt(stream.start - 1)))) {\n                    // URLs\n                    // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n                    // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine\n                    // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL\n                    state.combineTokens = true;\n                    return \"link\";\n                }\n                stream.next();\n                return null;\n            },\n            blankLine: blankLine\n        };\n        var markdownConfig = {\n            taskLists: true,\n            strikethrough: true,\n            emoji: true\n        };\n        for(var attr in modeConfig){\n            markdownConfig[attr] = modeConfig[attr];\n        }\n        markdownConfig.name = \"markdown\";\n        return CodeMirror1.overlayMode(CodeMirror1.getMode(config, markdownConfig), gfmOverlay);\n    }, \"markdown\");\n    CodeMirror1.defineMIME(\"text/x-gfm\", \"gfm\");\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvZ2ZtL2dmbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBRXBFLFVBQVNBLEdBQUc7SUFDWCxJQUFJLElBQXVELEVBQ3pEQSxJQUFJRyxtQkFBT0EsQ0FBQyw2RkFBc0IsR0FBR0EsbUJBQU9BLENBQUMscUdBQXNCLEdBQUdBLG1CQUFPQSxDQUFDLHFHQUEwQjtTQUNyRyxFQUdhRztBQUNwQixHQUFHLFNBQVNBLFdBQVU7SUFDdEI7SUFFQSxJQUFJQyxRQUFRO0lBRVpELFlBQVdFLFVBQVUsQ0FBQyxPQUFPLFNBQVNDLE1BQU0sRUFBRUMsVUFBVTtRQUN0RCxJQUFJQyxZQUFZO1FBQ2hCLFNBQVNDLFVBQVVDLEtBQUs7WUFDdEJBLE1BQU1DLElBQUksR0FBRztZQUNiLE9BQU87UUFDVDtRQUNBLElBQUlDLGFBQWE7WUFDZkMsWUFBWTtnQkFDVixPQUFPO29CQUNMRixNQUFNO29CQUNORyxXQUFXO29CQUNYQyxVQUFVO2dCQUNaO1lBQ0Y7WUFDQUMsV0FBVyxTQUFTQyxDQUFDO2dCQUNuQixPQUFPO29CQUNMTixNQUFNTSxFQUFFTixJQUFJO29CQUNaRyxXQUFXRyxFQUFFSCxTQUFTO29CQUN0QkMsVUFBVUUsRUFBRUYsUUFBUTtnQkFDdEI7WUFDRjtZQUNBRyxPQUFPLFNBQVNDLE1BQU0sRUFBRVQsS0FBSztnQkFDM0JBLE1BQU1VLGFBQWEsR0FBRztnQkFFdEIsNEVBQTRFO2dCQUM1RSxJQUFJVixNQUFNSSxTQUFTLEVBQUU7b0JBQ25CLElBQUlLLE9BQU9FLEtBQUssQ0FBQyxVQUFVO3dCQUN6QlgsTUFBTUksU0FBUyxHQUFHO3dCQUNsQixPQUFPO29CQUNUO29CQUNBSyxPQUFPRyxTQUFTO29CQUNoQixPQUFPO2dCQUNUO2dCQUNBLElBQUlILE9BQU9JLEdBQUcsSUFBSTtvQkFDaEJiLE1BQU1DLElBQUksR0FBRztnQkFDZjtnQkFDQSxJQUFJUSxPQUFPSSxHQUFHLE1BQU1KLE9BQU9FLEtBQUssQ0FBQyxVQUFVO29CQUN6Q0YsT0FBT0csU0FBUztvQkFDaEJaLE1BQU1JLFNBQVMsR0FBRztvQkFDbEIsT0FBTztnQkFDVDtnQkFDQSx1RUFBdUU7Z0JBQ3ZFLElBQUlLLE9BQU9LLElBQUksT0FBTyxLQUFLO29CQUN6QkwsT0FBT00sSUFBSTtvQkFDWCxJQUFJQyxTQUFTUCxPQUFPUSxHQUFHO29CQUN2QlIsT0FBT1MsUUFBUSxDQUFDO29CQUNoQixJQUFJQyxhQUFhLElBQUlWLE9BQU9RLEdBQUcsR0FBR0Q7b0JBQ2xDLElBQUksQ0FBQ2hCLE1BQU1DLElBQUksRUFBRTt3QkFDZkgsWUFBWXFCO3dCQUNabkIsTUFBTUMsSUFBSSxHQUFHO29CQUNmLE9BQU87d0JBQ0wsSUFBSWtCLGVBQWVyQixXQUFXOzRCQUM1QkUsTUFBTUMsSUFBSSxHQUFHO3dCQUNmO29CQUNGO29CQUNBLE9BQU87Z0JBQ1QsT0FBTyxJQUFJRCxNQUFNQyxJQUFJLEVBQUU7b0JBQ3JCUSxPQUFPTSxJQUFJO29CQUNYLE9BQU87Z0JBQ1Q7Z0JBQ0EseURBQXlEO2dCQUN6RCxJQUFJTixPQUFPVyxRQUFRLElBQUk7b0JBQ3JCcEIsTUFBTUssUUFBUSxHQUFHO29CQUNqQixPQUFPO2dCQUNUO2dCQUNBLElBQUlJLE9BQU9JLEdBQUcsTUFBTWIsTUFBTUssUUFBUSxFQUFFO29CQUNsQ0wsTUFBTUssUUFBUSxHQUFHO29CQUNqQixJQUFJUixXQUFXd0IsV0FBVyxLQUFLLE9BQU87d0JBQ3BDLElBQUdaLE9BQU9FLEtBQUssQ0FBQyxpRkFBaUY7NEJBQy9GLG1CQUFtQjs0QkFDbkIsV0FBVzs0QkFDWCxNQUFNOzRCQUNOWCxNQUFNVSxhQUFhLEdBQUc7NEJBQ3RCLE9BQU87d0JBQ1QsT0FBTyxJQUFJRCxPQUFPRSxLQUFLLENBQUMseURBQXlEOzRCQUMvRSxtQkFBbUI7NEJBQ25CLFdBQVc7NEJBQ1gsT0FBTzs0QkFDUFgsTUFBTVUsYUFBYSxHQUFHOzRCQUN0QixPQUFPO3dCQUNUO29CQUNGO2dCQUNGO2dCQUNBLElBQUlELE9BQU9FLEtBQUssQ0FBQ2pCLFVBQ2JlLE9BQU9hLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDZCxPQUFPZSxLQUFLLEdBQUcsR0FBR2YsT0FBT2UsS0FBSyxLQUFLLFFBQ3REZixDQUFBQSxPQUFPZSxLQUFLLElBQUksS0FBSyxLQUFLQyxJQUFJLENBQUNoQixPQUFPYSxNQUFNLENBQUNJLE1BQU0sQ0FBQ2pCLE9BQU9lLEtBQUssR0FBRyxHQUFFLEdBQUk7b0JBQzVFLE9BQU87b0JBQ1AsZ0ZBQWdGO29CQUNoRixrRkFBa0Y7b0JBQ2xGLHlGQUF5RjtvQkFDekZ4QixNQUFNVSxhQUFhLEdBQUc7b0JBQ3RCLE9BQU87Z0JBQ1Q7Z0JBQ0FELE9BQU9NLElBQUk7Z0JBQ1gsT0FBTztZQUNUO1lBQ0FoQixXQUFXQTtRQUNiO1FBRUEsSUFBSTRCLGlCQUFpQjtZQUNuQkMsV0FBVztZQUNYQyxlQUFlO1lBQ2ZDLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUMsUUFBUWxDLFdBQVk7WUFDM0I4QixjQUFjLENBQUNJLEtBQUssR0FBR2xDLFVBQVUsQ0FBQ2tDLEtBQUs7UUFDekM7UUFDQUosZUFBZUssSUFBSSxHQUFHO1FBQ3RCLE9BQU92QyxZQUFXd0MsV0FBVyxDQUFDeEMsWUFBV3lDLE9BQU8sQ0FBQ3RDLFFBQVErQixpQkFBaUJ6QjtJQUU1RSxHQUFHO0lBRURULFlBQVcwQyxVQUFVLENBQUMsY0FBYztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2dmbS9nZm0uanM/NTdhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNS9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9tYXJrZG93bi9tYXJrZG93blwiKSwgcmVxdWlyZShcIi4uLy4uL2FkZG9uL21vZGUvb3ZlcmxheVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL21hcmtkb3duL21hcmtkb3duXCIsIFwiLi4vLi4vYWRkb24vbW9kZS9vdmVybGF5XCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1cmxSRSA9IC9eKCg/Oig/OmFhYXM/fGFib3V0fGFjYXB8YWRpdW14dHJhfGFmW3BzXXxhaW18YXB0fGF0dGFjaG1lbnR8YXd8YmVzaGFyZXxiaXRjb2lufGJvbG98Y2FsbHRvfGNhcHxjaHJvbWUoPzotZXh0ZW5zaW9uKT98Y2lkfGNvYXB8Y29tLWV2ZW50YnJpdGUtYXR0ZW5kZWV8Y29udGVudHxjcmlkfGN2c3xkYXRhfGRhdnxkaWN0fGRsbmEtKD86cGxheWNvbnRhaW5lcnxwbGF5c2luZ2xlKXxkbnN8ZG9pfGR0bnxkdmJ8ZWQya3xmYWNldGltZXxmZWVkfGZpbGV8ZmluZ2VyfGZpc2h8ZnRwfGdlb3xnZ3xnaXR8Z2l6bW9wcm9qZWN0fGdvfGdvcGhlcnxndGFsa3xoMzIzfGhjcHxodHRwcz98aWF4fGljYXB8aWNvbnxpbXxpbWFwfGluZm98aXBufGlwcHxpcmNbNnNdP3xpcmlzKD86XFwuYmVlcHxcXC5sd3p8XFwueHBjfFxcLnhwY3MpP3xpdG1zfGphcnxqYXZhc2NyaXB0fGptc3xrZXlwYXJjfGxhc3RmbXxsZGFwcz98bWFnbmV0fG1haWx0b3xtYXBzfG1hcmtldHxtZXNzYWdlfG1pZHxtbXN8bXMtaGVscHxtc25pbXxtc3Jwcz98bXRxcHxtdW1ibGV8bXVwZGF0ZXxtdm58bmV3c3xuZnN8bmloP3xubnRwfG5vdGVzfG9pZHxvcGFxdWVsb2NrdG9rZW58cGFsbXxwYXBhcmF6eml8cGxhdGZvcm18cG9wfHByZXN8cHJveHl8cHN5Y3xxdWVyeXxyZXMoPzpvdXJjZSk/fHJtaXxyc3luY3xydG1wfHJ0c3B8c2Vjb25kbGlmZXxzZXJ2aWNlfHNlc3Npb258c2Z0cHxzZ258c2h0dHB8c2lldmV8c2lwcz98c2t5cGV8c21bYnNdfHNubXB8c29hcFxcLmJlZXBzP3xzb2xkYXR8c3BvdGlmeXxzc2h8c3RlYW18c3ZufHRhZ3x0ZWFtc3BlYWt8dGVsKD86bmV0KT98dGZ0cHx0aGluZ3N8dGhpc21lc3NhZ2V8dGlwfHRuMzI3MHx0dnx1ZHB8dW5yZWFsfHVybnx1dDIwMDR8dmVtbWl8dmVudHJpbG98dmlldy1zb3VyY2V8d2ViY2FsfHdzcz98d3RhaXx3eWNpd3lnfHhjb24oPzotdXNlcmlkKT98eGZpcmV8eG1scnBjXFwuYmVlcHM/fHhtcHB8eHJpfHltc2dyfHozOVxcLjUwW3JzXT8pOig/OlxcL3sxLDN9fFthLXowLTklXSl8d3d3XFxkezAsM31bLl18W2EtejAtOS5cXC1dK1suXVthLXpdezIsNH1cXC8pKD86W15cXHMoKTw+XXxcXChbXlxccygpPD5dKlxcKSkrKD86XFwoW15cXHMoKTw+XSpcXCl8W15cXHNgKiEoKVxcW1xcXXt9OzonXCIuLDw+P8KrwrvigJzigJ3igJjigJldKSkvaVxuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJnZm1cIiwgZnVuY3Rpb24oY29uZmlnLCBtb2RlQ29uZmlnKSB7XG4gIHZhciBjb2RlRGVwdGggPSAwO1xuICBmdW5jdGlvbiBibGFua0xpbmUoc3RhdGUpIHtcbiAgICBzdGF0ZS5jb2RlID0gZmFsc2U7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGdmbU92ZXJsYXkgPSB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBmYWxzZSxcbiAgICAgICAgY29kZUJsb2NrOiBmYWxzZSxcbiAgICAgICAgYXRlU3BhY2U6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29weVN0YXRlOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBzLmNvZGUsXG4gICAgICAgIGNvZGVCbG9jazogcy5jb2RlQmxvY2ssXG4gICAgICAgIGF0ZVNwYWNlOiBzLmF0ZVNwYWNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHN0YXRlLmNvbWJpbmVUb2tlbnMgPSBudWxsO1xuXG4gICAgICAvLyBIYWNrIHRvIHByZXZlbnQgZm9ybWF0dGluZyBvdmVycmlkZSBpbnNpZGUgY29kZSBibG9ja3MgKGJsb2NrIGFuZCBpbmxpbmUpXG4gICAgICBpZiAoc3RhdGUuY29kZUJsb2NrKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15gYGArLykpIHtcbiAgICAgICAgICBzdGF0ZS5jb2RlQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBzdGF0ZS5jb2RlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHN0cmVhbS5tYXRjaCgvXmBgYCsvKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHN0YXRlLmNvZGVCbG9jayA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhpcyBibG9jayBpcyBjaGFuZ2VkLCBpdCBtYXkgbmVlZCB0byBiZSB1cGRhdGVkIGluIE1hcmtkb3duIG1vZGVcbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSAnYCcpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHN0cmVhbS5wb3M7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgnYCcpO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IDEgKyBzdHJlYW0ucG9zIC0gYmVmb3JlO1xuICAgICAgICBpZiAoIXN0YXRlLmNvZGUpIHtcbiAgICAgICAgICBjb2RlRGVwdGggPSBkaWZmZXJlbmNlO1xuICAgICAgICAgIHN0YXRlLmNvZGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkaWZmZXJlbmNlID09PSBjb2RlRGVwdGgpIHsgLy8gTXVzdCBiZSBleGFjdFxuICAgICAgICAgICAgc3RhdGUuY29kZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY29kZSkge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIHNwYWNlLiBJZiBzbywgbGlua3MgY2FuIGJlIGZvcm1hdHRlZCBsYXRlciBvblxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICAgIHN0YXRlLmF0ZVNwYWNlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpIHx8IHN0YXRlLmF0ZVNwYWNlKSB7XG4gICAgICAgIHN0YXRlLmF0ZVNwYWNlID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RlQ29uZmlnLmdpdEh1YlNwaWNlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmKHN0cmVhbS5tYXRjaCgvXig/OlthLXpBLVowLTlcXC1fXStcXC8pPyg/OlthLXpBLVowLTlcXC1fXStAKT8oPz0uezAsNn1cXGQpKD86W2EtZjAtOV17Nyw0MH1cXGIpLykpIHtcbiAgICAgICAgICAgIC8vIFVzZXIvUHJvamVjdEBTSEFcbiAgICAgICAgICAgIC8vIFVzZXJAU0hBXG4gICAgICAgICAgICAvLyBTSEFcbiAgICAgICAgICAgIHN0YXRlLmNvbWJpbmVUb2tlbnMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFwibGlua1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eKD86W2EtekEtWjAtOVxcLV9dK1xcLyk/KD86W2EtekEtWjAtOVxcLV9dKyk/I1swLTldK1xcYi8pKSB7XG4gICAgICAgICAgICAvLyBVc2VyL1Byb2plY3QjTnVtXG4gICAgICAgICAgICAvLyBVc2VyI051bVxuICAgICAgICAgICAgLy8gI051bVxuICAgICAgICAgICAgc3RhdGUuY29tYmluZVRva2VucyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gXCJsaW5rXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHVybFJFKSAmJlxuICAgICAgICAgIHN0cmVhbS5zdHJpbmcuc2xpY2Uoc3RyZWFtLnN0YXJ0IC0gMiwgc3RyZWFtLnN0YXJ0KSAhPSBcIl0oXCIgJiZcbiAgICAgICAgICAoc3RyZWFtLnN0YXJ0ID09IDAgfHwgL1xcVy8udGVzdChzdHJlYW0uc3RyaW5nLmNoYXJBdChzdHJlYW0uc3RhcnQgLSAxKSkpKSB7XG4gICAgICAgIC8vIFVSTHNcbiAgICAgICAgLy8gVGFrZW4gZnJvbSBodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0LzIwMTAvMDcvaW1wcm92ZWRfcmVnZXhfZm9yX21hdGNoaW5nX3VybHNcbiAgICAgICAgLy8gQW5kIHRoZW4gKGlzc3VlICMxMTYwKSBzaW1wbGlmaWVkIHRvIG1ha2UgaXQgbm90IGNyYXNoIHRoZSBDaHJvbWUgUmVnZXhwIGVuZ2luZVxuICAgICAgICAvLyBBbmQgdGhlbiBsaW1pdGVkIHVybCBzY2hlbWVzIHRvIHRoZSBDb21tb25NYXJrIGxpc3QsIHNvIGZvbzpiYXIgaXNuJ3QgbWF0Y2hlZCBhcyBhIFVSTFxuICAgICAgICBzdGF0ZS5jb21iaW5lVG9rZW5zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwibGlua1wiO1xuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgYmxhbmtMaW5lOiBibGFua0xpbmVcbiAgfTtcblxuICB2YXIgbWFya2Rvd25Db25maWcgPSB7XG4gICAgdGFza0xpc3RzOiB0cnVlLFxuICAgIHN0cmlrZXRocm91Z2g6IHRydWUsXG4gICAgZW1vamk6IHRydWVcbiAgfTtcbiAgZm9yICh2YXIgYXR0ciBpbiBtb2RlQ29uZmlnKSB7XG4gICAgbWFya2Rvd25Db25maWdbYXR0cl0gPSBtb2RlQ29uZmlnW2F0dHJdO1xuICB9XG4gIG1hcmtkb3duQ29uZmlnLm5hbWUgPSBcIm1hcmtkb3duXCI7XG4gIHJldHVybiBDb2RlTWlycm9yLm92ZXJsYXlNb2RlKENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIG1hcmtkb3duQ29uZmlnKSwgZ2ZtT3ZlcmxheSk7XG5cbn0sIFwibWFya2Rvd25cIik7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWdmbVwiLCBcImdmbVwiKTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsInVybFJFIiwiZGVmaW5lTW9kZSIsImNvbmZpZyIsIm1vZGVDb25maWciLCJjb2RlRGVwdGgiLCJibGFua0xpbmUiLCJzdGF0ZSIsImNvZGUiLCJnZm1PdmVybGF5Iiwic3RhcnRTdGF0ZSIsImNvZGVCbG9jayIsImF0ZVNwYWNlIiwiY29weVN0YXRlIiwicyIsInRva2VuIiwic3RyZWFtIiwiY29tYmluZVRva2VucyIsIm1hdGNoIiwic2tpcFRvRW5kIiwic29sIiwicGVlayIsIm5leHQiLCJiZWZvcmUiLCJwb3MiLCJlYXRXaGlsZSIsImRpZmZlcmVuY2UiLCJlYXRTcGFjZSIsImdpdEh1YlNwaWNlIiwic3RyaW5nIiwic2xpY2UiLCJzdGFydCIsInRlc3QiLCJjaGFyQXQiLCJtYXJrZG93bkNvbmZpZyIsInRhc2tMaXN0cyIsInN0cmlrZXRocm91Z2giLCJlbW9qaSIsImF0dHIiLCJuYW1lIiwib3ZlcmxheU1vZGUiLCJnZXRNb2RlIiwiZGVmaW5lTUlNRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/mode/gfm/gfm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/mode/markdown/markdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/codemirror/mode/markdown/markdown.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"), __webpack_require__(/*! ../xml/xml */ \"(app-pages-browser)/./node_modules/codemirror/mode/xml/xml.js\"), __webpack_require__(/*! ../meta */ \"(app-pages-browser)/./node_modules/codemirror/mode/meta.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    CodeMirror1.defineMode(\"markdown\", function(cmCfg, modeCfg) {\n        var htmlMode = CodeMirror1.getMode(cmCfg, \"text/html\");\n        var htmlModeMissing = htmlMode.name == \"null\";\n        function getMode(name) {\n            if (CodeMirror1.findModeByName) {\n                var found = CodeMirror1.findModeByName(name);\n                if (found) name = found.mime || found.mimes[0];\n            }\n            var mode = CodeMirror1.getMode(cmCfg, name);\n            return mode.name == \"null\" ? null : mode;\n        }\n        // Should characters that affect highlighting be highlighted separate?\n        // Does not include characters that will be output (such as `1.` and `-` for lists)\n        if (modeCfg.highlightFormatting === undefined) modeCfg.highlightFormatting = false;\n        // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\n        // Excess `>` will emit `error` token.\n        if (modeCfg.maxBlockquoteDepth === undefined) modeCfg.maxBlockquoteDepth = 0;\n        // Turn on task lists? (\"- [ ] \" and \"- [x] \")\n        if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\n        // Turn on strikethrough syntax\n        if (modeCfg.strikethrough === undefined) modeCfg.strikethrough = false;\n        if (modeCfg.emoji === undefined) modeCfg.emoji = false;\n        if (modeCfg.fencedCodeBlockHighlighting === undefined) modeCfg.fencedCodeBlockHighlighting = true;\n        if (modeCfg.fencedCodeBlockDefaultMode === undefined) modeCfg.fencedCodeBlockDefaultMode = \"text/plain\";\n        if (modeCfg.xml === undefined) modeCfg.xml = true;\n        // Allow token types to be overridden by user-provided token types.\n        if (modeCfg.tokenTypeOverrides === undefined) modeCfg.tokenTypeOverrides = {};\n        var tokenTypes = {\n            header: \"header\",\n            code: \"comment\",\n            quote: \"quote\",\n            list1: \"variable-2\",\n            list2: \"variable-3\",\n            list3: \"keyword\",\n            hr: \"hr\",\n            image: \"image\",\n            imageAltText: \"image-alt-text\",\n            imageMarker: \"image-marker\",\n            formatting: \"formatting\",\n            linkInline: \"link\",\n            linkEmail: \"link\",\n            linkText: \"link\",\n            linkHref: \"string\",\n            em: \"em\",\n            strong: \"strong\",\n            strikethrough: \"strikethrough\",\n            emoji: \"builtin\"\n        };\n        for(var tokenType in tokenTypes){\n            if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\n                tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\n            }\n        }\n        var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/, listRE = /^(?:[*\\-+]|^[0-9]+([.)]))\\s+/, taskListRE = /^\\[(x| )\\](?=\\s)/i // Must follow listRE\n        , atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, setextHeaderRE = /^ {0,3}(?:\\={1,}|-{2,})\\s*$/, textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~:]+/, fencedCodeRE = /^(~~~+|```+)[ \\t]*([\\w\\/+#-]*)[^\\n`]*$/, linkDefRE = /^\\s*\\[[^\\]]+?\\]:.*$/ // naive link-definition\n        , punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/, expandedTab = \"    \" // CommonMark specifies tab as 4 spaces\n        ;\n        function switchInline(stream, state, f) {\n            state.f = state.inline = f;\n            return f(stream, state);\n        }\n        function switchBlock(stream, state, f) {\n            state.f = state.block = f;\n            return f(stream, state);\n        }\n        function lineIsEmpty(line) {\n            return !line || !/\\S/.test(line.string);\n        }\n        // Blocks\n        function blankLine(state) {\n            // Reset linkTitle state\n            state.linkTitle = false;\n            state.linkHref = false;\n            state.linkText = false;\n            // Reset EM state\n            state.em = false;\n            // Reset STRONG state\n            state.strong = false;\n            // Reset strikethrough state\n            state.strikethrough = false;\n            // Reset state.quote\n            state.quote = 0;\n            // Reset state.indentedCode\n            state.indentedCode = false;\n            if (state.f == htmlBlock) {\n                var exit = htmlModeMissing;\n                if (!exit) {\n                    var inner = CodeMirror1.innerMode(htmlMode, state.htmlState);\n                    exit = inner.mode.name == \"xml\" && inner.state.tagStart === null && !inner.state.context && inner.state.tokenize.isInText;\n                }\n                if (exit) {\n                    state.f = inlineNormal;\n                    state.block = blockNormal;\n                    state.htmlState = null;\n                }\n            }\n            // Reset state.trailingSpace\n            state.trailingSpace = 0;\n            state.trailingSpaceNewLine = false;\n            // Mark this line as blank\n            state.prevLine = state.thisLine;\n            state.thisLine = {\n                stream: null\n            };\n            return null;\n        }\n        function blockNormal(stream, state) {\n            var firstTokenOnLine = stream.column() === state.indentation;\n            var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);\n            var prevLineIsIndentedCode = state.indentedCode;\n            var prevLineIsHr = state.prevLine.hr;\n            var prevLineIsList = state.list !== false;\n            var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;\n            state.indentedCode = false;\n            var lineIndentation = state.indentation;\n            // compute once per line (on first token)\n            if (state.indentationDiff === null) {\n                state.indentationDiff = state.indentation;\n                if (prevLineIsList) {\n                    state.list = null;\n                    // While this list item's marker's indentation is less than the deepest\n                    //  list item's content's indentation,pop the deepest list item\n                    //  indentation off the stack, and update block indentation state\n                    while(lineIndentation < state.listStack[state.listStack.length - 1]){\n                        state.listStack.pop();\n                        if (state.listStack.length) {\n                            state.indentation = state.listStack[state.listStack.length - 1];\n                        // less than the first list's indent -> the line is no longer a list\n                        } else {\n                            state.list = false;\n                        }\n                    }\n                    if (state.list !== false) {\n                        state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];\n                    }\n                }\n            }\n            // not comprehensive (currently only for setext detection purposes)\n            var allowsInlineContinuation = !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header && (!prevLineIsList || !prevLineIsIndentedCode) && !state.prevLine.fencedCodeEnd;\n            var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) && state.indentation <= maxNonCodeIndentation && stream.match(hrRE);\n            var match = null;\n            if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd || state.prevLine.header || prevLineLineIsEmpty)) {\n                stream.skipToEnd();\n                state.indentedCode = true;\n                return tokenTypes.code;\n            } else if (stream.eatSpace()) {\n                return null;\n            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\n                state.quote = 0;\n                state.header = match[1].length;\n                state.thisLine.header = true;\n                if (modeCfg.highlightFormatting) state.formatting = \"header\";\n                state.f = state.inline;\n                return getType(state);\n            } else if (state.indentation <= maxNonCodeIndentation && stream.eat(\">\")) {\n                state.quote = firstTokenOnLine ? 1 : state.quote + 1;\n                if (modeCfg.highlightFormatting) state.formatting = \"quote\";\n                stream.eatSpace();\n                return getType(state);\n            } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {\n                var listType = match[1] ? \"ol\" : \"ul\";\n                state.indentation = lineIndentation + stream.current().length;\n                state.list = true;\n                state.quote = 0;\n                // Add this list item's content's indentation to the stack\n                state.listStack.push(state.indentation);\n                // Reset inline styles which shouldn't propagate across list items\n                state.em = false;\n                state.strong = false;\n                state.code = false;\n                state.strikethrough = false;\n                if (modeCfg.taskLists && stream.match(taskListRE, false)) {\n                    state.taskList = true;\n                }\n                state.f = state.inline;\n                if (modeCfg.highlightFormatting) state.formatting = [\n                    \"list\",\n                    \"list-\" + listType\n                ];\n                return getType(state);\n            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {\n                state.quote = 0;\n                state.fencedEndRE = new RegExp(match[1] + \"+ *$\");\n                // try switching mode\n                state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2] || modeCfg.fencedCodeBlockDefaultMode);\n                if (state.localMode) state.localState = CodeMirror1.startState(state.localMode);\n                state.f = state.block = local;\n                if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n                state.code = -1;\n                return getType(state);\n            // SETEXT has lowest block-scope precedence after HR, so check it after\n            //  the others (code, blockquote, list...)\n            } else if (// if setext set, indicates line after ---/===\n            state.setext || // line before ---/===\n            (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false && !state.code && !isHr && !linkDefRE.test(stream.string) && (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))) {\n                if (!state.setext) {\n                    state.header = match[0].charAt(0) == \"=\" ? 1 : 2;\n                    state.setext = state.header;\n                } else {\n                    state.header = state.setext;\n                    // has no effect on type so we can reset it now\n                    state.setext = 0;\n                    stream.skipToEnd();\n                    if (modeCfg.highlightFormatting) state.formatting = \"header\";\n                }\n                state.thisLine.header = true;\n                state.f = state.inline;\n                return getType(state);\n            } else if (isHr) {\n                stream.skipToEnd();\n                state.hr = true;\n                state.thisLine.hr = true;\n                return tokenTypes.hr;\n            } else if (stream.peek() === \"[\") {\n                return switchInline(stream, state, footnoteLink);\n            }\n            return switchInline(stream, state, state.inline);\n        }\n        function htmlBlock(stream, state) {\n            var style = htmlMode.token(stream, state.htmlState);\n            if (!htmlModeMissing) {\n                var inner = CodeMirror1.innerMode(htmlMode, state.htmlState);\n                if (inner.mode.name == \"xml\" && inner.state.tagStart === null && !inner.state.context && inner.state.tokenize.isInText || state.md_inside && stream.current().indexOf(\">\") > -1) {\n                    state.f = inlineNormal;\n                    state.block = blockNormal;\n                    state.htmlState = null;\n                }\n            }\n            return style;\n        }\n        function local(stream, state) {\n            var currListInd = state.listStack[state.listStack.length - 1] || 0;\n            var hasExitedList = state.indentation < currListInd;\n            var maxFencedEndInd = currListInd + 3;\n            if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {\n                if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n                var returnType;\n                if (!hasExitedList) returnType = getType(state);\n                state.localMode = state.localState = null;\n                state.block = blockNormal;\n                state.f = inlineNormal;\n                state.fencedEndRE = null;\n                state.code = 0;\n                state.thisLine.fencedCodeEnd = true;\n                if (hasExitedList) return switchBlock(stream, state, state.block);\n                return returnType;\n            } else if (state.localMode) {\n                return state.localMode.token(stream, state.localState);\n            } else {\n                stream.skipToEnd();\n                return tokenTypes.code;\n            }\n        }\n        // Inline\n        function getType(state) {\n            var styles = [];\n            if (state.formatting) {\n                styles.push(tokenTypes.formatting);\n                if (typeof state.formatting === \"string\") state.formatting = [\n                    state.formatting\n                ];\n                for(var i = 0; i < state.formatting.length; i++){\n                    styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\n                    if (state.formatting[i] === \"header\") {\n                        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\n                    }\n                    // Add `formatting-quote` and `formatting-quote-#` for blockquotes\n                    // Add `error` instead if the maximum blockquote nesting depth is passed\n                    if (state.formatting[i] === \"quote\") {\n                        if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n                            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\n                        } else {\n                            styles.push(\"error\");\n                        }\n                    }\n                }\n            }\n            if (state.taskOpen) {\n                styles.push(\"meta\");\n                return styles.length ? styles.join(\" \") : null;\n            }\n            if (state.taskClosed) {\n                styles.push(\"property\");\n                return styles.length ? styles.join(\" \") : null;\n            }\n            if (state.linkHref) {\n                styles.push(tokenTypes.linkHref, \"url\");\n            } else {\n                if (state.strong) {\n                    styles.push(tokenTypes.strong);\n                }\n                if (state.em) {\n                    styles.push(tokenTypes.em);\n                }\n                if (state.strikethrough) {\n                    styles.push(tokenTypes.strikethrough);\n                }\n                if (state.emoji) {\n                    styles.push(tokenTypes.emoji);\n                }\n                if (state.linkText) {\n                    styles.push(tokenTypes.linkText);\n                }\n                if (state.code) {\n                    styles.push(tokenTypes.code);\n                }\n                if (state.image) {\n                    styles.push(tokenTypes.image);\n                }\n                if (state.imageAltText) {\n                    styles.push(tokenTypes.imageAltText, \"link\");\n                }\n                if (state.imageMarker) {\n                    styles.push(tokenTypes.imageMarker);\n                }\n            }\n            if (state.header) {\n                styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header);\n            }\n            if (state.quote) {\n                styles.push(tokenTypes.quote);\n                // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\n                if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n                    styles.push(tokenTypes.quote + \"-\" + state.quote);\n                } else {\n                    styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\n                }\n            }\n            if (state.list !== false) {\n                var listMod = (state.listStack.length - 1) % 3;\n                if (!listMod) {\n                    styles.push(tokenTypes.list1);\n                } else if (listMod === 1) {\n                    styles.push(tokenTypes.list2);\n                } else {\n                    styles.push(tokenTypes.list3);\n                }\n            }\n            if (state.trailingSpaceNewLine) {\n                styles.push(\"trailing-space-new-line\");\n            } else if (state.trailingSpace) {\n                styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\n            }\n            return styles.length ? styles.join(\" \") : null;\n        }\n        function handleText(stream, state) {\n            if (stream.match(textRE, true)) {\n                return getType(state);\n            }\n            return undefined;\n        }\n        function inlineNormal(stream, state) {\n            var style = state.text(stream, state);\n            if (typeof style !== \"undefined\") return style;\n            if (state.list) {\n                state.list = null;\n                return getType(state);\n            }\n            if (state.taskList) {\n                var taskOpen = stream.match(taskListRE, true)[1] === \" \";\n                if (taskOpen) state.taskOpen = true;\n                else state.taskClosed = true;\n                if (modeCfg.highlightFormatting) state.formatting = \"task\";\n                state.taskList = false;\n                return getType(state);\n            }\n            state.taskOpen = false;\n            state.taskClosed = false;\n            if (state.header && stream.match(/^#+$/, true)) {\n                if (modeCfg.highlightFormatting) state.formatting = \"header\";\n                return getType(state);\n            }\n            var ch = stream.next();\n            // Matches link titles present on next line\n            if (state.linkTitle) {\n                state.linkTitle = false;\n                var matchCh = ch;\n                if (ch === \"(\") {\n                    matchCh = \")\";\n                }\n                matchCh = (matchCh + \"\").replace(/([.?*+^\\[\\]\\\\(){}|-])/g, \"\\\\$1\");\n                var regex = \"^\\\\s*(?:[^\" + matchCh + \"\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)\" + matchCh;\n                if (stream.match(new RegExp(regex), true)) {\n                    return tokenTypes.linkHref;\n                }\n            }\n            // If this block is changed, it may need to be updated in GFM mode\n            if (ch === \"`\") {\n                var previousFormatting = state.formatting;\n                if (modeCfg.highlightFormatting) state.formatting = \"code\";\n                stream.eatWhile(\"`\");\n                var count = stream.current().length;\n                if (state.code == 0 && (!state.quote || count == 1)) {\n                    state.code = count;\n                    return getType(state);\n                } else if (count == state.code) {\n                    var t = getType(state);\n                    state.code = 0;\n                    return t;\n                } else {\n                    state.formatting = previousFormatting;\n                    return getType(state);\n                }\n            } else if (state.code) {\n                return getType(state);\n            }\n            if (ch === \"\\\\\") {\n                stream.next();\n                if (modeCfg.highlightFormatting) {\n                    var type = getType(state);\n                    var formattingEscape = tokenTypes.formatting + \"-escape\";\n                    return type ? type + \" \" + formattingEscape : formattingEscape;\n                }\n            }\n            if (ch === \"!\" && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\n                state.imageMarker = true;\n                state.image = true;\n                if (modeCfg.highlightFormatting) state.formatting = \"image\";\n                return getType(state);\n            }\n            if (ch === \"[\" && state.imageMarker && stream.match(/[^\\]]*\\](\\(.*?\\)| ?\\[.*?\\])/, false)) {\n                state.imageMarker = false;\n                state.imageAltText = true;\n                if (modeCfg.highlightFormatting) state.formatting = \"image\";\n                return getType(state);\n            }\n            if (ch === \"]\" && state.imageAltText) {\n                if (modeCfg.highlightFormatting) state.formatting = \"image\";\n                var type = getType(state);\n                state.imageAltText = false;\n                state.image = false;\n                state.inline = state.f = linkHref;\n                return type;\n            }\n            if (ch === \"[\" && !state.image) {\n                if (state.linkText && stream.match(/^.*?\\]/)) return getType(state);\n                state.linkText = true;\n                if (modeCfg.highlightFormatting) state.formatting = \"link\";\n                return getType(state);\n            }\n            if (ch === \"]\" && state.linkText) {\n                if (modeCfg.highlightFormatting) state.formatting = \"link\";\n                var type = getType(state);\n                state.linkText = false;\n                state.inline = state.f = stream.match(/\\(.*?\\)| ?\\[.*?\\]/, false) ? linkHref : inlineNormal;\n                return type;\n            }\n            if (ch === \"<\" && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\n                state.f = state.inline = linkInline;\n                if (modeCfg.highlightFormatting) state.formatting = \"link\";\n                var type = getType(state);\n                if (type) {\n                    type += \" \";\n                } else {\n                    type = \"\";\n                }\n                return type + tokenTypes.linkInline;\n            }\n            if (ch === \"<\" && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\n                state.f = state.inline = linkInline;\n                if (modeCfg.highlightFormatting) state.formatting = \"link\";\n                var type = getType(state);\n                if (type) {\n                    type += \" \";\n                } else {\n                    type = \"\";\n                }\n                return type + tokenTypes.linkEmail;\n            }\n            if (modeCfg.xml && ch === \"<\" && stream.match(/^(!--|\\?|!\\[CDATA\\[|[a-z][a-z0-9-]*(?:\\s+[a-z_:.\\-]+(?:\\s*=\\s*[^>]+)?)*\\s*(?:>|$))/i, false)) {\n                var end = stream.string.indexOf(\">\", stream.pos);\n                if (end != -1) {\n                    var atts = stream.string.substring(stream.start, end);\n                    if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\n                }\n                stream.backUp(1);\n                state.htmlState = CodeMirror1.startState(htmlMode);\n                return switchBlock(stream, state, htmlBlock);\n            }\n            if (modeCfg.xml && ch === \"<\" && stream.match(/^\\/\\w*?>/)) {\n                state.md_inside = false;\n                return \"tag\";\n            } else if (ch === \"*\" || ch === \"_\") {\n                var len = 1, before = stream.pos == 1 ? \" \" : stream.string.charAt(stream.pos - 2);\n                while(len < 3 && stream.eat(ch))len++;\n                var after = stream.peek() || \" \";\n                // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis\n                var leftFlanking = !/\\s/.test(after) && (!punctuation.test(after) || /\\s/.test(before) || punctuation.test(before));\n                var rightFlanking = !/\\s/.test(before) && (!punctuation.test(before) || /\\s/.test(after) || punctuation.test(after));\n                var setEm = null, setStrong = null;\n                if (len % 2) {\n                    if (!state.em && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before))) setEm = true;\n                    else if (state.em == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after))) setEm = false;\n                }\n                if (len > 1) {\n                    if (!state.strong && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before))) setStrong = true;\n                    else if (state.strong == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after))) setStrong = false;\n                }\n                if (setStrong != null || setEm != null) {\n                    if (modeCfg.highlightFormatting) state.formatting = setEm == null ? \"strong\" : setStrong == null ? \"em\" : \"strong em\";\n                    if (setEm === true) state.em = ch;\n                    if (setStrong === true) state.strong = ch;\n                    var t = getType(state);\n                    if (setEm === false) state.em = false;\n                    if (setStrong === false) state.strong = false;\n                    return t;\n                }\n            } else if (ch === \" \") {\n                if (stream.eat(\"*\") || stream.eat(\"_\")) {\n                    if (stream.peek() === \" \") {\n                        return getType(state);\n                    } else {\n                        stream.backUp(1);\n                    }\n                }\n            }\n            if (modeCfg.strikethrough) {\n                if (ch === \"~\" && stream.eatWhile(ch)) {\n                    if (state.strikethrough) {\n                        if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n                        var t = getType(state);\n                        state.strikethrough = false;\n                        return t;\n                    } else if (stream.match(/^[^\\s]/, false)) {\n                        state.strikethrough = true;\n                        if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n                        return getType(state);\n                    }\n                } else if (ch === \" \") {\n                    if (stream.match(\"~~\", true)) {\n                        if (stream.peek() === \" \") {\n                            return getType(state);\n                        } else {\n                            stream.backUp(2);\n                        }\n                    }\n                }\n            }\n            if (modeCfg.emoji && ch === \":\" && stream.match(/^(?:[a-z_\\d+][a-z_\\d+-]*|\\-[a-z_\\d+][a-z_\\d+-]*):/)) {\n                state.emoji = true;\n                if (modeCfg.highlightFormatting) state.formatting = \"emoji\";\n                var retType = getType(state);\n                state.emoji = false;\n                return retType;\n            }\n            if (ch === \" \") {\n                if (stream.match(/^ +$/, false)) {\n                    state.trailingSpace++;\n                } else if (state.trailingSpace) {\n                    state.trailingSpaceNewLine = true;\n                }\n            }\n            return getType(state);\n        }\n        function linkInline(stream, state) {\n            var ch = stream.next();\n            if (ch === \">\") {\n                state.f = state.inline = inlineNormal;\n                if (modeCfg.highlightFormatting) state.formatting = \"link\";\n                var type = getType(state);\n                if (type) {\n                    type += \" \";\n                } else {\n                    type = \"\";\n                }\n                return type + tokenTypes.linkInline;\n            }\n            stream.match(/^[^>]+/, true);\n            return tokenTypes.linkInline;\n        }\n        function linkHref(stream, state) {\n            // Check if space, and return NULL if so (to avoid marking the space)\n            if (stream.eatSpace()) {\n                return null;\n            }\n            var ch = stream.next();\n            if (ch === \"(\" || ch === \"[\") {\n                state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\n                if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n                state.linkHref = true;\n                return getType(state);\n            }\n            return \"error\";\n        }\n        var linkRE = {\n            \")\": /^(?:[^\\\\\\(\\)]|\\\\.|\\((?:[^\\\\\\(\\)]|\\\\.)*\\))*?(?=\\))/,\n            \"]\": /^(?:[^\\\\\\[\\]]|\\\\.|\\[(?:[^\\\\\\[\\]]|\\\\.)*\\])*?(?=\\])/\n        };\n        function getLinkHrefInside(endChar) {\n            return function(stream, state) {\n                var ch = stream.next();\n                if (ch === endChar) {\n                    state.f = state.inline = inlineNormal;\n                    if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n                    var returnState = getType(state);\n                    state.linkHref = false;\n                    return returnState;\n                }\n                stream.match(linkRE[endChar]);\n                state.linkHref = true;\n                return getType(state);\n            };\n        }\n        function footnoteLink(stream, state) {\n            if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\n                state.f = footnoteLinkInside;\n                stream.next(); // Consume [\n                if (modeCfg.highlightFormatting) state.formatting = \"link\";\n                state.linkText = true;\n                return getType(state);\n            }\n            return switchInline(stream, state, inlineNormal);\n        }\n        function footnoteLinkInside(stream, state) {\n            if (stream.match(\"]:\", true)) {\n                state.f = state.inline = footnoteUrl;\n                if (modeCfg.highlightFormatting) state.formatting = \"link\";\n                var returnType = getType(state);\n                state.linkText = false;\n                return returnType;\n            }\n            stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\n            return tokenTypes.linkText;\n        }\n        function footnoteUrl(stream, state) {\n            // Check if space, and return NULL if so (to avoid marking the space)\n            if (stream.eatSpace()) {\n                return null;\n            }\n            // Match URL\n            stream.match(/^[^\\s]+/, true);\n            // Check for link title\n            if (stream.peek() === undefined) {\n                state.linkTitle = true;\n            } else {\n                stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\.)+\"|'(?:[^'\\\\]|\\\\.)+'|\\((?:[^)\\\\]|\\\\.)+\\)))?/, true);\n            }\n            state.f = state.inline = inlineNormal;\n            return tokenTypes.linkHref + \" url\";\n        }\n        var mode = {\n            startState: function() {\n                return {\n                    f: blockNormal,\n                    prevLine: {\n                        stream: null\n                    },\n                    thisLine: {\n                        stream: null\n                    },\n                    block: blockNormal,\n                    htmlState: null,\n                    indentation: 0,\n                    inline: inlineNormal,\n                    text: handleText,\n                    formatting: false,\n                    linkText: false,\n                    linkHref: false,\n                    linkTitle: false,\n                    code: 0,\n                    em: false,\n                    strong: false,\n                    header: 0,\n                    setext: 0,\n                    hr: false,\n                    taskList: false,\n                    list: false,\n                    listStack: [],\n                    quote: 0,\n                    trailingSpace: 0,\n                    trailingSpaceNewLine: false,\n                    strikethrough: false,\n                    emoji: false,\n                    fencedEndRE: null\n                };\n            },\n            copyState: function(s) {\n                return {\n                    f: s.f,\n                    prevLine: s.prevLine,\n                    thisLine: s.thisLine,\n                    block: s.block,\n                    htmlState: s.htmlState && CodeMirror1.copyState(htmlMode, s.htmlState),\n                    indentation: s.indentation,\n                    localMode: s.localMode,\n                    localState: s.localMode ? CodeMirror1.copyState(s.localMode, s.localState) : null,\n                    inline: s.inline,\n                    text: s.text,\n                    formatting: false,\n                    linkText: s.linkText,\n                    linkTitle: s.linkTitle,\n                    linkHref: s.linkHref,\n                    code: s.code,\n                    em: s.em,\n                    strong: s.strong,\n                    strikethrough: s.strikethrough,\n                    emoji: s.emoji,\n                    header: s.header,\n                    setext: s.setext,\n                    hr: s.hr,\n                    taskList: s.taskList,\n                    list: s.list,\n                    listStack: s.listStack.slice(0),\n                    quote: s.quote,\n                    indentedCode: s.indentedCode,\n                    trailingSpace: s.trailingSpace,\n                    trailingSpaceNewLine: s.trailingSpaceNewLine,\n                    md_inside: s.md_inside,\n                    fencedEndRE: s.fencedEndRE\n                };\n            },\n            token: function(stream, state) {\n                // Reset state.formatting\n                state.formatting = false;\n                if (stream != state.thisLine.stream) {\n                    state.header = 0;\n                    state.hr = false;\n                    if (stream.match(/^\\s*$/, true)) {\n                        blankLine(state);\n                        return null;\n                    }\n                    state.prevLine = state.thisLine;\n                    state.thisLine = {\n                        stream: stream\n                    };\n                    // Reset state.taskList\n                    state.taskList = false;\n                    // Reset state.trailingSpace\n                    state.trailingSpace = 0;\n                    state.trailingSpaceNewLine = false;\n                    if (!state.localState) {\n                        state.f = state.block;\n                        if (state.f != htmlBlock) {\n                            var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, expandedTab).length;\n                            state.indentation = indentation;\n                            state.indentationDiff = null;\n                            if (indentation > 0) return null;\n                        }\n                    }\n                }\n                return state.f(stream, state);\n            },\n            innerMode: function(state) {\n                if (state.block == htmlBlock) return {\n                    state: state.htmlState,\n                    mode: htmlMode\n                };\n                if (state.localState) return {\n                    state: state.localState,\n                    mode: state.localMode\n                };\n                return {\n                    state: state,\n                    mode: mode\n                };\n            },\n            indent: function(state, textAfter, line) {\n                if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line);\n                if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line);\n                return CodeMirror1.Pass;\n            },\n            blankLine: blankLine,\n            getType: getType,\n            blockCommentStart: \"<!--\",\n            blockCommentEnd: \"-->\",\n            closeBrackets: \"()[]{}''\\\"\\\"``\",\n            fold: \"markdown\"\n        };\n        return mode;\n    }, \"xml\");\n    CodeMirror1.defineMIME(\"text/markdown\", \"markdown\");\n    CodeMirror1.defineMIME(\"text/x-markdown\", \"markdown\");\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbWFya2Rvd24vbWFya2Rvd24uanMiLCJtYXBwaW5ncyI6IkFBQUEsMkRBQTJEO0FBQzNELHFFQUFxRTtBQUVwRSxVQUFTQSxHQUFHO0lBQ1gsSUFBSSxJQUF1RCxFQUN6REEsSUFBSUcsbUJBQU9BLENBQUMsNkZBQXNCLEdBQUdBLG1CQUFPQSxDQUFDLGlGQUFZLEdBQUdBLG1CQUFPQSxDQUFDLDJFQUFTO1NBQzFFLEVBR2FHO0FBQ3BCLEdBQUcsU0FBU0EsV0FBVTtJQUN0QjtJQUVBQSxZQUFXQyxVQUFVLENBQUMsWUFBWSxTQUFTQyxLQUFLLEVBQUVDLE9BQU87UUFFdkQsSUFBSUMsV0FBV0osWUFBV0ssT0FBTyxDQUFDSCxPQUFPO1FBQ3pDLElBQUlJLGtCQUFrQkYsU0FBU0csSUFBSSxJQUFJO1FBRXZDLFNBQVNGLFFBQVFFLElBQUk7WUFDbkIsSUFBSVAsWUFBV1EsY0FBYyxFQUFFO2dCQUM3QixJQUFJQyxRQUFRVCxZQUFXUSxjQUFjLENBQUNEO2dCQUN0QyxJQUFJRSxPQUFPRixPQUFPRSxNQUFNQyxJQUFJLElBQUlELE1BQU1FLEtBQUssQ0FBQyxFQUFFO1lBQ2hEO1lBQ0EsSUFBSUMsT0FBT1osWUFBV0ssT0FBTyxDQUFDSCxPQUFPSztZQUNyQyxPQUFPSyxLQUFLTCxJQUFJLElBQUksU0FBUyxPQUFPSztRQUN0QztRQUVBLHNFQUFzRTtRQUN0RSxtRkFBbUY7UUFDbkYsSUFBSVQsUUFBUVUsbUJBQW1CLEtBQUtDLFdBQ2xDWCxRQUFRVSxtQkFBbUIsR0FBRztRQUVoQyx1RUFBdUU7UUFDdkUsc0NBQXNDO1FBQ3RDLElBQUlWLFFBQVFZLGtCQUFrQixLQUFLRCxXQUNqQ1gsUUFBUVksa0JBQWtCLEdBQUc7UUFFL0IsOENBQThDO1FBQzlDLElBQUlaLFFBQVFhLFNBQVMsS0FBS0YsV0FBV1gsUUFBUWEsU0FBUyxHQUFHO1FBRXpELCtCQUErQjtRQUMvQixJQUFJ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LElBQUlRLGFBQWFoRSxTQUFTc0ssTUFBTSxFQUFFLE9BQU90SyxTQUFTc0ssTUFBTSxDQUFDbEgsTUFBTWdCLFNBQVMsRUFBRW1HLFdBQVc3RztnQkFDcEcsSUFBSU4sTUFBTXlELFVBQVUsSUFBSXpELE1BQU13RCxTQUFTLENBQUMwRCxNQUFNLEVBQUUsT0FBT2xILE1BQU13RCxTQUFTLENBQUMwRCxNQUFNLENBQUNsSCxNQUFNeUQsVUFBVSxFQUFFMEQsV0FBVzdHO2dCQUMzRyxPQUFPOUQsWUFBVzRLLElBQUk7WUFDeEI7WUFFQTNHLFdBQVdBO1lBRVhzQyxTQUFTQTtZQUVUc0UsbUJBQW1CO1lBQ25CQyxpQkFBaUI7WUFDakJDLGVBQWU7WUFDZkMsTUFBTTtRQUNSO1FBQ0EsT0FBT3BLO0lBQ1QsR0FBRztJQUVIWixZQUFXaUwsVUFBVSxDQUFDLGlCQUFpQjtJQUV2Q2pMLFlBQVdpTCxVQUFVLENBQUMsbUJBQW1CO0FBRXpDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbWFya2Rvd24vbWFya2Rvd24uanM/YzEyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNS9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi94bWwveG1sXCIpLCByZXF1aXJlKFwiLi4vbWV0YVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL3htbC94bWxcIiwgXCIuLi9tZXRhXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm1hcmtkb3duXCIsIGZ1bmN0aW9uKGNtQ2ZnLCBtb2RlQ2ZnKSB7XG5cbiAgdmFyIGh0bWxNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNtQ2ZnLCBcInRleHQvaHRtbFwiKTtcbiAgdmFyIGh0bWxNb2RlTWlzc2luZyA9IGh0bWxNb2RlLm5hbWUgPT0gXCJudWxsXCJcblxuICBmdW5jdGlvbiBnZXRNb2RlKG5hbWUpIHtcbiAgICBpZiAoQ29kZU1pcnJvci5maW5kTW9kZUJ5TmFtZSkge1xuICAgICAgdmFyIGZvdW5kID0gQ29kZU1pcnJvci5maW5kTW9kZUJ5TmFtZShuYW1lKTtcbiAgICAgIGlmIChmb3VuZCkgbmFtZSA9IGZvdW5kLm1pbWUgfHwgZm91bmQubWltZXNbMF07XG4gICAgfVxuICAgIHZhciBtb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNtQ2ZnLCBuYW1lKTtcbiAgICByZXR1cm4gbW9kZS5uYW1lID09IFwibnVsbFwiID8gbnVsbCA6IG1vZGU7XG4gIH1cblxuICAvLyBTaG91bGQgY2hhcmFjdGVycyB0aGF0IGFmZmVjdCBoaWdobGlnaHRpbmcgYmUgaGlnaGxpZ2h0ZWQgc2VwYXJhdGU/XG4gIC8vIERvZXMgbm90IGluY2x1ZGUgY2hhcmFjdGVycyB0aGF0IHdpbGwgYmUgb3V0cHV0IChzdWNoIGFzIGAxLmAgYW5kIGAtYCBmb3IgbGlzdHMpXG4gIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcgPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcgPSBmYWxzZTtcblxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBuZXN0ZWQgYmxvY2txdW90ZXMuIFNldCB0byAwIGZvciBpbmZpbml0ZSBuZXN0aW5nLlxuICAvLyBFeGNlc3MgYD5gIHdpbGwgZW1pdCBgZXJyb3JgIHRva2VuLlxuICBpZiAobW9kZUNmZy5tYXhCbG9ja3F1b3RlRGVwdGggPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLm1heEJsb2NrcXVvdGVEZXB0aCA9IDA7XG5cbiAgLy8gVHVybiBvbiB0YXNrIGxpc3RzPyAoXCItIFsgXSBcIiBhbmQgXCItIFt4XSBcIilcbiAgaWYgKG1vZGVDZmcudGFza0xpc3RzID09PSB1bmRlZmluZWQpIG1vZGVDZmcudGFza0xpc3RzID0gZmFsc2U7XG5cbiAgLy8gVHVybiBvbiBzdHJpa2V0aHJvdWdoIHN5bnRheFxuICBpZiAobW9kZUNmZy5zdHJpa2V0aHJvdWdoID09PSB1bmRlZmluZWQpXG4gICAgbW9kZUNmZy5zdHJpa2V0aHJvdWdoID0gZmFsc2U7XG5cbiAgaWYgKG1vZGVDZmcuZW1vamkgPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLmVtb2ppID0gZmFsc2U7XG5cbiAgaWYgKG1vZGVDZmcuZmVuY2VkQ29kZUJsb2NrSGlnaGxpZ2h0aW5nID09PSB1bmRlZmluZWQpXG4gICAgbW9kZUNmZy5mZW5jZWRDb2RlQmxvY2tIaWdobGlnaHRpbmcgPSB0cnVlO1xuXG4gIGlmIChtb2RlQ2ZnLmZlbmNlZENvZGVCbG9ja0RlZmF1bHRNb2RlID09PSB1bmRlZmluZWQpXG4gICAgbW9kZUNmZy5mZW5jZWRDb2RlQmxvY2tEZWZhdWx0TW9kZSA9ICd0ZXh0L3BsYWluJztcblxuICBpZiAobW9kZUNmZy54bWwgPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLnhtbCA9IHRydWU7XG5cbiAgLy8gQWxsb3cgdG9rZW4gdHlwZXMgdG8gYmUgb3ZlcnJpZGRlbiBieSB1c2VyLXByb3ZpZGVkIHRva2VuIHR5cGVzLlxuICBpZiAobW9kZUNmZy50b2tlblR5cGVPdmVycmlkZXMgPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLnRva2VuVHlwZU92ZXJyaWRlcyA9IHt9O1xuXG4gIHZhciB0b2tlblR5cGVzID0ge1xuICAgIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgICBjb2RlOiBcImNvbW1lbnRcIixcbiAgICBxdW90ZTogXCJxdW90ZVwiLFxuICAgIGxpc3QxOiBcInZhcmlhYmxlLTJcIixcbiAgICBsaXN0MjogXCJ2YXJpYWJsZS0zXCIsXG4gICAgbGlzdDM6IFwia2V5d29yZFwiLFxuICAgIGhyOiBcImhyXCIsXG4gICAgaW1hZ2U6IFwiaW1hZ2VcIixcbiAgICBpbWFnZUFsdFRleHQ6IFwiaW1hZ2UtYWx0LXRleHRcIixcbiAgICBpbWFnZU1hcmtlcjogXCJpbWFnZS1tYXJrZXJcIixcbiAgICBmb3JtYXR0aW5nOiBcImZvcm1hdHRpbmdcIixcbiAgICBsaW5rSW5saW5lOiBcImxpbmtcIixcbiAgICBsaW5rRW1haWw6IFwibGlua1wiLFxuICAgIGxpbmtUZXh0OiBcImxpbmtcIixcbiAgICBsaW5rSHJlZjogXCJzdHJpbmdcIixcbiAgICBlbTogXCJlbVwiLFxuICAgIHN0cm9uZzogXCJzdHJvbmdcIixcbiAgICBzdHJpa2V0aHJvdWdoOiBcInN0cmlrZXRocm91Z2hcIixcbiAgICBlbW9qaTogXCJidWlsdGluXCJcbiAgfTtcblxuICBmb3IgKHZhciB0b2tlblR5cGUgaW4gdG9rZW5UeXBlcykge1xuICAgIGlmICh0b2tlblR5cGVzLmhhc093blByb3BlcnR5KHRva2VuVHlwZSkgJiYgbW9kZUNmZy50b2tlblR5cGVPdmVycmlkZXNbdG9rZW5UeXBlXSkge1xuICAgICAgdG9rZW5UeXBlc1t0b2tlblR5cGVdID0gbW9kZUNmZy50b2tlblR5cGVPdmVycmlkZXNbdG9rZW5UeXBlXTtcbiAgICB9XG4gIH1cblxuICB2YXIgaHJSRSA9IC9eKFsqXFwtX10pKD86XFxzKlxcMSl7Mix9XFxzKiQvXG4gICwgICBsaXN0UkUgPSAvXig/OlsqXFwtK118XlswLTldKyhbLildKSlcXHMrL1xuICAsICAgdGFza0xpc3RSRSA9IC9eXFxbKHh8IClcXF0oPz1cXHMpL2kgLy8gTXVzdCBmb2xsb3cgbGlzdFJFXG4gICwgICBhdHhIZWFkZXJSRSA9IG1vZGVDZmcuYWxsb3dBdHhIZWFkZXJXaXRob3V0U3BhY2UgPyAvXigjKykvIDogL14oIyspKD86IHwkKS9cbiAgLCAgIHNldGV4dEhlYWRlclJFID0gL14gezAsM30oPzpcXD17MSx9fC17Mix9KVxccyokL1xuICAsICAgdGV4dFJFID0gL15bXiMhXFxbXFxdKl9cXFxcPD5gIFwiJyh+Ol0rL1xuICAsICAgZmVuY2VkQ29kZVJFID0gL14ofn5+K3xgYGArKVsgXFx0XSooW1xcd1xcLysjLV0qKVteXFxuYF0qJC9cbiAgLCAgIGxpbmtEZWZSRSA9IC9eXFxzKlxcW1teXFxdXSs/XFxdOi4qJC8gLy8gbmFpdmUgbGluay1kZWZpbml0aW9uXG4gICwgICBwdW5jdHVhdGlvbiA9IC9bIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AXFxbXFxcXFxcXV5fYHt8fX5cXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQyXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURGM0MtXFx1REYzRV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdL1xuICAsICAgZXhwYW5kZWRUYWIgPSBcIiAgICBcIiAvLyBDb21tb25NYXJrIHNwZWNpZmllcyB0YWIgYXMgNCBzcGFjZXNcblxuICBmdW5jdGlvbiBzd2l0Y2hJbmxpbmUoc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmUgPSBmO1xuICAgIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3dpdGNoQmxvY2soc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgIHN0YXRlLmYgPSBzdGF0ZS5ibG9jayA9IGY7XG4gICAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lSXNFbXB0eShsaW5lKSB7XG4gICAgcmV0dXJuICFsaW5lIHx8ICEvXFxTLy50ZXN0KGxpbmUuc3RyaW5nKVxuICB9XG5cbiAgLy8gQmxvY2tzXG5cbiAgZnVuY3Rpb24gYmxhbmtMaW5lKHN0YXRlKSB7XG4gICAgLy8gUmVzZXQgbGlua1RpdGxlIHN0YXRlXG4gICAgc3RhdGUubGlua1RpdGxlID0gZmFsc2U7XG4gICAgc3RhdGUubGlua0hyZWYgPSBmYWxzZTtcbiAgICBzdGF0ZS5saW5rVGV4dCA9IGZhbHNlO1xuICAgIC8vIFJlc2V0IEVNIHN0YXRlXG4gICAgc3RhdGUuZW0gPSBmYWxzZTtcbiAgICAvLyBSZXNldCBTVFJPTkcgc3RhdGVcbiAgICBzdGF0ZS5zdHJvbmcgPSBmYWxzZTtcbiAgICAvLyBSZXNldCBzdHJpa2V0aHJvdWdoIHN0YXRlXG4gICAgc3RhdGUuc3RyaWtldGhyb3VnaCA9IGZhbHNlO1xuICAgIC8vIFJlc2V0IHN0YXRlLnF1b3RlXG4gICAgc3RhdGUucXVvdGUgPSAwO1xuICAgIC8vIFJlc2V0IHN0YXRlLmluZGVudGVkQ29kZVxuICAgIHN0YXRlLmluZGVudGVkQ29kZSA9IGZhbHNlO1xuICAgIGlmIChzdGF0ZS5mID09IGh0bWxCbG9jaykge1xuICAgICAgdmFyIGV4aXQgPSBodG1sTW9kZU1pc3NpbmdcbiAgICAgIGlmICghZXhpdCkge1xuICAgICAgICB2YXIgaW5uZXIgPSBDb2RlTWlycm9yLmlubmVyTW9kZShodG1sTW9kZSwgc3RhdGUuaHRtbFN0YXRlKVxuICAgICAgICBleGl0ID0gaW5uZXIubW9kZS5uYW1lID09IFwieG1sXCIgJiYgaW5uZXIuc3RhdGUudGFnU3RhcnQgPT09IG51bGwgJiZcbiAgICAgICAgICAoIWlubmVyLnN0YXRlLmNvbnRleHQgJiYgaW5uZXIuc3RhdGUudG9rZW5pemUuaXNJblRleHQpXG4gICAgICB9XG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBzdGF0ZS5mID0gaW5saW5lTm9ybWFsO1xuICAgICAgICBzdGF0ZS5ibG9jayA9IGJsb2NrTm9ybWFsO1xuICAgICAgICBzdGF0ZS5odG1sU3RhdGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXNldCBzdGF0ZS50cmFpbGluZ1NwYWNlXG4gICAgc3RhdGUudHJhaWxpbmdTcGFjZSA9IDA7XG4gICAgc3RhdGUudHJhaWxpbmdTcGFjZU5ld0xpbmUgPSBmYWxzZTtcbiAgICAvLyBNYXJrIHRoaXMgbGluZSBhcyBibGFua1xuICAgIHN0YXRlLnByZXZMaW5lID0gc3RhdGUudGhpc0xpbmVcbiAgICBzdGF0ZS50aGlzTGluZSA9IHtzdHJlYW06IG51bGx9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBibG9ja05vcm1hbChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGZpcnN0VG9rZW5PbkxpbmUgPSBzdHJlYW0uY29sdW1uKCkgPT09IHN0YXRlLmluZGVudGF0aW9uO1xuICAgIHZhciBwcmV2TGluZUxpbmVJc0VtcHR5ID0gbGluZUlzRW1wdHkoc3RhdGUucHJldkxpbmUuc3RyZWFtKTtcbiAgICB2YXIgcHJldkxpbmVJc0luZGVudGVkQ29kZSA9IHN0YXRlLmluZGVudGVkQ29kZTtcbiAgICB2YXIgcHJldkxpbmVJc0hyID0gc3RhdGUucHJldkxpbmUuaHI7XG4gICAgdmFyIHByZXZMaW5lSXNMaXN0ID0gc3RhdGUubGlzdCAhPT0gZmFsc2U7XG4gICAgdmFyIG1heE5vbkNvZGVJbmRlbnRhdGlvbiA9IChzdGF0ZS5saXN0U3RhY2tbc3RhdGUubGlzdFN0YWNrLmxlbmd0aCAtIDFdIHx8IDApICsgMztcblxuICAgIHN0YXRlLmluZGVudGVkQ29kZSA9IGZhbHNlO1xuXG4gICAgdmFyIGxpbmVJbmRlbnRhdGlvbiA9IHN0YXRlLmluZGVudGF0aW9uO1xuICAgIC8vIGNvbXB1dGUgb25jZSBwZXIgbGluZSAob24gZmlyc3QgdG9rZW4pXG4gICAgaWYgKHN0YXRlLmluZGVudGF0aW9uRGlmZiA9PT0gbnVsbCkge1xuICAgICAgc3RhdGUuaW5kZW50YXRpb25EaWZmID0gc3RhdGUuaW5kZW50YXRpb247XG4gICAgICBpZiAocHJldkxpbmVJc0xpc3QpIHtcbiAgICAgICAgc3RhdGUubGlzdCA9IG51bGw7XG4gICAgICAgIC8vIFdoaWxlIHRoaXMgbGlzdCBpdGVtJ3MgbWFya2VyJ3MgaW5kZW50YXRpb24gaXMgbGVzcyB0aGFuIHRoZSBkZWVwZXN0XG4gICAgICAgIC8vICBsaXN0IGl0ZW0ncyBjb250ZW50J3MgaW5kZW50YXRpb24scG9wIHRoZSBkZWVwZXN0IGxpc3QgaXRlbVxuICAgICAgICAvLyAgaW5kZW50YXRpb24gb2ZmIHRoZSBzdGFjaywgYW5kIHVwZGF0ZSBibG9jayBpbmRlbnRhdGlvbiBzdGF0ZVxuICAgICAgICB3aGlsZSAobGluZUluZGVudGF0aW9uIDwgc3RhdGUubGlzdFN0YWNrW3N0YXRlLmxpc3RTdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgIHN0YXRlLmxpc3RTdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhdGUubGlzdFN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUuaW5kZW50YXRpb24gPSBzdGF0ZS5saXN0U3RhY2tbc3RhdGUubGlzdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgZmlyc3QgbGlzdCdzIGluZGVudCAtPiB0aGUgbGluZSBpcyBubyBsb25nZXIgYSBsaXN0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmxpc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmxpc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc3RhdGUuaW5kZW50YXRpb25EaWZmID0gbGluZUluZGVudGF0aW9uIC0gc3RhdGUubGlzdFN0YWNrW3N0YXRlLmxpc3RTdGFjay5sZW5ndGggLSAxXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm90IGNvbXByZWhlbnNpdmUgKGN1cnJlbnRseSBvbmx5IGZvciBzZXRleHQgZGV0ZWN0aW9uIHB1cnBvc2VzKVxuICAgIHZhciBhbGxvd3NJbmxpbmVDb250aW51YXRpb24gPSAoXG4gICAgICAgICFwcmV2TGluZUxpbmVJc0VtcHR5ICYmICFwcmV2TGluZUlzSHIgJiYgIXN0YXRlLnByZXZMaW5lLmhlYWRlciAmJlxuICAgICAgICAoIXByZXZMaW5lSXNMaXN0IHx8ICFwcmV2TGluZUlzSW5kZW50ZWRDb2RlKSAmJlxuICAgICAgICAhc3RhdGUucHJldkxpbmUuZmVuY2VkQ29kZUVuZFxuICAgICk7XG5cbiAgICB2YXIgaXNIciA9IChzdGF0ZS5saXN0ID09PSBmYWxzZSB8fCBwcmV2TGluZUlzSHIgfHwgcHJldkxpbmVMaW5lSXNFbXB0eSkgJiZcbiAgICAgIHN0YXRlLmluZGVudGF0aW9uIDw9IG1heE5vbkNvZGVJbmRlbnRhdGlvbiAmJiBzdHJlYW0ubWF0Y2goaHJSRSk7XG5cbiAgICB2YXIgbWF0Y2ggPSBudWxsO1xuICAgIGlmIChzdGF0ZS5pbmRlbnRhdGlvbkRpZmYgPj0gNCAmJiAocHJldkxpbmVJc0luZGVudGVkQ29kZSB8fCBzdGF0ZS5wcmV2TGluZS5mZW5jZWRDb2RlRW5kIHx8XG4gICAgICAgICBzdGF0ZS5wcmV2TGluZS5oZWFkZXIgfHwgcHJldkxpbmVMaW5lSXNFbXB0eSkpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHN0YXRlLmluZGVudGVkQ29kZSA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW5UeXBlcy5jb2RlO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RUb2tlbk9uTGluZSAmJiBzdGF0ZS5pbmRlbnRhdGlvbiA8PSBtYXhOb25Db2RlSW5kZW50YXRpb24gJiYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKGF0eEhlYWRlclJFKSkgJiYgbWF0Y2hbMV0ubGVuZ3RoIDw9IDYpIHtcbiAgICAgIHN0YXRlLnF1b3RlID0gMDtcbiAgICAgIHN0YXRlLmhlYWRlciA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgIHN0YXRlLnRoaXNMaW5lLmhlYWRlciA9IHRydWU7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJoZWFkZXJcIjtcbiAgICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmU7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5pbmRlbnRhdGlvbiA8PSBtYXhOb25Db2RlSW5kZW50YXRpb24gJiYgc3RyZWFtLmVhdCgnPicpKSB7XG4gICAgICBzdGF0ZS5xdW90ZSA9IGZpcnN0VG9rZW5PbkxpbmUgPyAxIDogc3RhdGUucXVvdGUgKyAxO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwicXVvdGVcIjtcbiAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoIWlzSHIgJiYgIXN0YXRlLnNldGV4dCAmJiBmaXJzdFRva2VuT25MaW5lICYmIHN0YXRlLmluZGVudGF0aW9uIDw9IG1heE5vbkNvZGVJbmRlbnRhdGlvbiAmJiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2gobGlzdFJFKSkpIHtcbiAgICAgIHZhciBsaXN0VHlwZSA9IG1hdGNoWzFdID8gXCJvbFwiIDogXCJ1bFwiO1xuXG4gICAgICBzdGF0ZS5pbmRlbnRhdGlvbiA9IGxpbmVJbmRlbnRhdGlvbiArIHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoO1xuICAgICAgc3RhdGUubGlzdCA9IHRydWU7XG4gICAgICBzdGF0ZS5xdW90ZSA9IDA7XG5cbiAgICAgIC8vIEFkZCB0aGlzIGxpc3QgaXRlbSdzIGNvbnRlbnQncyBpbmRlbnRhdGlvbiB0byB0aGUgc3RhY2tcbiAgICAgIHN0YXRlLmxpc3RTdGFjay5wdXNoKHN0YXRlLmluZGVudGF0aW9uKTtcbiAgICAgIC8vIFJlc2V0IGlubGluZSBzdHlsZXMgd2hpY2ggc2hvdWxkbid0IHByb3BhZ2F0ZSBhY3Jvc3MgbGlzdCBpdGVtc1xuICAgICAgc3RhdGUuZW0gPSBmYWxzZTtcbiAgICAgIHN0YXRlLnN0cm9uZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuY29kZSA9IGZhbHNlO1xuICAgICAgc3RhdGUuc3RyaWtldGhyb3VnaCA9IGZhbHNlO1xuXG4gICAgICBpZiAobW9kZUNmZy50YXNrTGlzdHMgJiYgc3RyZWFtLm1hdGNoKHRhc2tMaXN0UkUsIGZhbHNlKSkge1xuICAgICAgICBzdGF0ZS50YXNrTGlzdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFtcImxpc3RcIiwgXCJsaXN0LVwiICsgbGlzdFR5cGVdO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RUb2tlbk9uTGluZSAmJiBzdGF0ZS5pbmRlbnRhdGlvbiA8PSBtYXhOb25Db2RlSW5kZW50YXRpb24gJiYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKGZlbmNlZENvZGVSRSwgdHJ1ZSkpKSB7XG4gICAgICBzdGF0ZS5xdW90ZSA9IDA7XG4gICAgICBzdGF0ZS5mZW5jZWRFbmRSRSA9IG5ldyBSZWdFeHAobWF0Y2hbMV0gKyBcIisgKiRcIik7XG4gICAgICAvLyB0cnkgc3dpdGNoaW5nIG1vZGVcbiAgICAgIHN0YXRlLmxvY2FsTW9kZSA9IG1vZGVDZmcuZmVuY2VkQ29kZUJsb2NrSGlnaGxpZ2h0aW5nICYmIGdldE1vZGUobWF0Y2hbMl0gfHwgbW9kZUNmZy5mZW5jZWRDb2RlQmxvY2tEZWZhdWx0TW9kZSApO1xuICAgICAgaWYgKHN0YXRlLmxvY2FsTW9kZSkgc3RhdGUubG9jYWxTdGF0ZSA9IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShzdGF0ZS5sb2NhbE1vZGUpO1xuICAgICAgc3RhdGUuZiA9IHN0YXRlLmJsb2NrID0gbG9jYWw7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJjb2RlLWJsb2NrXCI7XG4gICAgICBzdGF0ZS5jb2RlID0gLTFcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICAvLyBTRVRFWFQgaGFzIGxvd2VzdCBibG9jay1zY29wZSBwcmVjZWRlbmNlIGFmdGVyIEhSLCBzbyBjaGVjayBpdCBhZnRlclxuICAgIC8vICB0aGUgb3RoZXJzIChjb2RlLCBibG9ja3F1b3RlLCBsaXN0Li4uKVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBpZiBzZXRleHQgc2V0LCBpbmRpY2F0ZXMgbGluZSBhZnRlciAtLS0vPT09XG4gICAgICBzdGF0ZS5zZXRleHQgfHwgKFxuICAgICAgICAvLyBsaW5lIGJlZm9yZSAtLS0vPT09XG4gICAgICAgICghYWxsb3dzSW5saW5lQ29udGludWF0aW9uIHx8ICFwcmV2TGluZUlzTGlzdCkgJiYgIXN0YXRlLnF1b3RlICYmIHN0YXRlLmxpc3QgPT09IGZhbHNlICYmXG4gICAgICAgICFzdGF0ZS5jb2RlICYmICFpc0hyICYmICFsaW5rRGVmUkUudGVzdChzdHJlYW0uc3RyaW5nKSAmJlxuICAgICAgICAobWF0Y2ggPSBzdHJlYW0ubG9va0FoZWFkKDEpKSAmJiAobWF0Y2ggPSBtYXRjaC5tYXRjaChzZXRleHRIZWFkZXJSRSkpXG4gICAgICApXG4gICAgKSB7XG4gICAgICBpZiAoICFzdGF0ZS5zZXRleHQgKSB7XG4gICAgICAgIHN0YXRlLmhlYWRlciA9IG1hdGNoWzBdLmNoYXJBdCgwKSA9PSAnPScgPyAxIDogMjtcbiAgICAgICAgc3RhdGUuc2V0ZXh0ID0gc3RhdGUuaGVhZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuaGVhZGVyID0gc3RhdGUuc2V0ZXh0O1xuICAgICAgICAvLyBoYXMgbm8gZWZmZWN0IG9uIHR5cGUgc28gd2UgY2FuIHJlc2V0IGl0IG5vd1xuICAgICAgICBzdGF0ZS5zZXRleHQgPSAwO1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImhlYWRlclwiO1xuICAgICAgfVxuICAgICAgc3RhdGUudGhpc0xpbmUuaGVhZGVyID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmU7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChpc0hyKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICBzdGF0ZS5ociA9IHRydWU7XG4gICAgICBzdGF0ZS50aGlzTGluZS5ociA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW5UeXBlcy5ocjtcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT09ICdbJykge1xuICAgICAgcmV0dXJuIHN3aXRjaElubGluZShzdHJlYW0sIHN0YXRlLCBmb290bm90ZUxpbmspO1xuICAgIH1cblxuICAgIHJldHVybiBzd2l0Y2hJbmxpbmUoc3RyZWFtLCBzdGF0ZSwgc3RhdGUuaW5saW5lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGh0bWxCbG9jayhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gaHRtbE1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5odG1sU3RhdGUpO1xuICAgIGlmICghaHRtbE1vZGVNaXNzaW5nKSB7XG4gICAgICB2YXIgaW5uZXIgPSBDb2RlTWlycm9yLmlubmVyTW9kZShodG1sTW9kZSwgc3RhdGUuaHRtbFN0YXRlKVxuICAgICAgaWYgKChpbm5lci5tb2RlLm5hbWUgPT0gXCJ4bWxcIiAmJiBpbm5lci5zdGF0ZS50YWdTdGFydCA9PT0gbnVsbCAmJlxuICAgICAgICAgICAoIWlubmVyLnN0YXRlLmNvbnRleHQgJiYgaW5uZXIuc3RhdGUudG9rZW5pemUuaXNJblRleHQpKSB8fFxuICAgICAgICAgIChzdGF0ZS5tZF9pbnNpZGUgJiYgc3RyZWFtLmN1cnJlbnQoKS5pbmRleE9mKFwiPlwiKSA+IC0xKSkge1xuICAgICAgICBzdGF0ZS5mID0gaW5saW5lTm9ybWFsO1xuICAgICAgICBzdGF0ZS5ibG9jayA9IGJsb2NrTm9ybWFsO1xuICAgICAgICBzdGF0ZS5odG1sU3RhdGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGN1cnJMaXN0SW5kID0gc3RhdGUubGlzdFN0YWNrW3N0YXRlLmxpc3RTdGFjay5sZW5ndGggLSAxXSB8fCAwO1xuICAgIHZhciBoYXNFeGl0ZWRMaXN0ID0gc3RhdGUuaW5kZW50YXRpb24gPCBjdXJyTGlzdEluZDtcbiAgICB2YXIgbWF4RmVuY2VkRW5kSW5kID0gY3Vyckxpc3RJbmQgKyAzO1xuICAgIGlmIChzdGF0ZS5mZW5jZWRFbmRSRSAmJiBzdGF0ZS5pbmRlbnRhdGlvbiA8PSBtYXhGZW5jZWRFbmRJbmQgJiYgKGhhc0V4aXRlZExpc3QgfHwgc3RyZWFtLm1hdGNoKHN0YXRlLmZlbmNlZEVuZFJFKSkpIHtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImNvZGUtYmxvY2tcIjtcbiAgICAgIHZhciByZXR1cm5UeXBlO1xuICAgICAgaWYgKCFoYXNFeGl0ZWRMaXN0KSByZXR1cm5UeXBlID0gZ2V0VHlwZShzdGF0ZSlcbiAgICAgIHN0YXRlLmxvY2FsTW9kZSA9IHN0YXRlLmxvY2FsU3RhdGUgPSBudWxsO1xuICAgICAgc3RhdGUuYmxvY2sgPSBibG9ja05vcm1hbDtcbiAgICAgIHN0YXRlLmYgPSBpbmxpbmVOb3JtYWw7XG4gICAgICBzdGF0ZS5mZW5jZWRFbmRSRSA9IG51bGw7XG4gICAgICBzdGF0ZS5jb2RlID0gMFxuICAgICAgc3RhdGUudGhpc0xpbmUuZmVuY2VkQ29kZUVuZCA9IHRydWU7XG4gICAgICBpZiAoaGFzRXhpdGVkTGlzdCkgcmV0dXJuIHN3aXRjaEJsb2NrKHN0cmVhbSwgc3RhdGUsIHN0YXRlLmJsb2NrKTtcbiAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubG9jYWxNb2RlKSB7XG4gICAgICByZXR1cm4gc3RhdGUubG9jYWxNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUubG9jYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiB0b2tlblR5cGVzLmNvZGU7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5saW5lXG4gIGZ1bmN0aW9uIGdldFR5cGUoc3RhdGUpIHtcbiAgICB2YXIgc3R5bGVzID0gW107XG5cbiAgICBpZiAoc3RhdGUuZm9ybWF0dGluZykge1xuICAgICAgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5mb3JtYXR0aW5nKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5mb3JtYXR0aW5nID09PSBcInN0cmluZ1wiKSBzdGF0ZS5mb3JtYXR0aW5nID0gW3N0YXRlLmZvcm1hdHRpbmddO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmZvcm1hdHRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5mb3JtYXR0aW5nICsgXCItXCIgKyBzdGF0ZS5mb3JtYXR0aW5nW2ldKTtcblxuICAgICAgICBpZiAoc3RhdGUuZm9ybWF0dGluZ1tpXSA9PT0gXCJoZWFkZXJcIikge1xuICAgICAgICAgIHN0eWxlcy5wdXNoKHRva2VuVHlwZXMuZm9ybWF0dGluZyArIFwiLVwiICsgc3RhdGUuZm9ybWF0dGluZ1tpXSArIFwiLVwiICsgc3RhdGUuaGVhZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBgZm9ybWF0dGluZy1xdW90ZWAgYW5kIGBmb3JtYXR0aW5nLXF1b3RlLSNgIGZvciBibG9ja3F1b3Rlc1xuICAgICAgICAvLyBBZGQgYGVycm9yYCBpbnN0ZWFkIGlmIHRoZSBtYXhpbXVtIGJsb2NrcXVvdGUgbmVzdGluZyBkZXB0aCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKHN0YXRlLmZvcm1hdHRpbmdbaV0gPT09IFwicXVvdGVcIikge1xuICAgICAgICAgIGlmICghbW9kZUNmZy5tYXhCbG9ja3F1b3RlRGVwdGggfHwgbW9kZUNmZy5tYXhCbG9ja3F1b3RlRGVwdGggPj0gc3RhdGUucXVvdGUpIHtcbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKHRva2VuVHlwZXMuZm9ybWF0dGluZyArIFwiLVwiICsgc3RhdGUuZm9ybWF0dGluZ1tpXSArIFwiLVwiICsgc3RhdGUucXVvdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMucHVzaChcImVycm9yXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YXNrT3Blbikge1xuICAgICAgc3R5bGVzLnB1c2goXCJtZXRhXCIpO1xuICAgICAgcmV0dXJuIHN0eWxlcy5sZW5ndGggPyBzdHlsZXMuam9pbignICcpIDogbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnRhc2tDbG9zZWQpIHtcbiAgICAgIHN0eWxlcy5wdXNoKFwicHJvcGVydHlcIik7XG4gICAgICByZXR1cm4gc3R5bGVzLmxlbmd0aCA/IHN0eWxlcy5qb2luKCcgJykgOiBudWxsO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5saW5rSHJlZikge1xuICAgICAgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5saW5rSHJlZiwgXCJ1cmxcIik7XG4gICAgfSBlbHNlIHsgLy8gT25seSBhcHBseSBpbmxpbmUgc3R5bGVzIHRvIG5vbi11cmwgdGV4dFxuICAgICAgaWYgKHN0YXRlLnN0cm9uZykgeyBzdHlsZXMucHVzaCh0b2tlblR5cGVzLnN0cm9uZyk7IH1cbiAgICAgIGlmIChzdGF0ZS5lbSkgeyBzdHlsZXMucHVzaCh0b2tlblR5cGVzLmVtKTsgfVxuICAgICAgaWYgKHN0YXRlLnN0cmlrZXRocm91Z2gpIHsgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5zdHJpa2V0aHJvdWdoKTsgfVxuICAgICAgaWYgKHN0YXRlLmVtb2ppKSB7IHN0eWxlcy5wdXNoKHRva2VuVHlwZXMuZW1vamkpOyB9XG4gICAgICBpZiAoc3RhdGUubGlua1RleHQpIHsgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5saW5rVGV4dCk7IH1cbiAgICAgIGlmIChzdGF0ZS5jb2RlKSB7IHN0eWxlcy5wdXNoKHRva2VuVHlwZXMuY29kZSk7IH1cbiAgICAgIGlmIChzdGF0ZS5pbWFnZSkgeyBzdHlsZXMucHVzaCh0b2tlblR5cGVzLmltYWdlKTsgfVxuICAgICAgaWYgKHN0YXRlLmltYWdlQWx0VGV4dCkgeyBzdHlsZXMucHVzaCh0b2tlblR5cGVzLmltYWdlQWx0VGV4dCwgXCJsaW5rXCIpOyB9XG4gICAgICBpZiAoc3RhdGUuaW1hZ2VNYXJrZXIpIHsgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5pbWFnZU1hcmtlcik7IH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaGVhZGVyKSB7IHN0eWxlcy5wdXNoKHRva2VuVHlwZXMuaGVhZGVyLCB0b2tlblR5cGVzLmhlYWRlciArIFwiLVwiICsgc3RhdGUuaGVhZGVyKTsgfVxuXG4gICAgaWYgKHN0YXRlLnF1b3RlKSB7XG4gICAgICBzdHlsZXMucHVzaCh0b2tlblR5cGVzLnF1b3RlKTtcblxuICAgICAgLy8gQWRkIGBxdW90ZS0jYCB3aGVyZSB0aGUgbWF4aW11bSBmb3IgYCNgIGlzIG1vZGVDZmcubWF4QmxvY2txdW90ZURlcHRoXG4gICAgICBpZiAoIW1vZGVDZmcubWF4QmxvY2txdW90ZURlcHRoIHx8IG1vZGVDZmcubWF4QmxvY2txdW90ZURlcHRoID49IHN0YXRlLnF1b3RlKSB7XG4gICAgICAgIHN0eWxlcy5wdXNoKHRva2VuVHlwZXMucXVvdGUgKyBcIi1cIiArIHN0YXRlLnF1b3RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy5wdXNoKHRva2VuVHlwZXMucXVvdGUgKyBcIi1cIiArIG1vZGVDZmcubWF4QmxvY2txdW90ZURlcHRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBsaXN0TW9kID0gKHN0YXRlLmxpc3RTdGFjay5sZW5ndGggLSAxKSAlIDM7XG4gICAgICBpZiAoIWxpc3RNb2QpIHtcbiAgICAgICAgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5saXN0MSk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RNb2QgPT09IDEpIHtcbiAgICAgICAgc3R5bGVzLnB1c2godG9rZW5UeXBlcy5saXN0Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZXMucHVzaCh0b2tlblR5cGVzLmxpc3QzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudHJhaWxpbmdTcGFjZU5ld0xpbmUpIHtcbiAgICAgIHN0eWxlcy5wdXNoKFwidHJhaWxpbmctc3BhY2UtbmV3LWxpbmVcIik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS50cmFpbGluZ1NwYWNlKSB7XG4gICAgICBzdHlsZXMucHVzaChcInRyYWlsaW5nLXNwYWNlLVwiICsgKHN0YXRlLnRyYWlsaW5nU3BhY2UgJSAyID8gXCJhXCIgOiBcImJcIikpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXMubGVuZ3RoID8gc3R5bGVzLmpvaW4oJyAnKSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUZXh0KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKHRleHRSRSwgdHJ1ZSkpIHtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubGluZU5vcm1hbChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudGV4dChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZW9mIHN0eWxlICE9PSAndW5kZWZpbmVkJylcbiAgICAgIHJldHVybiBzdHlsZTtcblxuICAgIGlmIChzdGF0ZS5saXN0KSB7IC8vIExpc3QgbWFya2VyICgqLCArLCAtLCAxLiwgZXRjKVxuICAgICAgc3RhdGUubGlzdCA9IG51bGw7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhc2tMaXN0KSB7XG4gICAgICB2YXIgdGFza09wZW4gPSBzdHJlYW0ubWF0Y2godGFza0xpc3RSRSwgdHJ1ZSlbMV0gPT09IFwiIFwiO1xuICAgICAgaWYgKHRhc2tPcGVuKSBzdGF0ZS50YXNrT3BlbiA9IHRydWU7XG4gICAgICBlbHNlIHN0YXRlLnRhc2tDbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwidGFza1wiO1xuICAgICAgc3RhdGUudGFza0xpc3QgPSBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS50YXNrT3BlbiA9IGZhbHNlO1xuICAgIHN0YXRlLnRhc2tDbG9zZWQgPSBmYWxzZTtcblxuICAgIGlmIChzdGF0ZS5oZWFkZXIgJiYgc3RyZWFtLm1hdGNoKC9eIyskLywgdHJ1ZSkpIHtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImhlYWRlclwiO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICAvLyBNYXRjaGVzIGxpbmsgdGl0bGVzIHByZXNlbnQgb24gbmV4dCBsaW5lXG4gICAgaWYgKHN0YXRlLmxpbmtUaXRsZSkge1xuICAgICAgc3RhdGUubGlua1RpdGxlID0gZmFsc2U7XG4gICAgICB2YXIgbWF0Y2hDaCA9IGNoO1xuICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgbWF0Y2hDaCA9ICcpJztcbiAgICAgIH1cbiAgICAgIG1hdGNoQ2ggPSAobWF0Y2hDaCsnJykucmVwbGFjZSgvKFsuPyorXlxcW1xcXVxcXFwoKXt9fC1dKS9nLCBcIlxcXFwkMVwiKTtcbiAgICAgIHZhciByZWdleCA9ICdeXFxcXHMqKD86W14nICsgbWF0Y2hDaCArICdcXFxcXFxcXF0rfFxcXFxcXFxcXFxcXFxcXFx8XFxcXFxcXFwuKScgKyBtYXRjaENoO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChuZXcgUmVnRXhwKHJlZ2V4KSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuVHlwZXMubGlua0hyZWY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBibG9jayBpcyBjaGFuZ2VkLCBpdCBtYXkgbmVlZCB0byBiZSB1cGRhdGVkIGluIEdGTSBtb2RlXG4gICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgIHZhciBwcmV2aW91c0Zvcm1hdHRpbmcgPSBzdGF0ZS5mb3JtYXR0aW5nO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwiY29kZVwiO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKCdgJyk7XG4gICAgICB2YXIgY291bnQgPSBzdHJlYW0uY3VycmVudCgpLmxlbmd0aFxuICAgICAgaWYgKHN0YXRlLmNvZGUgPT0gMCAmJiAoIXN0YXRlLnF1b3RlIHx8IGNvdW50ID09IDEpKSB7XG4gICAgICAgIHN0YXRlLmNvZGUgPSBjb3VudFxuICAgICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSlcbiAgICAgIH0gZWxzZSBpZiAoY291bnQgPT0gc3RhdGUuY29kZSkgeyAvLyBNdXN0IGJlIGV4YWN0XG4gICAgICAgIHZhciB0ID0gZ2V0VHlwZShzdGF0ZSlcbiAgICAgICAgc3RhdGUuY29kZSA9IDBcbiAgICAgICAgcmV0dXJuIHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmZvcm1hdHRpbmcgPSBwcmV2aW91c0Zvcm1hdHRpbmdcbiAgICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5jb2RlKSB7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICAgIHZhciBmb3JtYXR0aW5nRXNjYXBlID0gdG9rZW5UeXBlcy5mb3JtYXR0aW5nICsgXCItZXNjYXBlXCI7XG4gICAgICAgIHJldHVybiB0eXBlID8gdHlwZSArIFwiIFwiICsgZm9ybWF0dGluZ0VzY2FwZSA6IGZvcm1hdHRpbmdFc2NhcGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnIScgJiYgc3RyZWFtLm1hdGNoKC9cXFtbXlxcXV0qXFxdID8oPzpcXCh8XFxbKS8sIGZhbHNlKSkge1xuICAgICAgc3RhdGUuaW1hZ2VNYXJrZXIgPSB0cnVlO1xuICAgICAgc3RhdGUuaW1hZ2UgPSB0cnVlO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwiaW1hZ2VcIjtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICdbJyAmJiBzdGF0ZS5pbWFnZU1hcmtlciAmJiBzdHJlYW0ubWF0Y2goL1teXFxdXSpcXF0oXFwoLio/XFwpfCA/XFxbLio/XFxdKS8sIGZhbHNlKSkge1xuICAgICAgc3RhdGUuaW1hZ2VNYXJrZXIgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmltYWdlQWx0VGV4dCA9IHRydWVcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImltYWdlXCI7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnXScgJiYgc3RhdGUuaW1hZ2VBbHRUZXh0KSB7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJpbWFnZVwiO1xuICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIHN0YXRlLmltYWdlQWx0VGV4dCA9IGZhbHNlO1xuICAgICAgc3RhdGUuaW1hZ2UgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmlubGluZSA9IHN0YXRlLmYgPSBsaW5rSHJlZjtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ1snICYmICFzdGF0ZS5pbWFnZSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmtUZXh0ICYmIHN0cmVhbS5tYXRjaCgvXi4qP1xcXS8pKSByZXR1cm4gZ2V0VHlwZShzdGF0ZSlcbiAgICAgIHN0YXRlLmxpbmtUZXh0ID0gdHJ1ZTtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmtcIjtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICddJyAmJiBzdGF0ZS5saW5rVGV4dCkge1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwibGlua1wiO1xuICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIHN0YXRlLmxpbmtUZXh0ID0gZmFsc2U7XG4gICAgICBzdGF0ZS5pbmxpbmUgPSBzdGF0ZS5mID0gc3RyZWFtLm1hdGNoKC9cXCguKj9cXCl8ID9cXFsuKj9cXF0vLCBmYWxzZSkgPyBsaW5rSHJlZiA6IGlubGluZU5vcm1hbFxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnPCcgJiYgc3RyZWFtLm1hdGNoKC9eKGh0dHBzP3xmdHBzPyk6XFwvXFwvKD86W15cXFxcPl18XFxcXC4pKz4vLCBmYWxzZSkpIHtcbiAgICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmUgPSBsaW5rSW5saW5lO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwibGlua1wiO1xuICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIGlmICh0eXBlKXtcbiAgICAgICAgdHlwZSArPSBcIiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGUgKyB0b2tlblR5cGVzLmxpbmtJbmxpbmU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnPCcgJiYgc3RyZWFtLm1hdGNoKC9eW14+IFxcXFxdK0AoPzpbXlxcXFw+XXxcXFxcLikrPi8sIGZhbHNlKSkge1xuICAgICAgc3RhdGUuZiA9IHN0YXRlLmlubGluZSA9IGxpbmtJbmxpbmU7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJsaW5rXCI7XG4gICAgICB2YXIgdHlwZSA9IGdldFR5cGUoc3RhdGUpO1xuICAgICAgaWYgKHR5cGUpe1xuICAgICAgICB0eXBlICs9IFwiIFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZSArIHRva2VuVHlwZXMubGlua0VtYWlsO1xuICAgIH1cblxuICAgIGlmIChtb2RlQ2ZnLnhtbCAmJiBjaCA9PT0gJzwnICYmIHN0cmVhbS5tYXRjaCgvXighLS18XFw/fCFcXFtDREFUQVxcW3xbYS16XVthLXowLTktXSooPzpcXHMrW2Etel86LlxcLV0rKD86XFxzKj1cXHMqW14+XSspPykqXFxzKig/Oj58JCkpL2ksIGZhbHNlKSkge1xuICAgICAgdmFyIGVuZCA9IHN0cmVhbS5zdHJpbmcuaW5kZXhPZihcIj5cIiwgc3RyZWFtLnBvcyk7XG4gICAgICBpZiAoZW5kICE9IC0xKSB7XG4gICAgICAgIHZhciBhdHRzID0gc3RyZWFtLnN0cmluZy5zdWJzdHJpbmcoc3RyZWFtLnN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAoL21hcmtkb3duXFxzKj1cXHMqKCd8XCIpezAsMX0xKCd8XCIpezAsMX0vLnRlc3QoYXR0cykpIHN0YXRlLm1kX2luc2lkZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgc3RhdGUuaHRtbFN0YXRlID0gQ29kZU1pcnJvci5zdGFydFN0YXRlKGh0bWxNb2RlKTtcbiAgICAgIHJldHVybiBzd2l0Y2hCbG9jayhzdHJlYW0sIHN0YXRlLCBodG1sQmxvY2spO1xuICAgIH1cblxuICAgIGlmIChtb2RlQ2ZnLnhtbCAmJiBjaCA9PT0gJzwnICYmIHN0cmVhbS5tYXRjaCgvXlxcL1xcdyo/Pi8pKSB7XG4gICAgICBzdGF0ZS5tZF9pbnNpZGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiKlwiIHx8IGNoID09PSBcIl9cIikge1xuICAgICAgdmFyIGxlbiA9IDEsIGJlZm9yZSA9IHN0cmVhbS5wb3MgPT0gMSA/IFwiIFwiIDogc3RyZWFtLnN0cmluZy5jaGFyQXQoc3RyZWFtLnBvcyAtIDIpXG4gICAgICB3aGlsZSAobGVuIDwgMyAmJiBzdHJlYW0uZWF0KGNoKSkgbGVuKytcbiAgICAgIHZhciBhZnRlciA9IHN0cmVhbS5wZWVrKCkgfHwgXCIgXCJcbiAgICAgIC8vIFNlZSBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjI3LyNlbXBoYXNpcy1hbmQtc3Ryb25nLWVtcGhhc2lzXG4gICAgICB2YXIgbGVmdEZsYW5raW5nID0gIS9cXHMvLnRlc3QoYWZ0ZXIpICYmICghcHVuY3R1YXRpb24udGVzdChhZnRlcikgfHwgL1xccy8udGVzdChiZWZvcmUpIHx8IHB1bmN0dWF0aW9uLnRlc3QoYmVmb3JlKSlcbiAgICAgIHZhciByaWdodEZsYW5raW5nID0gIS9cXHMvLnRlc3QoYmVmb3JlKSAmJiAoIXB1bmN0dWF0aW9uLnRlc3QoYmVmb3JlKSB8fCAvXFxzLy50ZXN0KGFmdGVyKSB8fCBwdW5jdHVhdGlvbi50ZXN0KGFmdGVyKSlcbiAgICAgIHZhciBzZXRFbSA9IG51bGwsIHNldFN0cm9uZyA9IG51bGxcbiAgICAgIGlmIChsZW4gJSAyKSB7IC8vIEVtXG4gICAgICAgIGlmICghc3RhdGUuZW0gJiYgbGVmdEZsYW5raW5nICYmIChjaCA9PT0gXCIqXCIgfHwgIXJpZ2h0RmxhbmtpbmcgfHwgcHVuY3R1YXRpb24udGVzdChiZWZvcmUpKSlcbiAgICAgICAgICBzZXRFbSA9IHRydWVcbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuZW0gPT0gY2ggJiYgcmlnaHRGbGFua2luZyAmJiAoY2ggPT09IFwiKlwiIHx8ICFsZWZ0RmxhbmtpbmcgfHwgcHVuY3R1YXRpb24udGVzdChhZnRlcikpKVxuICAgICAgICAgIHNldEVtID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChsZW4gPiAxKSB7IC8vIFN0cm9uZ1xuICAgICAgICBpZiAoIXN0YXRlLnN0cm9uZyAmJiBsZWZ0RmxhbmtpbmcgJiYgKGNoID09PSBcIipcIiB8fCAhcmlnaHRGbGFua2luZyB8fCBwdW5jdHVhdGlvbi50ZXN0KGJlZm9yZSkpKVxuICAgICAgICAgIHNldFN0cm9uZyA9IHRydWVcbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuc3Ryb25nID09IGNoICYmIHJpZ2h0RmxhbmtpbmcgJiYgKGNoID09PSBcIipcIiB8fCAhbGVmdEZsYW5raW5nIHx8IHB1bmN0dWF0aW9uLnRlc3QoYWZ0ZXIpKSlcbiAgICAgICAgICBzZXRTdHJvbmcgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHNldFN0cm9uZyAhPSBudWxsIHx8IHNldEVtICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IHNldEVtID09IG51bGwgPyBcInN0cm9uZ1wiIDogc2V0U3Ryb25nID09IG51bGwgPyBcImVtXCIgOiBcInN0cm9uZyBlbVwiXG4gICAgICAgIGlmIChzZXRFbSA9PT0gdHJ1ZSkgc3RhdGUuZW0gPSBjaFxuICAgICAgICBpZiAoc2V0U3Ryb25nID09PSB0cnVlKSBzdGF0ZS5zdHJvbmcgPSBjaFxuICAgICAgICB2YXIgdCA9IGdldFR5cGUoc3RhdGUpXG4gICAgICAgIGlmIChzZXRFbSA9PT0gZmFsc2UpIHN0YXRlLmVtID0gZmFsc2VcbiAgICAgICAgaWYgKHNldFN0cm9uZyA9PT0gZmFsc2UpIHN0YXRlLnN0cm9uZyA9IGZhbHNlXG4gICAgICAgIHJldHVybiB0XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJyAnKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdCgnKicpIHx8IHN0cmVhbS5lYXQoJ18nKSkgeyAvLyBQcm9iYWJseSBzdXJyb3VuZGVkIGJ5IHNwYWNlc1xuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJyAnKSB7IC8vIFN1cnJvdW5kZWQgYnkgc3BhY2VzLCBpZ25vcmVcbiAgICAgICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIE5vdCBzdXJyb3VuZGVkIGJ5IHNwYWNlcywgYmFjayB1cCBwb2ludGVyXG4gICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RlQ2ZnLnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGlmIChjaCA9PT0gJ34nICYmIHN0cmVhbS5lYXRXaGlsZShjaCkpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0cmlrZXRocm91Z2gpIHsvLyBSZW1vdmUgc3RyaWtldGhyb3VnaFxuICAgICAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcInN0cmlrZXRocm91Z2hcIjtcbiAgICAgICAgICB2YXIgdCA9IGdldFR5cGUoc3RhdGUpO1xuICAgICAgICAgIHN0YXRlLnN0cmlrZXRocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bXlxcc10vLCBmYWxzZSkpIHsvLyBBZGQgc3RyaWtldGhyb3VnaFxuICAgICAgICAgIHN0YXRlLnN0cmlrZXRocm91Z2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcInN0cmlrZXRocm91Z2hcIjtcbiAgICAgICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcgJykge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKCd+ficsIHRydWUpKSB7IC8vIFByb2JhYmx5IHN1cnJvdW5kZWQgYnkgc3BhY2VcbiAgICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJyAnKSB7IC8vIFN1cnJvdW5kZWQgYnkgc3BhY2VzLCBpZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBOb3Qgc3Vycm91bmRlZCBieSBzcGFjZXMsIGJhY2sgdXAgcG9pbnRlclxuICAgICAgICAgICAgc3RyZWFtLmJhY2tVcCgyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZUNmZy5lbW9qaSAmJiBjaCA9PT0gXCI6XCIgJiYgc3RyZWFtLm1hdGNoKC9eKD86W2Etel9cXGQrXVthLXpfXFxkKy1dKnxcXC1bYS16X1xcZCtdW2Etel9cXGQrLV0qKTovKSkge1xuICAgICAgc3RhdGUuZW1vamkgPSB0cnVlO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwiZW1vamlcIjtcbiAgICAgIHZhciByZXRUeXBlID0gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICBzdGF0ZS5lbW9qaSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJldFR5cGU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnICcpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14gKyQvLCBmYWxzZSkpIHtcbiAgICAgICAgc3RhdGUudHJhaWxpbmdTcGFjZSsrO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS50cmFpbGluZ1NwYWNlKSB7XG4gICAgICAgIHN0YXRlLnRyYWlsaW5nU3BhY2VOZXdMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rSW5saW5lKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgaWYgKGNoID09PSBcIj5cIikge1xuICAgICAgc3RhdGUuZiA9IHN0YXRlLmlubGluZSA9IGlubGluZU5vcm1hbDtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmtcIjtcbiAgICAgIHZhciB0eXBlID0gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICBpZiAodHlwZSl7XG4gICAgICAgIHR5cGUgKz0gXCIgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlICsgdG9rZW5UeXBlcy5saW5rSW5saW5lO1xuICAgIH1cblxuICAgIHN0cmVhbS5tYXRjaCgvXltePl0rLywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdG9rZW5UeXBlcy5saW5rSW5saW5lO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlua0hyZWYoc3RyZWFtLCBzdGF0ZSkge1xuICAgIC8vIENoZWNrIGlmIHNwYWNlLCBhbmQgcmV0dXJuIE5VTEwgaWYgc28gKHRvIGF2b2lkIG1hcmtpbmcgdGhlIHNwYWNlKVxuICAgIGlmKHN0cmVhbS5lYXRTcGFjZSgpKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PT0gJygnIHx8IGNoID09PSAnWycpIHtcbiAgICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmUgPSBnZXRMaW5rSHJlZkluc2lkZShjaCA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmstc3RyaW5nXCI7XG4gICAgICBzdGF0ZS5saW5rSHJlZiA9IHRydWU7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgdmFyIGxpbmtSRSA9IHtcbiAgICBcIilcIjogL14oPzpbXlxcXFxcXChcXCldfFxcXFwufFxcKCg/OlteXFxcXFxcKFxcKV18XFxcXC4pKlxcKSkqPyg/PVxcKSkvLFxuICAgIFwiXVwiOiAvXig/OlteXFxcXFxcW1xcXV18XFxcXC58XFxbKD86W15cXFxcXFxbXFxdXXxcXFxcLikqXFxdKSo/KD89XFxdKS9cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmtIcmVmSW5zaWRlKGVuZENoYXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgICAgaWYgKGNoID09PSBlbmRDaGFyKSB7XG4gICAgICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmUgPSBpbmxpbmVOb3JtYWw7XG4gICAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmstc3RyaW5nXCI7XG4gICAgICAgIHZhciByZXR1cm5TdGF0ZSA9IGdldFR5cGUoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5saW5rSHJlZiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0dXJuU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbS5tYXRjaChsaW5rUkVbZW5kQ2hhcl0pXG4gICAgICBzdGF0ZS5saW5rSHJlZiA9IHRydWU7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvb3Rub3RlTGluayhzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXihbXlxcXVxcXFxdfFxcXFwuKSpcXF06LywgZmFsc2UpKSB7XG4gICAgICBzdGF0ZS5mID0gZm9vdG5vdGVMaW5rSW5zaWRlO1xuICAgICAgc3RyZWFtLm5leHQoKTsgLy8gQ29uc3VtZSBbXG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJsaW5rXCI7XG4gICAgICBzdGF0ZS5saW5rVGV4dCA9IHRydWU7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBzd2l0Y2hJbmxpbmUoc3RyZWFtLCBzdGF0ZSwgaW5saW5lTm9ybWFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvb3Rub3RlTGlua0luc2lkZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgnXTonLCB0cnVlKSkge1xuICAgICAgc3RhdGUuZiA9IHN0YXRlLmlubGluZSA9IGZvb3Rub3RlVXJsO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwibGlua1wiO1xuICAgICAgdmFyIHJldHVyblR5cGUgPSBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIHN0YXRlLmxpbmtUZXh0ID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICB9XG5cbiAgICBzdHJlYW0ubWF0Y2goL14oW15cXF1cXFxcXXxcXFxcLikrLywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdG9rZW5UeXBlcy5saW5rVGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvb3Rub3RlVXJsKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAvLyBDaGVjayBpZiBzcGFjZSwgYW5kIHJldHVybiBOVUxMIGlmIHNvICh0byBhdm9pZCBtYXJraW5nIHRoZSBzcGFjZSlcbiAgICBpZihzdHJlYW0uZWF0U3BhY2UoKSl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWF0Y2ggVVJMXG4gICAgc3RyZWFtLm1hdGNoKC9eW15cXHNdKy8sIHRydWUpO1xuICAgIC8vIENoZWNrIGZvciBsaW5rIHRpdGxlXG4gICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09IHVuZGVmaW5lZCkgeyAvLyBFbmQgb2YgbGluZSwgc2V0IGZsYWcgdG8gY2hlY2sgbmV4dCBsaW5lXG4gICAgICBzdGF0ZS5saW5rVGl0bGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7IC8vIE1vcmUgY29udGVudCBvbiBsaW5lLCBjaGVjayBpZiBsaW5rIHRpdGxlXG4gICAgICBzdHJlYW0ubWF0Y2goL14oPzpcXHMrKD86XCIoPzpbXlwiXFxcXF18XFxcXC4pK1wifCcoPzpbXidcXFxcXXxcXFxcLikrJ3xcXCgoPzpbXilcXFxcXXxcXFxcLikrXFwpKSk/LywgdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmUgPSBpbmxpbmVOb3JtYWw7XG4gICAgcmV0dXJuIHRva2VuVHlwZXMubGlua0hyZWYgKyBcIiB1cmxcIjtcbiAgfVxuXG4gIHZhciBtb2RlID0ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZjogYmxvY2tOb3JtYWwsXG5cbiAgICAgICAgcHJldkxpbmU6IHtzdHJlYW06IG51bGx9LFxuICAgICAgICB0aGlzTGluZToge3N0cmVhbTogbnVsbH0sXG5cbiAgICAgICAgYmxvY2s6IGJsb2NrTm9ybWFsLFxuICAgICAgICBodG1sU3RhdGU6IG51bGwsXG4gICAgICAgIGluZGVudGF0aW9uOiAwLFxuXG4gICAgICAgIGlubGluZTogaW5saW5lTm9ybWFsLFxuICAgICAgICB0ZXh0OiBoYW5kbGVUZXh0LFxuXG4gICAgICAgIGZvcm1hdHRpbmc6IGZhbHNlLFxuICAgICAgICBsaW5rVGV4dDogZmFsc2UsXG4gICAgICAgIGxpbmtIcmVmOiBmYWxzZSxcbiAgICAgICAgbGlua1RpdGxlOiBmYWxzZSxcbiAgICAgICAgY29kZTogMCxcbiAgICAgICAgZW06IGZhbHNlLFxuICAgICAgICBzdHJvbmc6IGZhbHNlLFxuICAgICAgICBoZWFkZXI6IDAsXG4gICAgICAgIHNldGV4dDogMCxcbiAgICAgICAgaHI6IGZhbHNlLFxuICAgICAgICB0YXNrTGlzdDogZmFsc2UsXG4gICAgICAgIGxpc3Q6IGZhbHNlLFxuICAgICAgICBsaXN0U3RhY2s6IFtdLFxuICAgICAgICBxdW90ZTogMCxcbiAgICAgICAgdHJhaWxpbmdTcGFjZTogMCxcbiAgICAgICAgdHJhaWxpbmdTcGFjZU5ld0xpbmU6IGZhbHNlLFxuICAgICAgICBzdHJpa2V0aHJvdWdoOiBmYWxzZSxcbiAgICAgICAgZW1vamk6IGZhbHNlLFxuICAgICAgICBmZW5jZWRFbmRSRTogbnVsbFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgY29weVN0YXRlOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmOiBzLmYsXG5cbiAgICAgICAgcHJldkxpbmU6IHMucHJldkxpbmUsXG4gICAgICAgIHRoaXNMaW5lOiBzLnRoaXNMaW5lLFxuXG4gICAgICAgIGJsb2NrOiBzLmJsb2NrLFxuICAgICAgICBodG1sU3RhdGU6IHMuaHRtbFN0YXRlICYmIENvZGVNaXJyb3IuY29weVN0YXRlKGh0bWxNb2RlLCBzLmh0bWxTdGF0ZSksXG4gICAgICAgIGluZGVudGF0aW9uOiBzLmluZGVudGF0aW9uLFxuXG4gICAgICAgIGxvY2FsTW9kZTogcy5sb2NhbE1vZGUsXG4gICAgICAgIGxvY2FsU3RhdGU6IHMubG9jYWxNb2RlID8gQ29kZU1pcnJvci5jb3B5U3RhdGUocy5sb2NhbE1vZGUsIHMubG9jYWxTdGF0ZSkgOiBudWxsLFxuXG4gICAgICAgIGlubGluZTogcy5pbmxpbmUsXG4gICAgICAgIHRleHQ6IHMudGV4dCxcbiAgICAgICAgZm9ybWF0dGluZzogZmFsc2UsXG4gICAgICAgIGxpbmtUZXh0OiBzLmxpbmtUZXh0LFxuICAgICAgICBsaW5rVGl0bGU6IHMubGlua1RpdGxlLFxuICAgICAgICBsaW5rSHJlZjogcy5saW5rSHJlZixcbiAgICAgICAgY29kZTogcy5jb2RlLFxuICAgICAgICBlbTogcy5lbSxcbiAgICAgICAgc3Ryb25nOiBzLnN0cm9uZyxcbiAgICAgICAgc3RyaWtldGhyb3VnaDogcy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICBlbW9qaTogcy5lbW9qaSxcbiAgICAgICAgaGVhZGVyOiBzLmhlYWRlcixcbiAgICAgICAgc2V0ZXh0OiBzLnNldGV4dCxcbiAgICAgICAgaHI6IHMuaHIsXG4gICAgICAgIHRhc2tMaXN0OiBzLnRhc2tMaXN0LFxuICAgICAgICBsaXN0OiBzLmxpc3QsXG4gICAgICAgIGxpc3RTdGFjazogcy5saXN0U3RhY2suc2xpY2UoMCksXG4gICAgICAgIHF1b3RlOiBzLnF1b3RlLFxuICAgICAgICBpbmRlbnRlZENvZGU6IHMuaW5kZW50ZWRDb2RlLFxuICAgICAgICB0cmFpbGluZ1NwYWNlOiBzLnRyYWlsaW5nU3BhY2UsXG4gICAgICAgIHRyYWlsaW5nU3BhY2VOZXdMaW5lOiBzLnRyYWlsaW5nU3BhY2VOZXdMaW5lLFxuICAgICAgICBtZF9pbnNpZGU6IHMubWRfaW5zaWRlLFxuICAgICAgICBmZW5jZWRFbmRSRTogcy5mZW5jZWRFbmRSRVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcblxuICAgICAgLy8gUmVzZXQgc3RhdGUuZm9ybWF0dGluZ1xuICAgICAgc3RhdGUuZm9ybWF0dGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoc3RyZWFtICE9IHN0YXRlLnRoaXNMaW5lLnN0cmVhbSkge1xuICAgICAgICBzdGF0ZS5oZWFkZXIgPSAwO1xuICAgICAgICBzdGF0ZS5ociA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqJC8sIHRydWUpKSB7XG4gICAgICAgICAgYmxhbmtMaW5lKHN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnByZXZMaW5lID0gc3RhdGUudGhpc0xpbmVcbiAgICAgICAgc3RhdGUudGhpc0xpbmUgPSB7c3RyZWFtOiBzdHJlYW19XG5cbiAgICAgICAgLy8gUmVzZXQgc3RhdGUudGFza0xpc3RcbiAgICAgICAgc3RhdGUudGFza0xpc3QgPSBmYWxzZTtcblxuICAgICAgICAvLyBSZXNldCBzdGF0ZS50cmFpbGluZ1NwYWNlXG4gICAgICAgIHN0YXRlLnRyYWlsaW5nU3BhY2UgPSAwO1xuICAgICAgICBzdGF0ZS50cmFpbGluZ1NwYWNlTmV3TGluZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghc3RhdGUubG9jYWxTdGF0ZSkge1xuICAgICAgICAgIHN0YXRlLmYgPSBzdGF0ZS5ibG9jaztcbiAgICAgICAgICBpZiAoc3RhdGUuZiAhPSBodG1sQmxvY2spIHtcbiAgICAgICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IHN0cmVhbS5tYXRjaCgvXlxccyovLCB0cnVlKVswXS5yZXBsYWNlKC9cXHQvZywgZXhwYW5kZWRUYWIpLmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRlLmluZGVudGF0aW9uID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBzdGF0ZS5pbmRlbnRhdGlvbkRpZmYgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGluZGVudGF0aW9uID4gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUuZihzdHJlYW0sIHN0YXRlKTtcbiAgICB9LFxuXG4gICAgaW5uZXJNb2RlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLmJsb2NrID09IGh0bWxCbG9jaykgcmV0dXJuIHtzdGF0ZTogc3RhdGUuaHRtbFN0YXRlLCBtb2RlOiBodG1sTW9kZX07XG4gICAgICBpZiAoc3RhdGUubG9jYWxTdGF0ZSkgcmV0dXJuIHtzdGF0ZTogc3RhdGUubG9jYWxTdGF0ZSwgbW9kZTogc3RhdGUubG9jYWxNb2RlfTtcbiAgICAgIHJldHVybiB7c3RhdGU6IHN0YXRlLCBtb2RlOiBtb2RlfTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBsaW5lKSB7XG4gICAgICBpZiAoc3RhdGUuYmxvY2sgPT0gaHRtbEJsb2NrICYmIGh0bWxNb2RlLmluZGVudCkgcmV0dXJuIGh0bWxNb2RlLmluZGVudChzdGF0ZS5odG1sU3RhdGUsIHRleHRBZnRlciwgbGluZSlcbiAgICAgIGlmIChzdGF0ZS5sb2NhbFN0YXRlICYmIHN0YXRlLmxvY2FsTW9kZS5pbmRlbnQpIHJldHVybiBzdGF0ZS5sb2NhbE1vZGUuaW5kZW50KHN0YXRlLmxvY2FsU3RhdGUsIHRleHRBZnRlciwgbGluZSlcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3NcbiAgICB9LFxuXG4gICAgYmxhbmtMaW5lOiBibGFua0xpbmUsXG5cbiAgICBnZXRUeXBlOiBnZXRUeXBlLFxuXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiPCEtLVwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCItLT5cIixcbiAgICBjbG9zZUJyYWNrZXRzOiBcIigpW117fScnXFxcIlxcXCJgYFwiLFxuICAgIGZvbGQ6IFwibWFya2Rvd25cIlxuICB9O1xuICByZXR1cm4gbW9kZTtcbn0sIFwieG1sXCIpO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L21hcmtkb3duXCIsIFwibWFya2Rvd25cIik7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1tYXJrZG93blwiLCBcIm1hcmtkb3duXCIpO1xuXG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkZWZpbmVNb2RlIiwiY21DZmciLCJtb2RlQ2ZnIiwiaHRtbE1vZGUiLCJnZXRNb2RlIiwiaHRtbE1vZGVNaXNzaW5nIiwibmFtZSIsImZpbmRNb2RlQnlOYW1lIiwiZm91bmQiLCJtaW1lIiwibWltZXMiLCJtb2RlIiwiaGlnaGxpZ2h0Rm9ybWF0dGluZyIsInVuZGVmaW5lZCIsIm1heEJsb2NrcXVvdGVEZXB0aCIsInRhc2tMaXN0cyIsInN0cmlrZXRocm91Z2giLCJlbW9qaSIsImZlbmNlZENvZGVCbG9ja0hpZ2hsaWdodGluZyIsImZlbmNlZENvZGVCbG9ja0RlZmF1bHRNb2RlIiwieG1sIiwidG9rZW5UeXBlT3ZlcnJpZGVzIiwidG9rZW5UeXBlcyIsImhlYWRlciIsImNvZGUiLCJxdW90ZSIsImxpc3QxIiwibGlzdDIiLCJsaXN0MyIsImhyIiwiaW1hZ2UiLCJpbWFnZUFsdFRleHQiLCJpbWFnZU1hcmtlciIsImZvcm1hdHRpbmciLCJsaW5rSW5saW5lIiwibGlua0VtYWlsIiwibGlua1RleHQiLCJsaW5rSHJlZiIsImVtIiwic3Ryb25nIiwidG9rZW5UeXBlIiwiaGFzT3duUHJvcGVydHkiLCJoclJFIiwibGlzdFJFIiwidGFza0xpc3RSRSIsImF0eEhlYWRlclJFIiwiYWxsb3dBdHhIZWFkZXJXaXRob3V0U3BhY2UiLCJzZXRleHRIZWFkZXJSRSIsInRleHRSRSIsImZlbmNlZENvZGVSRSIsImxpbmtEZWZSRSIsInB1bmN0dWF0aW9uIiwiZXhwYW5kZWRUYWIiLCJzd2l0Y2hJbmxpbmUiLCJzdHJlYW0iLCJzdGF0ZSIsImYiLCJpbmxpbmUiLCJzd2l0Y2hCbG9jayIsImJsb2NrIiwibGluZUlzRW1wdHkiLCJsaW5lIiwidGVzdCIsInN0cmluZyIsImJsYW5rTGluZSIsImxpbmtUaXRsZSIsImluZGVudGVkQ29kZSIsImh0bWxCbG9jayIsImV4aXQiLCJpbm5lciIsImlubmVyTW9kZSIsImh0bWxTdGF0ZSIsInRhZ1N0YXJ0IiwiY29udGV4dCIsInRva2VuaXplIiwiaXNJblRleHQiLCJpbmxpbmVOb3JtYWwiLCJibG9ja05vcm1hbCIsInRyYWlsaW5nU3BhY2UiLCJ0cmFpbGluZ1NwYWNlTmV3TGluZSIsInByZXZMaW5lIiwidGhpc0xpbmUiLCJmaXJzdFRva2VuT25MaW5lIiwiY29sdW1uIiwiaW5kZW50YXRpb24iLCJwcmV2TGluZUxpbmVJc0VtcHR5IiwicHJldkxpbmVJc0luZGVudGVkQ29kZSIsInByZXZMaW5lSXNIciIsInByZXZMaW5lSXNMaXN0IiwibGlzdCIsIm1heE5vbkNvZGVJbmRlbnRhdGlvbiIsImxpc3RTdGFjayIsImxlbmd0aCIsImxpbmVJbmRlbnRhdGlvbiIsImluZGVudGF0aW9uRGlmZiIsInBvcCIsImFsbG93c0lubGluZUNvbnRpbnVhdGlvbiIsImZlbmNlZENvZGVFbmQiLCJpc0hyIiwibWF0Y2giLCJza2lwVG9FbmQiLCJlYXRTcGFjZSIsImdldFR5cGUiLCJlYXQiLCJzZXRleHQiLCJsaXN0VHlwZSIsImN1cnJlbnQiLCJwdXNoIiwidGFza0xpc3QiLCJmZW5jZWRFbmRSRSIsIlJlZ0V4cCIsImxvY2FsTW9kZSIsImxvY2FsU3RhdGUiLCJzdGFydFN0YXRlIiwibG9jYWwiLCJsb29rQWhlYWQiLCJjaGFyQXQiLCJwZWVrIiwiZm9vdG5vdGVMaW5rIiwic3R5bGUiLCJ0b2tlbiIsIm1kX2luc2lkZSIsImluZGV4T2YiLCJjdXJyTGlzdEluZCIsImhhc0V4aXRlZExpc3QiLCJtYXhGZW5jZWRFbmRJbmQiLCJyZXR1cm5UeXBlIiwic3R5bGVzIiwiaSIsInRhc2tPcGVuIiwiam9pbiIsInRhc2tDbG9zZWQiLCJsaXN0TW9kIiwiaGFuZGxlVGV4dCIsInRleHQiLCJjaCIsIm5leHQiLCJtYXRjaENoIiwicmVwbGFjZSIsInJlZ2V4IiwicHJldmlvdXNGb3JtYXR0aW5nIiwiZWF0V2hpbGUiLCJjb3VudCIsInQiLCJ0eXBlIiwiZm9ybWF0dGluZ0VzY2FwZSIsImVuZCIsInBvcyIsImF0dHMiLCJzdWJzdHJpbmciLCJzdGFydCIsImJhY2tVcCIsImxlbiIsImJlZm9yZSIsImFmdGVyIiwibGVmdEZsYW5raW5nIiwicmlnaHRGbGFua2luZyIsInNldEVtIiwic2V0U3Ryb25nIiwicmV0VHlwZSIsImdldExpbmtIcmVmSW5zaWRlIiwibGlua1JFIiwiZW5kQ2hhciIsInJldHVyblN0YXRlIiwiZm9vdG5vdGVMaW5rSW5zaWRlIiwiZm9vdG5vdGVVcmwiLCJjb3B5U3RhdGUiLCJzIiwic2xpY2UiLCJpbmRlbnQiLCJ0ZXh0QWZ0ZXIiLCJQYXNzIiwiYmxvY2tDb21tZW50U3RhcnQiLCJibG9ja0NvbW1lbnRFbmQiLCJjbG9zZUJyYWNrZXRzIiwiZm9sZCIsImRlZmluZU1JTUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/mode/markdown/markdown.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/mode/meta.js":
/*!**********************************************!*\
  !*** ./node_modules/codemirror/mode/meta.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    CodeMirror1.modeInfo = [\n        {\n            name: \"APL\",\n            mime: \"text/apl\",\n            mode: \"apl\",\n            ext: [\n                \"dyalog\",\n                \"apl\"\n            ]\n        },\n        {\n            name: \"PGP\",\n            mimes: [\n                \"application/pgp\",\n                \"application/pgp-encrypted\",\n                \"application/pgp-keys\",\n                \"application/pgp-signature\"\n            ],\n            mode: \"asciiarmor\",\n            ext: [\n                \"asc\",\n                \"pgp\",\n                \"sig\"\n            ]\n        },\n        {\n            name: \"ASN.1\",\n            mime: \"text/x-ttcn-asn\",\n            mode: \"asn.1\",\n            ext: [\n                \"asn\",\n                \"asn1\"\n            ]\n        },\n        {\n            name: \"Asterisk\",\n            mime: \"text/x-asterisk\",\n            mode: \"asterisk\",\n            file: /^extensions\\.conf$/i\n        },\n        {\n            name: \"Brainfuck\",\n            mime: \"text/x-brainfuck\",\n            mode: \"brainfuck\",\n            ext: [\n                \"b\",\n                \"bf\"\n            ]\n        },\n        {\n            name: \"C\",\n            mime: \"text/x-csrc\",\n            mode: \"clike\",\n            ext: [\n                \"c\",\n                \"h\",\n                \"ino\"\n            ]\n        },\n        {\n            name: \"C++\",\n            mime: \"text/x-c++src\",\n            mode: \"clike\",\n            ext: [\n                \"cpp\",\n                \"c++\",\n                \"cc\",\n                \"cxx\",\n                \"hpp\",\n                \"h++\",\n                \"hh\",\n                \"hxx\"\n            ],\n            alias: [\n                \"cpp\"\n            ]\n        },\n        {\n            name: \"Cobol\",\n            mime: \"text/x-cobol\",\n            mode: \"cobol\",\n            ext: [\n                \"cob\",\n                \"cpy\",\n                \"cbl\"\n            ]\n        },\n        {\n            name: \"C#\",\n            mime: \"text/x-csharp\",\n            mode: \"clike\",\n            ext: [\n                \"cs\"\n            ],\n            alias: [\n                \"csharp\",\n                \"cs\"\n            ]\n        },\n        {\n            name: \"Clojure\",\n            mime: \"text/x-clojure\",\n            mode: \"clojure\",\n            ext: [\n                \"clj\",\n                \"cljc\",\n                \"cljx\"\n            ]\n        },\n        {\n            name: \"ClojureScript\",\n            mime: \"text/x-clojurescript\",\n            mode: \"clojure\",\n            ext: [\n                \"cljs\"\n            ]\n        },\n        {\n            name: \"Closure Stylesheets (GSS)\",\n            mime: \"text/x-gss\",\n            mode: \"css\",\n            ext: [\n                \"gss\"\n            ]\n        },\n        {\n            name: \"CMake\",\n            mime: \"text/x-cmake\",\n            mode: \"cmake\",\n            ext: [\n                \"cmake\",\n                \"cmake.in\"\n            ],\n            file: /^CMakeLists\\.txt$/\n        },\n        {\n            name: \"CoffeeScript\",\n            mimes: [\n                \"application/vnd.coffeescript\",\n                \"text/coffeescript\",\n                \"text/x-coffeescript\"\n            ],\n            mode: \"coffeescript\",\n            ext: [\n                \"coffee\"\n            ],\n            alias: [\n                \"coffee\",\n                \"coffee-script\"\n            ]\n        },\n        {\n            name: \"Common Lisp\",\n            mime: \"text/x-common-lisp\",\n            mode: \"commonlisp\",\n            ext: [\n                \"cl\",\n                \"lisp\",\n                \"el\"\n            ],\n            alias: [\n                \"lisp\"\n            ]\n        },\n        {\n            name: \"Cypher\",\n            mime: \"application/x-cypher-query\",\n            mode: \"cypher\",\n            ext: [\n                \"cyp\",\n                \"cypher\"\n            ]\n        },\n        {\n            name: \"Cython\",\n            mime: \"text/x-cython\",\n            mode: \"python\",\n            ext: [\n                \"pyx\",\n                \"pxd\",\n                \"pxi\"\n            ]\n        },\n        {\n            name: \"Crystal\",\n            mime: \"text/x-crystal\",\n            mode: \"crystal\",\n            ext: [\n                \"cr\"\n            ]\n        },\n        {\n            name: \"CSS\",\n            mime: \"text/css\",\n            mode: \"css\",\n            ext: [\n                \"css\"\n            ]\n        },\n        {\n            name: \"CQL\",\n            mime: \"text/x-cassandra\",\n            mode: \"sql\",\n            ext: [\n                \"cql\"\n            ]\n        },\n        {\n            name: \"D\",\n            mime: \"text/x-d\",\n            mode: \"d\",\n            ext: [\n                \"d\"\n            ]\n        },\n        {\n            name: \"Dart\",\n            mimes: [\n                \"application/dart\",\n                \"text/x-dart\"\n            ],\n            mode: \"dart\",\n            ext: [\n                \"dart\"\n            ]\n        },\n        {\n            name: \"diff\",\n            mime: \"text/x-diff\",\n            mode: \"diff\",\n            ext: [\n                \"diff\",\n                \"patch\"\n            ]\n        },\n        {\n            name: \"Django\",\n            mime: \"text/x-django\",\n            mode: \"django\"\n        },\n        {\n            name: \"Dockerfile\",\n            mime: \"text/x-dockerfile\",\n            mode: \"dockerfile\",\n            file: /^Dockerfile$/\n        },\n        {\n            name: \"DTD\",\n            mime: \"application/xml-dtd\",\n            mode: \"dtd\",\n            ext: [\n                \"dtd\"\n            ]\n        },\n        {\n            name: \"Dylan\",\n            mime: \"text/x-dylan\",\n            mode: \"dylan\",\n            ext: [\n                \"dylan\",\n                \"dyl\",\n                \"intr\"\n            ]\n        },\n        {\n            name: \"EBNF\",\n            mime: \"text/x-ebnf\",\n            mode: \"ebnf\"\n        },\n        {\n            name: \"ECL\",\n            mime: \"text/x-ecl\",\n            mode: \"ecl\",\n            ext: [\n                \"ecl\"\n            ]\n        },\n        {\n            name: \"edn\",\n            mime: \"application/edn\",\n            mode: \"clojure\",\n            ext: [\n                \"edn\"\n            ]\n        },\n        {\n            name: \"Eiffel\",\n            mime: \"text/x-eiffel\",\n            mode: \"eiffel\",\n            ext: [\n                \"e\"\n            ]\n        },\n        {\n            name: \"Elm\",\n            mime: \"text/x-elm\",\n            mode: \"elm\",\n            ext: [\n                \"elm\"\n            ]\n        },\n        {\n            name: \"Embedded JavaScript\",\n            mime: \"application/x-ejs\",\n            mode: \"htmlembedded\",\n            ext: [\n                \"ejs\"\n            ]\n        },\n        {\n            name: \"Embedded Ruby\",\n            mime: \"application/x-erb\",\n            mode: \"htmlembedded\",\n            ext: [\n                \"erb\"\n            ]\n        },\n        {\n            name: \"Erlang\",\n            mime: \"text/x-erlang\",\n            mode: \"erlang\",\n            ext: [\n                \"erl\"\n            ]\n        },\n        {\n            name: \"Esper\",\n            mime: \"text/x-esper\",\n            mode: \"sql\"\n        },\n        {\n            name: \"Factor\",\n            mime: \"text/x-factor\",\n            mode: \"factor\",\n            ext: [\n                \"factor\"\n            ]\n        },\n        {\n            name: \"FCL\",\n            mime: \"text/x-fcl\",\n            mode: \"fcl\"\n        },\n        {\n            name: \"Forth\",\n            mime: \"text/x-forth\",\n            mode: \"forth\",\n            ext: [\n                \"forth\",\n                \"fth\",\n                \"4th\"\n            ]\n        },\n        {\n            name: \"Fortran\",\n            mime: \"text/x-fortran\",\n            mode: \"fortran\",\n            ext: [\n                \"f\",\n                \"for\",\n                \"f77\",\n                \"f90\",\n                \"f95\"\n            ]\n        },\n        {\n            name: \"F#\",\n            mime: \"text/x-fsharp\",\n            mode: \"mllike\",\n            ext: [\n                \"fs\"\n            ],\n            alias: [\n                \"fsharp\"\n            ]\n        },\n        {\n            name: \"Gas\",\n            mime: \"text/x-gas\",\n            mode: \"gas\",\n            ext: [\n                \"s\"\n            ]\n        },\n        {\n            name: \"Gherkin\",\n            mime: \"text/x-feature\",\n            mode: \"gherkin\",\n            ext: [\n                \"feature\"\n            ]\n        },\n        {\n            name: \"GitHub Flavored Markdown\",\n            mime: \"text/x-gfm\",\n            mode: \"gfm\",\n            file: /^(readme|contributing|history)\\.md$/i\n        },\n        {\n            name: \"Go\",\n            mime: \"text/x-go\",\n            mode: \"go\",\n            ext: [\n                \"go\"\n            ]\n        },\n        {\n            name: \"Groovy\",\n            mime: \"text/x-groovy\",\n            mode: \"groovy\",\n            ext: [\n                \"groovy\",\n                \"gradle\"\n            ],\n            file: /^Jenkinsfile$/\n        },\n        {\n            name: \"HAML\",\n            mime: \"text/x-haml\",\n            mode: \"haml\",\n            ext: [\n                \"haml\"\n            ]\n        },\n        {\n            name: \"Haskell\",\n            mime: \"text/x-haskell\",\n            mode: \"haskell\",\n            ext: [\n                \"hs\"\n            ]\n        },\n        {\n            name: \"Haskell (Literate)\",\n            mime: \"text/x-literate-haskell\",\n            mode: \"haskell-literate\",\n            ext: [\n                \"lhs\"\n            ]\n        },\n        {\n            name: \"Haxe\",\n            mime: \"text/x-haxe\",\n            mode: \"haxe\",\n            ext: [\n                \"hx\"\n            ]\n        },\n        {\n            name: \"HXML\",\n            mime: \"text/x-hxml\",\n            mode: \"haxe\",\n            ext: [\n                \"hxml\"\n            ]\n        },\n        {\n            name: \"ASP.NET\",\n            mime: \"application/x-aspx\",\n            mode: \"htmlembedded\",\n            ext: [\n                \"aspx\"\n            ],\n            alias: [\n                \"asp\",\n                \"aspx\"\n            ]\n        },\n        {\n            name: \"HTML\",\n            mime: \"text/html\",\n            mode: \"htmlmixed\",\n            ext: [\n                \"html\",\n                \"htm\",\n                \"handlebars\",\n                \"hbs\"\n            ],\n            alias: [\n                \"xhtml\"\n            ]\n        },\n        {\n            name: \"HTTP\",\n            mime: \"message/http\",\n            mode: \"http\"\n        },\n        {\n            name: \"IDL\",\n            mime: \"text/x-idl\",\n            mode: \"idl\",\n            ext: [\n                \"pro\"\n            ]\n        },\n        {\n            name: \"Pug\",\n            mime: \"text/x-pug\",\n            mode: \"pug\",\n            ext: [\n                \"jade\",\n                \"pug\"\n            ],\n            alias: [\n                \"jade\"\n            ]\n        },\n        {\n            name: \"Java\",\n            mime: \"text/x-java\",\n            mode: \"clike\",\n            ext: [\n                \"java\"\n            ]\n        },\n        {\n            name: \"Java Server Pages\",\n            mime: \"application/x-jsp\",\n            mode: \"htmlembedded\",\n            ext: [\n                \"jsp\"\n            ],\n            alias: [\n                \"jsp\"\n            ]\n        },\n        {\n            name: \"JavaScript\",\n            mimes: [\n                \"text/javascript\",\n                \"text/ecmascript\",\n                \"application/javascript\",\n                \"application/x-javascript\",\n                \"application/ecmascript\"\n            ],\n            mode: \"javascript\",\n            ext: [\n                \"js\"\n            ],\n            alias: [\n                \"ecmascript\",\n                \"js\",\n                \"node\"\n            ]\n        },\n        {\n            name: \"JSON\",\n            mimes: [\n                \"application/json\",\n                \"application/x-json\"\n            ],\n            mode: \"javascript\",\n            ext: [\n                \"json\",\n                \"map\"\n            ],\n            alias: [\n                \"json5\"\n            ]\n        },\n        {\n            name: \"JSON-LD\",\n            mime: \"application/ld+json\",\n            mode: \"javascript\",\n            ext: [\n                \"jsonld\"\n            ],\n            alias: [\n                \"jsonld\"\n            ]\n        },\n        {\n            name: \"JSX\",\n            mime: \"text/jsx\",\n            mode: \"jsx\",\n            ext: [\n                \"jsx\"\n            ]\n        },\n        {\n            name: \"Jinja2\",\n            mime: \"text/jinja2\",\n            mode: \"jinja2\",\n            ext: [\n                \"j2\",\n                \"jinja\",\n                \"jinja2\"\n            ]\n        },\n        {\n            name: \"Julia\",\n            mime: \"text/x-julia\",\n            mode: \"julia\",\n            ext: [\n                \"jl\"\n            ],\n            alias: [\n                \"jl\"\n            ]\n        },\n        {\n            name: \"Kotlin\",\n            mime: \"text/x-kotlin\",\n            mode: \"clike\",\n            ext: [\n                \"kt\"\n            ]\n        },\n        {\n            name: \"LESS\",\n            mime: \"text/x-less\",\n            mode: \"css\",\n            ext: [\n                \"less\"\n            ]\n        },\n        {\n            name: \"LiveScript\",\n            mime: \"text/x-livescript\",\n            mode: \"livescript\",\n            ext: [\n                \"ls\"\n            ],\n            alias: [\n                \"ls\"\n            ]\n        },\n        {\n            name: \"Lua\",\n            mime: \"text/x-lua\",\n            mode: \"lua\",\n            ext: [\n                \"lua\"\n            ]\n        },\n        {\n            name: \"Markdown\",\n            mime: \"text/x-markdown\",\n            mode: \"markdown\",\n            ext: [\n                \"markdown\",\n                \"md\",\n                \"mkd\"\n            ]\n        },\n        {\n            name: \"mIRC\",\n            mime: \"text/mirc\",\n            mode: \"mirc\"\n        },\n        {\n            name: \"MariaDB SQL\",\n            mime: \"text/x-mariadb\",\n            mode: \"sql\"\n        },\n        {\n            name: \"Mathematica\",\n            mime: \"text/x-mathematica\",\n            mode: \"mathematica\",\n            ext: [\n                \"m\",\n                \"nb\",\n                \"wl\",\n                \"wls\"\n            ]\n        },\n        {\n            name: \"Modelica\",\n            mime: \"text/x-modelica\",\n            mode: \"modelica\",\n            ext: [\n                \"mo\"\n            ]\n        },\n        {\n            name: \"MUMPS\",\n            mime: \"text/x-mumps\",\n            mode: \"mumps\",\n            ext: [\n                \"mps\"\n            ]\n        },\n        {\n            name: \"MS SQL\",\n            mime: \"text/x-mssql\",\n            mode: \"sql\"\n        },\n        {\n            name: \"mbox\",\n            mime: \"application/mbox\",\n            mode: \"mbox\",\n            ext: [\n                \"mbox\"\n            ]\n        },\n        {\n            name: \"MySQL\",\n            mime: \"text/x-mysql\",\n            mode: \"sql\"\n        },\n        {\n            name: \"Nginx\",\n            mime: \"text/x-nginx-conf\",\n            mode: \"nginx\",\n            file: /nginx.*\\.conf$/i\n        },\n        {\n            name: \"NSIS\",\n            mime: \"text/x-nsis\",\n            mode: \"nsis\",\n            ext: [\n                \"nsh\",\n                \"nsi\"\n            ]\n        },\n        {\n            name: \"NTriples\",\n            mimes: [\n                \"application/n-triples\",\n                \"application/n-quads\",\n                \"text/n-triples\"\n            ],\n            mode: \"ntriples\",\n            ext: [\n                \"nt\",\n                \"nq\"\n            ]\n        },\n        {\n            name: \"Objective-C\",\n            mime: \"text/x-objectivec\",\n            mode: \"clike\",\n            ext: [\n                \"m\"\n            ],\n            alias: [\n                \"objective-c\",\n                \"objc\"\n            ]\n        },\n        {\n            name: \"Objective-C++\",\n            mime: \"text/x-objectivec++\",\n            mode: \"clike\",\n            ext: [\n                \"mm\"\n            ],\n            alias: [\n                \"objective-c++\",\n                \"objc++\"\n            ]\n        },\n        {\n            name: \"OCaml\",\n            mime: \"text/x-ocaml\",\n            mode: \"mllike\",\n            ext: [\n                \"ml\",\n                \"mli\",\n                \"mll\",\n                \"mly\"\n            ]\n        },\n        {\n            name: \"Octave\",\n            mime: \"text/x-octave\",\n            mode: \"octave\",\n            ext: [\n                \"m\"\n            ]\n        },\n        {\n            name: \"Oz\",\n            mime: \"text/x-oz\",\n            mode: \"oz\",\n            ext: [\n                \"oz\"\n            ]\n        },\n        {\n            name: \"Pascal\",\n            mime: \"text/x-pascal\",\n            mode: \"pascal\",\n            ext: [\n                \"p\",\n                \"pas\"\n            ]\n        },\n        {\n            name: \"PEG.js\",\n            mime: \"null\",\n            mode: \"pegjs\",\n            ext: [\n                \"jsonld\"\n            ]\n        },\n        {\n            name: \"Perl\",\n            mime: \"text/x-perl\",\n            mode: \"perl\",\n            ext: [\n                \"pl\",\n                \"pm\"\n            ]\n        },\n        {\n            name: \"PHP\",\n            mimes: [\n                \"text/x-php\",\n                \"application/x-httpd-php\",\n                \"application/x-httpd-php-open\"\n            ],\n            mode: \"php\",\n            ext: [\n                \"php\",\n                \"php3\",\n                \"php4\",\n                \"php5\",\n                \"php7\",\n                \"phtml\"\n            ]\n        },\n        {\n            name: \"Pig\",\n            mime: \"text/x-pig\",\n            mode: \"pig\",\n            ext: [\n                \"pig\"\n            ]\n        },\n        {\n            name: \"Plain Text\",\n            mime: \"text/plain\",\n            mode: \"null\",\n            ext: [\n                \"txt\",\n                \"text\",\n                \"conf\",\n                \"def\",\n                \"list\",\n                \"log\"\n            ]\n        },\n        {\n            name: \"PLSQL\",\n            mime: \"text/x-plsql\",\n            mode: \"sql\",\n            ext: [\n                \"pls\"\n            ]\n        },\n        {\n            name: \"PostgreSQL\",\n            mime: \"text/x-pgsql\",\n            mode: \"sql\"\n        },\n        {\n            name: \"PowerShell\",\n            mime: \"application/x-powershell\",\n            mode: \"powershell\",\n            ext: [\n                \"ps1\",\n                \"psd1\",\n                \"psm1\"\n            ]\n        },\n        {\n            name: \"Properties files\",\n            mime: \"text/x-properties\",\n            mode: \"properties\",\n            ext: [\n                \"properties\",\n                \"ini\",\n                \"in\"\n            ],\n            alias: [\n                \"ini\",\n                \"properties\"\n            ]\n        },\n        {\n            name: \"ProtoBuf\",\n            mime: \"text/x-protobuf\",\n            mode: \"protobuf\",\n            ext: [\n                \"proto\"\n            ]\n        },\n        {\n            name: \"Python\",\n            mime: \"text/x-python\",\n            mode: \"python\",\n            ext: [\n                \"BUILD\",\n                \"bzl\",\n                \"py\",\n                \"pyw\"\n            ],\n            file: /^(BUCK|BUILD)$/\n        },\n        {\n            name: \"Puppet\",\n            mime: \"text/x-puppet\",\n            mode: \"puppet\",\n            ext: [\n                \"pp\"\n            ]\n        },\n        {\n            name: \"Q\",\n            mime: \"text/x-q\",\n            mode: \"q\",\n            ext: [\n                \"q\"\n            ]\n        },\n        {\n            name: \"R\",\n            mime: \"text/x-rsrc\",\n            mode: \"r\",\n            ext: [\n                \"r\",\n                \"R\"\n            ],\n            alias: [\n                \"rscript\"\n            ]\n        },\n        {\n            name: \"reStructuredText\",\n            mime: \"text/x-rst\",\n            mode: \"rst\",\n            ext: [\n                \"rst\"\n            ],\n            alias: [\n                \"rst\"\n            ]\n        },\n        {\n            name: \"RPM Changes\",\n            mime: \"text/x-rpm-changes\",\n            mode: \"rpm\"\n        },\n        {\n            name: \"RPM Spec\",\n            mime: \"text/x-rpm-spec\",\n            mode: \"rpm\",\n            ext: [\n                \"spec\"\n            ]\n        },\n        {\n            name: \"Ruby\",\n            mime: \"text/x-ruby\",\n            mode: \"ruby\",\n            ext: [\n                \"rb\"\n            ],\n            alias: [\n                \"jruby\",\n                \"macruby\",\n                \"rake\",\n                \"rb\",\n                \"rbx\"\n            ]\n        },\n        {\n            name: \"Rust\",\n            mime: \"text/x-rustsrc\",\n            mode: \"rust\",\n            ext: [\n                \"rs\"\n            ]\n        },\n        {\n            name: \"SAS\",\n            mime: \"text/x-sas\",\n            mode: \"sas\",\n            ext: [\n                \"sas\"\n            ]\n        },\n        {\n            name: \"Sass\",\n            mime: \"text/x-sass\",\n            mode: \"sass\",\n            ext: [\n                \"sass\"\n            ]\n        },\n        {\n            name: \"Scala\",\n            mime: \"text/x-scala\",\n            mode: \"clike\",\n            ext: [\n                \"scala\"\n            ]\n        },\n        {\n            name: \"Scheme\",\n            mime: \"text/x-scheme\",\n            mode: \"scheme\",\n            ext: [\n                \"scm\",\n                \"ss\"\n            ]\n        },\n        {\n            name: \"SCSS\",\n            mime: \"text/x-scss\",\n            mode: \"css\",\n            ext: [\n                \"scss\"\n            ]\n        },\n        {\n            name: \"Shell\",\n            mimes: [\n                \"text/x-sh\",\n                \"application/x-sh\"\n            ],\n            mode: \"shell\",\n            ext: [\n                \"sh\",\n                \"ksh\",\n                \"bash\"\n            ],\n            alias: [\n                \"bash\",\n                \"sh\",\n                \"zsh\"\n            ],\n            file: /^PKGBUILD$/\n        },\n        {\n            name: \"Sieve\",\n            mime: \"application/sieve\",\n            mode: \"sieve\",\n            ext: [\n                \"siv\",\n                \"sieve\"\n            ]\n        },\n        {\n            name: \"Slim\",\n            mimes: [\n                \"text/x-slim\",\n                \"application/x-slim\"\n            ],\n            mode: \"slim\",\n            ext: [\n                \"slim\"\n            ]\n        },\n        {\n            name: \"Smalltalk\",\n            mime: \"text/x-stsrc\",\n            mode: \"smalltalk\",\n            ext: [\n                \"st\"\n            ]\n        },\n        {\n            name: \"Smarty\",\n            mime: \"text/x-smarty\",\n            mode: \"smarty\",\n            ext: [\n                \"tpl\"\n            ]\n        },\n        {\n            name: \"Solr\",\n            mime: \"text/x-solr\",\n            mode: \"solr\"\n        },\n        {\n            name: \"SML\",\n            mime: \"text/x-sml\",\n            mode: \"mllike\",\n            ext: [\n                \"sml\",\n                \"sig\",\n                \"fun\",\n                \"smackspec\"\n            ]\n        },\n        {\n            name: \"Soy\",\n            mime: \"text/x-soy\",\n            mode: \"soy\",\n            ext: [\n                \"soy\"\n            ],\n            alias: [\n                \"closure template\"\n            ]\n        },\n        {\n            name: \"SPARQL\",\n            mime: \"application/sparql-query\",\n            mode: \"sparql\",\n            ext: [\n                \"rq\",\n                \"sparql\"\n            ],\n            alias: [\n                \"sparul\"\n            ]\n        },\n        {\n            name: \"Spreadsheet\",\n            mime: \"text/x-spreadsheet\",\n            mode: \"spreadsheet\",\n            alias: [\n                \"excel\",\n                \"formula\"\n            ]\n        },\n        {\n            name: \"SQL\",\n            mime: \"text/x-sql\",\n            mode: \"sql\",\n            ext: [\n                \"sql\"\n            ]\n        },\n        {\n            name: \"SQLite\",\n            mime: \"text/x-sqlite\",\n            mode: \"sql\"\n        },\n        {\n            name: \"Squirrel\",\n            mime: \"text/x-squirrel\",\n            mode: \"clike\",\n            ext: [\n                \"nut\"\n            ]\n        },\n        {\n            name: \"Stylus\",\n            mime: \"text/x-styl\",\n            mode: \"stylus\",\n            ext: [\n                \"styl\"\n            ]\n        },\n        {\n            name: \"Swift\",\n            mime: \"text/x-swift\",\n            mode: \"swift\",\n            ext: [\n                \"swift\"\n            ]\n        },\n        {\n            name: \"sTeX\",\n            mime: \"text/x-stex\",\n            mode: \"stex\"\n        },\n        {\n            name: \"LaTeX\",\n            mime: \"text/x-latex\",\n            mode: \"stex\",\n            ext: [\n                \"text\",\n                \"ltx\",\n                \"tex\"\n            ],\n            alias: [\n                \"tex\"\n            ]\n        },\n        {\n            name: \"SystemVerilog\",\n            mime: \"text/x-systemverilog\",\n            mode: \"verilog\",\n            ext: [\n                \"v\",\n                \"sv\",\n                \"svh\"\n            ]\n        },\n        {\n            name: \"Tcl\",\n            mime: \"text/x-tcl\",\n            mode: \"tcl\",\n            ext: [\n                \"tcl\"\n            ]\n        },\n        {\n            name: \"Textile\",\n            mime: \"text/x-textile\",\n            mode: \"textile\",\n            ext: [\n                \"textile\"\n            ]\n        },\n        {\n            name: \"TiddlyWiki\",\n            mime: \"text/x-tiddlywiki\",\n            mode: \"tiddlywiki\"\n        },\n        {\n            name: \"Tiki wiki\",\n            mime: \"text/tiki\",\n            mode: \"tiki\"\n        },\n        {\n            name: \"TOML\",\n            mime: \"text/x-toml\",\n            mode: \"toml\",\n            ext: [\n                \"toml\"\n            ]\n        },\n        {\n            name: \"Tornado\",\n            mime: \"text/x-tornado\",\n            mode: \"tornado\"\n        },\n        {\n            name: \"troff\",\n            mime: \"text/troff\",\n            mode: \"troff\",\n            ext: [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"7\",\n                \"8\",\n                \"9\"\n            ]\n        },\n        {\n            name: \"TTCN\",\n            mime: \"text/x-ttcn\",\n            mode: \"ttcn\",\n            ext: [\n                \"ttcn\",\n                \"ttcn3\",\n                \"ttcnpp\"\n            ]\n        },\n        {\n            name: \"TTCN_CFG\",\n            mime: \"text/x-ttcn-cfg\",\n            mode: \"ttcn-cfg\",\n            ext: [\n                \"cfg\"\n            ]\n        },\n        {\n            name: \"Turtle\",\n            mime: \"text/turtle\",\n            mode: \"turtle\",\n            ext: [\n                \"ttl\"\n            ]\n        },\n        {\n            name: \"TypeScript\",\n            mime: \"application/typescript\",\n            mode: \"javascript\",\n            ext: [\n                \"ts\"\n            ],\n            alias: [\n                \"ts\"\n            ]\n        },\n        {\n            name: \"TypeScript-JSX\",\n            mime: \"text/typescript-jsx\",\n            mode: \"jsx\",\n            ext: [\n                \"tsx\"\n            ],\n            alias: [\n                \"tsx\"\n            ]\n        },\n        {\n            name: \"Twig\",\n            mime: \"text/x-twig\",\n            mode: \"twig\"\n        },\n        {\n            name: \"Web IDL\",\n            mime: \"text/x-webidl\",\n            mode: \"webidl\",\n            ext: [\n                \"webidl\"\n            ]\n        },\n        {\n            name: \"VB.NET\",\n            mime: \"text/x-vb\",\n            mode: \"vb\",\n            ext: [\n                \"vb\"\n            ]\n        },\n        {\n            name: \"VBScript\",\n            mime: \"text/vbscript\",\n            mode: \"vbscript\",\n            ext: [\n                \"vbs\"\n            ]\n        },\n        {\n            name: \"Velocity\",\n            mime: \"text/velocity\",\n            mode: \"velocity\",\n            ext: [\n                \"vtl\"\n            ]\n        },\n        {\n            name: \"Verilog\",\n            mime: \"text/x-verilog\",\n            mode: \"verilog\",\n            ext: [\n                \"v\"\n            ]\n        },\n        {\n            name: \"VHDL\",\n            mime: \"text/x-vhdl\",\n            mode: \"vhdl\",\n            ext: [\n                \"vhd\",\n                \"vhdl\"\n            ]\n        },\n        {\n            name: \"Vue.js Component\",\n            mimes: [\n                \"script/x-vue\",\n                \"text/x-vue\"\n            ],\n            mode: \"vue\",\n            ext: [\n                \"vue\"\n            ]\n        },\n        {\n            name: \"XML\",\n            mimes: [\n                \"application/xml\",\n                \"text/xml\"\n            ],\n            mode: \"xml\",\n            ext: [\n                \"xml\",\n                \"xsl\",\n                \"xsd\",\n                \"svg\"\n            ],\n            alias: [\n                \"rss\",\n                \"wsdl\",\n                \"xsd\"\n            ]\n        },\n        {\n            name: \"XQuery\",\n            mime: \"application/xquery\",\n            mode: \"xquery\",\n            ext: [\n                \"xy\",\n                \"xquery\"\n            ]\n        },\n        {\n            name: \"Yacas\",\n            mime: \"text/x-yacas\",\n            mode: \"yacas\",\n            ext: [\n                \"ys\"\n            ]\n        },\n        {\n            name: \"YAML\",\n            mimes: [\n                \"text/x-yaml\",\n                \"text/yaml\"\n            ],\n            mode: \"yaml\",\n            ext: [\n                \"yaml\",\n                \"yml\"\n            ],\n            alias: [\n                \"yml\"\n            ]\n        },\n        {\n            name: \"Z80\",\n            mime: \"text/x-z80\",\n            mode: \"z80\",\n            ext: [\n                \"z80\"\n            ]\n        },\n        {\n            name: \"mscgen\",\n            mime: \"text/x-mscgen\",\n            mode: \"mscgen\",\n            ext: [\n                \"mscgen\",\n                \"mscin\",\n                \"msc\"\n            ]\n        },\n        {\n            name: \"xu\",\n            mime: \"text/x-xu\",\n            mode: \"mscgen\",\n            ext: [\n                \"xu\"\n            ]\n        },\n        {\n            name: \"msgenny\",\n            mime: \"text/x-msgenny\",\n            mode: \"mscgen\",\n            ext: [\n                \"msgenny\"\n            ]\n        },\n        {\n            name: \"WebAssembly\",\n            mime: \"text/webassembly\",\n            mode: \"wast\",\n            ext: [\n                \"wat\",\n                \"wast\"\n            ]\n        }\n    ];\n    // Ensure all modes have a mime property for backwards compatibility\n    for(var i = 0; i < CodeMirror1.modeInfo.length; i++){\n        var info = CodeMirror1.modeInfo[i];\n        if (info.mimes) info.mime = info.mimes[0];\n    }\n    CodeMirror1.findModeByMIME = function(mime) {\n        mime = mime.toLowerCase();\n        for(var i = 0; i < CodeMirror1.modeInfo.length; i++){\n            var info = CodeMirror1.modeInfo[i];\n            if (info.mime == mime) return info;\n            if (info.mimes) {\n                for(var j = 0; j < info.mimes.length; j++)if (info.mimes[j] == mime) return info;\n            }\n        }\n        if (/\\+xml$/.test(mime)) return CodeMirror1.findModeByMIME(\"application/xml\");\n        if (/\\+json$/.test(mime)) return CodeMirror1.findModeByMIME(\"application/json\");\n    };\n    CodeMirror1.findModeByExtension = function(ext) {\n        ext = ext.toLowerCase();\n        for(var i = 0; i < CodeMirror1.modeInfo.length; i++){\n            var info = CodeMirror1.modeInfo[i];\n            if (info.ext) {\n                for(var j = 0; j < info.ext.length; j++)if (info.ext[j] == ext) return info;\n            }\n        }\n    };\n    CodeMirror1.findModeByFileName = function(filename) {\n        for(var i = 0; i < CodeMirror1.modeInfo.length; i++){\n            var info = CodeMirror1.modeInfo[i];\n            if (info.file && info.file.test(filename)) return info;\n        }\n        var dot = filename.lastIndexOf(\".\");\n        var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n        if (ext) return CodeMirror1.findModeByExtension(ext);\n    };\n    CodeMirror1.findModeByName = function(name) {\n        name = name.toLowerCase();\n        for(var i = 0; i < CodeMirror1.modeInfo.length; i++){\n            var info = CodeMirror1.modeInfo[i];\n            if (info.name.toLowerCase() == name) return info;\n            if (info.alias) {\n                for(var j = 0; j < info.alias.length; j++)if (info.alias[j].toLowerCase() == name) return info;\n            }\n        }\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBRXBFLFVBQVNBLEdBQUc7SUFDWCxJQUFJLElBQXVELEVBQ3pEQSxJQUFJRyxtQkFBT0EsQ0FBQywwRkFBbUI7U0FDNUIsRUFHYUc7QUFDcEIsR0FBRyxTQUFTQSxXQUFVO0lBQ3BCO0lBRUFBLFlBQVdDLFFBQVEsR0FBRztRQUNwQjtZQUFDQyxNQUFNO1lBQU9DLE1BQU07WUFBWUMsTUFBTTtZQUFPQyxLQUFLO2dCQUFDO2dCQUFVO2FBQU07UUFBQTtRQUNuRTtZQUFDSCxNQUFNO1lBQU9JLE9BQU87Z0JBQUM7Z0JBQW1CO2dCQUE2QjtnQkFBd0I7YUFBNEI7WUFBRUYsTUFBTTtZQUFjQyxLQUFLO2dCQUFDO2dCQUFPO2dCQUFPO2FBQU07UUFBQTtRQUMxSztZQUFDSCxNQUFNO1lBQVNDLE1BQU07WUFBbUJDLE1BQU07WUFBU0MsS0FBSztnQkFBQztnQkFBTzthQUFPO1FBQUE7UUFDNUU7WUFBQ0gsTUFBTTtZQUFZQyxNQUFNO1lBQW1CQyxNQUFNO1lBQVlHLE1BQU07UUFBcUI7UUFDekY7WUFBQ0wsTUFBTTtZQUFhQyxNQUFNO1lBQW9CQyxNQUFNO1lBQWFDLEtBQUs7Z0JBQUM7Z0JBQUs7YUFBSztRQUFBO1FBQ2pGO1lBQUNILE1BQU07WUFBS0MsTUFBTTtZQUFlQyxNQUFNO1lBQVNDLEtBQUs7Z0JBQUM7Z0JBQUs7Z0JBQUs7YUFBTTtRQUFBO1FBQ3RFO1lBQUNILE1BQU07WUFBT0MsTUFBTTtZQUFpQkMsTUFBTTtZQUFTQyxLQUFLO2dCQUFDO2dCQUFPO2dCQUFPO2dCQUFNO2dCQUFPO2dCQUFPO2dCQUFPO2dCQUFNO2FBQU07WUFBRUcsT0FBTztnQkFBQzthQUFNO1FBQUE7UUFDL0g7WUFBQ04sTUFBTTtZQUFTQyxNQUFNO1lBQWdCQyxNQUFNO1lBQVNDLEtBQUs7Z0JBQUM7Z0JB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VyxNQUFNWCxNQUFNLE9BQU9TO1lBQzVDLElBQUlBLEtBQUtILEtBQUssRUFBRTtnQkFBQSxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUgsS0FBS0gsS0FBSyxDQUFDRSxNQUFNLEVBQUVJLElBQ3JELElBQUlILEtBQUtILEtBQUssQ0FBQ00sRUFBRSxDQUFDRCxXQUFXLE1BQU1YLE1BQU0sT0FBT1M7WUFBSTtRQUN4RDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9tZXRhLmpzP2YwY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0LzUvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLm1vZGVJbmZvID0gW1xuICAgIHtuYW1lOiBcIkFQTFwiLCBtaW1lOiBcInRleHQvYXBsXCIsIG1vZGU6IFwiYXBsXCIsIGV4dDogW1wiZHlhbG9nXCIsIFwiYXBsXCJdfSxcbiAgICB7bmFtZTogXCJQR1BcIiwgbWltZXM6IFtcImFwcGxpY2F0aW9uL3BncFwiLCBcImFwcGxpY2F0aW9uL3BncC1lbmNyeXB0ZWRcIiwgXCJhcHBsaWNhdGlvbi9wZ3Ata2V5c1wiLCBcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIl0sIG1vZGU6IFwiYXNjaWlhcm1vclwiLCBleHQ6IFtcImFzY1wiLCBcInBncFwiLCBcInNpZ1wiXX0sXG4gICAge25hbWU6IFwiQVNOLjFcIiwgbWltZTogXCJ0ZXh0L3gtdHRjbi1hc25cIiwgbW9kZTogXCJhc24uMVwiLCBleHQ6IFtcImFzblwiLCBcImFzbjFcIl19LFxuICAgIHtuYW1lOiBcIkFzdGVyaXNrXCIsIG1pbWU6IFwidGV4dC94LWFzdGVyaXNrXCIsIG1vZGU6IFwiYXN0ZXJpc2tcIiwgZmlsZTogL15leHRlbnNpb25zXFwuY29uZiQvaX0sXG4gICAge25hbWU6IFwiQnJhaW5mdWNrXCIsIG1pbWU6IFwidGV4dC94LWJyYWluZnVja1wiLCBtb2RlOiBcImJyYWluZnVja1wiLCBleHQ6IFtcImJcIiwgXCJiZlwiXX0sXG4gICAge25hbWU6IFwiQ1wiLCBtaW1lOiBcInRleHQveC1jc3JjXCIsIG1vZGU6IFwiY2xpa2VcIiwgZXh0OiBbXCJjXCIsIFwiaFwiLCBcImlub1wiXX0sXG4gICAge25hbWU6IFwiQysrXCIsIG1pbWU6IFwidGV4dC94LWMrK3NyY1wiLCBtb2RlOiBcImNsaWtlXCIsIGV4dDogW1wiY3BwXCIsIFwiYysrXCIsIFwiY2NcIiwgXCJjeHhcIiwgXCJocHBcIiwgXCJoKytcIiwgXCJoaFwiLCBcImh4eFwiXSwgYWxpYXM6IFtcImNwcFwiXX0sXG4gICAge25hbWU6IFwiQ29ib2xcIiwgbWltZTogXCJ0ZXh0L3gtY29ib2xcIiwgbW9kZTogXCJjb2JvbFwiLCBleHQ6IFtcImNvYlwiLCBcImNweVwiLCBcImNibFwiXX0sXG4gICAge25hbWU6IFwiQyNcIiwgbWltZTogXCJ0ZXh0L3gtY3NoYXJwXCIsIG1vZGU6IFwiY2xpa2VcIiwgZXh0OiBbXCJjc1wiXSwgYWxpYXM6IFtcImNzaGFycFwiLCBcImNzXCJdfSxcbiAgICB7bmFtZTogXCJDbG9qdXJlXCIsIG1pbWU6IFwidGV4dC94LWNsb2p1cmVcIiwgbW9kZTogXCJjbG9qdXJlXCIsIGV4dDogW1wiY2xqXCIsIFwiY2xqY1wiLCBcImNsanhcIl19LFxuICAgIHtuYW1lOiBcIkNsb2p1cmVTY3JpcHRcIiwgbWltZTogXCJ0ZXh0L3gtY2xvanVyZXNjcmlwdFwiLCBtb2RlOiBcImNsb2p1cmVcIiwgZXh0OiBbXCJjbGpzXCJdfSxcbiAgICB7bmFtZTogXCJDbG9zdXJlIFN0eWxlc2hlZXRzIChHU1MpXCIsIG1pbWU6IFwidGV4dC94LWdzc1wiLCBtb2RlOiBcImNzc1wiLCBleHQ6IFtcImdzc1wiXX0sXG4gICAge25hbWU6IFwiQ01ha2VcIiwgbWltZTogXCJ0ZXh0L3gtY21ha2VcIiwgbW9kZTogXCJjbWFrZVwiLCBleHQ6IFtcImNtYWtlXCIsIFwiY21ha2UuaW5cIl0sIGZpbGU6IC9eQ01ha2VMaXN0c1xcLnR4dCQvfSxcbiAgICB7bmFtZTogXCJDb2ZmZWVTY3JpcHRcIiwgbWltZXM6IFtcImFwcGxpY2F0aW9uL3ZuZC5jb2ZmZWVzY3JpcHRcIiwgXCJ0ZXh0L2NvZmZlZXNjcmlwdFwiLCBcInRleHQveC1jb2ZmZWVzY3JpcHRcIl0sIG1vZGU6IFwiY29mZmVlc2NyaXB0XCIsIGV4dDogW1wiY29mZmVlXCJdLCBhbGlhczogW1wiY29mZmVlXCIsIFwiY29mZmVlLXNjcmlwdFwiXX0sXG4gICAge25hbWU6IFwiQ29tbW9uIExpc3BcIiwgbWltZTogXCJ0ZXh0L3gtY29tbW9uLWxpc3BcIiwgbW9kZTogXCJjb21tb25saXNwXCIsIGV4dDogW1wiY2xcIiwgXCJsaXNwXCIsIFwiZWxcIl0sIGFsaWFzOiBbXCJsaXNwXCJdfSxcbiAgICB7bmFtZTogXCJDeXBoZXJcIiwgbWltZTogXCJhcHBsaWNhdGlvbi94LWN5cGhlci1xdWVyeVwiLCBtb2RlOiBcImN5cGhlclwiLCBleHQ6IFtcImN5cFwiLCBcImN5cGhlclwiXX0sXG4gICAge25hbWU6IFwiQ3l0aG9uXCIsIG1pbWU6IFwidGV4dC94LWN5dGhvblwiLCBtb2RlOiBcInB5dGhvblwiLCBleHQ6IFtcInB5eFwiLCBcInB4ZFwiLCBcInB4aVwiXX0sXG4gICAge25hbWU6IFwiQ3J5c3RhbFwiLCBtaW1lOiBcInRleHQveC1jcnlzdGFsXCIsIG1vZGU6IFwiY3J5c3RhbFwiLCBleHQ6IFtcImNyXCJdfSxcbiAgICB7bmFtZTogXCJDU1NcIiwgbWltZTogXCJ0ZXh0L2Nzc1wiLCBtb2RlOiBcImNzc1wiLCBleHQ6IFtcImNzc1wiXX0sXG4gICAge25hbWU6IFwiQ1FMXCIsIG1pbWU6IFwidGV4dC94LWNhc3NhbmRyYVwiLCBtb2RlOiBcInNxbFwiLCBleHQ6IFtcImNxbFwiXX0sXG4gICAge25hbWU6IFwiRFwiLCBtaW1lOiBcInRleHQveC1kXCIsIG1vZGU6IFwiZFwiLCBleHQ6IFtcImRcIl19LFxuICAgIHtuYW1lOiBcIkRhcnRcIiwgbWltZXM6IFtcImFwcGxpY2F0aW9uL2RhcnRcIiwgXCJ0ZXh0L3gtZGFydFwiXSwgbW9kZTogXCJkYXJ0XCIsIGV4dDogW1wiZGFydFwiXX0sXG4gICAge25hbWU6IFwiZGlmZlwiLCBtaW1lOiBcInRleHQveC1kaWZmXCIsIG1vZGU6IFwiZGlmZlwiLCBleHQ6IFtcImRpZmZcIiwgXCJwYXRjaFwiXX0sXG4gICAge25hbWU6IFwiRGphbmdvXCIsIG1pbWU6IFwidGV4dC94LWRqYW5nb1wiLCBtb2RlOiBcImRqYW5nb1wifSxcbiAgICB7bmFtZTogXCJEb2NrZXJmaWxlXCIsIG1pbWU6IFwidGV4dC94LWRvY2tlcmZpbGVcIiwgbW9kZTogXCJkb2NrZXJmaWxlXCIsIGZpbGU6IC9eRG9ja2VyZmlsZSQvfSxcbiAgICB7bmFtZTogXCJEVERcIiwgbWltZTogXCJhcHBsaWNhdGlvbi94bWwtZHRkXCIsIG1vZGU6IFwiZHRkXCIsIGV4dDogW1wiZHRkXCJdfSxcbiAgICB7bmFtZTogXCJEeWxhblwiLCBtaW1lOiBcInRleHQveC1keWxhblwiLCBtb2RlOiBcImR5bGFuXCIsIGV4dDogW1wiZHlsYW5cIiwgXCJkeWxcIiwgXCJpbnRyXCJdfSxcbiAgICB7bmFtZTogXCJFQk5GXCIsIG1pbWU6IFwidGV4dC94LWVibmZcIiwgbW9kZTogXCJlYm5mXCJ9LFxuICAgIHtuYW1lOiBcIkVDTFwiLCBtaW1lOiBcInRleHQveC1lY2xcIiwgbW9kZTogXCJlY2xcIiwgZXh0OiBbXCJlY2xcIl19LFxuICAgIHtuYW1lOiBcImVkblwiLCBtaW1lOiBcImFwcGxpY2F0aW9uL2VkblwiLCBtb2RlOiBcImNsb2p1cmVcIiwgZXh0OiBbXCJlZG5cIl19LFxuICAgIHtuYW1lOiBcIkVpZmZlbFwiLCBtaW1lOiBcInRleHQveC1laWZmZWxcIiwgbW9kZTogXCJlaWZmZWxcIiwgZXh0OiBbXCJlXCJdfSxcbiAgICB7bmFtZTogXCJFbG1cIiwgbWltZTogXCJ0ZXh0L3gtZWxtXCIsIG1vZGU6IFwiZWxtXCIsIGV4dDogW1wiZWxtXCJdfSxcbiAgICB7bmFtZTogXCJFbWJlZGRlZCBKYXZhU2NyaXB0XCIsIG1pbWU6IFwiYXBwbGljYXRpb24veC1lanNcIiwgbW9kZTogXCJodG1sZW1iZWRkZWRcIiwgZXh0OiBbXCJlanNcIl19LFxuICAgIHtuYW1lOiBcIkVtYmVkZGVkIFJ1YnlcIiwgbWltZTogXCJhcHBsaWNhdGlvbi94LWVyYlwiLCBtb2RlOiBcImh0bWxlbWJlZGRlZFwiLCBleHQ6IFtcImVyYlwiXX0sXG4gICAge25hbWU6IFwiRXJsYW5nXCIsIG1pbWU6IFwidGV4dC94LWVybGFuZ1wiLCBtb2RlOiBcImVybGFuZ1wiLCBleHQ6IFtcImVybFwiXX0sXG4gICAge25hbWU6IFwiRXNwZXJcIiwgbWltZTogXCJ0ZXh0L3gtZXNwZXJcIiwgbW9kZTogXCJzcWxcIn0sXG4gICAge25hbWU6IFwiRmFjdG9yXCIsIG1pbWU6IFwidGV4dC94LWZhY3RvclwiLCBtb2RlOiBcImZhY3RvclwiLCBleHQ6IFtcImZhY3RvclwiXX0sXG4gICAge25hbWU6IFwiRkNMXCIsIG1pbWU6IFwidGV4dC94LWZjbFwiLCBtb2RlOiBcImZjbFwifSxcbiAgICB7bmFtZTogXCJGb3J0aFwiLCBtaW1lOiBcInRleHQveC1mb3J0aFwiLCBtb2RlOiBcImZvcnRoXCIsIGV4dDogW1wiZm9ydGhcIiwgXCJmdGhcIiwgXCI0dGhcIl19LFxuICAgIHtuYW1lOiBcIkZvcnRyYW5cIiwgbWltZTogXCJ0ZXh0L3gtZm9ydHJhblwiLCBtb2RlOiBcImZvcnRyYW5cIiwgZXh0OiBbXCJmXCIsIFwiZm9yXCIsIFwiZjc3XCIsIFwiZjkwXCIsIFwiZjk1XCJdfSxcbiAgICB7bmFtZTogXCJGI1wiLCBtaW1lOiBcInRleHQveC1mc2hhcnBcIiwgbW9kZTogXCJtbGxpa2VcIiwgZXh0OiBbXCJmc1wiXSwgYWxpYXM6IFtcImZzaGFycFwiXX0sXG4gICAge25hbWU6IFwiR2FzXCIsIG1pbWU6IFwidGV4dC94LWdhc1wiLCBtb2RlOiBcImdhc1wiLCBleHQ6IFtcInNcIl19LFxuICAgIHtuYW1lOiBcIkdoZXJraW5cIiwgbWltZTogXCJ0ZXh0L3gtZmVhdHVyZVwiLCBtb2RlOiBcImdoZXJraW5cIiwgZXh0OiBbXCJmZWF0dXJlXCJdfSxcbiAgICB7bmFtZTogXCJHaXRIdWIgRmxhdm9yZWQgTWFya2Rvd25cIiwgbWltZTogXCJ0ZXh0L3gtZ2ZtXCIsIG1vZGU6IFwiZ2ZtXCIsIGZpbGU6IC9eKHJlYWRtZXxjb250cmlidXRpbmd8aGlzdG9yeSlcXC5tZCQvaX0sXG4gICAge25hbWU6IFwiR29cIiwgbWltZTogXCJ0ZXh0L3gtZ29cIiwgbW9kZTogXCJnb1wiLCBleHQ6IFtcImdvXCJdfSxcbiAgICB7bmFtZTogXCJHcm9vdnlcIiwgbWltZTogXCJ0ZXh0L3gtZ3Jvb3Z5XCIsIG1vZGU6IFwiZ3Jvb3Z5XCIsIGV4dDogW1wiZ3Jvb3Z5XCIsIFwiZ3JhZGxlXCJdLCBmaWxlOiAvXkplbmtpbnNmaWxlJC99LFxuICAgIHtuYW1lOiBcIkhBTUxcIiwgbWltZTogXCJ0ZXh0L3gtaGFtbFwiLCBtb2RlOiBcImhhbWxcIiwgZXh0OiBbXCJoYW1sXCJdfSxcbiAgICB7bmFtZTogXCJIYXNrZWxsXCIsIG1pbWU6IFwidGV4dC94LWhhc2tlbGxcIiwgbW9kZTogXCJoYXNrZWxsXCIsIGV4dDogW1wiaHNcIl19LFxuICAgIHtuYW1lOiBcIkhhc2tlbGwgKExpdGVyYXRlKVwiLCBtaW1lOiBcInRleHQveC1saXRlcmF0ZS1oYXNrZWxsXCIsIG1vZGU6IFwiaGFza2VsbC1saXRlcmF0ZVwiLCBleHQ6IFtcImxoc1wiXX0sXG4gICAge25hbWU6IFwiSGF4ZVwiLCBtaW1lOiBcInRleHQveC1oYXhlXCIsIG1vZGU6IFwiaGF4ZVwiLCBleHQ6IFtcImh4XCJdfSxcbiAgICB7bmFtZTogXCJIWE1MXCIsIG1pbWU6IFwidGV4dC94LWh4bWxcIiwgbW9kZTogXCJoYXhlXCIsIGV4dDogW1wiaHhtbFwiXX0sXG4gICAge25hbWU6IFwiQVNQLk5FVFwiLCBtaW1lOiBcImFwcGxpY2F0aW9uL3gtYXNweFwiLCBtb2RlOiBcImh0bWxlbWJlZGRlZFwiLCBleHQ6IFtcImFzcHhcIl0sIGFsaWFzOiBbXCJhc3BcIiwgXCJhc3B4XCJdfSxcbiAgICB7bmFtZTogXCJIVE1MXCIsIG1pbWU6IFwidGV4dC9odG1sXCIsIG1vZGU6IFwiaHRtbG1peGVkXCIsIGV4dDogW1wiaHRtbFwiLCBcImh0bVwiLCBcImhhbmRsZWJhcnNcIiwgXCJoYnNcIl0sIGFsaWFzOiBbXCJ4aHRtbFwiXX0sXG4gICAge25hbWU6IFwiSFRUUFwiLCBtaW1lOiBcIm1lc3NhZ2UvaHR0cFwiLCBtb2RlOiBcImh0dHBcIn0sXG4gICAge25hbWU6IFwiSURMXCIsIG1pbWU6IFwidGV4dC94LWlkbFwiLCBtb2RlOiBcImlkbFwiLCBleHQ6IFtcInByb1wiXX0sXG4gICAge25hbWU6IFwiUHVnXCIsIG1pbWU6IFwidGV4dC94LXB1Z1wiLCBtb2RlOiBcInB1Z1wiLCBleHQ6IFtcImphZGVcIiwgXCJwdWdcIl0sIGFsaWFzOiBbXCJqYWRlXCJdfSxcbiAgICB7bmFtZTogXCJKYXZhXCIsIG1pbWU6IFwidGV4dC94LWphdmFcIiwgbW9kZTogXCJjbGlrZVwiLCBleHQ6IFtcImphdmFcIl19LFxuICAgIHtuYW1lOiBcIkphdmEgU2VydmVyIFBhZ2VzXCIsIG1pbWU6IFwiYXBwbGljYXRpb24veC1qc3BcIiwgbW9kZTogXCJodG1sZW1iZWRkZWRcIiwgZXh0OiBbXCJqc3BcIl0sIGFsaWFzOiBbXCJqc3BcIl19LFxuICAgIHtuYW1lOiBcIkphdmFTY3JpcHRcIiwgbWltZXM6IFtcInRleHQvamF2YXNjcmlwdFwiLCBcInRleHQvZWNtYXNjcmlwdFwiLCBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiwgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIiwgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCJdLFxuICAgICBtb2RlOiBcImphdmFzY3JpcHRcIiwgZXh0OiBbXCJqc1wiXSwgYWxpYXM6IFtcImVjbWFzY3JpcHRcIiwgXCJqc1wiLCBcIm5vZGVcIl19LFxuICAgIHtuYW1lOiBcIkpTT05cIiwgbWltZXM6IFtcImFwcGxpY2F0aW9uL2pzb25cIiwgXCJhcHBsaWNhdGlvbi94LWpzb25cIl0sIG1vZGU6IFwiamF2YXNjcmlwdFwiLCBleHQ6IFtcImpzb25cIiwgXCJtYXBcIl0sIGFsaWFzOiBbXCJqc29uNVwiXX0sXG4gICAge25hbWU6IFwiSlNPTi1MRFwiLCBtaW1lOiBcImFwcGxpY2F0aW9uL2xkK2pzb25cIiwgbW9kZTogXCJqYXZhc2NyaXB0XCIsIGV4dDogW1wianNvbmxkXCJdLCBhbGlhczogW1wianNvbmxkXCJdfSxcbiAgICB7bmFtZTogXCJKU1hcIiwgbWltZTogXCJ0ZXh0L2pzeFwiLCBtb2RlOiBcImpzeFwiLCBleHQ6IFtcImpzeFwiXX0sXG4gICAge25hbWU6IFwiSmluamEyXCIsIG1pbWU6IFwidGV4dC9qaW5qYTJcIiwgbW9kZTogXCJqaW5qYTJcIiwgZXh0OiBbXCJqMlwiLCBcImppbmphXCIsIFwiamluamEyXCJdfSxcbiAgICB7bmFtZTogXCJKdWxpYVwiLCBtaW1lOiBcInRleHQveC1qdWxpYVwiLCBtb2RlOiBcImp1bGlhXCIsIGV4dDogW1wiamxcIl0sIGFsaWFzOiBbXCJqbFwiXX0sXG4gICAge25hbWU6IFwiS290bGluXCIsIG1pbWU6IFwidGV4dC94LWtvdGxpblwiLCBtb2RlOiBcImNsaWtlXCIsIGV4dDogW1wia3RcIl19LFxuICAgIHtuYW1lOiBcIkxFU1NcIiwgbWltZTogXCJ0ZXh0L3gtbGVzc1wiLCBtb2RlOiBcImNzc1wiLCBleHQ6IFtcImxlc3NcIl19LFxuICAgIHtuYW1lOiBcIkxpdmVTY3JpcHRcIiwgbWltZTogXCJ0ZXh0L3gtbGl2ZXNjcmlwdFwiLCBtb2RlOiBcImxpdmVzY3JpcHRcIiwgZXh0OiBbXCJsc1wiXSwgYWxpYXM6IFtcImxzXCJdfSxcbiAgICB7bmFtZTogXCJMdWFcIiwgbWltZTogXCJ0ZXh0L3gtbHVhXCIsIG1vZGU6IFwibHVhXCIsIGV4dDogW1wibHVhXCJdfSxcbiAgICB7bmFtZTogXCJNYXJrZG93blwiLCBtaW1lOiBcInRleHQveC1tYXJrZG93blwiLCBtb2RlOiBcIm1hcmtkb3duXCIsIGV4dDogW1wibWFya2Rvd25cIiwgXCJtZFwiLCBcIm1rZFwiXX0sXG4gICAge25hbWU6IFwibUlSQ1wiLCBtaW1lOiBcInRleHQvbWlyY1wiLCBtb2RlOiBcIm1pcmNcIn0sXG4gICAge25hbWU6IFwiTWFyaWFEQiBTUUxcIiwgbWltZTogXCJ0ZXh0L3gtbWFyaWFkYlwiLCBtb2RlOiBcInNxbFwifSxcbiAgICB7bmFtZTogXCJNYXRoZW1hdGljYVwiLCBtaW1lOiBcInRleHQveC1tYXRoZW1hdGljYVwiLCBtb2RlOiBcIm1hdGhlbWF0aWNhXCIsIGV4dDogW1wibVwiLCBcIm5iXCIsIFwid2xcIiwgXCJ3bHNcIl19LFxuICAgIHtuYW1lOiBcIk1vZGVsaWNhXCIsIG1pbWU6IFwidGV4dC94LW1vZGVsaWNhXCIsIG1vZGU6IFwibW9kZWxpY2FcIiwgZXh0OiBbXCJtb1wiXX0sXG4gICAge25hbWU6IFwiTVVNUFNcIiwgbWltZTogXCJ0ZXh0L3gtbXVtcHNcIiwgbW9kZTogXCJtdW1wc1wiLCBleHQ6IFtcIm1wc1wiXX0sXG4gICAge25hbWU6IFwiTVMgU1FMXCIsIG1pbWU6IFwidGV4dC94LW1zc3FsXCIsIG1vZGU6IFwic3FsXCJ9LFxuICAgIHtuYW1lOiBcIm1ib3hcIiwgbWltZTogXCJhcHBsaWNhdGlvbi9tYm94XCIsIG1vZGU6IFwibWJveFwiLCBleHQ6IFtcIm1ib3hcIl19LFxuICAgIHtuYW1lOiBcIk15U1FMXCIsIG1pbWU6IFwidGV4dC94LW15c3FsXCIsIG1vZGU6IFwic3FsXCJ9LFxuICAgIHtuYW1lOiBcIk5naW54XCIsIG1pbWU6IFwidGV4dC94LW5naW54LWNvbmZcIiwgbW9kZTogXCJuZ2lueFwiLCBmaWxlOiAvbmdpbnguKlxcLmNvbmYkL2l9LFxuICAgIHtuYW1lOiBcIk5TSVNcIiwgbWltZTogXCJ0ZXh0L3gtbnNpc1wiLCBtb2RlOiBcIm5zaXNcIiwgZXh0OiBbXCJuc2hcIiwgXCJuc2lcIl19LFxuICAgIHtuYW1lOiBcIk5UcmlwbGVzXCIsIG1pbWVzOiBbXCJhcHBsaWNhdGlvbi9uLXRyaXBsZXNcIiwgXCJhcHBsaWNhdGlvbi9uLXF1YWRzXCIsIFwidGV4dC9uLXRyaXBsZXNcIl0sXG4gICAgIG1vZGU6IFwibnRyaXBsZXNcIiwgZXh0OiBbXCJudFwiLCBcIm5xXCJdfSxcbiAgICB7bmFtZTogXCJPYmplY3RpdmUtQ1wiLCBtaW1lOiBcInRleHQveC1vYmplY3RpdmVjXCIsIG1vZGU6IFwiY2xpa2VcIiwgZXh0OiBbXCJtXCJdLCBhbGlhczogW1wib2JqZWN0aXZlLWNcIiwgXCJvYmpjXCJdfSxcbiAgICB7bmFtZTogXCJPYmplY3RpdmUtQysrXCIsIG1pbWU6IFwidGV4dC94LW9iamVjdGl2ZWMrK1wiLCBtb2RlOiBcImNsaWtlXCIsIGV4dDogW1wibW1cIl0sIGFsaWFzOiBbXCJvYmplY3RpdmUtYysrXCIsIFwib2JqYysrXCJdfSxcbiAgICB7bmFtZTogXCJPQ2FtbFwiLCBtaW1lOiBcInRleHQveC1vY2FtbFwiLCBtb2RlOiBcIm1sbGlrZVwiLCBleHQ6IFtcIm1sXCIsIFwibWxpXCIsIFwibWxsXCIsIFwibWx5XCJdfSxcbiAgICB7bmFtZTogXCJPY3RhdmVcIiwgbWltZTogXCJ0ZXh0L3gtb2N0YXZlXCIsIG1vZGU6IFwib2N0YXZlXCIsIGV4dDogW1wibVwiXX0sXG4gICAge25hbWU6IFwiT3pcIiwgbWltZTogXCJ0ZXh0L3gtb3pcIiwgbW9kZTogXCJvelwiLCBleHQ6IFtcIm96XCJdfSxcbiAgICB7bmFtZTogXCJQYXNjYWxcIiwgbWltZTogXCJ0ZXh0L3gtcGFzY2FsXCIsIG1vZGU6IFwicGFzY2FsXCIsIGV4dDogW1wicFwiLCBcInBhc1wiXX0sXG4gICAge25hbWU6IFwiUEVHLmpzXCIsIG1pbWU6IFwibnVsbFwiLCBtb2RlOiBcInBlZ2pzXCIsIGV4dDogW1wianNvbmxkXCJdfSxcbiAgICB7bmFtZTogXCJQZXJsXCIsIG1pbWU6IFwidGV4dC94LXBlcmxcIiwgbW9kZTogXCJwZXJsXCIsIGV4dDogW1wicGxcIiwgXCJwbVwiXX0sXG4gICAge25hbWU6IFwiUEhQXCIsIG1pbWVzOiBbXCJ0ZXh0L3gtcGhwXCIsIFwiYXBwbGljYXRpb24veC1odHRwZC1waHBcIiwgXCJhcHBsaWNhdGlvbi94LWh0dHBkLXBocC1vcGVuXCJdLCBtb2RlOiBcInBocFwiLCBleHQ6IFtcInBocFwiLCBcInBocDNcIiwgXCJwaHA0XCIsIFwicGhwNVwiLCBcInBocDdcIiwgXCJwaHRtbFwiXX0sXG4gICAge25hbWU6IFwiUGlnXCIsIG1pbWU6IFwidGV4dC94LXBpZ1wiLCBtb2RlOiBcInBpZ1wiLCBleHQ6IFtcInBpZ1wiXX0sXG4gICAge25hbWU6IFwiUGxhaW4gVGV4dFwiLCBtaW1lOiBcInRleHQvcGxhaW5cIiwgbW9kZTogXCJudWxsXCIsIGV4dDogW1widHh0XCIsIFwidGV4dFwiLCBcImNvbmZcIiwgXCJkZWZcIiwgXCJsaXN0XCIsIFwibG9nXCJdfSxcbiAgICB7bmFtZTogXCJQTFNRTFwiLCBtaW1lOiBcInRleHQveC1wbHNxbFwiLCBtb2RlOiBcInNxbFwiLCBleHQ6IFtcInBsc1wiXX0sXG4gICAge25hbWU6IFwiUG9zdGdyZVNRTFwiLCBtaW1lOiBcInRleHQveC1wZ3NxbFwiLCBtb2RlOiBcInNxbFwifSxcbiAgICB7bmFtZTogXCJQb3dlclNoZWxsXCIsIG1pbWU6IFwiYXBwbGljYXRpb24veC1wb3dlcnNoZWxsXCIsIG1vZGU6IFwicG93ZXJzaGVsbFwiLCBleHQ6IFtcInBzMVwiLCBcInBzZDFcIiwgXCJwc20xXCJdfSxcbiAgICB7bmFtZTogXCJQcm9wZXJ0aWVzIGZpbGVzXCIsIG1pbWU6IFwidGV4dC94LXByb3BlcnRpZXNcIiwgbW9kZTogXCJwcm9wZXJ0aWVzXCIsIGV4dDogW1wicHJvcGVydGllc1wiLCBcImluaVwiLCBcImluXCJdLCBhbGlhczogW1wiaW5pXCIsIFwicHJvcGVydGllc1wiXX0sXG4gICAge25hbWU6IFwiUHJvdG9CdWZcIiwgbWltZTogXCJ0ZXh0L3gtcHJvdG9idWZcIiwgbW9kZTogXCJwcm90b2J1ZlwiLCBleHQ6IFtcInByb3RvXCJdfSxcbiAgICB7bmFtZTogXCJQeXRob25cIiwgbWltZTogXCJ0ZXh0L3gtcHl0aG9uXCIsIG1vZGU6IFwicHl0aG9uXCIsIGV4dDogW1wiQlVJTERcIiwgXCJiemxcIiwgXCJweVwiLCBcInB5d1wiXSwgZmlsZTogL14oQlVDS3xCVUlMRCkkL30sXG4gICAge25hbWU6IFwiUHVwcGV0XCIsIG1pbWU6IFwidGV4dC94LXB1cHBldFwiLCBtb2RlOiBcInB1cHBldFwiLCBleHQ6IFtcInBwXCJdfSxcbiAgICB7bmFtZTogXCJRXCIsIG1pbWU6IFwidGV4dC94LXFcIiwgbW9kZTogXCJxXCIsIGV4dDogW1wicVwiXX0sXG4gICAge25hbWU6IFwiUlwiLCBtaW1lOiBcInRleHQveC1yc3JjXCIsIG1vZGU6IFwiclwiLCBleHQ6IFtcInJcIiwgXCJSXCJdLCBhbGlhczogW1wicnNjcmlwdFwiXX0sXG4gICAge25hbWU6IFwicmVTdHJ1Y3R1cmVkVGV4dFwiLCBtaW1lOiBcInRleHQveC1yc3RcIiwgbW9kZTogXCJyc3RcIiwgZXh0OiBbXCJyc3RcIl0sIGFsaWFzOiBbXCJyc3RcIl19LFxuICAgIHtuYW1lOiBcIlJQTSBDaGFuZ2VzXCIsIG1pbWU6IFwidGV4dC94LXJwbS1jaGFuZ2VzXCIsIG1vZGU6IFwicnBtXCJ9LFxuICAgIHtuYW1lOiBcIlJQTSBTcGVjXCIsIG1pbWU6IFwidGV4dC94LXJwbS1zcGVjXCIsIG1vZGU6IFwicnBtXCIsIGV4dDogW1wic3BlY1wiXX0sXG4gICAge25hbWU6IFwiUnVieVwiLCBtaW1lOiBcInRleHQveC1ydWJ5XCIsIG1vZGU6IFwicnVieVwiLCBleHQ6IFtcInJiXCJdLCBhbGlhczogW1wianJ1YnlcIiwgXCJtYWNydWJ5XCIsIFwicmFrZVwiLCBcInJiXCIsIFwicmJ4XCJdfSxcbiAgICB7bmFtZTogXCJSdXN0XCIsIG1pbWU6IFwidGV4dC94LXJ1c3RzcmNcIiwgbW9kZTogXCJydXN0XCIsIGV4dDogW1wicnNcIl19LFxuICAgIHtuYW1lOiBcIlNBU1wiLCBtaW1lOiBcInRleHQveC1zYXNcIiwgbW9kZTogXCJzYXNcIiwgZXh0OiBbXCJzYXNcIl19LFxuICAgIHtuYW1lOiBcIlNhc3NcIiwgbWltZTogXCJ0ZXh0L3gtc2Fzc1wiLCBtb2RlOiBcInNhc3NcIiwgZXh0OiBbXCJzYXNzXCJdfSxcbiAgICB7bmFtZTogXCJTY2FsYVwiLCBtaW1lOiBcInRleHQveC1zY2FsYVwiLCBtb2RlOiBcImNsaWtlXCIsIGV4dDogW1wic2NhbGFcIl19LFxuICAgIHtuYW1lOiBcIlNjaGVtZVwiLCBtaW1lOiBcInRleHQveC1zY2hlbWVcIiwgbW9kZTogXCJzY2hlbWVcIiwgZXh0OiBbXCJzY21cIiwgXCJzc1wiXX0sXG4gICAge25hbWU6IFwiU0NTU1wiLCBtaW1lOiBcInRleHQveC1zY3NzXCIsIG1vZGU6IFwiY3NzXCIsIGV4dDogW1wic2Nzc1wiXX0sXG4gICAge25hbWU6IFwiU2hlbGxcIiwgbWltZXM6IFtcInRleHQveC1zaFwiLCBcImFwcGxpY2F0aW9uL3gtc2hcIl0sIG1vZGU6IFwic2hlbGxcIiwgZXh0OiBbXCJzaFwiLCBcImtzaFwiLCBcImJhc2hcIl0sIGFsaWFzOiBbXCJiYXNoXCIsIFwic2hcIiwgXCJ6c2hcIl0sIGZpbGU6IC9eUEtHQlVJTEQkL30sXG4gICAge25hbWU6IFwiU2lldmVcIiwgbWltZTogXCJhcHBsaWNhdGlvbi9zaWV2ZVwiLCBtb2RlOiBcInNpZXZlXCIsIGV4dDogW1wic2l2XCIsIFwic2lldmVcIl19LFxuICAgIHtuYW1lOiBcIlNsaW1cIiwgbWltZXM6IFtcInRleHQveC1zbGltXCIsIFwiYXBwbGljYXRpb24veC1zbGltXCJdLCBtb2RlOiBcInNsaW1cIiwgZXh0OiBbXCJzbGltXCJdfSxcbiAgICB7bmFtZTogXCJTbWFsbHRhbGtcIiwgbWltZTogXCJ0ZXh0L3gtc3RzcmNcIiwgbW9kZTogXCJzbWFsbHRhbGtcIiwgZXh0OiBbXCJzdFwiXX0sXG4gICAge25hbWU6IFwiU21hcnR5XCIsIG1pbWU6IFwidGV4dC94LXNtYXJ0eVwiLCBtb2RlOiBcInNtYXJ0eVwiLCBleHQ6IFtcInRwbFwiXX0sXG4gICAge25hbWU6IFwiU29sclwiLCBtaW1lOiBcInRleHQveC1zb2xyXCIsIG1vZGU6IFwic29sclwifSxcbiAgICB7bmFtZTogXCJTTUxcIiwgbWltZTogXCJ0ZXh0L3gtc21sXCIsIG1vZGU6IFwibWxsaWtlXCIsIGV4dDogW1wic21sXCIsIFwic2lnXCIsIFwiZnVuXCIsIFwic21hY2tzcGVjXCJdfSxcbiAgICB7bmFtZTogXCJTb3lcIiwgbWltZTogXCJ0ZXh0L3gtc295XCIsIG1vZGU6IFwic295XCIsIGV4dDogW1wic295XCJdLCBhbGlhczogW1wiY2xvc3VyZSB0ZW1wbGF0ZVwiXX0sXG4gICAge25hbWU6IFwiU1BBUlFMXCIsIG1pbWU6IFwiYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5XCIsIG1vZGU6IFwic3BhcnFsXCIsIGV4dDogW1wicnFcIiwgXCJzcGFycWxcIl0sIGFsaWFzOiBbXCJzcGFydWxcIl19LFxuICAgIHtuYW1lOiBcIlNwcmVhZHNoZWV0XCIsIG1pbWU6IFwidGV4dC94LXNwcmVhZHNoZWV0XCIsIG1vZGU6IFwic3ByZWFkc2hlZXRcIiwgYWxpYXM6IFtcImV4Y2VsXCIsIFwiZm9ybXVsYVwiXX0sXG4gICAge25hbWU6IFwiU1FMXCIsIG1pbWU6IFwidGV4dC94LXNxbFwiLCBtb2RlOiBcInNxbFwiLCBleHQ6IFtcInNxbFwiXX0sXG4gICAge25hbWU6IFwiU1FMaXRlXCIsIG1pbWU6IFwidGV4dC94LXNxbGl0ZVwiLCBtb2RlOiBcInNxbFwifSxcbiAgICB7bmFtZTogXCJTcXVpcnJlbFwiLCBtaW1lOiBcInRleHQveC1zcXVpcnJlbFwiLCBtb2RlOiBcImNsaWtlXCIsIGV4dDogW1wibnV0XCJdfSxcbiAgICB7bmFtZTogXCJTdHlsdXNcIiwgbWltZTogXCJ0ZXh0L3gtc3R5bFwiLCBtb2RlOiBcInN0eWx1c1wiLCBleHQ6IFtcInN0eWxcIl19LFxuICAgIHtuYW1lOiBcIlN3aWZ0XCIsIG1pbWU6IFwidGV4dC94LXN3aWZ0XCIsIG1vZGU6IFwic3dpZnRcIiwgZXh0OiBbXCJzd2lmdFwiXX0sXG4gICAge25hbWU6IFwic1RlWFwiLCBtaW1lOiBcInRleHQveC1zdGV4XCIsIG1vZGU6IFwic3RleFwifSxcbiAgICB7bmFtZTogXCJMYVRlWFwiLCBtaW1lOiBcInRleHQveC1sYXRleFwiLCBtb2RlOiBcInN0ZXhcIiwgZXh0OiBbXCJ0ZXh0XCIsIFwibHR4XCIsIFwidGV4XCJdLCBhbGlhczogW1widGV4XCJdfSxcbiAgICB7bmFtZTogXCJTeXN0ZW1WZXJpbG9nXCIsIG1pbWU6IFwidGV4dC94LXN5c3RlbXZlcmlsb2dcIiwgbW9kZTogXCJ2ZXJpbG9nXCIsIGV4dDogW1widlwiLCBcInN2XCIsIFwic3ZoXCJdfSxcbiAgICB7bmFtZTogXCJUY2xcIiwgbWltZTogXCJ0ZXh0L3gtdGNsXCIsIG1vZGU6IFwidGNsXCIsIGV4dDogW1widGNsXCJdfSxcbiAgICB7bmFtZTogXCJUZXh0aWxlXCIsIG1pbWU6IFwidGV4dC94LXRleHRpbGVcIiwgbW9kZTogXCJ0ZXh0aWxlXCIsIGV4dDogW1widGV4dGlsZVwiXX0sXG4gICAge25hbWU6IFwiVGlkZGx5V2lraVwiLCBtaW1lOiBcInRleHQveC10aWRkbHl3aWtpXCIsIG1vZGU6IFwidGlkZGx5d2lraVwifSxcbiAgICB7bmFtZTogXCJUaWtpIHdpa2lcIiwgbWltZTogXCJ0ZXh0L3Rpa2lcIiwgbW9kZTogXCJ0aWtpXCJ9LFxuICAgIHtuYW1lOiBcIlRPTUxcIiwgbWltZTogXCJ0ZXh0L3gtdG9tbFwiLCBtb2RlOiBcInRvbWxcIiwgZXh0OiBbXCJ0b21sXCJdfSxcbiAgICB7bmFtZTogXCJUb3JuYWRvXCIsIG1pbWU6IFwidGV4dC94LXRvcm5hZG9cIiwgbW9kZTogXCJ0b3JuYWRvXCJ9LFxuICAgIHtuYW1lOiBcInRyb2ZmXCIsIG1pbWU6IFwidGV4dC90cm9mZlwiLCBtb2RlOiBcInRyb2ZmXCIsIGV4dDogW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCJdfSxcbiAgICB7bmFtZTogXCJUVENOXCIsIG1pbWU6IFwidGV4dC94LXR0Y25cIiwgbW9kZTogXCJ0dGNuXCIsIGV4dDogW1widHRjblwiLCBcInR0Y24zXCIsIFwidHRjbnBwXCJdfSxcbiAgICB7bmFtZTogXCJUVENOX0NGR1wiLCBtaW1lOiBcInRleHQveC10dGNuLWNmZ1wiLCBtb2RlOiBcInR0Y24tY2ZnXCIsIGV4dDogW1wiY2ZnXCJdfSxcbiAgICB7bmFtZTogXCJUdXJ0bGVcIiwgbWltZTogXCJ0ZXh0L3R1cnRsZVwiLCBtb2RlOiBcInR1cnRsZVwiLCBleHQ6IFtcInR0bFwiXX0sXG4gICAge25hbWU6IFwiVHlwZVNjcmlwdFwiLCBtaW1lOiBcImFwcGxpY2F0aW9uL3R5cGVzY3JpcHRcIiwgbW9kZTogXCJqYXZhc2NyaXB0XCIsIGV4dDogW1widHNcIl0sIGFsaWFzOiBbXCJ0c1wiXX0sXG4gICAge25hbWU6IFwiVHlwZVNjcmlwdC1KU1hcIiwgbWltZTogXCJ0ZXh0L3R5cGVzY3JpcHQtanN4XCIsIG1vZGU6IFwianN4XCIsIGV4dDogW1widHN4XCJdLCBhbGlhczogW1widHN4XCJdfSxcbiAgICB7bmFtZTogXCJUd2lnXCIsIG1pbWU6IFwidGV4dC94LXR3aWdcIiwgbW9kZTogXCJ0d2lnXCJ9LFxuICAgIHtuYW1lOiBcIldlYiBJRExcIiwgbWltZTogXCJ0ZXh0L3gtd2ViaWRsXCIsIG1vZGU6IFwid2ViaWRsXCIsIGV4dDogW1wid2ViaWRsXCJdfSxcbiAgICB7bmFtZTogXCJWQi5ORVRcIiwgbWltZTogXCJ0ZXh0L3gtdmJcIiwgbW9kZTogXCJ2YlwiLCBleHQ6IFtcInZiXCJdfSxcbiAgICB7bmFtZTogXCJWQlNjcmlwdFwiLCBtaW1lOiBcInRleHQvdmJzY3JpcHRcIiwgbW9kZTogXCJ2YnNjcmlwdFwiLCBleHQ6IFtcInZic1wiXX0sXG4gICAge25hbWU6IFwiVmVsb2NpdHlcIiwgbWltZTogXCJ0ZXh0L3ZlbG9jaXR5XCIsIG1vZGU6IFwidmVsb2NpdHlcIiwgZXh0OiBbXCJ2dGxcIl19LFxuICAgIHtuYW1lOiBcIlZlcmlsb2dcIiwgbWltZTogXCJ0ZXh0L3gtdmVyaWxvZ1wiLCBtb2RlOiBcInZlcmlsb2dcIiwgZXh0OiBbXCJ2XCJdfSxcbiAgICB7bmFtZTogXCJWSERMXCIsIG1pbWU6IFwidGV4dC94LXZoZGxcIiwgbW9kZTogXCJ2aGRsXCIsIGV4dDogW1widmhkXCIsIFwidmhkbFwiXX0sXG4gICAge25hbWU6IFwiVnVlLmpzIENvbXBvbmVudFwiLCBtaW1lczogW1wic2NyaXB0L3gtdnVlXCIsIFwidGV4dC94LXZ1ZVwiXSwgbW9kZTogXCJ2dWVcIiwgZXh0OiBbXCJ2dWVcIl19LFxuICAgIHtuYW1lOiBcIlhNTFwiLCBtaW1lczogW1wiYXBwbGljYXRpb24veG1sXCIsIFwidGV4dC94bWxcIl0sIG1vZGU6IFwieG1sXCIsIGV4dDogW1wieG1sXCIsIFwieHNsXCIsIFwieHNkXCIsIFwic3ZnXCJdLCBhbGlhczogW1wicnNzXCIsIFwid3NkbFwiLCBcInhzZFwiXX0sXG4gICAge25hbWU6IFwiWFF1ZXJ5XCIsIG1pbWU6IFwiYXBwbGljYXRpb24veHF1ZXJ5XCIsIG1vZGU6IFwieHF1ZXJ5XCIsIGV4dDogW1wieHlcIiwgXCJ4cXVlcnlcIl19LFxuICAgIHtuYW1lOiBcIllhY2FzXCIsIG1pbWU6IFwidGV4dC94LXlhY2FzXCIsIG1vZGU6IFwieWFjYXNcIiwgZXh0OiBbXCJ5c1wiXX0sXG4gICAge25hbWU6IFwiWUFNTFwiLCBtaW1lczogW1widGV4dC94LXlhbWxcIiwgXCJ0ZXh0L3lhbWxcIl0sIG1vZGU6IFwieWFtbFwiLCBleHQ6IFtcInlhbWxcIiwgXCJ5bWxcIl0sIGFsaWFzOiBbXCJ5bWxcIl19LFxuICAgIHtuYW1lOiBcIlo4MFwiLCBtaW1lOiBcInRleHQveC16ODBcIiwgbW9kZTogXCJ6ODBcIiwgZXh0OiBbXCJ6ODBcIl19LFxuICAgIHtuYW1lOiBcIm1zY2dlblwiLCBtaW1lOiBcInRleHQveC1tc2NnZW5cIiwgbW9kZTogXCJtc2NnZW5cIiwgZXh0OiBbXCJtc2NnZW5cIiwgXCJtc2NpblwiLCBcIm1zY1wiXX0sXG4gICAge25hbWU6IFwieHVcIiwgbWltZTogXCJ0ZXh0L3gteHVcIiwgbW9kZTogXCJtc2NnZW5cIiwgZXh0OiBbXCJ4dVwiXX0sXG4gICAge25hbWU6IFwibXNnZW5ueVwiLCBtaW1lOiBcInRleHQveC1tc2dlbm55XCIsIG1vZGU6IFwibXNjZ2VuXCIsIGV4dDogW1wibXNnZW5ueVwiXX0sXG4gICAge25hbWU6IFwiV2ViQXNzZW1ibHlcIiwgbWltZTogXCJ0ZXh0L3dlYmFzc2VtYmx5XCIsIG1vZGU6IFwid2FzdFwiLCBleHQ6IFtcIndhdFwiLCBcIndhc3RcIl19LFxuICBdO1xuICAvLyBFbnN1cmUgYWxsIG1vZGVzIGhhdmUgYSBtaW1lIHByb3BlcnR5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBmb3IgKHZhciBpID0gMDsgaSA8IENvZGVNaXJyb3IubW9kZUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5mbyA9IENvZGVNaXJyb3IubW9kZUluZm9baV07XG4gICAgaWYgKGluZm8ubWltZXMpIGluZm8ubWltZSA9IGluZm8ubWltZXNbMF07XG4gIH1cblxuICBDb2RlTWlycm9yLmZpbmRNb2RlQnlNSU1FID0gZnVuY3Rpb24obWltZSkge1xuICAgIG1pbWUgPSBtaW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDb2RlTWlycm9yLm1vZGVJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IENvZGVNaXJyb3IubW9kZUluZm9baV07XG4gICAgICBpZiAoaW5mby5taW1lID09IG1pbWUpIHJldHVybiBpbmZvO1xuICAgICAgaWYgKGluZm8ubWltZXMpIGZvciAodmFyIGogPSAwOyBqIDwgaW5mby5taW1lcy5sZW5ndGg7IGorKylcbiAgICAgICAgaWYgKGluZm8ubWltZXNbal0gPT0gbWltZSkgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIGlmICgvXFwreG1sJC8udGVzdChtaW1lKSkgcmV0dXJuIENvZGVNaXJyb3IuZmluZE1vZGVCeU1JTUUoXCJhcHBsaWNhdGlvbi94bWxcIilcbiAgICBpZiAoL1xcK2pzb24kLy50ZXN0KG1pbWUpKSByZXR1cm4gQ29kZU1pcnJvci5maW5kTW9kZUJ5TUlNRShcImFwcGxpY2F0aW9uL2pzb25cIilcbiAgfTtcblxuICBDb2RlTWlycm9yLmZpbmRNb2RlQnlFeHRlbnNpb24gPSBmdW5jdGlvbihleHQpIHtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENvZGVNaXJyb3IubW9kZUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gQ29kZU1pcnJvci5tb2RlSW5mb1tpXTtcbiAgICAgIGlmIChpbmZvLmV4dCkgZm9yICh2YXIgaiA9IDA7IGogPCBpbmZvLmV4dC5sZW5ndGg7IGorKylcbiAgICAgICAgaWYgKGluZm8uZXh0W2pdID09IGV4dCkgcmV0dXJuIGluZm87XG4gICAgfVxuICB9O1xuXG4gIENvZGVNaXJyb3IuZmluZE1vZGVCeUZpbGVOYW1lID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENvZGVNaXJyb3IubW9kZUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gQ29kZU1pcnJvci5tb2RlSW5mb1tpXTtcbiAgICAgIGlmIChpbmZvLmZpbGUgJiYgaW5mby5maWxlLnRlc3QoZmlsZW5hbWUpKSByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIGRvdCA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICB2YXIgZXh0ID0gZG90ID4gLTEgJiYgZmlsZW5hbWUuc3Vic3RyaW5nKGRvdCArIDEsIGZpbGVuYW1lLmxlbmd0aCk7XG4gICAgaWYgKGV4dCkgcmV0dXJuIENvZGVNaXJyb3IuZmluZE1vZGVCeUV4dGVuc2lvbihleHQpO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZmluZE1vZGVCeU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENvZGVNaXJyb3IubW9kZUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gQ29kZU1pcnJvci5tb2RlSW5mb1tpXTtcbiAgICAgIGlmIChpbmZvLm5hbWUudG9Mb3dlckNhc2UoKSA9PSBuYW1lKSByZXR1cm4gaW5mbztcbiAgICAgIGlmIChpbmZvLmFsaWFzKSBmb3IgKHZhciBqID0gMDsgaiA8IGluZm8uYWxpYXMubGVuZ3RoOyBqKyspXG4gICAgICAgIGlmIChpbmZvLmFsaWFzW2pdLnRvTG93ZXJDYXNlKCkgPT0gbmFtZSkgcmV0dXJuIGluZm87XG4gICAgfVxuICB9O1xufSk7XG4iXSwibmFtZXMiOlsibW9kIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJDb2RlTWlycm9yIiwibW9kZUluZm8iLCJuYW1lIiwibWltZSIsIm1vZGUiLCJleHQiLCJtaW1lcyIsImZpbGUiLCJhbGlhcyIsImkiLCJsZW5ndGgiLCJpbmZvIiwiZmluZE1vZGVCeU1JTUUiLCJ0b0xvd2VyQ2FzZSIsImoiLCJ0ZXN0IiwiZmluZE1vZGVCeUV4dGVuc2lvbiIsImZpbmRNb2RlQnlGaWxlTmFtZSIsImZpbGVuYW1lIiwiZG90IiwibGFzdEluZGV4T2YiLCJzdWJzdHJpbmciLCJmaW5kTW9kZUJ5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/mode/meta.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/codemirror/mode/xml/xml.js":
/*!*************************************************!*\
  !*** ./node_modules/codemirror/mode/xml/xml.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n(function(mod) {\n    if (true) mod(__webpack_require__(/*! ../../lib/codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\"));\n    else {}\n})(function(CodeMirror1) {\n    \"use strict\";\n    var htmlConfig = {\n        autoSelfClosers: {\n            \"area\": true,\n            \"base\": true,\n            \"br\": true,\n            \"col\": true,\n            \"command\": true,\n            \"embed\": true,\n            \"frame\": true,\n            \"hr\": true,\n            \"img\": true,\n            \"input\": true,\n            \"keygen\": true,\n            \"link\": true,\n            \"meta\": true,\n            \"param\": true,\n            \"source\": true,\n            \"track\": true,\n            \"wbr\": true,\n            \"menuitem\": true\n        },\n        implicitlyClosed: {\n            \"dd\": true,\n            \"li\": true,\n            \"optgroup\": true,\n            \"option\": true,\n            \"p\": true,\n            \"rp\": true,\n            \"rt\": true,\n            \"tbody\": true,\n            \"td\": true,\n            \"tfoot\": true,\n            \"th\": true,\n            \"tr\": true\n        },\n        contextGrabbers: {\n            \"dd\": {\n                \"dd\": true,\n                \"dt\": true\n            },\n            \"dt\": {\n                \"dd\": true,\n                \"dt\": true\n            },\n            \"li\": {\n                \"li\": true\n            },\n            \"option\": {\n                \"option\": true,\n                \"optgroup\": true\n            },\n            \"optgroup\": {\n                \"optgroup\": true\n            },\n            \"p\": {\n                \"address\": true,\n                \"article\": true,\n                \"aside\": true,\n                \"blockquote\": true,\n                \"dir\": true,\n                \"div\": true,\n                \"dl\": true,\n                \"fieldset\": true,\n                \"footer\": true,\n                \"form\": true,\n                \"h1\": true,\n                \"h2\": true,\n                \"h3\": true,\n                \"h4\": true,\n                \"h5\": true,\n                \"h6\": true,\n                \"header\": true,\n                \"hgroup\": true,\n                \"hr\": true,\n                \"menu\": true,\n                \"nav\": true,\n                \"ol\": true,\n                \"p\": true,\n                \"pre\": true,\n                \"section\": true,\n                \"table\": true,\n                \"ul\": true\n            },\n            \"rp\": {\n                \"rp\": true,\n                \"rt\": true\n            },\n            \"rt\": {\n                \"rp\": true,\n                \"rt\": true\n            },\n            \"tbody\": {\n                \"tbody\": true,\n                \"tfoot\": true\n            },\n            \"td\": {\n                \"td\": true,\n                \"th\": true\n            },\n            \"tfoot\": {\n                \"tbody\": true\n            },\n            \"th\": {\n                \"td\": true,\n                \"th\": true\n            },\n            \"thead\": {\n                \"tbody\": true,\n                \"tfoot\": true\n            },\n            \"tr\": {\n                \"tr\": true\n            }\n        },\n        doNotIndent: {\n            \"pre\": true\n        },\n        allowUnquoted: true,\n        allowMissing: true,\n        caseFold: true\n    };\n    var xmlConfig = {\n        autoSelfClosers: {},\n        implicitlyClosed: {},\n        contextGrabbers: {},\n        doNotIndent: {},\n        allowUnquoted: false,\n        allowMissing: false,\n        allowMissingTagName: false,\n        caseFold: false\n    };\n    CodeMirror1.defineMode(\"xml\", function(editorConf, config_) {\n        var indentUnit = editorConf.indentUnit;\n        var config = {};\n        var defaults = config_.htmlMode ? htmlConfig : xmlConfig;\n        for(var prop in defaults)config[prop] = defaults[prop];\n        for(var prop in config_)config[prop] = config_[prop];\n        // Return variables for tokenizers\n        var type, setStyle;\n        function inText(stream, state) {\n            function chain(parser) {\n                state.tokenize = parser;\n                return parser(stream, state);\n            }\n            var ch = stream.next();\n            if (ch == \"<\") {\n                if (stream.eat(\"!\")) {\n                    if (stream.eat(\"[\")) {\n                        if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n                        else return null;\n                    } else if (stream.match(\"--\")) {\n                        return chain(inBlock(\"comment\", \"-->\"));\n                    } else if (stream.match(\"DOCTYPE\", true, true)) {\n                        stream.eatWhile(/[\\w\\._\\-]/);\n                        return chain(doctype(1));\n                    } else {\n                        return null;\n                    }\n                } else if (stream.eat(\"?\")) {\n                    stream.eatWhile(/[\\w\\._\\-]/);\n                    state.tokenize = inBlock(\"meta\", \"?>\");\n                    return \"meta\";\n                } else {\n                    type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n                    state.tokenize = inTag;\n                    return \"tag bracket\";\n                }\n            } else if (ch == \"&\") {\n                var ok;\n                if (stream.eat(\"#\")) {\n                    if (stream.eat(\"x\")) {\n                        ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n                    } else {\n                        ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n                    }\n                } else {\n                    ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n                }\n                return ok ? \"atom\" : \"error\";\n            } else {\n                stream.eatWhile(/[^&<]/);\n                return null;\n            }\n        }\n        inText.isInText = true;\n        function inTag(stream, state) {\n            var ch = stream.next();\n            if (ch == \">\" || ch == \"/\" && stream.eat(\">\")) {\n                state.tokenize = inText;\n                type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n                return \"tag bracket\";\n            } else if (ch == \"=\") {\n                type = \"equals\";\n                return null;\n            } else if (ch == \"<\") {\n                state.tokenize = inText;\n                state.state = baseState;\n                state.tagName = state.tagStart = null;\n                var next = state.tokenize(stream, state);\n                return next ? next + \" tag error\" : \"tag error\";\n            } else if (/[\\'\\\"]/.test(ch)) {\n                state.tokenize = inAttribute(ch);\n                state.stringStartCol = stream.column();\n                return state.tokenize(stream, state);\n            } else {\n                stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n                return \"word\";\n            }\n        }\n        function inAttribute(quote) {\n            var closure = function(stream, state) {\n                while(!stream.eol()){\n                    if (stream.next() == quote) {\n                        state.tokenize = inTag;\n                        break;\n                    }\n                }\n                return \"string\";\n            };\n            closure.isInAttribute = true;\n            return closure;\n        }\n        function inBlock(style, terminator) {\n            return function(stream, state) {\n                while(!stream.eol()){\n                    if (stream.match(terminator)) {\n                        state.tokenize = inText;\n                        break;\n                    }\n                    stream.next();\n                }\n                return style;\n            };\n        }\n        function doctype(depth) {\n            return function(stream, state) {\n                var ch;\n                while((ch = stream.next()) != null){\n                    if (ch == \"<\") {\n                        state.tokenize = doctype(depth + 1);\n                        return state.tokenize(stream, state);\n                    } else if (ch == \">\") {\n                        if (depth == 1) {\n                            state.tokenize = inText;\n                            break;\n                        } else {\n                            state.tokenize = doctype(depth - 1);\n                            return state.tokenize(stream, state);\n                        }\n                    }\n                }\n                return \"meta\";\n            };\n        }\n        function lower(tagName) {\n            return tagName && tagName.toLowerCase();\n        }\n        function Context(state, tagName, startOfLine) {\n            this.prev = state.context;\n            this.tagName = tagName || \"\";\n            this.indent = state.indented;\n            this.startOfLine = startOfLine;\n            if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;\n        }\n        function popContext(state) {\n            if (state.context) state.context = state.context.prev;\n        }\n        function maybePopContext(state, nextTagName) {\n            var parentTagName;\n            while(true){\n                if (!state.context) {\n                    return;\n                }\n                parentTagName = state.context.tagName;\n                if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) || !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {\n                    return;\n                }\n                popContext(state);\n            }\n        }\n        function baseState(type, stream, state) {\n            if (type == \"openTag\") {\n                state.tagStart = stream.column();\n                return tagNameState;\n            } else if (type == \"closeTag\") {\n                return closeTagNameState;\n            } else {\n                return baseState;\n            }\n        }\n        function tagNameState(type, stream, state) {\n            if (type == \"word\") {\n                state.tagName = stream.current();\n                setStyle = \"tag\";\n                return attrState;\n            } else if (config.allowMissingTagName && type == \"endTag\") {\n                setStyle = \"tag bracket\";\n                return attrState(type, stream, state);\n            } else {\n                setStyle = \"error\";\n                return tagNameState;\n            }\n        }\n        function closeTagNameState(type, stream, state) {\n            if (type == \"word\") {\n                var tagName = stream.current();\n                if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName))) popContext(state);\n                if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n                    setStyle = \"tag\";\n                    return closeState;\n                } else {\n                    setStyle = \"tag error\";\n                    return closeStateErr;\n                }\n            } else if (config.allowMissingTagName && type == \"endTag\") {\n                setStyle = \"tag bracket\";\n                return closeState(type, stream, state);\n            } else {\n                setStyle = \"error\";\n                return closeStateErr;\n            }\n        }\n        function closeState(type, _stream, state) {\n            if (type != \"endTag\") {\n                setStyle = \"error\";\n                return closeState;\n            }\n            popContext(state);\n            return baseState;\n        }\n        function closeStateErr(type, stream, state) {\n            setStyle = \"error\";\n            return closeState(type, stream, state);\n        }\n        function attrState(type, _stream, state) {\n            if (type == \"word\") {\n                setStyle = \"attribute\";\n                return attrEqState;\n            } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n                var tagName = state.tagName, tagStart = state.tagStart;\n                state.tagName = state.tagStart = null;\n                if (type == \"selfcloseTag\" || config.autoSelfClosers.hasOwnProperty(lower(tagName))) {\n                    maybePopContext(state, tagName);\n                } else {\n                    maybePopContext(state, tagName);\n                    state.context = new Context(state, tagName, tagStart == state.indented);\n                }\n                return baseState;\n            }\n            setStyle = \"error\";\n            return attrState;\n        }\n        function attrEqState(type, stream, state) {\n            if (type == \"equals\") return attrValueState;\n            if (!config.allowMissing) setStyle = \"error\";\n            return attrState(type, stream, state);\n        }\n        function attrValueState(type, stream, state) {\n            if (type == \"string\") return attrContinuedState;\n            if (type == \"word\" && config.allowUnquoted) {\n                setStyle = \"string\";\n                return attrState;\n            }\n            setStyle = \"error\";\n            return attrState(type, stream, state);\n        }\n        function attrContinuedState(type, stream, state) {\n            if (type == \"string\") return attrContinuedState;\n            return attrState(type, stream, state);\n        }\n        return {\n            startState: function(baseIndent) {\n                var state = {\n                    tokenize: inText,\n                    state: baseState,\n                    indented: baseIndent || 0,\n                    tagName: null,\n                    tagStart: null,\n                    context: null\n                };\n                if (baseIndent != null) state.baseIndent = baseIndent;\n                return state;\n            },\n            token: function(stream, state) {\n                if (!state.tagName && stream.sol()) state.indented = stream.indentation();\n                if (stream.eatSpace()) return null;\n                type = null;\n                var style = state.tokenize(stream, state);\n                if ((style || type) && style != \"comment\") {\n                    setStyle = null;\n                    state.state = state.state(type || style, stream, state);\n                    if (setStyle) style = setStyle == \"error\" ? style + \" error\" : setStyle;\n                }\n                return style;\n            },\n            indent: function(state, textAfter, fullLine) {\n                var context = state.context;\n                // Indent multi-line strings (e.g. css).\n                if (state.tokenize.isInAttribute) {\n                    if (state.tagStart == state.indented) return state.stringStartCol + 1;\n                    else return state.indented + indentUnit;\n                }\n                if (context && context.noIndent) return CodeMirror1.Pass;\n                if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n                // Indent the starts of attribute names.\n                if (state.tagName) {\n                    if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;\n                    else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n                }\n                if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n                var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n                if (tagAfter && tagAfter[1]) {\n                    while(context){\n                        if (context.tagName == tagAfter[2]) {\n                            context = context.prev;\n                            break;\n                        } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {\n                            context = context.prev;\n                        } else {\n                            break;\n                        }\n                    }\n                } else if (tagAfter) {\n                    while(context){\n                        var grabbers = config.contextGrabbers[lower(context.tagName)];\n                        if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2]))) context = context.prev;\n                        else break;\n                    }\n                }\n                while(context && context.prev && !context.startOfLine)context = context.prev;\n                if (context) return context.indent + indentUnit;\n                else return state.baseIndent || 0;\n            },\n            electricInput: /<\\/[\\s\\w:]+>$/,\n            blockCommentStart: \"<!--\",\n            blockCommentEnd: \"-->\",\n            configuration: config.htmlMode ? \"html\" : \"xml\",\n            helperType: config.htmlMode ? \"html\" : \"xml\",\n            skipAttribute: function(state) {\n                if (state.state == attrValueState) state.state = attrState;\n            },\n            xmlCurrentTag: function(state) {\n                return state.tagName ? {\n                    name: state.tagName,\n                    close: state.type == \"closeTag\"\n                } : null;\n            },\n            xmlCurrentContext: function(state) {\n                var context = [];\n                for(var cx = state.context; cx; cx = cx.prev)context.push(cx.tagName);\n                return context.reverse();\n            }\n        };\n    });\n    CodeMirror1.defineMIME(\"text/xml\", \"xml\");\n    CodeMirror1.defineMIME(\"application/xml\", \"xml\");\n    if (!CodeMirror1.mimeModes.hasOwnProperty(\"text/html\")) CodeMirror1.defineMIME(\"text/html\", {\n        name: \"xml\",\n        htmlMode: true\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBRXBFLFVBQVNBLEdBQUc7SUFDWCxJQUFJLElBQXVELEVBQ3pEQSxJQUFJRyxtQkFBT0EsQ0FBQyw2RkFBc0I7U0FDL0IsRUFHYUc7QUFDcEIsR0FBRyxTQUFTQSxXQUFVO0lBQ3RCO0lBRUEsSUFBSUMsYUFBYTtRQUNmQyxpQkFBaUI7WUFBQyxRQUFRO1lBQU0sUUFBUTtZQUFNLE1BQU07WUFBTSxPQUFPO1lBQU0sV0FBVztZQUNoRSxTQUFTO1lBQU0sU0FBUztZQUFNLE1BQU07WUFBTSxPQUFPO1lBQU0sU0FBUztZQUNoRSxVQUFVO1lBQU0sUUFBUTtZQUFNLFFBQVE7WUFBTSxTQUFTO1lBQU0sVUFBVTtZQUNyRSxTQUFTO1lBQU0sT0FBTztZQUFNLFlBQVk7UUFBSTtRQUM5REMsa0JBQWtCO1lBQUMsTUFBTTtZQUFNLE1BQU07WUFBTSxZQUFZO1lBQU0sVUFBVTtZQUFNLEtBQUs7WUFDL0QsTUFBTTtZQUFNLE1BQU07WUFBTSxTQUFTO1lBQU0sTUFBTTtZQUFNLFNBQVM7WUFDNUQsTUFBTTtZQUFNLE1BQU07UUFBSTtRQUN6Q0MsaUJBQWlCO1lBQ2YsTUFBTTtnQkFBQyxNQUFNO2dCQUFNLE1BQU07WUFBSTtZQUM3QixNQUFNO2dCQUFDLE1BQU07Z0JBQU0sTUFBTTtZQUFJO1lBQzdCLE1BQU07Z0JBQUMsTUFBTTtZQUFJO1lBQ2pCLFVBQVU7Z0JBQUMsVUFBVTtnQkFBTSxZQUFZO1lBQUk7WUFDM0MsWUFBWTtnQkFBQyxZQUFZO1lBQUk7WUFDN0IsS0FBSztnQkFBQyxXQUFXO2dCQUFNLFdBQVc7Z0JBQU0sU0FBUztnQkFBTSxjQUFjO2dCQUFNLE9BQU87Z0JBQzVFLE9BQU87Z0JBQU0sTUFBTTtnQkFBTSxZQUFZO2dCQUFNLFVBQVU7Z0JBQU0sUUFBUTtnQkFDbkUsTUFBTTtnQkFBTSxNQUFNO2dCQUFNLE1BQU07Z0JBQU0sTUFBTTtnQkFBTSxNQUFNO2dCQUFNLE1BQU07Z0JBQ2xFLFVBQVU7Z0JBQU0sVUFBVTtnQkFBTSxNQUFNO2dCQUFNLFFBQVE7Z0JBQU0sT0FBTztnQkFBTSxNQUFNO2dCQUM3RSxLQUFLO2dCQUFNLE9BQU87Z0JBQU0sV0FBVztnQkFBTSxTQUFTO2dCQUFNLE1BQU07WUFBSTtZQUN4RSxNQUFNO2dCQUFDLE1BQU07Z0JBQU0sTUFBTTtZQUFJO1lBQzdCLE1BQU07Z0JBQUMsTUFBTTtnQkFBTSxNQUFNO1lBQUk7WUFDN0IsU0FBUztnQkFBQyxTQUFTO2dCQUFNLFNBQVM7WUFBSTtZQUN0QyxNQUFNO2dCQUFDLE1BQU07Z0JBQU0sTUFBTTtZQUFJO1lBQzdCLFNBQVM7Z0JBQUMsU0FBUztZQUFJO1lBQ3ZCLE1BQU07Z0JBQUMsTUFBTTtnQkFBTSxNQUFNO1lBQUk7WUFDN0IsU0FBUztnQkFBQyxTQUFTO2dCQUFNLFNBQVM7WUFBSTtZQUN0QyxNQUFNO2dCQUFDLE1BQU07WUFBSTtRQUNuQjtRQUNBQyxhQUFhO1lBQUMsT0FBTztRQUFJO1FBQ3pCQyxlQUFlO1FBQ2ZDLGNBQWM7UUFDZEMsVUFBVTtJQUNaO0lBRUEsSUFBSUMsWUFBWTtRQUNkUCxpQkFBaUIsQ0FBQztRQUNsQkMsa0JBQWtCLENBQUM7UUFDbkJDLGlCQUFpQixDQUFDO1FBQ2xCQyxhQUFhLENBQUM7UUFDZEMsZUFBZTtRQUNmQyxjQUFjO1FBQ2RHLHFCQUFxQjtRQUNyQkYsVUFBVTtJQUNaO0lBRUFSLFlBQVdXLFVBQVUsQ0FBQyxPQUFPLFNBQVNDLFVBQVUsRUFBRUMsT0FBTztRQUN2RCxJQUFJQyxhQUFhRixXQUFXRSxVQUFVO1FBQ3RDLElBQUlDLFNBQVMsQ0FBQztRQUNkLElBQUlDLFdBQVdILFFBQVFJLFFBQVEsR0FBR2hCLGFBQWFRO1FBQy9DLElBQUssSUFBSVMsUUFBUUYsU0FBVUQsTUFBTSxDQUFDRyxLQUFLLEdBQUdGLFFBQVEsQ0FBQ0UsS0FBSztRQUN4RCxJQUFLLElBQUlBLFFBQVFMLFFBQVNFLE1BQU0sQ0FBQ0csS0FBSyxHQUFHTCxPQUFPLENBQUNLLEtBQUs7UUFFdEQsa0NBQWtDO1FBQ2xDLElBQUlDLE1BQU1DO1FBRVYsU0FBU0MsT0FBT0MsTUFBTSxFQUFFQyxLQUFLO1lBQzNCLFNBQVNDLE1BQU1DLE1BQU07Z0JBQ25CRixNQUFNRyxRQUFRLEdBQUdEO2dCQUNqQixPQUFPQSxPQUFPSCxRQUFRQztZQUN4QjtZQUVBLElBQUlJLEtBQUtMLE9BQU9NLElBQUk7WUFDcEIsSUFBSUQsTUFBTSxLQUFLO2dCQUNiLElBQUlMLE9BQU9PLEdBQUcsQ0FBQyxNQUFNO29CQUNuQixJQUFJUCxPQUFPTyxHQUFHLENBQUMsTUFBTTt3QkFDbkIsSUFBSVAsT0FBT1EsS0FBSyxDQUFDLFdBQVcsT0FBT04sTUFBTU8sUUFBUSxRQUFROzZCQUNwRCxPQUFPO29CQUNkLE9BQU8sSUFBSVQsT0FBT1EsS0FBSyxDQUFDLE9BQU87d0JBQzdCLE9BQU9OLE1BQU1PLFFBQVEsV0FBVztvQkFDbEMsT0FBTyxJQUFJVCxPQUFPUSxLQUFLLENBQUMsV0FBVyxNQUFNLE9BQU87d0JBQzlDUixPQUFPVSxRQUFRLENBQUM7d0JBQ2hCLE9BQU9SLE1BQU1TLFFBQVE7b0JBQ3ZCLE9BQU87d0JBQ0wsT0FBTztvQkFDVDtnQkFDRixPQUFPLElBQUlYLE9BQU9PLEdBQUcsQ0FBQyxNQUFNO29CQUMxQlAsT0FBT1UsUUFBUSxDQUFDO29CQUNoQlQsTUFBTUcsUUFBUSxHQUFHSyxRQUFRLFFBQVE7b0JBQ2pDLE9BQU87Z0JBQ1QsT0FBTztvQkFDTFosT0FBT0csT0FBT08sR0FBRyxDQUFDLE9BQU8sYUFBYTtvQkFDdENOLE1BQU1HLFFBQVEsR0FBR1E7b0JBQ2pCLE9BQU87Z0JBQ1Q7WUFDRixPQUFPLElBQUlQLE1BQU0sS0FBSztnQkFDcEIsSUFBSVE7Z0JBQ0osSUFBSWIsT0FBT08sR0FBRyxDQUFDLE1BQU07b0JBQ25CLElBQUlQLE9BQU9PLEdBQUcsQ0FBQyxNQUFNO3dCQUNuQk0sS0FBS2IsT0FBT1UsUUFBUSxDQUFDLGlCQUFpQlYsT0FBT08sR0FBRyxDQUFDO29CQUNuRCxPQUFPO3dCQUNMTSxLQUFLYixPQUFPVSxRQUFRLENBQUMsV0FBV1YsT0FBT08sR0FBRyxDQUFDO29CQUM3QztnQkFDRixPQUFPO29CQUNMTSxLQUFLYixPQUFPVSxRQUFRLENBQUMsZ0JBQWdCVixPQUFPTyxHQUFHLENBQUM7Z0JBQ2xEO2dCQUNBLE9BQU9NLEtBQUssU0FBUztZQUN2QixPQUFPO2dCQUNMYixPQUFPVSxRQUFRLENBQUM7Z0JBQ2hCLE9BQU87WUFDVDtRQUNGO1FBQ0FYLE9BQU9lLFFBQVEsR0FBRztRQUVsQixTQUFTRixNQUFNWixNQUFNLEVBQUVDLEtBQUs7WUFDMUIsSUFBSUksS0FBS0wsT0FBT00sSUFBSTtZQUNwQixJQUFJRCxNQUFNLE9BQVFBLE1BQU0sT0FBT0wsT0FBT08sR0FBRyxDQUFDLE1BQU87Z0JBQy9DTixNQUFNRyxRQUFRLEdBQUdMO2dCQUNqQkYsT0FBT1EsTUFBTSxNQUFNLFdBQVc7Z0JBQzlCLE9BQU87WUFDVCxPQUFPLElBQUlBLE1BQU0sS0FBSztnQkFDcEJSLE9BQU87Z0JBQ1AsT0FBTztZQUNULE9BQU8sSUFBSVEsTUFBTSxLQUFLO2dCQUNwQkosTUFBTUcsUUFBUSxHQUFHTDtnQkFDakJFLE1BQU1BLEtBQUssR0FBR2M7Z0JBQ2RkLE1BQU1lLE9BQU8sR0FBR2YsTUFBTWdCLFFBQVEsR0FBRztnQkFDakMsSUFBSVgsT0FBT0wsTUFBTUcsUUFBUSxDQUFDSixRQUFRQztnQkFDbEMsT0FBT0ssT0FBT0EsT0FBTyxlQUFlO1lBQ3RDLE9BQU8sSUFBSSxTQUFTWSxJQUFJLENBQUNiLEtBQUs7Z0JBQzVCSixNQUFNRyxRQUFRLEdBQUdlLFlBQVlkO2dCQUM3QkosTUFBTW1CLGNBQWMsR0FBR3BCLE9BQU9xQixNQUFNO2dCQUNwQyxPQUFPcEIsTUFBTUcsUUFBUSxDQUFDSixRQUFRQztZQUNoQyxPQUFPO2dCQUNMRCxPQUFPUSxLQUFLLENBQUM7Z0JBQ2IsT0FBTztZQUNUO1FBQ0Y7UUFFQSxTQUFTVyxZQUFZRyxLQUFLO1lBQ3hCLElBQUlDLFVBQVUsU0FBU3ZCLE1BQU0sRUFBRUMsS0FBSztnQkFDbEMsTUFBTyxDQUFDRCxPQUFPd0IsR0FBRyxHQUFJO29CQUNwQixJQUFJeEIsT0FBT00sSUFBSSxNQUFNZ0IsT0FBTzt3QkFDMUJyQixNQUFNRyxRQUFRLEdBQUdRO3dCQUNqQjtvQkFDRjtnQkFDRjtnQkFDQSxPQUFPO1lBQ1Q7WUFDQVcsUUFBUUUsYUFBYSxHQUFHO1lBQ3hCLE9BQU9GO1FBQ1Q7UUFFQSxTQUFTZCxRQUFRaUIsS0FBSyxFQUFFQyxVQUFVO1lBQ2hDLE9BQU8sU0FBUzNCLE1BQU0sRUFBRUMsS0FBSztnQkFDM0IsTUFBTyxDQUFDRCxPQUFPd0IsR0FBRyxHQUFJO29CQUNwQixJQUFJeEIsT0FBT1EsS0FBSyxDQUFDbUIsYUFBYTt3QkFDNUIxQixNQUFNRyxRQUFRLEdBQUdMO3dCQUNqQjtvQkFDRjtvQkFDQUMsT0FBT00sSUFBSTtnQkFDYjtnQkFDQSxPQUFPb0I7WUFDVDtRQUNGO1FBRUEsU0FBU2YsUUFBUWlCLEtBQUs7WUFDcEIsT0FBTyxTQUFTNUIsTUFBTSxFQUFFQyxLQUFLO2dCQUMzQixJQUFJSTtnQkFDSixNQUFPLENBQUNBLEtBQUtMLE9BQU9NLElBQUksRUFBQyxLQUFNLEtBQU07b0JBQ25DLElBQUlELE1BQU0sS0FBSzt3QkFDYkosTUFBTUcsUUFBUSxHQUFHTyxRQUFRaUIsUUFBUTt3QkFDakMsT0FBTzNCLE1BQU1HLFFBQVEsQ0FBQ0osUUFBUUM7b0JBQ2hDLE9BQU8sSUFBSUksTUFBTSxLQUFLO3dCQUNwQixJQUFJdUIsU0FBUyxHQUFHOzRCQUNkM0IsTUFBTUcsUUFBUSxHQUFHTDs0QkFDakI7d0JBQ0YsT0FBTzs0QkFDTEUsTUFBTUcsUUFBUSxHQUFHTyxRQUFRaUIsUUFBUTs0QkFDakMsT0FBTzNCLE1BQU1HLFFBQVEsQ0FBQ0osUUFBUUM7d0JBQ2hDO29CQUNGO2dCQUNGO2dCQUNBLE9BQU87WUFDVDtRQUNGO1FBRUEsU0FBUzRCLE1BQU1iLE9BQU87WUFDcEIsT0FBT0EsV0FBV0EsUUFBUWMsV0FBVztRQUN2QztRQUVBLFNBQVNDLFFBQVE5QixLQUFLLEVBQUVlLE9BQU8sRUFBRWdCLFdBQVc7WUFDMUMsSUFBSSxDQUFDQyxJQUFJLEdBQUdoQyxNQUFNaUMsT0FBTztZQUN6QixJQUFJLENBQUNsQixPQUFPLEdBQUdBLFdBQVc7WUFDMUIsSUFBSSxDQUFDbUIsTUFBTSxHQUFHbEMsTUFBTW1DLFFBQVE7WUFDNUIsSUFBSSxDQUFDSixXQUFXLEdBQUdBO1lBQ25CLElBQUl2QyxPQUFPVixXQUFXLENBQUNzRCxjQUFjLENBQUNyQixZQUFhZixNQUFNaUMsT0FBTyxJQUFJakMsTUFBTWlDLE9BQU8sQ0FBQ0ksUUFBUSxFQUN4RixJQUFJLENBQUNBLFFBQVEsR0FBRztRQUNwQjtRQUNBLFNBQVNDLFdBQVd0QyxLQUFLO1lBQ3ZCLElBQUlBLE1BQU1pQyxPQUFPLEVBQUVqQyxNQUFNaUMsT0FBTyxHQUFHakMsTUFBTWlDLE9BQU8sQ0FBQ0QsSUFBSTtRQUN2RDtRQUNBLFNBQVNPLGdCQUFnQnZDLEtBQUssRUFBRXdDLFdBQVc7WUFDekMsSUFBSUM7WUFDSixNQUFPLEtBQU07Z0JBQ1gsSUFBSSxDQUFDekMsTUFBTWlDLE9BQU8sRUFBRTtvQkFDbEI7Z0JBQ0Y7Z0JBQ0FRLGdCQUFnQnpDLE1BQU1pQyxPQUFPLENBQUNsQixPQUFPO2dCQUNyQyxJQUFJLENBQUN2QixPQUFPWCxlQUFlLENBQUN1RCxjQUFjLENBQUNSLE1BQU1hLG1CQUM3QyxDQUFDakQsT0FBT1gsZUFBZSxDQUFDK0MsTUFBTWEsZUFBZSxDQUFDTCxjQUFjLENBQUNSLE1BQU1ZLGVBQWU7b0JBQ3BGO2dCQUNGO2dCQUNBRixXQUFXdEM7WUFDYjtRQUNGO1FBRUEsU0FBU2MsVUFBVWxCLElBQUksRUFBRUcsTUFBTSxFQUFFQyxLQUFLO1lBQ3BDLElBQUlKLFFBQVEsV0FBVztnQkFDckJJLE1BQU1nQixRQUFRLEdBQUdqQixPQUFPcUIsTUFBTTtnQkFDOUIsT0FBT3NCO1lBQ1QsT0FBTyxJQUFJOUMsUUFBUSxZQUFZO2dCQUM3QixPQUFPK0M7WUFDVCxPQUFPO2dCQUNMLE9BQU83QjtZQUNUO1FBQ0Y7UUFDQSxTQUFTNEIsYUFBYTlDLElBQUksRUFBRUcsTUFBTSxFQUFFQyxLQUFLO1lBQ3ZDLElBQUlKLFFBQVEsUUFBUTtnQkFDbEJJLE1BQU1lLE9BQU8sR0FBR2hCLE9BQU82QyxPQUFPO2dCQUM5Qi9DLFdBQVc7Z0JBQ1gsT0FBT2dEO1lBQ1QsT0FBTyxJQUFJckQsT0FBT0wsbUJBQW1CLElBQUlTLFFBQVEsVUFBVTtnQkFDekRDLFdBQVc7Z0JBQ1gsT0FBT2dELFVBQVVqRCxNQUFNRyxRQUFRQztZQUNqQyxPQUFPO2dCQUNMSCxXQUFXO2dCQUNYLE9BQU82QztZQUNUO1FBQ0Y7UUFDQSxTQUFTQyxrQkFBa0IvQyxJQUFJLEVBQUVHLE1BQU0sRUFBRUMsS0FBSztZQUM1QyxJQUFJSixRQUFRLFFBQVE7Z0JBQ2xCLElBQUltQixVQUFVaEIsT0FBTzZDLE9BQU87Z0JBQzVCLElBQUk1QyxNQUFNaUMsT0FBTyxJQUFJakMsTUFBTWlDLE9BQU8sQ0FBQ2xCLE9BQU8sSUFBSUEsV0FDMUN2QixPQUFPWixnQkFBZ0IsQ0FBQ3dELGNBQWMsQ0FBQ1IsTUFBTTVCLE1BQU1pQyxPQUFPLENBQUNsQixPQUFPLElBQ3BFdUIsV0FBV3RDO2dCQUNiLElBQUksTUFBT2lDLE9BQU8sSUFBSWpDLE1BQU1pQyxPQUFPLENBQUNsQixPQUFPLElBQUlBLFdBQVl2QixPQUFPc0QsWUFBWSxLQUFLLE9BQU87b0JBQ3hGakQsV0FBVztvQkFDWCxPQUFPa0Q7Z0JBQ1QsT0FBTztvQkFDTGxELFdBQVc7b0JBQ1gsT0FBT21EO2dCQUNUO1lBQ0YsT0FBTyxJQUFJeEQsT0FBT0wsbUJBQW1CLElBQUlTLFFBQVEsVUFBVTtnQkFDekRDLFdBQVc7Z0JBQ1gsT0FBT2tELFdBQVduRCxNQUFNRyxRQUFRQztZQUNsQyxPQUFPO2dCQUNMSCxXQUFXO2dCQUNYLE9BQU9tRDtZQUNUO1FBQ0Y7UUFFQSxTQUFTRCxXQUFXbkQsSUFBSSxFQUFFcUQsT0FBTyxFQUFFakQsS0FBSztZQUN0QyxJQUFJSixRQUFRLFVBQVU7Z0JBQ3BCQyxXQUFXO2dCQUNYLE9BQU9rRDtZQUNUO1lBQ0FULFdBQVd0QztZQUNYLE9BQU9jO1FBQ1Q7UUFDQSxTQUFTa0MsY0FBY3BELElBQUksRUFBRUcsTUFBTSxFQUFFQyxLQUFLO1lBQ3hDSCxXQUFXO1lBQ1gsT0FBT2tELFdBQVduRCxNQUFNRyxRQUFRQztRQUNsQztRQUVBLFNBQVM2QyxVQUFVakQsSUFBSSxFQUFFcUQsT0FBTyxFQUFFakQsS0FBSztZQUNyQyxJQUFJSixRQUFRLFFBQVE7Z0JBQ2xCQyxXQUFXO2dCQUNYLE9BQU9xRDtZQUNULE9BQU8sSUFBSXRELFFBQVEsWUFBWUEsUUFBUSxnQkFBZ0I7Z0JBQ3JELElBQUltQixVQUFVZixNQUFNZSxPQUFPLEVBQUVDLFdBQVdoQixNQUFNZ0IsUUFBUTtnQkFDdERoQixNQUFNZSxPQUFPLEdBQUdmLE1BQU1nQixRQUFRLEdBQUc7Z0JBQ2pDLElBQUlwQixRQUFRLGtCQUNSSixPQUFPYixlQUFlLENBQUN5RCxjQUFjLENBQUNSLE1BQU1iLFdBQVc7b0JBQ3pEd0IsZ0JBQWdCdkMsT0FBT2U7Z0JBQ3pCLE9BQU87b0JBQ0x3QixnQkFBZ0J2QyxPQUFPZTtvQkFDdkJmLE1BQU1pQyxPQUFPLEdBQUcsSUFBSUgsUUFBUTlCLE9BQU9lLFNBQVNDLFlBQVloQixNQUFNbUMsUUFBUTtnQkFDeEU7Z0JBQ0EsT0FBT3JCO1lBQ1Q7WUFDQWpCLFdBQVc7WUFDWCxPQUFPZ0Q7UUFDVDtRQUNBLFNBQVNLLFlBQVl0RCxJQUFJLEVBQUVHLE1BQU0sRUFBRUMsS0FBSztZQUN0QyxJQUFJSixRQUFRLFVBQVUsT0FBT3VEO1lBQzdCLElBQUksQ0FBQzNELE9BQU9SLFlBQVksRUFBRWEsV0FBVztZQUNyQyxPQUFPZ0QsVUFBVWpELE1BQU1HLFFBQVFDO1FBQ2pDO1FBQ0EsU0FBU21ELGVBQWV2RCxJQUFJLEVBQUVHLE1BQU0sRUFBRUMsS0FBSztZQUN6QyxJQUFJSixRQUFRLFVBQVUsT0FBT3dEO1lBQzdCLElBQUl4RCxRQUFRLFVBQVVKLE9BQU9ULGFBQWEsRUFBRTtnQkFBQ2MsV0FBVztnQkFBVSxPQUFPZ0Q7WUFBVTtZQUNuRmhELFdBQVc7WUFDWCxPQUFPZ0QsVUFBVWpELE1BQU1HLFFBQVFDO1FBQ2pDO1FBQ0EsU0FBU29ELG1CQUFtQnhELElBQUksRUFBRUcsTUFBTSxFQUFFQyxLQUFLO1lBQzdDLElBQUlKLFFBQVEsVUFBVSxPQUFPd0Q7WUFDN0IsT0FBT1AsVUFBVWpELE1BQU1HLFFBQVFDO1FBQ2pDO1FBRUEsT0FBTztZQUNMcUQsWUFBWSxTQUFTQyxVQUFVO2dCQUM3QixJQUFJdEQsUUFBUTtvQkFBQ0csVUFBVUw7b0JBQ1ZFLE9BQU9jO29CQUNQcUIsVUFBVW1CLGNBQWM7b0JBQ3hCdkMsU0FBUztvQkFBTUMsVUFBVTtvQkFDekJpQixTQUFTO2dCQUFJO2dCQUMxQixJQUFJcUIsY0FBYyxNQUFNdEQsTUFBTXNELFVBQVUsR0FBR0E7Z0JBQzNDLE9BQU90RDtZQUNUO1lBRUF1RCxPQUFPLFNBQVN4RCxNQUFNLEVBQUVDLEtBQUs7Z0JBQzNCLElBQUksQ0FBQ0EsTUFBTWUsT0FBTyxJQUFJaEIsT0FBT3lELEdBQUcsSUFDOUJ4RCxNQUFNbUMsUUFBUSxHQUFHcEMsT0FBTzBELFdBQVc7Z0JBRXJDLElBQUkxRCxPQUFPMkQsUUFBUSxJQUFJLE9BQU87Z0JBQzlCOUQsT0FBTztnQkFDUCxJQUFJNkIsUUFBUXpCLE1BQU1HLFFBQVEsQ0FBQ0osUUFBUUM7Z0JBQ25DLElBQUksQ0FBQ3lCLFNBQVM3QixJQUFHLEtBQU02QixTQUFTLFdBQVc7b0JBQ3pDNUIsV0FBVztvQkFDWEcsTUFBTUEsS0FBSyxHQUFHQSxNQUFNQSxLQUFLLENBQUNKLFFBQVE2QixPQUFPMUIsUUFBUUM7b0JBQ2pELElBQUlILFVBQ0Y0QixRQUFRNUIsWUFBWSxVQUFVNEIsUUFBUSxXQUFXNUI7Z0JBQ3JEO2dCQUNBLE9BQU80QjtZQUNUO1lBRUFTLFFBQVEsU0FBU2xDLEtBQUssRUFBRTJELFNBQVMsRUFBRUMsUUFBUTtnQkFDekMsSUFBSTNCLFVBQVVqQyxNQUFNaUMsT0FBTztnQkFDM0Isd0NBQXdDO2dCQUN4QyxJQUFJakMsTUFBTUcsUUFBUSxDQUFDcUIsYUFBYSxFQUFFO29CQUNoQyxJQUFJeEIsTUFBTWdCLFFBQVEsSUFBSWhCLE1BQU1tQyxRQUFRLEVBQ2xDLE9BQU9uQyxNQUFNbUIsY0FBYyxHQUFHO3lCQUU5QixPQUFPbkIsTUFBTW1DLFFBQVEsR0FBRzVDO2dCQUM1QjtnQkFDQSxJQUFJMEMsV0FBV0EsUUFBUUksUUFBUSxFQUFFLE9BQU81RCxZQUFXb0YsSUFBSTtnQkFDdkQsSUFBSTdELE1BQU1HLFFBQVEsSUFBSVEsU0FBU1gsTUFBTUcsUUFBUSxJQUFJTCxRQUMvQyxPQUFPOEQsV0FBV0EsU0FBU3JELEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDdUQsTUFBTSxHQUFHO2dCQUN6RCx3Q0FBd0M7Z0JBQ3hDLElBQUk5RCxNQUFNZSxPQUFPLEVBQUU7b0JBQ2pCLElBQUl2QixPQUFPdUUseUJBQXlCLEtBQUssT0FDdkMsT0FBTy9ELE1BQU1nQixRQUFRLEdBQUdoQixNQUFNZSxPQUFPLENBQUMrQyxNQUFNLEdBQUc7eUJBRS9DLE9BQU85RCxNQUFNZ0IsUUFBUSxHQUFHekIsYUFBY0MsQ0FBQUEsT0FBT3dFLHdCQUF3QixJQUFJO2dCQUM3RTtnQkFDQSxJQUFJeEUsT0FBT3lFLFVBQVUsSUFBSSxjQUFjaEQsSUFBSSxDQUFDMEMsWUFBWSxPQUFPO2dCQUMvRCxJQUFJTyxXQUFXUCxhQUFhLHNCQUFzQlEsSUFBSSxDQUFDUjtnQkFDdkQsSUFBSU8sWUFBWUEsUUFBUSxDQUFDLEVBQUUsRUFBRTtvQkFDM0IsTUFBT2pDLFFBQVM7d0JBQ2QsSUFBSUEsUUFBUWxCLE9BQU8sSUFBSW1ELFFBQVEsQ0FBQyxFQUFFLEVBQUU7NEJBQ2xDakMsVUFBVUEsUUFBUUQsSUFBSTs0QkFDdEI7d0JBQ0YsT0FBTyxJQUFJeEMsT0FBT1osZ0JBQWdCLENBQUN3RCxjQUFjLENBQUNSLE1BQU1LLFFBQVFsQixPQUFPLElBQUk7NEJBQ3pFa0IsVUFBVUEsUUFBUUQsSUFBSTt3QkFDeEIsT0FBTzs0QkFDTDt3QkFDRjtvQkFDRjtnQkFDRixPQUFPLElBQUlrQyxVQUFVO29CQUNuQixNQUFPakMsUUFBUzt3QkFDZCxJQUFJbUMsV0FBVzVFLE9BQU9YLGVBQWUsQ0FBQytDLE1BQU1LLFFBQVFsQixPQUFPLEVBQUU7d0JBQzdELElBQUlxRCxZQUFZQSxTQUFTaEMsY0FBYyxDQUFDUixNQUFNc0MsUUFBUSxDQUFDLEVBQUUsSUFDdkRqQyxVQUFVQSxRQUFRRCxJQUFJOzZCQUV0QjtvQkFDSjtnQkFDRjtnQkFDQSxNQUFPQyxXQUFXQSxRQUFRRCxJQUFJLElBQUksQ0FBQ0MsUUFBUUYsV0FBVyxDQUNwREUsVUFBVUEsUUFBUUQsSUFBSTtnQkFDeEIsSUFBSUMsU0FBUyxPQUFPQSxRQUFRQyxNQUFNLEdBQUczQztxQkFDaEMsT0FBT1MsTUFBTXNELFVBQVUsSUFBSTtZQUNsQztZQUVBZSxlQUFlO1lBQ2ZDLG1CQUFtQjtZQUNuQkMsaUJBQWlCO1lBRWpCQyxlQUFlaEYsT0FBT0UsUUFBUSxHQUFHLFNBQVM7WUFDMUMrRSxZQUFZakYsT0FBT0UsUUFBUSxHQUFHLFNBQVM7WUFFdkNnRixlQUFlLFNBQVMxRSxLQUFLO2dCQUMzQixJQUFJQSxNQUFNQSxLQUFLLElBQUltRCxnQkFDakJuRCxNQUFNQSxLQUFLLEdBQUc2QztZQUNsQjtZQUVBOEIsZUFBZSxTQUFTM0UsS0FBSztnQkFDM0IsT0FBT0EsTUFBTWUsT0FBTyxHQUFHO29CQUFDNkQsTUFBTTVFLE1BQU1lLE9BQU87b0JBQUU4RCxPQUFPN0UsTUFBTUosSUFBSSxJQUFJO2dCQUFVLElBQUk7WUFDbEY7WUFFQWtGLG1CQUFtQixTQUFTOUUsS0FBSztnQkFDL0IsSUFBSWlDLFVBQVUsRUFBRTtnQkFDaEIsSUFBSyxJQUFJOEMsS0FBSy9FLE1BQU1pQyxPQUFPLEVBQUU4QyxJQUFJQSxLQUFLQSxHQUFHL0MsSUFBSSxDQUMzQ0MsUUFBUStDLElBQUksQ0FBQ0QsR0FBR2hFLE9BQU87Z0JBQ3pCLE9BQU9rQixRQUFRZ0QsT0FBTztZQUN4QjtRQUNGO0lBQ0Y7SUFFQXhHLFlBQVd5RyxVQUFVLENBQUMsWUFBWTtJQUNsQ3pHLFlBQVd5RyxVQUFVLENBQUMsbUJBQW1CO0lBQ3pDLElBQUksQ0FBQ3pHLFlBQVcwRyxTQUFTLENBQUMvQyxjQUFjLENBQUMsY0FDdkMzRCxZQUFXeUcsVUFBVSxDQUFDLGFBQWE7UUFBQ04sTUFBTTtRQUFPbEYsVUFBVTtJQUFJO0FBRWpFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qcz80ZGU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC81L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaHRtbENvbmZpZyA9IHtcbiAgYXV0b1NlbGZDbG9zZXJzOiB7J2FyZWEnOiB0cnVlLCAnYmFzZSc6IHRydWUsICdicic6IHRydWUsICdjb2wnOiB0cnVlLCAnY29tbWFuZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdlbWJlZCc6IHRydWUsICdmcmFtZSc6IHRydWUsICdocic6IHRydWUsICdpbWcnOiB0cnVlLCAnaW5wdXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAna2V5Z2VuJzogdHJ1ZSwgJ2xpbmsnOiB0cnVlLCAnbWV0YSc6IHRydWUsICdwYXJhbSc6IHRydWUsICdzb3VyY2UnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndHJhY2snOiB0cnVlLCAnd2JyJzogdHJ1ZSwgJ21lbnVpdGVtJzogdHJ1ZX0sXG4gIGltcGxpY2l0bHlDbG9zZWQ6IHsnZGQnOiB0cnVlLCAnbGknOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlLCAnb3B0aW9uJzogdHJ1ZSwgJ3AnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgJ3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZSwgJ3Rib2R5JzogdHJ1ZSwgJ3RkJzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICd0aCc6IHRydWUsICd0cic6IHRydWV9LFxuICBjb250ZXh0R3JhYmJlcnM6IHtcbiAgICAnZGQnOiB7J2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZX0sXG4gICAgJ2R0JzogeydkZCc6IHRydWUsICdkdCc6IHRydWV9LFxuICAgICdsaSc6IHsnbGknOiB0cnVlfSxcbiAgICAnb3B0aW9uJzogeydvcHRpb24nOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlfSxcbiAgICAnb3B0Z3JvdXAnOiB7J29wdGdyb3VwJzogdHJ1ZX0sXG4gICAgJ3AnOiB7J2FkZHJlc3MnOiB0cnVlLCAnYXJ0aWNsZSc6IHRydWUsICdhc2lkZSc6IHRydWUsICdibG9ja3F1b3RlJzogdHJ1ZSwgJ2Rpcic6IHRydWUsXG4gICAgICAgICAgJ2Rpdic6IHRydWUsICdkbCc6IHRydWUsICdmaWVsZHNldCc6IHRydWUsICdmb290ZXInOiB0cnVlLCAnZm9ybSc6IHRydWUsXG4gICAgICAgICAgJ2gxJzogdHJ1ZSwgJ2gyJzogdHJ1ZSwgJ2gzJzogdHJ1ZSwgJ2g0JzogdHJ1ZSwgJ2g1JzogdHJ1ZSwgJ2g2JzogdHJ1ZSxcbiAgICAgICAgICAnaGVhZGVyJzogdHJ1ZSwgJ2hncm91cCc6IHRydWUsICdocic6IHRydWUsICdtZW51JzogdHJ1ZSwgJ25hdic6IHRydWUsICdvbCc6IHRydWUsXG4gICAgICAgICAgJ3AnOiB0cnVlLCAncHJlJzogdHJ1ZSwgJ3NlY3Rpb24nOiB0cnVlLCAndGFibGUnOiB0cnVlLCAndWwnOiB0cnVlfSxcbiAgICAncnAnOiB7J3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZX0sXG4gICAgJ3J0JzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxuICAgICd0Ym9keSc6IHsndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlfSxcbiAgICAndGQnOiB7J3RkJzogdHJ1ZSwgJ3RoJzogdHJ1ZX0sXG4gICAgJ3Rmb290Jzogeyd0Ym9keSc6IHRydWV9LFxuICAgICd0aCc6IHsndGQnOiB0cnVlLCAndGgnOiB0cnVlfSxcbiAgICAndGhlYWQnOiB7J3Rib2R5JzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZX0sXG4gICAgJ3RyJzogeyd0cic6IHRydWV9XG4gIH0sXG4gIGRvTm90SW5kZW50OiB7XCJwcmVcIjogdHJ1ZX0sXG4gIGFsbG93VW5xdW90ZWQ6IHRydWUsXG4gIGFsbG93TWlzc2luZzogdHJ1ZSxcbiAgY2FzZUZvbGQ6IHRydWVcbn1cblxudmFyIHhtbENvbmZpZyA9IHtcbiAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcbiAgaW1wbGljaXRseUNsb3NlZDoge30sXG4gIGNvbnRleHRHcmFiYmVyczoge30sXG4gIGRvTm90SW5kZW50OiB7fSxcbiAgYWxsb3dVbnF1b3RlZDogZmFsc2UsXG4gIGFsbG93TWlzc2luZzogZmFsc2UsXG4gIGFsbG93TWlzc2luZ1RhZ05hbWU6IGZhbHNlLFxuICBjYXNlRm9sZDogZmFsc2Vcbn1cblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwieG1sXCIsIGZ1bmN0aW9uKGVkaXRvckNvbmYsIGNvbmZpZ18pIHtcbiAgdmFyIGluZGVudFVuaXQgPSBlZGl0b3JDb25mLmluZGVudFVuaXRcbiAgdmFyIGNvbmZpZyA9IHt9XG4gIHZhciBkZWZhdWx0cyA9IGNvbmZpZ18uaHRtbE1vZGUgPyBodG1sQ29uZmlnIDogeG1sQ29uZmlnXG4gIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdHMpIGNvbmZpZ1twcm9wXSA9IGRlZmF1bHRzW3Byb3BdXG4gIGZvciAodmFyIHByb3AgaW4gY29uZmlnXykgY29uZmlnW3Byb3BdID0gY29uZmlnX1twcm9wXVxuXG4gIC8vIFJldHVybiB2YXJpYWJsZXMgZm9yIHRva2VuaXplcnNcbiAgdmFyIHR5cGUsIHNldFN0eWxlO1xuXG4gIGZ1bmN0aW9uIGluVGV4dChzdHJlYW0sIHN0YXRlKSB7XG4gICAgZnVuY3Rpb24gY2hhaW4ocGFyc2VyKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcbiAgICAgIHJldHVybiBwYXJzZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiIVwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIltcIikpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiQ0RBVEFbXCIpKSByZXR1cm4gY2hhaW4oaW5CbG9jayhcImF0b21cIiwgXCJdXT5cIikpO1xuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiLS1cIikpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcImNvbW1lbnRcIiwgXCItLT5cIikpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcIkRPQ1RZUEVcIiwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pO1xuICAgICAgICAgIHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluQmxvY2soXCJtZXRhXCIsIFwiPz5cIik7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBzdHJlYW0uZWF0KFwiL1wiKSA/IFwiY2xvc2VUYWdcIiA6IFwib3BlblRhZ1wiO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGFnO1xuICAgICAgICByZXR1cm4gXCJ0YWcgYnJhY2tldFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCImXCIpIHtcbiAgICAgIHZhciBvaztcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiI1wiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcInhcIikpIHtcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW2EtZkEtRlxcZF0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcZF0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5cXC06XS8pICYmIHN0cmVhbS5lYXQoXCI7XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9rID8gXCJhdG9tXCIgOiBcImVycm9yXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14mPF0vKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpblRleHQuaXNJblRleHQgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIGluVGFnKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIj5cIiB8fCAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgIHR5cGUgPSBjaCA9PSBcIj5cIiA/IFwiZW5kVGFnXCIgOiBcInNlbGZjbG9zZVRhZ1wiO1xuICAgICAgcmV0dXJuIFwidGFnIGJyYWNrZXRcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiPVwiKSB7XG4gICAgICB0eXBlID0gXCJlcXVhbHNcIjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgc3RhdGUuc3RhdGUgPSBiYXNlU3RhdGU7XG4gICAgICBzdGF0ZS50YWdOYW1lID0gc3RhdGUudGFnU3RhcnQgPSBudWxsO1xuICAgICAgdmFyIG5leHQgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHJldHVybiBuZXh0ID8gbmV4dCArIFwiIHRhZyBlcnJvclwiIDogXCJ0YWcgZXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKC9bXFwnXFxcIl0vLnRlc3QoY2gpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGluQXR0cmlidXRlKGNoKTtcbiAgICAgIHN0YXRlLnN0cmluZ1N0YXJ0Q29sID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcc1xcdTAwYTA9PD5cXFwiXFwnXSpbXlxcc1xcdTAwYTA9PD5cXFwiXFwnXFwvXS8pO1xuICAgICAgcmV0dXJuIFwid29yZFwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluQXR0cmlidXRlKHF1b3RlKSB7XG4gICAgdmFyIGNsb3N1cmUgPSBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQoKSA9PSBxdW90ZSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gICAgY2xvc3VyZS5pc0luQXR0cmlidXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xvc3VyZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluQmxvY2soc3R5bGUsIHRlcm1pbmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCh0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9jdHlwZShkZXB0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2g7XG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggKyAxKTtcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI+XCIpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPT0gMSkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBkb2N0eXBlKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvd2VyKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gdGFnTmFtZSAmJiB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCBzdGFydE9mTGluZSkge1xuICAgIHRoaXMucHJldiA9IHN0YXRlLmNvbnRleHQ7XG4gICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZSB8fCBcIlwiO1xuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgdGhpcy5zdGFydE9mTGluZSA9IHN0YXJ0T2ZMaW5lO1xuICAgIGlmIChjb25maWcuZG9Ob3RJbmRlbnQuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgfHwgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC5ub0luZGVudCkpXG4gICAgICB0aGlzLm5vSW5kZW50ID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVQb3BDb250ZXh0KHN0YXRlLCBuZXh0VGFnTmFtZSkge1xuICAgIHZhciBwYXJlbnRUYWdOYW1lO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIXN0YXRlLmNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50VGFnTmFtZSA9IHN0YXRlLmNvbnRleHQudGFnTmFtZTtcbiAgICAgIGlmICghY29uZmlnLmNvbnRleHRHcmFiYmVycy5oYXNPd25Qcm9wZXJ0eShsb3dlcihwYXJlbnRUYWdOYW1lKSkgfHxcbiAgICAgICAgICAhY29uZmlnLmNvbnRleHRHcmFiYmVyc1tsb3dlcihwYXJlbnRUYWdOYW1lKV0uaGFzT3duUHJvcGVydHkobG93ZXIobmV4dFRhZ05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwib3BlblRhZ1wiKSB7XG4gICAgICBzdGF0ZS50YWdTdGFydCA9IHN0cmVhbS5jb2x1bW4oKTtcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiY2xvc2VUYWdcIikge1xuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZVN0YXRlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0YWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBzdGF0ZS50YWdOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHNldFN0eWxlID0gXCJ0YWdcIjtcbiAgICAgIHJldHVybiBhdHRyU3RhdGU7XG4gICAgfSBlbHNlIGlmIChjb25maWcuYWxsb3dNaXNzaW5nVGFnTmFtZSAmJiB0eXBlID09IFwiZW5kVGFnXCIpIHtcbiAgICAgIHNldFN0eWxlID0gXCJ0YWcgYnJhY2tldFwiO1xuICAgICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICByZXR1cm4gdGFnTmFtZVN0YXRlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbG9zZVRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudGFnTmFtZSAhPSB0YWdOYW1lICYmXG4gICAgICAgICAgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkobG93ZXIoc3RhdGUuY29udGV4dC50YWdOYW1lKSkpXG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgaWYgKChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudGFnTmFtZSA9PSB0YWdOYW1lKSB8fCBjb25maWcubWF0Y2hDbG9zaW5nID09PSBmYWxzZSkge1xuICAgICAgICBzZXRTdHlsZSA9IFwidGFnXCI7XG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3R5bGUgPSBcInRhZyBlcnJvclwiO1xuICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZUVycjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5hbGxvd01pc3NpbmdUYWdOYW1lICYmIHR5cGUgPT0gXCJlbmRUYWdcIikge1xuICAgICAgc2V0U3R5bGUgPSBcInRhZyBicmFja2V0XCI7XG4gICAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICByZXR1cm4gY2xvc2VTdGF0ZUVycjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVN0YXRlKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCJlbmRUYWdcIikge1xuICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICByZXR1cm4gY2xvc2VTdGF0ZTtcbiAgICB9XG4gICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgcmV0dXJuIGJhc2VTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJTdGF0ZSh0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBzZXRTdHlsZSA9IFwiYXR0cmlidXRlXCI7XG4gICAgICByZXR1cm4gYXR0ckVxU3RhdGU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiZW5kVGFnXCIgfHwgdHlwZSA9PSBcInNlbGZjbG9zZVRhZ1wiKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsIHRhZ1N0YXJ0ID0gc3RhdGUudGFnU3RhcnQ7XG4gICAgICBzdGF0ZS50YWdOYW1lID0gc3RhdGUudGFnU3RhcnQgPSBudWxsO1xuICAgICAgaWYgKHR5cGUgPT0gXCJzZWxmY2xvc2VUYWdcIiB8fFxuICAgICAgICAgIGNvbmZpZy5hdXRvU2VsZkNsb3NlcnMuaGFzT3duUHJvcGVydHkobG93ZXIodGFnTmFtZSkpKSB7XG4gICAgICAgIG1heWJlUG9wQ29udGV4dChzdGF0ZSwgdGFnTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xuICAgICAgICBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoc3RhdGUsIHRhZ05hbWUsIHRhZ1N0YXJ0ID09IHN0YXRlLmluZGVudGVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XG4gICAgfVxuICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBhdHRyU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gYXR0ckVxU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiZXF1YWxzXCIpIHJldHVybiBhdHRyVmFsdWVTdGF0ZTtcbiAgICBpZiAoIWNvbmZpZy5hbGxvd01pc3NpbmcpIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYXR0clZhbHVlU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIgJiYgY29uZmlnLmFsbG93VW5xdW90ZWQpIHtzZXRTdHlsZSA9IFwic3RyaW5nXCI7IHJldHVybiBhdHRyU3RhdGU7fVxuICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYXR0ckNvbnRpbnVlZFN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gYXR0ckNvbnRpbnVlZFN0YXRlO1xuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2VJbmRlbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHt0b2tlbml6ZTogaW5UZXh0LFxuICAgICAgICAgICAgICAgICAgIHN0YXRlOiBiYXNlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgaW5kZW50ZWQ6IGJhc2VJbmRlbnQgfHwgMCxcbiAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBudWxsLCB0YWdTdGFydDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBudWxsfVxuICAgICAgaWYgKGJhc2VJbmRlbnQgIT0gbnVsbCkgc3RhdGUuYmFzZUluZGVudCA9IGJhc2VJbmRlbnRcbiAgICAgIHJldHVybiBzdGF0ZVxuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdGF0ZS50YWdOYW1lICYmIHN0cmVhbS5zb2woKSlcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcblxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoKHN0eWxlIHx8IHR5cGUpICYmIHN0eWxlICE9IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHNldFN0eWxlID0gbnVsbDtcbiAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZS5zdGF0ZSh0eXBlIHx8IHN0eWxlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHNldFN0eWxlKVxuICAgICAgICAgIHN0eWxlID0gc2V0U3R5bGUgPT0gXCJlcnJvclwiID8gc3R5bGUgKyBcIiBlcnJvclwiIDogc2V0U3R5bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgZnVsbExpbmUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIC8vIEluZGVudCBtdWx0aS1saW5lIHN0cmluZ3MgKGUuZy4gY3NzKS5cbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZS5pc0luQXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS50YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZClcbiAgICAgICAgICByZXR1cm4gc3RhdGUuc3RyaW5nU3RhcnRDb2wgKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkICsgaW5kZW50VW5pdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQubm9JbmRlbnQpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gaW5UYWcgJiYgc3RhdGUudG9rZW5pemUgIT0gaW5UZXh0KVxuICAgICAgICByZXR1cm4gZnVsbExpbmUgPyBmdWxsTGluZS5tYXRjaCgvXihcXHMqKS8pWzBdLmxlbmd0aCA6IDA7XG4gICAgICAvLyBJbmRlbnQgdGhlIHN0YXJ0cyBvZiBhdHRyaWJ1dGUgbmFtZXMuXG4gICAgICBpZiAoc3RhdGUudGFnTmFtZSkge1xuICAgICAgICBpZiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcgIT09IGZhbHNlKVxuICAgICAgICAgIHJldHVybiBzdGF0ZS50YWdTdGFydCArIHN0YXRlLnRhZ05hbWUubGVuZ3RoICsgMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBzdGF0ZS50YWdTdGFydCArIGluZGVudFVuaXQgKiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudEZhY3RvciB8fCAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcuYWxpZ25DREFUQSAmJiAvPCFcXFtDREFUQVxcWy8udGVzdCh0ZXh0QWZ0ZXIpKSByZXR1cm4gMDtcbiAgICAgIHZhciB0YWdBZnRlciA9IHRleHRBZnRlciAmJiAvXjwoXFwvKT8oW1xcd186XFwuLV0qKS8uZXhlYyh0ZXh0QWZ0ZXIpO1xuICAgICAgaWYgKHRhZ0FmdGVyICYmIHRhZ0FmdGVyWzFdKSB7IC8vIENsb3NpbmcgdGFnIHNwb3R0ZWRcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC50YWdOYW1lID09IHRhZ0FmdGVyWzJdKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuaW1wbGljaXRseUNsb3NlZC5oYXNPd25Qcm9wZXJ0eShsb3dlcihjb250ZXh0LnRhZ05hbWUpKSkge1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhZ0FmdGVyKSB7IC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgZ3JhYmJlcnMgPSBjb25maWcuY29udGV4dEdyYWJiZXJzW2xvd2VyKGNvbnRleHQudGFnTmFtZSldO1xuICAgICAgICAgIGlmIChncmFiYmVycyAmJiBncmFiYmVycy5oYXNPd25Qcm9wZXJ0eShsb3dlcih0YWdBZnRlclsyXSkpKVxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGNvbnRleHQgJiYgY29udGV4dC5wcmV2ICYmICFjb250ZXh0LnN0YXJ0T2ZMaW5lKVxuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XG4gICAgICBlbHNlIHJldHVybiBzdGF0ZS5iYXNlSW5kZW50IHx8IDA7XG4gICAgfSxcblxuICAgIGVsZWN0cmljSW5wdXQ6IC88XFwvW1xcc1xcdzpdKz4kLyxcbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCI8IS0tXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIi0tPlwiLFxuXG4gICAgY29uZmlndXJhdGlvbjogY29uZmlnLmh0bWxNb2RlID8gXCJodG1sXCIgOiBcInhtbFwiLFxuICAgIGhlbHBlclR5cGU6IGNvbmZpZy5odG1sTW9kZSA/IFwiaHRtbFwiIDogXCJ4bWxcIixcblxuICAgIHNraXBBdHRyaWJ1dGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gYXR0clZhbHVlU3RhdGUpXG4gICAgICAgIHN0YXRlLnN0YXRlID0gYXR0clN0YXRlXG4gICAgfSxcblxuICAgIHhtbEN1cnJlbnRUYWc6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUudGFnTmFtZSA/IHtuYW1lOiBzdGF0ZS50YWdOYW1lLCBjbG9zZTogc3RhdGUudHlwZSA9PSBcImNsb3NlVGFnXCJ9IDogbnVsbFxuICAgIH0sXG5cbiAgICB4bWxDdXJyZW50Q29udGV4dDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gW11cbiAgICAgIGZvciAodmFyIGN4ID0gc3RhdGUuY29udGV4dDsgY3g7IGN4ID0gY3gucHJldilcbiAgICAgICAgY29udGV4dC5wdXNoKGN4LnRhZ05hbWUpXG4gICAgICByZXR1cm4gY29udGV4dC5yZXZlcnNlKClcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94bWxcIiwgXCJ4bWxcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94bWxcIiwgXCJ4bWxcIik7XG5pZiAoIUNvZGVNaXJyb3IubWltZU1vZGVzLmhhc093blByb3BlcnR5KFwidGV4dC9odG1sXCIpKVxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2h0bWxcIiwge25hbWU6IFwieG1sXCIsIGh0bWxNb2RlOiB0cnVlfSk7XG5cbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsImh0bWxDb25maWciLCJhdXRvU2VsZkNsb3NlcnMiLCJpbXBsaWNpdGx5Q2xvc2VkIiwiY29udGV4dEdyYWJiZXJzIiwiZG9Ob3RJbmRlbnQiLCJhbGxvd1VucXVvdGVkIiwiYWxsb3dNaXNzaW5nIiwiY2FzZUZvbGQiLCJ4bWxDb25maWciLCJhbGxvd01pc3NpbmdUYWdOYW1lIiwiZGVmaW5lTW9kZSIsImVkaXRvckNvbmYiLCJjb25maWdfIiwiaW5kZW50VW5pdCIsImNvbmZpZyIsImRlZmF1bHRzIiwiaHRtbE1vZGUiLCJwcm9wIiwidHlwZSIsInNldFN0eWxlIiwiaW5UZXh0Iiwic3RyZWFtIiwic3RhdGUiLCJjaGFpbiIsInBhcnNlciIsInRva2VuaXplIiwiY2giLCJuZXh0IiwiZWF0IiwibWF0Y2giLCJpbkJsb2NrIiwiZWF0V2hpbGUiLCJkb2N0eXBlIiwiaW5UYWciLCJvayIsImlzSW5UZXh0IiwiYmFzZVN0YXRlIiwidGFnTmFtZSIsInRhZ1N0YXJ0IiwidGVzdCIsImluQXR0cmlidXRlIiwic3RyaW5nU3RhcnRDb2wiLCJjb2x1bW4iLCJxdW90ZSIsImNsb3N1cmUiLCJlb2wiLCJpc0luQXR0cmlidXRlIiwic3R5bGUiLCJ0ZXJtaW5hdG9yIiwiZGVwdGgiLCJsb3dlciIsInRvTG93ZXJDYXNlIiwiQ29udGV4dCIsInN0YXJ0T2ZMaW5lIiwicHJldiIsImNvbnRleHQiLCJpbmRlbnQiLCJpbmRlbnRlZCIsImhhc093blByb3BlcnR5Iiwibm9JbmRlbnQiLCJwb3BDb250ZXh0IiwibWF5YmVQb3BDb250ZXh0IiwibmV4dFRhZ05hbWUiLCJwYXJlbnRUYWdOYW1lIiwidGFnTmFtZVN0YXRlIiwiY2xvc2VUYWdOYW1lU3RhdGUiLCJjdXJyZW50IiwiYXR0clN0YXRlIiwibWF0Y2hDbG9zaW5nIiwiY2xvc2VTdGF0ZSIsImNsb3NlU3RhdGVFcnIiLCJfc3RyZWFtIiwiYXR0ckVxU3RhdGUiLCJhdHRyVmFsdWVTdGF0ZSIsImF0dHJDb250aW51ZWRTdGF0ZSIsInN0YXJ0U3RhdGUiLCJiYXNlSW5kZW50IiwidG9rZW4iLCJzb2wiLCJpbmRlbnRhdGlvbiIsImVhdFNwYWNlIiwidGV4dEFmdGVyIiwiZnVsbExpbmUiLCJQYXNzIiwibGVuZ3RoIiwibXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZyIsIm11bHRpbGluZVRhZ0luZGVudEZhY3RvciIsImFsaWduQ0RBVEEiLCJ0YWdBZnRlciIsImV4ZWMiLCJncmFiYmVycyIsImVsZWN0cmljSW5wdXQiLCJibG9ja0NvbW1lbnRTdGFydCIsImJsb2NrQ29tbWVudEVuZCIsImNvbmZpZ3VyYXRpb24iLCJoZWxwZXJUeXBlIiwic2tpcEF0dHJpYnV0ZSIsInhtbEN1cnJlbnRUYWciLCJuYW1lIiwiY2xvc2UiLCJ4bWxDdXJyZW50Q29udGV4dCIsImN4IiwicHVzaCIsInJldmVyc2UiLCJkZWZpbmVNSU1FIiwibWltZU1vZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/codemirror/mode/xml/xml.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/easymde/src/js/codemirror/tablist.js":
/*!***********************************************************!*\
  !*** ./node_modules/easymde/src/js/codemirror/tablist.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\");\nCodeMirror.commands.tabAndIndentMarkdownList = function(cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n    if (inList) {\n        cm.execCommand(\"indentMore\");\n        return;\n    }\n    if (cm.options.indentWithTabs) {\n        cm.execCommand(\"insertTab\");\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(\" \");\n        cm.replaceSelection(spaces);\n    }\n};\nCodeMirror.commands.shiftTabAndUnindentMarkdownList = function(cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n    if (inList) {\n        cm.execCommand(\"indentLess\");\n        return;\n    }\n    if (cm.options.indentWithTabs) {\n        cm.execCommand(\"insertTab\");\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(\" \");\n        cm.replaceSelection(spaces);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lYXN5bWRlL3NyYy9qcy9jb2RlbWlycm9yL3RhYmxpc3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsMkRBQTJEO0FBQzNELGtFQUFrRTtBQUVsRSxJQUFJQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUV6QkQsV0FBV0UsUUFBUSxDQUFDQyx3QkFBd0IsR0FBRyxTQUFVQyxFQUFFO0lBQ3ZELElBQUlDLFNBQVNELEdBQUdFLGNBQWM7SUFDOUIsSUFBSUMsTUFBTUYsTUFBTSxDQUFDLEVBQUUsQ0FBQ0csSUFBSTtJQUN4QixJQUFJQyxXQUFXTCxHQUFHTSxhQUFhLENBQUNILElBQUlJLElBQUk7SUFDeEMsSUFBSUMsU0FBU0gsU0FBU0ksSUFBSSxLQUFLO0lBRS9CLElBQUlELFFBQVE7UUFDUlIsR0FBR1UsV0FBVyxDQUFDO1FBQ2Y7SUFDSjtJQUVBLElBQUlWLEdBQUdXLE9BQU8sQ0FBQ0MsY0FBYyxFQUFFO1FBQzNCWixHQUFHVSxXQUFXLENBQUM7SUFDbkIsT0FBTztRQUNILElBQUlHLFNBQVNDLE1BQU1kLEdBQUdXLE9BQU8sQ0FBQ0ksT0FBTyxHQUFHLEdBQUdDLElBQUksQ0FBQztRQUNoRGhCLEdBQUdpQixnQkFBZ0IsQ0FBQ0o7SUFDeEI7QUFDSjtBQUVBakIsV0FBV0UsUUFBUSxDQUFDb0IsK0JBQStCLEdBQUcsU0FBVWxCLEVBQUU7SUFDOUQsSUFBSUMsU0FBU0QsR0FBR0UsY0FBYztJQUM5QixJQUFJQyxNQUFNRixNQUFNLENBQUMsRUFBRSxDQUFDRyxJQUFJO0lBQ3hCLElBQUlDLFdBQVdMLEdBQUdNLGFBQWEsQ0FBQ0gsSUFBSUksSUFBSTtJQUN4QyxJQUFJQyxTQUFTSCxTQUFTSSxJQUFJLEtBQUs7SUFFL0IsSUFBSUQsUUFBUTtRQUNSUixHQUFHVSxXQUFXLENBQUM7UUFDZjtJQUNKO0lBRUEsSUFBSVYsR0FBR1csT0FBTyxDQUFDQyxjQUFjLEVBQUU7UUFDM0JaLEdBQUdVLFdBQVcsQ0FBQztJQUNuQixPQUFPO1FBQ0gsSUFBSUcsU0FBU0MsTUFBTWQsR0FBR1csT0FBTyxDQUFDSSxPQUFPLEdBQUcsR0FBR0MsSUFBSSxDQUFDO1FBQ2hEaEIsR0FBR2lCLGdCQUFnQixDQUFDSjtJQUN4QjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lYXN5bWRlL3NyYy9qcy9jb2RlbWlycm9yL3RhYmxpc3QuanM/MWEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHA6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbnZhciBDb2RlTWlycm9yID0gcmVxdWlyZSgnY29kZW1pcnJvcicpO1xuXG5Db2RlTWlycm9yLmNvbW1hbmRzLnRhYkFuZEluZGVudE1hcmtkb3duTGlzdCA9IGZ1bmN0aW9uIChjbSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIHZhciBwb3MgPSByYW5nZXNbMF0uaGVhZDtcbiAgICB2YXIgZW9sU3RhdGUgPSBjbS5nZXRTdGF0ZUFmdGVyKHBvcy5saW5lKTtcbiAgICB2YXIgaW5MaXN0ID0gZW9sU3RhdGUubGlzdCAhPT0gZmFsc2U7XG5cbiAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgIGNtLmV4ZWNDb21tYW5kKCdpbmRlbnRNb3JlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicykge1xuICAgICAgICBjbS5leGVjQ29tbWFuZCgnaW5zZXJ0VGFiJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNwYWNlcyA9IEFycmF5KGNtLm9wdGlvbnMudGFiU2l6ZSArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzcGFjZXMpO1xuICAgIH1cbn07XG5cbkNvZGVNaXJyb3IuY29tbWFuZHMuc2hpZnRUYWJBbmRVbmluZGVudE1hcmtkb3duTGlzdCA9IGZ1bmN0aW9uIChjbSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIHZhciBwb3MgPSByYW5nZXNbMF0uaGVhZDtcbiAgICB2YXIgZW9sU3RhdGUgPSBjbS5nZXRTdGF0ZUFmdGVyKHBvcy5saW5lKTtcbiAgICB2YXIgaW5MaXN0ID0gZW9sU3RhdGUubGlzdCAhPT0gZmFsc2U7XG5cbiAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgIGNtLmV4ZWNDb21tYW5kKCdpbmRlbnRMZXNzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicykge1xuICAgICAgICBjbS5leGVjQ29tbWFuZCgnaW5zZXJ0VGFiJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNwYWNlcyA9IEFycmF5KGNtLm9wdGlvbnMudGFiU2l6ZSArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzcGFjZXMpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiQ29kZU1pcnJvciIsInJlcXVpcmUiLCJjb21tYW5kcyIsInRhYkFuZEluZGVudE1hcmtkb3duTGlzdCIsImNtIiwicmFuZ2VzIiwibGlzdFNlbGVjdGlvbnMiLCJwb3MiLCJoZWFkIiwiZW9sU3RhdGUiLCJnZXRTdGF0ZUFmdGVyIiwibGluZSIsImluTGlzdCIsImxpc3QiLCJleGVjQ29tbWFuZCIsIm9wdGlvbnMiLCJpbmRlbnRXaXRoVGFicyIsInNwYWNlcyIsIkFycmF5IiwidGFiU2l6ZSIsImpvaW4iLCJyZXBsYWNlU2VsZWN0aW9uIiwic2hpZnRUYWJBbmRVbmluZGVudE1hcmtkb3duTGlzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/easymde/src/js/codemirror/tablist.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/easymde/src/js/easymde.js":
/*!************************************************!*\
  !*** ./node_modules/easymde/src/js/easymde.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(app-pages-browser)/./node_modules/codemirror/lib/codemirror.js\");\n__webpack_require__(/*! codemirror/addon/edit/continuelist.js */ \"(app-pages-browser)/./node_modules/codemirror/addon/edit/continuelist.js\");\n__webpack_require__(/*! ./codemirror/tablist */ \"(app-pages-browser)/./node_modules/easymde/src/js/codemirror/tablist.js\");\n__webpack_require__(/*! codemirror/addon/display/fullscreen.js */ \"(app-pages-browser)/./node_modules/codemirror/addon/display/fullscreen.js\");\n__webpack_require__(/*! codemirror/mode/markdown/markdown.js */ \"(app-pages-browser)/./node_modules/codemirror/mode/markdown/markdown.js\");\n__webpack_require__(/*! codemirror/addon/mode/overlay.js */ \"(app-pages-browser)/./node_modules/codemirror/addon/mode/overlay.js\");\n__webpack_require__(/*! codemirror/addon/display/placeholder.js */ \"(app-pages-browser)/./node_modules/codemirror/addon/display/placeholder.js\");\n__webpack_require__(/*! codemirror/addon/display/autorefresh.js */ \"(app-pages-browser)/./node_modules/codemirror/addon/display/autorefresh.js\");\n__webpack_require__(/*! codemirror/addon/selection/mark-selection.js */ \"(app-pages-browser)/./node_modules/codemirror/addon/selection/mark-selection.js\");\n__webpack_require__(/*! codemirror/addon/search/searchcursor.js */ \"(app-pages-browser)/./node_modules/codemirror/addon/search/searchcursor.js\");\n__webpack_require__(/*! codemirror/mode/gfm/gfm.js */ \"(app-pages-browser)/./node_modules/codemirror/mode/gfm/gfm.js\");\n__webpack_require__(/*! codemirror/mode/xml/xml.js */ \"(app-pages-browser)/./node_modules/codemirror/mode/xml/xml.js\");\nvar CodeMirrorSpellChecker = __webpack_require__(/*! codemirror-spell-checker */ \"(app-pages-browser)/./node_modules/codemirror-spell-checker/src/js/spell-checker.js\");\nvar marked = (__webpack_require__(/*! marked */ \"(app-pages-browser)/./node_modules/marked/lib/marked.cjs\").marked);\n// Some variables\nvar isMac = /Mac/.test(navigator.platform);\nvar anchorToExternalRegex = new RegExp(/(<a.*?https?:\\/\\/.*?[^a]>)+?/g);\n// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons\nvar bindings = {\n    \"toggleBold\": toggleBold,\n    \"toggleItalic\": toggleItalic,\n    \"drawLink\": drawLink,\n    \"toggleHeadingSmaller\": toggleHeadingSmaller,\n    \"toggleHeadingBigger\": toggleHeadingBigger,\n    \"drawImage\": drawImage,\n    \"toggleBlockquote\": toggleBlockquote,\n    \"toggleOrderedList\": toggleOrderedList,\n    \"toggleUnorderedList\": toggleUnorderedList,\n    \"toggleCodeBlock\": toggleCodeBlock,\n    \"togglePreview\": togglePreview,\n    \"toggleStrikethrough\": toggleStrikethrough,\n    \"toggleHeading1\": toggleHeading1,\n    \"toggleHeading2\": toggleHeading2,\n    \"toggleHeading3\": toggleHeading3,\n    \"toggleHeading4\": toggleHeading4,\n    \"toggleHeading5\": toggleHeading5,\n    \"toggleHeading6\": toggleHeading6,\n    \"cleanBlock\": cleanBlock,\n    \"drawTable\": drawTable,\n    \"drawHorizontalRule\": drawHorizontalRule,\n    \"undo\": undo,\n    \"redo\": redo,\n    \"toggleSideBySide\": toggleSideBySide,\n    \"toggleFullScreen\": toggleFullScreen\n};\nvar shortcuts = {\n    \"toggleBold\": \"Cmd-B\",\n    \"toggleItalic\": \"Cmd-I\",\n    \"drawLink\": \"Cmd-K\",\n    \"toggleHeadingSmaller\": \"Cmd-H\",\n    \"toggleHeadingBigger\": \"Shift-Cmd-H\",\n    \"toggleHeading1\": \"Ctrl+Alt+1\",\n    \"toggleHeading2\": \"Ctrl+Alt+2\",\n    \"toggleHeading3\": \"Ctrl+Alt+3\",\n    \"toggleHeading4\": \"Ctrl+Alt+4\",\n    \"toggleHeading5\": \"Ctrl+Alt+5\",\n    \"toggleHeading6\": \"Ctrl+Alt+6\",\n    \"cleanBlock\": \"Cmd-E\",\n    \"drawImage\": \"Cmd-Alt-I\",\n    \"toggleBlockquote\": \"Cmd-'\",\n    \"toggleOrderedList\": \"Cmd-Alt-L\",\n    \"toggleUnorderedList\": \"Cmd-L\",\n    \"toggleCodeBlock\": \"Cmd-Alt-C\",\n    \"togglePreview\": \"Cmd-P\",\n    \"toggleSideBySide\": \"F9\",\n    \"toggleFullScreen\": \"F11\"\n};\nvar getBindingName = function(f) {\n    for(var key in bindings){\n        if (bindings[key] === f) {\n            return key;\n        }\n    }\n    return null;\n};\nvar isMobile = function() {\n    var check = false;\n    (function(a) {\n        if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a.substr(0, 4))) check = true;\n    })(navigator.userAgent || navigator.vendor || window.opera);\n    return check;\n};\n/**\n * Modify HTML to add 'target=\"_blank\"' to links so they open in new tabs by default.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */ function addAnchorTargetBlank(htmlText) {\n    var match;\n    while((match = anchorToExternalRegex.exec(htmlText)) !== null){\n        // With only one capture group in the RegExp, we can safely take the first index from the match.\n        var linkString = match[0];\n        if (linkString.indexOf(\"target=\") === -1) {\n            var fixedLinkString = linkString.replace(/>$/, ' target=\"_blank\">');\n            htmlText = htmlText.replace(linkString, fixedLinkString);\n        }\n    }\n    return htmlText;\n}\n/**\n * Modify HTML to remove the list-style when rendering checkboxes.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */ function removeListStyleWhenCheckbox(htmlText) {\n    var parser = new DOMParser();\n    var htmlDoc = parser.parseFromString(htmlText, \"text/html\");\n    var listItems = htmlDoc.getElementsByTagName(\"li\");\n    for(var i = 0; i < listItems.length; i++){\n        var listItem = listItems[i];\n        for(var j = 0; j < listItem.children.length; j++){\n            var listItemChild = listItem.children[j];\n            if (listItemChild instanceof HTMLInputElement && listItemChild.type === \"checkbox\") {\n                // From Github: margin: 0 .2em .25em -1.6em;\n                listItem.style.marginLeft = \"-1.5em\";\n                listItem.style.listStyleType = \"none\";\n            }\n        }\n    }\n    return htmlDoc.documentElement.innerHTML;\n}\n/**\n * Fix shortcut. Mac use Command, others use Ctrl.\n */ function fixShortcut(name) {\n    if (isMac) {\n        name = name.replace(\"Ctrl\", \"Cmd\");\n    } else {\n        name = name.replace(\"Cmd\", \"Ctrl\");\n    }\n    return name;\n}\n/**\n * Create dropdown block\n */ function createToolbarDropdown(options, enableTooltips, shortcuts, parent) {\n    var el = createToolbarButton(options, false, enableTooltips, shortcuts, \"button\", parent);\n    el.classList.add(\"easymde-dropdown\");\n    el.onclick = function() {\n        el.focus();\n    };\n    var content = document.createElement(\"div\");\n    content.className = \"easymde-dropdown-content\";\n    for(var childrenIndex = 0; childrenIndex < options.children.length; childrenIndex++){\n        var child = options.children[childrenIndex];\n        var childElement;\n        if (typeof child === \"string\" && child in toolbarBuiltInButtons) {\n            childElement = createToolbarButton(toolbarBuiltInButtons[child], true, enableTooltips, shortcuts, \"button\", parent);\n        } else {\n            childElement = createToolbarButton(child, true, enableTooltips, shortcuts, \"button\", parent);\n        }\n        childElement.addEventListener(\"click\", function(e) {\n            e.stopPropagation();\n        }, false);\n        content.appendChild(childElement);\n    }\n    el.appendChild(content);\n    return el;\n}\n/**\n * Create button element for toolbar.\n */ function createToolbarButton(options, enableActions, enableTooltips, shortcuts, markup, parent) {\n    options = options || {};\n    var el = document.createElement(markup);\n    // Add 'custom' attributes as early as possible, so that 'official' attributes will never be overwritten.\n    if (options.attributes) {\n        for(var attribute in options.attributes){\n            if (Object.prototype.hasOwnProperty.call(options.attributes, attribute)) {\n                el.setAttribute(attribute, options.attributes[attribute]);\n            }\n        }\n    }\n    var classNamePrefix = parent.options.toolbarButtonClassPrefix ? parent.options.toolbarButtonClassPrefix + \"-\" : \"\";\n    el.className = classNamePrefix + options.name;\n    el.setAttribute(\"type\", markup);\n    enableTooltips = enableTooltips == undefined ? true : enableTooltips;\n    if (options.text) {\n        el.innerText = options.text;\n    }\n    // Properly handle custom shortcuts\n    if (options.name && options.name in shortcuts) {\n        bindings[options.name] = options.action;\n    }\n    if (options.title && enableTooltips) {\n        el.title = createTooltip(options.title, options.action, shortcuts);\n        if (isMac) {\n            el.title = el.title.replace(\"Ctrl\", \"\");\n            el.title = el.title.replace(\"Alt\", \"\");\n        }\n    }\n    if (options.title) {\n        el.setAttribute(\"aria-label\", options.title);\n    }\n    if (options.noDisable) {\n        el.classList.add(\"no-disable\");\n    }\n    if (options.noMobile) {\n        el.classList.add(\"no-mobile\");\n    }\n    // Prevent errors if there is no class name in custom options\n    var classNameParts = [];\n    if (typeof options.className !== \"undefined\") {\n        classNameParts = options.className.split(\" \");\n    }\n    // Provide backwards compatibility with simple-markdown-editor by adding custom classes to the button.\n    var iconClasses = [];\n    for(var classNameIndex = 0; classNameIndex < classNameParts.length; classNameIndex++){\n        var classNamePart = classNameParts[classNameIndex];\n        // Split icon classes from the button.\n        // Regex will detect \"fa\", \"fas\", \"fa-something\" and \"fa-some-icon-1\", but not \"fanfare\".\n        if (classNamePart.match(/^fa([srlb]|(-[\\w-]*)|$)/)) {\n            iconClasses.push(classNamePart);\n        } else {\n            el.classList.add(classNamePart);\n        }\n    }\n    el.tabIndex = -1;\n    if (iconClasses.length > 0) {\n        // Create icon element and append as a child to the button\n        var icon = document.createElement(\"i\");\n        for(var iconClassIndex = 0; iconClassIndex < iconClasses.length; iconClassIndex++){\n            var iconClass = iconClasses[iconClassIndex];\n            icon.classList.add(iconClass);\n        }\n        el.appendChild(icon);\n    }\n    // If there is a custom icon markup set, use that\n    if (typeof options.icon !== \"undefined\") {\n        el.innerHTML = options.icon;\n    }\n    if (options.action && enableActions) {\n        if (typeof options.action === \"function\") {\n            el.onclick = function(e) {\n                e.preventDefault();\n                options.action(parent);\n            };\n        } else if (typeof options.action === \"string\") {\n            el.onclick = function(e) {\n                e.preventDefault();\n                window.open(options.action, \"_blank\");\n            };\n        }\n    }\n    return el;\n}\nfunction createSep() {\n    var el = document.createElement(\"i\");\n    el.className = \"separator\";\n    el.innerHTML = \"|\";\n    return el;\n}\nfunction createTooltip(title, action, shortcuts) {\n    var actionName;\n    var tooltip = title;\n    if (action) {\n        actionName = getBindingName(action);\n        if (shortcuts[actionName]) {\n            tooltip += \" (\" + fixShortcut(shortcuts[actionName]) + \")\";\n        }\n    }\n    return tooltip;\n}\n/**\n * The state of CodeMirror at the given position.\n */ function getState(cm, pos) {\n    pos = pos || cm.getCursor(\"start\");\n    var stat = cm.getTokenAt(pos);\n    if (!stat.type) return {};\n    var types = stat.type.split(\" \");\n    var ret = {}, data, text;\n    for(var i = 0; i < types.length; i++){\n        data = types[i];\n        if (data === \"strong\") {\n            ret.bold = true;\n        } else if (data === \"variable-2\") {\n            text = cm.getLine(pos.line);\n            if (/^\\s*\\d+\\.\\s/.test(text)) {\n                ret[\"ordered-list\"] = true;\n            } else {\n                ret[\"unordered-list\"] = true;\n            }\n        } else if (data === \"atom\") {\n            ret.quote = true;\n        } else if (data === \"em\") {\n            ret.italic = true;\n        } else if (data === \"quote\") {\n            ret.quote = true;\n        } else if (data === \"strikethrough\") {\n            ret.strikethrough = true;\n        } else if (data === \"comment\") {\n            ret.code = true;\n        } else if (data === \"link\" && !ret.image) {\n            ret.link = true;\n        } else if (data === \"image\") {\n            ret.image = true;\n        } else if (data.match(/^header(-[1-6])?$/)) {\n            ret[data.replace(\"header\", \"heading\")] = true;\n        }\n    }\n    return ret;\n}\n// Saved overflow setting\nvar saved_overflow = \"\";\n/**\n * Toggle full screen of the editor.\n * @param {EasyMDE} editor\n */ function toggleFullScreen(editor) {\n    // Set fullscreen\n    var cm = editor.codemirror;\n    cm.setOption(\"fullScreen\", !cm.getOption(\"fullScreen\"));\n    // Prevent scrolling on body during fullscreen active\n    if (cm.getOption(\"fullScreen\")) {\n        saved_overflow = document.body.style.overflow;\n        document.body.style.overflow = \"hidden\";\n    } else {\n        document.body.style.overflow = saved_overflow;\n    }\n    var wrapper = cm.getWrapperElement();\n    var sidebyside = wrapper.nextSibling;\n    if (sidebyside.classList.contains(\"editor-preview-active-side\")) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, apply classes as needed\n            var easyMDEContainer = wrapper.parentNode;\n            if (cm.getOption(\"fullScreen\")) {\n                easyMDEContainer.classList.remove(\"sided--no-fullscreen\");\n            } else {\n                easyMDEContainer.classList.add(\"sided--no-fullscreen\");\n            }\n        } else {\n            toggleSideBySide(editor);\n        }\n    }\n    if (editor.options.onToggleFullScreen) {\n        editor.options.onToggleFullScreen(cm.getOption(\"fullScreen\") || false);\n    }\n    // Remove or set maxHeight\n    if (typeof editor.options.maxHeight !== \"undefined\") {\n        if (cm.getOption(\"fullScreen\")) {\n            cm.getScrollerElement().style.removeProperty(\"height\");\n            sidebyside.style.removeProperty(\"height\");\n        } else {\n            cm.getScrollerElement().style.height = editor.options.maxHeight;\n            editor.setPreviewMaxHeight();\n        }\n    }\n    // Update toolbar class\n    editor.toolbar_div.classList.toggle(\"fullscreen\");\n    // Update toolbar button\n    if (editor.toolbarElements && editor.toolbarElements.fullscreen) {\n        var toolbarButton = editor.toolbarElements.fullscreen;\n        toolbarButton.classList.toggle(\"active\");\n    }\n}\n/**\n * Action for toggling bold.\n * @param {EasyMDE} editor\n */ function toggleBold(editor) {\n    _toggleBlock(editor, \"bold\", editor.options.blockStyles.bold);\n}\n/**\n * Action for toggling italic.\n * @param {EasyMDE} editor\n */ function toggleItalic(editor) {\n    _toggleBlock(editor, \"italic\", editor.options.blockStyles.italic);\n}\n/**\n * Action for toggling strikethrough.\n * @param {EasyMDE} editor\n */ function toggleStrikethrough(editor) {\n    _toggleBlock(editor, \"strikethrough\", \"~~\");\n}\n/**\n * Action for toggling code block.\n * @param {EasyMDE} editor\n */ function toggleCodeBlock(editor) {\n    var fenceCharsToInsert = editor.options.blockStyles.code;\n    function fencing_line(line) {\n        /* return true, if this is a ``` or ~~~ line */ if (typeof line !== \"object\") {\n            throw \"fencing_line() takes a 'line' object (not a line number, or line text).  Got: \" + typeof line + \": \" + line;\n        }\n        return line.styles && line.styles[2] && line.styles[2].indexOf(\"formatting-code-block\") !== -1;\n    }\n    function token_state(token) {\n        // base goes an extra level deep when mode backdrops are used, e.g. spellchecker on\n        return token.state.base.base || token.state.base;\n    }\n    function code_type(cm, line_num, line, firstTok, lastTok) {\n        /*\n         * Return \"single\", \"indented\", \"fenced\" or false\n         *\n         * cm and line_num are required.  Others are optional for efficiency\n         *   To check in the middle of a line, pass in firstTok yourself.\n         */ line = line || cm.getLineHandle(line_num);\n        firstTok = firstTok || cm.getTokenAt({\n            line: line_num,\n            ch: 1\n        });\n        lastTok = lastTok || !!line.text && cm.getTokenAt({\n            line: line_num,\n            ch: line.text.length - 1\n        });\n        var types = firstTok.type ? firstTok.type.split(\" \") : [];\n        if (lastTok && token_state(lastTok).indentedCode) {\n            // have to check last char, since first chars of first line aren\"t marked as indented\n            return \"indented\";\n        } else if (types.indexOf(\"comment\") === -1) {\n            // has to be after \"indented\" check, since first chars of first indented line aren\"t marked as such\n            return false;\n        } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {\n            return \"fenced\";\n        } else {\n            return \"single\";\n        }\n    }\n    function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {\n        var start_line_sel = cur_start.line + 1, end_line_sel = cur_end.line + 1, sel_multi = cur_start.line !== cur_end.line, repl_start = fenceCharsToInsert + \"\\n\", repl_end = \"\\n\" + fenceCharsToInsert;\n        if (sel_multi) {\n            end_line_sel++;\n        }\n        // handle last char including \\n or not\n        if (sel_multi && cur_end.ch === 0) {\n            repl_end = fenceCharsToInsert + \"\\n\";\n            end_line_sel--;\n        }\n        _replaceSelection(cm, false, [\n            repl_start,\n            repl_end\n        ]);\n        cm.setSelection({\n            line: start_line_sel,\n            ch: 0\n        }, {\n            line: end_line_sel,\n            ch: 0\n        });\n    }\n    var cm = editor.codemirror, cur_start = cm.getCursor(\"start\"), cur_end = cm.getCursor(\"end\"), tok = cm.getTokenAt({\n        line: cur_start.line,\n        ch: cur_start.ch || 1\n    }), line = cm.getLineHandle(cur_start.line), is_code = code_type(cm, cur_start.line, line, tok);\n    var block_start, block_end, lineCount;\n    if (is_code === \"single\") {\n        // similar to some EasyMDE _toggleBlock logic\n        var start = line.text.slice(0, cur_start.ch).replace(\"`\", \"\"), end = line.text.slice(cur_start.ch).replace(\"`\", \"\");\n        cm.replaceRange(start + end, {\n            line: cur_start.line,\n            ch: 0\n        }, {\n            line: cur_start.line,\n            ch: 99999999999999\n        });\n        cur_start.ch--;\n        if (cur_start !== cur_end) {\n            cur_end.ch--;\n        }\n        cm.setSelection(cur_start, cur_end);\n        cm.focus();\n    } else if (is_code === \"fenced\") {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n            // find the fenced line so we know what type it is (tilde, backticks, number of them)\n            for(block_start = cur_start.line; block_start >= 0; block_start--){\n                line = cm.getLineHandle(block_start);\n                if (fencing_line(line)) {\n                    break;\n                }\n            }\n            var fencedTok = cm.getTokenAt({\n                line: block_start,\n                ch: 1\n            });\n            var fence_chars = token_state(fencedTok).fencedChars;\n            var start_text, start_line;\n            var end_text, end_line;\n            // check for selection going up against fenced lines, in which case we don't want to add more fencing\n            if (fencing_line(cm.getLineHandle(cur_start.line))) {\n                start_text = \"\";\n                start_line = cur_start.line;\n            } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {\n                start_text = \"\";\n                start_line = cur_start.line - 1;\n            } else {\n                start_text = fence_chars + \"\\n\";\n                start_line = cur_start.line;\n            }\n            if (fencing_line(cm.getLineHandle(cur_end.line))) {\n                end_text = \"\";\n                end_line = cur_end.line;\n                if (cur_end.ch === 0) {\n                    end_line += 1;\n                }\n            } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {\n                end_text = \"\";\n                end_line = cur_end.line + 1;\n            } else {\n                end_text = fence_chars + \"\\n\";\n                end_line = cur_end.line + 1;\n            }\n            if (cur_end.ch === 0) {\n                // full last line selected, putting cursor at beginning of next\n                end_line -= 1;\n            }\n            cm.operation(function() {\n                // end line first, so that line numbers don't change\n                cm.replaceRange(end_text, {\n                    line: end_line,\n                    ch: 0\n                }, {\n                    line: end_line + (end_text ? 0 : 1),\n                    ch: 0\n                });\n                cm.replaceRange(start_text, {\n                    line: start_line,\n                    ch: 0\n                }, {\n                    line: start_line + (start_text ? 0 : 1),\n                    ch: 0\n                });\n            });\n            cm.setSelection({\n                line: start_line + (start_text ? 1 : 0),\n                ch: 0\n            }, {\n                line: end_line + (start_text ? 1 : -1),\n                ch: 0\n            });\n            cm.focus();\n        } else {\n            // no selection, search for ends of this fenced block\n            var search_from = cur_start.line;\n            if (fencing_line(cm.getLineHandle(cur_start.line))) {\n                if (code_type(cm, cur_start.line + 1) === \"fenced\") {\n                    block_start = cur_start.line;\n                    search_from = cur_start.line + 1; // for searching for \"end\"\n                } else {\n                    block_end = cur_start.line;\n                    search_from = cur_start.line - 1; // for searching for \"start\"\n                }\n            }\n            if (block_start === undefined) {\n                for(block_start = search_from; block_start >= 0; block_start--){\n                    line = cm.getLineHandle(block_start);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            if (block_end === undefined) {\n                lineCount = cm.lineCount();\n                for(block_end = search_from; block_end < lineCount; block_end++){\n                    line = cm.getLineHandle(block_end);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            cm.operation(function() {\n                cm.replaceRange(\"\", {\n                    line: block_start,\n                    ch: 0\n                }, {\n                    line: block_start + 1,\n                    ch: 0\n                });\n                cm.replaceRange(\"\", {\n                    line: block_end - 1,\n                    ch: 0\n                }, {\n                    line: block_end,\n                    ch: 0\n                });\n            });\n            cm.focus();\n        }\n    } else if (is_code === \"indented\") {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n            block_start = cur_start.line;\n            block_end = cur_end.line;\n            if (cur_end.ch === 0) {\n                block_end--;\n            }\n        } else {\n            // no selection, search for ends of this indented block\n            for(block_start = cur_start.line; block_start >= 0; block_start--){\n                line = cm.getLineHandle(block_start);\n                if (line.text.match(/^\\s*$/)) {\n                    continue;\n                } else {\n                    if (code_type(cm, block_start, line) !== \"indented\") {\n                        block_start += 1;\n                        break;\n                    }\n                }\n            }\n            lineCount = cm.lineCount();\n            for(block_end = cur_start.line; block_end < lineCount; block_end++){\n                line = cm.getLineHandle(block_end);\n                if (line.text.match(/^\\s*$/)) {\n                    continue;\n                } else {\n                    if (code_type(cm, block_end, line) !== \"indented\") {\n                        block_end -= 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to\n        // insert a blank line so that the next line(s) continue to be indented code\n        var next_line = cm.getLineHandle(block_end + 1), next_line_last_tok = next_line && cm.getTokenAt({\n            line: block_end + 1,\n            ch: next_line.text.length - 1\n        }), next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;\n        if (next_line_indented) {\n            cm.replaceRange(\"\\n\", {\n                line: block_end + 1,\n                ch: 0\n            });\n        }\n        for(var i = block_start; i <= block_end; i++){\n            cm.indentLine(i, \"subtract\"); // TODO: this doesn't get tracked in the history, so can't be undone :(\n        }\n        cm.focus();\n    } else {\n        // insert code formatting\n        var no_sel_and_starting_of_line = cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0;\n        var sel_multi = cur_start.line !== cur_end.line;\n        if (no_sel_and_starting_of_line || sel_multi) {\n            insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);\n        } else {\n            _replaceSelection(cm, false, [\n                \"`\",\n                \"`\"\n            ]);\n        }\n    }\n}\n/**\n * Action for toggling blockquote.\n */ function toggleBlockquote(editor) {\n    _toggleLine(editor.codemirror, \"quote\");\n}\n/**\n * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal\n */ function toggleHeadingSmaller(editor) {\n    _toggleHeading(editor.codemirror, \"smaller\");\n}\n/**\n * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal\n */ function toggleHeadingBigger(editor) {\n    _toggleHeading(editor.codemirror, \"bigger\");\n}\n/**\n * Action for toggling heading size 1\n */ function toggleHeading1(editor) {\n    _toggleHeading(editor.codemirror, undefined, 1);\n}\n/**\n * Action for toggling heading size 2\n */ function toggleHeading2(editor) {\n    _toggleHeading(editor.codemirror, undefined, 2);\n}\n/**\n * Action for toggling heading size 3\n */ function toggleHeading3(editor) {\n    _toggleHeading(editor.codemirror, undefined, 3);\n}\n/**\n * Action for toggling heading size 4\n */ function toggleHeading4(editor) {\n    _toggleHeading(editor.codemirror, undefined, 4);\n}\n/**\n * Action for toggling heading size 5\n */ function toggleHeading5(editor) {\n    _toggleHeading(editor.codemirror, undefined, 5);\n}\n/**\n * Action for toggling heading size 6\n */ function toggleHeading6(editor) {\n    _toggleHeading(editor.codemirror, undefined, 6);\n}\n/**\n * Action for toggling ul.\n */ function toggleUnorderedList(editor) {\n    var cm = editor.codemirror;\n    var listStyle = \"*\"; // Default\n    if ([\n        \"-\",\n        \"+\",\n        \"*\"\n    ].includes(editor.options.unorderedListStyle)) {\n        listStyle = editor.options.unorderedListStyle;\n    }\n    _toggleLine(cm, \"unordered-list\", listStyle);\n}\n/**\n * Action for toggling ol.\n */ function toggleOrderedList(editor) {\n    _toggleLine(editor.codemirror, \"ordered-list\");\n}\n/**\n * Action for clean block (remove headline, list, blockquote code, markers)\n */ function cleanBlock(editor) {\n    _cleanBlock(editor.codemirror);\n}\n/**\n * Action for drawing a link.\n * @param {EasyMDE} editor\n */ function drawLink(editor) {\n    var options = editor.options;\n    var url = \"https://\";\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.link, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, \"link\", options.insertTexts.link, url);\n}\n/**\n * Action for drawing an img.\n * @param {EasyMDE} editor\n */ function drawImage(editor) {\n    var options = editor.options;\n    var url = \"https://\";\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.image, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, \"image\", options.insertTexts.image, url);\n}\n/**\n * Encode and escape URLs to prevent breaking up rendered Markdown links.\n * @param {string} url The url of the link or image\n */ function escapePromptURL(url) {\n    return encodeURI(url).replace(/([\\\\()])/g, \"\\\\$1\");\n}\n/**\n * Action for opening the browse-file window to upload an image to a server.\n * @param {EasyMDE} editor The EasyMDE object\n */ function drawUploadedImage(editor) {\n    // TODO: Draw the image template with a fake url? ie: '![](importing foo.png...)'\n    editor.openBrowseFileWindow();\n}\n/**\n * Action executed after an image have been successfully imported on the server.\n * @param {EasyMDE} editor The EasyMDE object\n * @param {string} url The url of the uploaded image\n */ function afterImageUploaded(editor, url) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    var imageName = url.substr(url.lastIndexOf(\"/\") + 1);\n    var ext = imageName.substring(imageName.lastIndexOf(\".\") + 1).replace(/\\?.*$/, \"\").toLowerCase();\n    // Check if media is an image\n    if ([\n        \"png\",\n        \"jpg\",\n        \"jpeg\",\n        \"gif\",\n        \"svg\",\n        \"apng\",\n        \"avif\",\n        \"webp\"\n    ].includes(ext)) {\n        _replaceSelection(cm, stat.image, options.insertTexts.uploadedImage, url);\n    } else {\n        var text_link = options.insertTexts.link;\n        text_link[0] = \"[\" + imageName;\n        _replaceSelection(cm, stat.link, text_link, url);\n    }\n    // show uploaded image filename for 1000ms\n    editor.updateStatusBar(\"upload-image\", editor.options.imageTexts.sbOnUploaded.replace(\"#image_name#\", imageName));\n    setTimeout(function() {\n        editor.updateStatusBar(\"upload-image\", editor.options.imageTexts.sbInit);\n    }, 1000);\n}\n/**\n * Action for drawing a table.\n * @param {EasyMDE} editor\n */ function drawTable(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.table, options.insertTexts.table);\n}\n/**\n * Action for drawing a horizontal rule.\n * @param {EasyMDE} editor\n */ function drawHorizontalRule(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);\n}\n/**\n * Undo action.\n * @param {EasyMDE} editor\n */ function undo(editor) {\n    var cm = editor.codemirror;\n    cm.undo();\n    cm.focus();\n}\n/**\n * Redo action.\n * @param {EasyMDE} editor\n */ function redo(editor) {\n    var cm = editor.codemirror;\n    cm.redo();\n    cm.focus();\n}\n/**\n * Toggle side by side preview\n * @param {EasyMDE} editor\n */ function toggleSideBySide(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n    var toolbarButton = editor.toolbarElements && editor.toolbarElements[\"side-by-side\"];\n    var useSideBySideListener = false;\n    var easyMDEContainer = wrapper.parentNode;\n    if (preview.classList.contains(\"editor-preview-active-side\")) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, remove classes when hiding side\n            easyMDEContainer.classList.remove(\"sided--no-fullscreen\");\n        }\n        preview.classList.remove(\"editor-preview-active-side\");\n        if (toolbarButton) toolbarButton.classList.remove(\"active\");\n        wrapper.classList.remove(\"CodeMirror-sided\");\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function() {\n            if (!cm.getOption(\"fullScreen\")) {\n                if (editor.options.sideBySideFullscreen === false) {\n                    // if side-by-side not-fullscreen ok, add classes when not fullscreen and showing side\n                    easyMDEContainer.classList.add(\"sided--no-fullscreen\");\n                } else {\n                    toggleFullScreen(editor);\n                }\n            }\n            preview.classList.add(\"editor-preview-active-side\");\n        }, 1);\n        if (toolbarButton) toolbarButton.classList.add(\"active\");\n        wrapper.classList.add(\"CodeMirror-sided\");\n        useSideBySideListener = true;\n    }\n    // Hide normal preview if active\n    var previewNormal = wrapper.lastChild;\n    if (previewNormal.classList.contains(\"editor-preview-active\")) {\n        previewNormal.classList.remove(\"editor-preview-active\");\n        var toolbar = editor.toolbarElements.preview;\n        var toolbar_div = editor.toolbar_div;\n        toolbar.classList.remove(\"active\");\n        toolbar_div.classList.remove(\"disabled-for-preview\");\n    }\n    var sideBySideRenderingFunction = function() {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n    };\n    if (!cm.sideBySideRenderingFunction) {\n        cm.sideBySideRenderingFunction = sideBySideRenderingFunction;\n    }\n    if (useSideBySideListener) {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n        cm.on(\"update\", cm.sideBySideRenderingFunction);\n    } else {\n        cm.off(\"update\", cm.sideBySideRenderingFunction);\n    }\n    // Refresh to fix selection being off (#309)\n    cm.refresh();\n}\n/**\n * Preview action.\n * @param {EasyMDE} editor\n */ function togglePreview(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var toolbar_div = editor.toolbar_div;\n    var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;\n    var preview = wrapper.lastChild;\n    // Turn off side by side if needed\n    var sidebyside = cm.getWrapperElement().nextSibling;\n    if (sidebyside.classList.contains(\"editor-preview-active-side\")) toggleSideBySide(editor);\n    if (!preview || !preview.classList.contains(\"editor-preview-full\")) {\n        preview = document.createElement(\"div\");\n        preview.className = \"editor-preview-full\";\n        if (editor.options.previewClass) {\n            if (Array.isArray(editor.options.previewClass)) {\n                for(var i = 0; i < editor.options.previewClass.length; i++){\n                    preview.classList.add(editor.options.previewClass[i]);\n                }\n            } else if (typeof editor.options.previewClass === \"string\") {\n                preview.classList.add(editor.options.previewClass);\n            }\n        }\n        wrapper.appendChild(preview);\n    }\n    if (preview.classList.contains(\"editor-preview-active\")) {\n        preview.classList.remove(\"editor-preview-active\");\n        if (toolbar) {\n            toolbar.classList.remove(\"active\");\n            toolbar_div.classList.remove(\"disabled-for-preview\");\n        }\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function() {\n            preview.classList.add(\"editor-preview-active\");\n        }, 1);\n        if (toolbar) {\n            toolbar.classList.add(\"active\");\n            toolbar_div.classList.add(\"disabled-for-preview\");\n        }\n    }\n    var preview_result = editor.options.previewRender(editor.value(), preview);\n    if (preview_result !== null) {\n        preview.innerHTML = preview_result;\n    }\n}\nfunction _replaceSelection(cm, active, startEnd, url) {\n    if (cm.getWrapperElement().lastChild.classList.contains(\"editor-preview-active\")) return;\n    var text;\n    var start = startEnd[0];\n    var end = startEnd[1];\n    var startPoint = {}, endPoint = {};\n    Object.assign(startPoint, cm.getCursor(\"start\"));\n    Object.assign(endPoint, cm.getCursor(\"end\"));\n    if (url) {\n        start = start.replace(\"#url#\", url); // url is in start for upload-image\n        end = end.replace(\"#url#\", url);\n    }\n    if (active) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0\n        });\n    } else {\n        text = cm.getSelection();\n        cm.replaceSelection(start + text + end);\n        startPoint.ch += start.length;\n        if (startPoint !== endPoint) {\n            endPoint.ch += start.length;\n        }\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\nfunction _toggleHeading(cm, direction, size) {\n    if (cm.getWrapperElement().lastChild.classList.contains(\"editor-preview-active\")) return;\n    var startPoint = cm.getCursor(\"start\");\n    var endPoint = cm.getCursor(\"end\");\n    for(var i = startPoint.line; i <= endPoint.line; i++){\n        (function(i) {\n            var text = cm.getLine(i);\n            var currHeadingLevel = text.search(/[^#]/);\n            if (direction !== undefined) {\n                if (currHeadingLevel <= 0) {\n                    if (direction == \"bigger\") {\n                        text = \"###### \" + text;\n                    } else {\n                        text = \"# \" + text;\n                    }\n                } else if (currHeadingLevel == 6 && direction == \"smaller\") {\n                    text = text.substr(7);\n                } else if (currHeadingLevel == 1 && direction == \"bigger\") {\n                    text = text.substr(2);\n                } else {\n                    if (direction == \"bigger\") {\n                        text = text.substr(1);\n                    } else {\n                        text = \"#\" + text;\n                    }\n                }\n            } else {\n                if (currHeadingLevel <= 0) {\n                    text = \"#\".repeat(size) + \" \" + text;\n                } else if (currHeadingLevel == size) {\n                    text = text.substr(currHeadingLevel + 1);\n                } else {\n                    text = \"#\".repeat(size) + \" \" + text.substr(currHeadingLevel + 1);\n                }\n            }\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0\n            }, {\n                line: i,\n                ch: 99999999999999\n            });\n        })(i);\n    }\n    cm.focus();\n}\nfunction _toggleLine(cm, name, liststyle) {\n    if (cm.getWrapperElement().lastChild.classList.contains(\"editor-preview-active\")) return;\n    var listRegexp = /^(\\s*)(\\*|-|\\+|\\d*\\.)(\\s+)/;\n    var whitespacesRegexp = /^\\s*/;\n    var stat = getState(cm);\n    var startPoint = cm.getCursor(\"start\");\n    var endPoint = cm.getCursor(\"end\");\n    var repl = {\n        \"quote\": /^(\\s*)>\\s+/,\n        \"unordered-list\": listRegexp,\n        \"ordered-list\": listRegexp\n    };\n    var _getChar = function(name, i) {\n        var map = {\n            \"quote\": \">\",\n            \"unordered-list\": liststyle,\n            \"ordered-list\": \"%%i.\"\n        };\n        return map[name].replace(\"%%i\", i);\n    };\n    var _checkChar = function(name, char) {\n        var map = {\n            \"quote\": \">\",\n            \"unordered-list\": \"\\\\\" + liststyle,\n            \"ordered-list\": \"\\\\d+.\"\n        };\n        var rt = new RegExp(map[name]);\n        return char && rt.test(char);\n    };\n    var _toggle = function(name, text, untoggleOnly) {\n        var arr = listRegexp.exec(text);\n        var char = _getChar(name, line);\n        if (arr !== null) {\n            if (_checkChar(name, arr[2])) {\n                char = \"\";\n            }\n            text = arr[1] + char + arr[3] + text.replace(whitespacesRegexp, \"\").replace(repl[name], \"$1\");\n        } else if (untoggleOnly == false) {\n            text = char + \" \" + text;\n        }\n        return text;\n    };\n    var line = 1;\n    for(var i = startPoint.line; i <= endPoint.line; i++){\n        (function(i) {\n            var text = cm.getLine(i);\n            if (stat[name]) {\n                text = text.replace(repl[name], \"$1\");\n            } else {\n                // If we're toggling unordered-list formatting, check if the current line\n                // is part of an ordered-list, and if so, untoggle that first.\n                // Workaround for https://github.com/Ionaru/easy-markdown-editor/issues/92\n                if (name == \"unordered-list\") {\n                    text = _toggle(\"ordered-list\", text, true);\n                }\n                text = _toggle(name, text, false);\n                line += 1;\n            }\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0\n            }, {\n                line: i,\n                ch: 99999999999999\n            });\n        })(i);\n    }\n    cm.focus();\n}\n/**\n * @param {EasyMDE} editor\n * @param {'link' | 'image'} type\n * @param {string} startEnd\n * @param {string} url\n */ function _toggleLink(editor, type, startEnd, url) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var active = stat[type];\n    if (!active) {\n        _replaceSelection(cm, active, startEnd, url);\n        return;\n    }\n    var startPoint = cm.getCursor(\"start\");\n    var endPoint = cm.getCursor(\"end\");\n    var text = cm.getLine(startPoint.line);\n    var start = text.slice(0, startPoint.ch);\n    var end = text.slice(startPoint.ch);\n    if (type == \"link\") {\n        start = start.replace(/(.*)[^!]\\[/, \"$1\");\n    } else if (type == \"image\") {\n        start = start.replace(/(.*)!\\[$/, \"$1\");\n    }\n    end = end.replace(/]\\(.*?\\)/, \"\");\n    cm.replaceRange(start + end, {\n        line: startPoint.line,\n        ch: 0\n    }, {\n        line: startPoint.line,\n        ch: 99999999999999\n    });\n    startPoint.ch -= startEnd[0].length;\n    if (startPoint !== endPoint) {\n        endPoint.ch -= startEnd[0].length;\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n/**\n * @param {EasyMDE} editor\n */ function _toggleBlock(editor, type, start_chars, end_chars) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n    end_chars = typeof end_chars === \"undefined\" ? start_chars : end_chars;\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var text;\n    var start = start_chars;\n    var end = end_chars;\n    var startPoint = cm.getCursor(\"start\");\n    var endPoint = cm.getCursor(\"end\");\n    if (stat[type]) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        if (type == \"bold\") {\n            start = start.replace(/(\\*\\*|__)(?![\\s\\S]*(\\*\\*|__))/, \"\");\n            end = end.replace(/(\\*\\*|__)/, \"\");\n        } else if (type == \"italic\") {\n            start = start.replace(/(\\*|_)(?![\\s\\S]*(\\*|_))/, \"\");\n            end = end.replace(/(\\*|_)/, \"\");\n        } else if (type == \"strikethrough\") {\n            start = start.replace(/(\\*\\*|~~)(?![\\s\\S]*(\\*\\*|~~))/, \"\");\n            end = end.replace(/(\\*\\*|~~)/, \"\");\n        }\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0\n        }, {\n            line: startPoint.line,\n            ch: 99999999999999\n        });\n        if (type == \"bold\" || type == \"strikethrough\") {\n            startPoint.ch -= 2;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 2;\n            }\n        } else if (type == \"italic\") {\n            startPoint.ch -= 1;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 1;\n            }\n        }\n    } else {\n        text = cm.getSelection();\n        if (type == \"bold\") {\n            text = text.split(\"**\").join(\"\");\n            text = text.split(\"__\").join(\"\");\n        } else if (type == \"italic\") {\n            text = text.split(\"*\").join(\"\");\n            text = text.split(\"_\").join(\"\");\n        } else if (type == \"strikethrough\") {\n            text = text.split(\"~~\").join(\"\");\n        }\n        cm.replaceSelection(start + text + end);\n        startPoint.ch += start_chars.length;\n        endPoint.ch = startPoint.ch + text.length;\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\nfunction _cleanBlock(cm) {\n    if (cm.getWrapperElement().lastChild.classList.contains(\"editor-preview-active\")) return;\n    var startPoint = cm.getCursor(\"start\");\n    var endPoint = cm.getCursor(\"end\");\n    var text;\n    for(var line = startPoint.line; line <= endPoint.line; line++){\n        text = cm.getLine(line);\n        text = text.replace(/^[ ]*([# ]+|\\*|-|[> ]+|[0-9]+(.|\\)))[ ]*/, \"\");\n        cm.replaceRange(text, {\n            line: line,\n            ch: 0\n        }, {\n            line: line,\n            ch: 99999999999999\n        });\n    }\n}\n/**\n * Convert a number of bytes to a human-readable file size. If you desire\n * to add a space between the value and the unit, you need to add this space\n * to the given units.\n * @param bytes {number} A number of bytes, as integer. Ex: 421137\n * @param units {number[]} An array of human-readable units, ie. [' B', ' K', ' MB']\n * @returns string A human-readable file size. Ex: '412 KB'\n */ function humanFileSize(bytes, units) {\n    if (Math.abs(bytes) < 1024) {\n        return \"\" + bytes + units[0];\n    }\n    var u = 0;\n    do {\n        bytes /= 1024;\n        ++u;\n    }while (Math.abs(bytes) >= 1024 && u < units.length);\n    return \"\" + bytes.toFixed(1) + units[u];\n}\n// Merge the properties of one object into another.\nfunction _mergeProperties(target, source) {\n    for(var property in source){\n        if (Object.prototype.hasOwnProperty.call(source, property)) {\n            if (source[property] instanceof Array) {\n                target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);\n            } else if (source[property] !== null && typeof source[property] === \"object\" && source[property].constructor === Object) {\n                target[property] = _mergeProperties(target[property] || {}, source[property]);\n            } else {\n                target[property] = source[property];\n            }\n        }\n    }\n    return target;\n}\n// Merge an arbitrary number of objects into one.\nfunction extend(target) {\n    for(var i = 1; i < arguments.length; i++){\n        target = _mergeProperties(target, arguments[i]);\n    }\n    return target;\n}\n/* The right word count in respect for CJK. */ function wordCount(data) {\n    var pattern = /[a-zA-Z0-9_\\u00A0-\\u02AF\\u0392-\\u03c9\\u0410-\\u04F9]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af]+/g;\n    var m = data.match(pattern);\n    var count = 0;\n    if (m === null) return count;\n    for(var i = 0; i < m.length; i++){\n        if (m[i].charCodeAt(0) >= 0x4E00) {\n            count += m[i].length;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\nvar iconClassMap = {\n    \"bold\": \"fa fa-bold\",\n    \"italic\": \"fa fa-italic\",\n    \"strikethrough\": \"fa fa-strikethrough\",\n    \"heading\": \"fa fa-header fa-heading\",\n    \"heading-smaller\": \"fa fa-header fa-heading header-smaller\",\n    \"heading-bigger\": \"fa fa-header fa-heading header-bigger\",\n    \"heading-1\": \"fa fa-header fa-heading header-1\",\n    \"heading-2\": \"fa fa-header fa-heading header-2\",\n    \"heading-3\": \"fa fa-header fa-heading header-3\",\n    \"code\": \"fa fa-code\",\n    \"quote\": \"fa fa-quote-left\",\n    \"ordered-list\": \"fa fa-list-ol\",\n    \"unordered-list\": \"fa fa-list-ul\",\n    \"clean-block\": \"fa fa-eraser\",\n    \"link\": \"fa fa-link\",\n    \"image\": \"fa fa-image\",\n    \"upload-image\": \"fa fa-image\",\n    \"table\": \"fa fa-table\",\n    \"horizontal-rule\": \"fa fa-minus\",\n    \"preview\": \"fa fa-eye\",\n    \"side-by-side\": \"fa fa-columns\",\n    \"fullscreen\": \"fa fa-arrows-alt\",\n    \"guide\": \"fa fa-question-circle\",\n    \"undo\": \"fa fa-undo\",\n    \"redo\": \"fa fa-repeat fa-redo\"\n};\nvar toolbarBuiltInButtons = {\n    \"bold\": {\n        name: \"bold\",\n        action: toggleBold,\n        className: iconClassMap[\"bold\"],\n        title: \"Bold\",\n        default: true\n    },\n    \"italic\": {\n        name: \"italic\",\n        action: toggleItalic,\n        className: iconClassMap[\"italic\"],\n        title: \"Italic\",\n        default: true\n    },\n    \"strikethrough\": {\n        name: \"strikethrough\",\n        action: toggleStrikethrough,\n        className: iconClassMap[\"strikethrough\"],\n        title: \"Strikethrough\"\n    },\n    \"heading\": {\n        name: \"heading\",\n        action: toggleHeadingSmaller,\n        className: iconClassMap[\"heading\"],\n        title: \"Heading\",\n        default: true\n    },\n    \"heading-smaller\": {\n        name: \"heading-smaller\",\n        action: toggleHeadingSmaller,\n        className: iconClassMap[\"heading-smaller\"],\n        title: \"Smaller Heading\"\n    },\n    \"heading-bigger\": {\n        name: \"heading-bigger\",\n        action: toggleHeadingBigger,\n        className: iconClassMap[\"heading-bigger\"],\n        title: \"Bigger Heading\"\n    },\n    \"heading-1\": {\n        name: \"heading-1\",\n        action: toggleHeading1,\n        className: iconClassMap[\"heading-1\"],\n        title: \"Big Heading\"\n    },\n    \"heading-2\": {\n        name: \"heading-2\",\n        action: toggleHeading2,\n        className: iconClassMap[\"heading-2\"],\n        title: \"Medium Heading\"\n    },\n    \"heading-3\": {\n        name: \"heading-3\",\n        action: toggleHeading3,\n        className: iconClassMap[\"heading-3\"],\n        title: \"Small Heading\"\n    },\n    \"separator-1\": {\n        name: \"separator-1\"\n    },\n    \"code\": {\n        name: \"code\",\n        action: toggleCodeBlock,\n        className: iconClassMap[\"code\"],\n        title: \"Code\"\n    },\n    \"quote\": {\n        name: \"quote\",\n        action: toggleBlockquote,\n        className: iconClassMap[\"quote\"],\n        title: \"Quote\",\n        default: true\n    },\n    \"unordered-list\": {\n        name: \"unordered-list\",\n        action: toggleUnorderedList,\n        className: iconClassMap[\"unordered-list\"],\n        title: \"Generic List\",\n        default: true\n    },\n    \"ordered-list\": {\n        name: \"ordered-list\",\n        action: toggleOrderedList,\n        className: iconClassMap[\"ordered-list\"],\n        title: \"Numbered List\",\n        default: true\n    },\n    \"clean-block\": {\n        name: \"clean-block\",\n        action: cleanBlock,\n        className: iconClassMap[\"clean-block\"],\n        title: \"Clean block\"\n    },\n    \"separator-2\": {\n        name: \"separator-2\"\n    },\n    \"link\": {\n        name: \"link\",\n        action: drawLink,\n        className: iconClassMap[\"link\"],\n        title: \"Create Link\",\n        default: true\n    },\n    \"image\": {\n        name: \"image\",\n        action: drawImage,\n        className: iconClassMap[\"image\"],\n        title: \"Insert Image\",\n        default: true\n    },\n    \"upload-image\": {\n        name: \"upload-image\",\n        action: drawUploadedImage,\n        className: iconClassMap[\"upload-image\"],\n        title: \"Import an image\"\n    },\n    \"table\": {\n        name: \"table\",\n        action: drawTable,\n        className: iconClassMap[\"table\"],\n        title: \"Insert Table\"\n    },\n    \"horizontal-rule\": {\n        name: \"horizontal-rule\",\n        action: drawHorizontalRule,\n        className: iconClassMap[\"horizontal-rule\"],\n        title: \"Insert Horizontal Line\"\n    },\n    \"separator-3\": {\n        name: \"separator-3\"\n    },\n    \"preview\": {\n        name: \"preview\",\n        action: togglePreview,\n        className: iconClassMap[\"preview\"],\n        noDisable: true,\n        title: \"Toggle Preview\",\n        default: true\n    },\n    \"side-by-side\": {\n        name: \"side-by-side\",\n        action: toggleSideBySide,\n        className: iconClassMap[\"side-by-side\"],\n        noDisable: true,\n        noMobile: true,\n        title: \"Toggle Side by Side\",\n        default: true\n    },\n    \"fullscreen\": {\n        name: \"fullscreen\",\n        action: toggleFullScreen,\n        className: iconClassMap[\"fullscreen\"],\n        noDisable: true,\n        noMobile: true,\n        title: \"Toggle Fullscreen\",\n        default: true\n    },\n    \"separator-4\": {\n        name: \"separator-4\"\n    },\n    \"guide\": {\n        name: \"guide\",\n        action: \"https://www.markdownguide.org/basic-syntax/\",\n        className: iconClassMap[\"guide\"],\n        noDisable: true,\n        title: \"Markdown Guide\",\n        default: true\n    },\n    \"separator-5\": {\n        name: \"separator-5\"\n    },\n    \"undo\": {\n        name: \"undo\",\n        action: undo,\n        className: iconClassMap[\"undo\"],\n        noDisable: true,\n        title: \"Undo\"\n    },\n    \"redo\": {\n        name: \"redo\",\n        action: redo,\n        className: iconClassMap[\"redo\"],\n        noDisable: true,\n        title: \"Redo\"\n    }\n};\nvar insertTexts = {\n    link: [\n        \"[\",\n        \"](#url#)\"\n    ],\n    image: [\n        \"![\",\n        \"](#url#)\"\n    ],\n    uploadedImage: [\n        \"![](#url#)\",\n        \"\"\n    ],\n    // uploadedImage: ['![](#url#)\\n', ''], // TODO: New line insertion doesn't work here.\n    table: [\n        \"\",\n        \"\\n\\n| Column 1 | Column 2 | Column 3 |\\n| -------- | -------- | -------- |\\n| Text     | Text     | Text     |\\n\\n\"\n    ],\n    horizontalRule: [\n        \"\",\n        \"\\n\\n-----\\n\\n\"\n    ]\n};\nvar promptTexts = {\n    link: \"URL for the link:\",\n    image: \"URL of the image:\"\n};\nvar timeFormat = {\n    locale: \"en-US\",\n    format: {\n        hour: \"2-digit\",\n        minute: \"2-digit\"\n    }\n};\nvar blockStyles = {\n    \"bold\": \"**\",\n    \"code\": \"```\",\n    \"italic\": \"*\"\n};\n/**\n * Texts displayed to the user (mainly on the status bar) for the import image\n * feature. Can be used for customization or internationalization.\n */ var imageTexts = {\n    sbInit: \"Attach files by drag and dropping or pasting from clipboard.\",\n    sbOnDragEnter: \"Drop image to upload it.\",\n    sbOnDrop: \"Uploading image #images_names#...\",\n    sbProgress: \"Uploading #file_name#: #progress#%\",\n    sbOnUploaded: \"Uploaded #image_name#\",\n    sizeUnits: \" B, KB, MB\"\n};\n/**\n * Errors displayed to the user, using the `errorCallback` option. Can be used for\n * customization or internationalization.\n */ var errorMessages = {\n    noFileGiven: \"You must select a file.\",\n    typeNotAllowed: \"This image type is not allowed.\",\n    fileTooLarge: \"Image #image_name# is too big (#image_size#).\\n\" + \"Maximum file size is #image_max_size#.\",\n    importError: \"Something went wrong when uploading the image #image_name#.\"\n};\n/**\n * Interface of EasyMDE.\n */ function EasyMDE(options) {\n    // Handle options parameter\n    options = options || {};\n    // Used later to refer to it\"s parent\n    options.parent = this;\n    // Check if Font Awesome needs to be auto downloaded\n    var autoDownloadFA = true;\n    if (options.autoDownloadFontAwesome === false) {\n        autoDownloadFA = false;\n    }\n    if (options.autoDownloadFontAwesome !== true) {\n        var styleSheets = document.styleSheets;\n        for(var i = 0; i < styleSheets.length; i++){\n            if (!styleSheets[i].href) continue;\n            if (styleSheets[i].href.indexOf(\"//maxcdn.bootstrapcdn.com/font-awesome/\") > -1) {\n                autoDownloadFA = false;\n            }\n        }\n    }\n    if (autoDownloadFA) {\n        var link = document.createElement(\"link\");\n        link.rel = \"stylesheet\";\n        link.href = \"https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css\";\n        document.getElementsByTagName(\"head\")[0].appendChild(link);\n    }\n    // Find the textarea to use\n    if (options.element) {\n        this.element = options.element;\n    } else if (options.element === null) {\n        // This means that the element option was specified, but no element was found\n        console.log(\"EasyMDE: Error. No element was found.\");\n        return;\n    }\n    // Handle toolbar\n    if (options.toolbar === undefined) {\n        // Initialize\n        options.toolbar = [];\n        // Loop over the built in buttons, to get the preferred order\n        for(var key in toolbarBuiltInButtons){\n            if (Object.prototype.hasOwnProperty.call(toolbarBuiltInButtons, key)) {\n                if (key.indexOf(\"separator-\") != -1) {\n                    options.toolbar.push(\"|\");\n                }\n                if (toolbarBuiltInButtons[key].default === true || options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1) {\n                    options.toolbar.push(key);\n                }\n            }\n        }\n    }\n    // Editor preview styling class.\n    if (!Object.prototype.hasOwnProperty.call(options, \"previewClass\")) {\n        options.previewClass = \"editor-preview\";\n    }\n    // Handle status bar\n    if (!Object.prototype.hasOwnProperty.call(options, \"status\")) {\n        options.status = [\n            \"autosave\",\n            \"lines\",\n            \"words\",\n            \"cursor\"\n        ];\n        if (options.uploadImage) {\n            options.status.unshift(\"upload-image\");\n        }\n    }\n    // Add default preview rendering function\n    if (!options.previewRender) {\n        options.previewRender = function(plainText) {\n            // Note: \"this\" refers to the options object\n            return this.parent.markdown(plainText);\n        };\n    }\n    // Set default options for parsing config\n    options.parsingConfig = extend({\n        highlightFormatting: true\n    }, options.parsingConfig || {});\n    // Merging the insertTexts, with the given options\n    options.insertTexts = extend({}, insertTexts, options.insertTexts || {});\n    // Merging the promptTexts, with the given options\n    options.promptTexts = extend({}, promptTexts, options.promptTexts || {});\n    // Merging the blockStyles, with the given options\n    options.blockStyles = extend({}, blockStyles, options.blockStyles || {});\n    if (options.autosave != undefined) {\n        // Merging the Autosave timeFormat, with the given options\n        options.autosave.timeFormat = extend({}, timeFormat, options.autosave.timeFormat || {});\n    }\n    options.iconClassMap = extend({}, iconClassMap, options.iconClassMap || {});\n    // Merging the shortcuts, with the given options\n    options.shortcuts = extend({}, shortcuts, options.shortcuts || {});\n    options.maxHeight = options.maxHeight || undefined;\n    options.direction = options.direction || \"ltr\";\n    if (typeof options.maxHeight !== \"undefined\") {\n        // Min and max height are equal if maxHeight is set\n        options.minHeight = options.maxHeight;\n    } else {\n        options.minHeight = options.minHeight || \"300px\";\n    }\n    options.errorCallback = options.errorCallback || function(errorMessage) {\n        alert(errorMessage);\n    };\n    // Import-image default configuration\n    options.uploadImage = options.uploadImage || false;\n    options.imageMaxSize = options.imageMaxSize || 2097152; // 1024 * 1024 * 2\n    options.imageAccept = options.imageAccept || \"image/png, image/jpeg, image/gif, image/avif\";\n    options.imageTexts = extend({}, imageTexts, options.imageTexts || {});\n    options.errorMessages = extend({}, errorMessages, options.errorMessages || {});\n    options.imagePathAbsolute = options.imagePathAbsolute || false;\n    options.imageCSRFName = options.imageCSRFName || \"csrfmiddlewaretoken\";\n    options.imageCSRFHeader = options.imageCSRFHeader || false;\n    options.imageInputName = options.imageInputName || \"image\";\n    // Change unique_id to uniqueId for backwards compatibility\n    if (options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != \"\") options.autosave.uniqueId = options.autosave.unique_id;\n    // If overlay mode is specified and combine is not provided, default it to true\n    if (options.overlayMode && options.overlayMode.combine === undefined) {\n        options.overlayMode.combine = true;\n    }\n    // Update this options\n    this.options = options;\n    // Auto render\n    this.render();\n    // The codemirror component is only available after rendering\n    // so, the setter for the initialValue can only run after\n    // the element has been rendered\n    if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {\n        this.value(options.initialValue);\n    }\n    if (options.uploadImage) {\n        var self = this;\n        this.codemirror.on(\"dragenter\", function(cm, event) {\n            self.updateStatusBar(\"upload-image\", self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on(\"dragend\", function(cm, event) {\n            self.updateStatusBar(\"upload-image\", self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on(\"dragleave\", function(cm, event) {\n            self.updateStatusBar(\"upload-image\", self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on(\"dragover\", function(cm, event) {\n            self.updateStatusBar(\"upload-image\", self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on(\"drop\", function(cm, event) {\n            event.stopPropagation();\n            event.preventDefault();\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.dataTransfer.files);\n            } else {\n                self.uploadImages(event.dataTransfer.files);\n            }\n        });\n        this.codemirror.on(\"paste\", function(cm, event) {\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.clipboardData.files);\n            } else {\n                self.uploadImages(event.clipboardData.files);\n            }\n        });\n    }\n}\n_c = EasyMDE;\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param {FileList} files The files to upload the the server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */ EasyMDE.prototype.uploadImages = function(files, onSuccess, onError) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for(var i = 0; i < files.length; i++){\n        names.push(files[i].name);\n        this.uploadImage(files[i], onSuccess, onError);\n    }\n    this.updateStatusBar(\"upload-image\", this.options.imageTexts.sbOnDrop.replace(\"#images_names#\", names.join(\", \")));\n};\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options.\n * @param {FileList} files The files to upload the the server.\n */ EasyMDE.prototype.uploadImagesUsingCustomFunction = function(imageUploadFunction, files) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for(var i = 0; i < files.length; i++){\n        names.push(files[i].name);\n        this.uploadImageUsingCustomFunction(imageUploadFunction, files[i]);\n    }\n    this.updateStatusBar(\"upload-image\", this.options.imageTexts.sbOnDrop.replace(\"#images_names#\", names.join(\", \")));\n};\n/**\n * Update an item in the status bar.\n * @param itemName {string} The name of the item to update (ie. 'upload-image', 'autosave', etc.).\n * @param content {string} the new content of the item to write in the status bar.\n */ EasyMDE.prototype.updateStatusBar = function(itemName, content) {\n    if (!this.gui.statusbar) {\n        return;\n    }\n    var matchingClasses = this.gui.statusbar.getElementsByClassName(itemName);\n    if (matchingClasses.length === 1) {\n        this.gui.statusbar.getElementsByClassName(itemName)[0].textContent = content;\n    } else if (matchingClasses.length === 0) {\n        console.log(\"EasyMDE: status bar item \" + itemName + \" was not found.\");\n    } else {\n        console.log(\"EasyMDE: Several status bar items named \" + itemName + \" was found.\");\n    }\n};\n/**\n * Default markdown render.\n */ EasyMDE.prototype.markdown = function(text) {\n    if (marked) {\n        // Initialize\n        var markedOptions;\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.markedOptions) {\n            markedOptions = this.options.renderingConfig.markedOptions;\n        } else {\n            markedOptions = {};\n        }\n        // Update options\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {\n            markedOptions.breaks = false;\n        } else {\n            markedOptions.breaks = true;\n        }\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true) {\n            /* Get HLJS from config or window */ var hljs = this.options.renderingConfig.hljs || window.hljs;\n            /* Check if HLJS loaded */ if (hljs) {\n                markedOptions.highlight = function(code, language) {\n                    if (language && hljs.getLanguage(language)) {\n                        return hljs.highlight(language, code).value;\n                    } else {\n                        return hljs.highlightAuto(code).value;\n                    }\n                };\n            }\n        }\n        // Set options\n        marked.use(markedOptions);\n        // Convert the markdown to HTML\n        var htmlText = marked.parse(text);\n        // Sanitize HTML\n        if (this.options.renderingConfig && typeof this.options.renderingConfig.sanitizerFunction === \"function\") {\n            htmlText = this.options.renderingConfig.sanitizerFunction.call(this, htmlText);\n        }\n        // Edit the HTML anchors to add 'target=\"_blank\"' by default.\n        htmlText = addAnchorTargetBlank(htmlText);\n        // Remove list-style when rendering checkboxes\n        htmlText = removeListStyleWhenCheckbox(htmlText);\n        return htmlText;\n    }\n};\n/**\n * Render editor to the given element.\n */ EasyMDE.prototype.render = function(el) {\n    if (!el) {\n        el = this.element || document.getElementsByTagName(\"textarea\")[0];\n    }\n    if (this._rendered && this._rendered === el) {\n        // Already rendered.\n        return;\n    }\n    this.element = el;\n    var options = this.options;\n    var self = this;\n    var keyMaps = {};\n    for(var key in options.shortcuts){\n        // null stands for \"do not bind this command\"\n        if (options.shortcuts[key] !== null && bindings[key] !== null) {\n            (function(key) {\n                keyMaps[fixShortcut(options.shortcuts[key])] = function() {\n                    var action = bindings[key];\n                    if (typeof action === \"function\") {\n                        action(self);\n                    } else if (typeof action === \"string\") {\n                        window.open(action, \"_blank\");\n                    }\n                };\n            })(key);\n        }\n    }\n    keyMaps[\"Enter\"] = \"newlineAndIndentContinueMarkdownList\";\n    keyMaps[\"Tab\"] = \"tabAndIndentMarkdownList\";\n    keyMaps[\"Shift-Tab\"] = \"shiftTabAndUnindentMarkdownList\";\n    keyMaps[\"Esc\"] = function(cm) {\n        if (cm.getOption(\"fullScreen\")) toggleFullScreen(self);\n    };\n    this.documentOnKeyDown = function(e) {\n        e = e || window.event;\n        if (e.keyCode == 27) {\n            if (self.codemirror.getOption(\"fullScreen\")) toggleFullScreen(self);\n        }\n    };\n    document.addEventListener(\"keydown\", this.documentOnKeyDown, false);\n    var mode, backdrop;\n    // CodeMirror overlay mode\n    if (options.overlayMode) {\n        CodeMirror.defineMode(\"overlay-mode\", function(config) {\n            return CodeMirror.overlayMode(CodeMirror.getMode(config, options.spellChecker !== false ? \"spell-checker\" : \"gfm\"), options.overlayMode.mode, options.overlayMode.combine);\n        });\n        mode = \"overlay-mode\";\n        backdrop = options.parsingConfig;\n        backdrop.gitHubSpice = false;\n    } else {\n        mode = options.parsingConfig;\n        mode.name = \"gfm\";\n        mode.gitHubSpice = false;\n    }\n    if (options.spellChecker !== false) {\n        mode = \"spell-checker\";\n        backdrop = options.parsingConfig;\n        backdrop.name = \"gfm\";\n        backdrop.gitHubSpice = false;\n        if (typeof options.spellChecker === \"function\") {\n            options.spellChecker({\n                codeMirrorInstance: CodeMirror\n            });\n        } else {\n            CodeMirrorSpellChecker({\n                codeMirrorInstance: CodeMirror\n            });\n        }\n    }\n    // eslint-disable-next-line no-unused-vars\n    function configureMouse(cm, repeat, event) {\n        return {\n            addNew: false\n        };\n    }\n    this.codemirror = CodeMirror.fromTextArea(el, {\n        mode: mode,\n        backdrop: backdrop,\n        theme: options.theme != undefined ? options.theme : \"easymde\",\n        tabSize: options.tabSize != undefined ? options.tabSize : 2,\n        indentUnit: options.tabSize != undefined ? options.tabSize : 2,\n        indentWithTabs: options.indentWithTabs === false ? false : true,\n        lineNumbers: options.lineNumbers === true ? true : false,\n        autofocus: options.autofocus === true ? true : false,\n        extraKeys: keyMaps,\n        direction: options.direction,\n        lineWrapping: options.lineWrapping === false ? false : true,\n        allowDropFileTypes: [\n            \"text/plain\"\n        ],\n        placeholder: options.placeholder || el.getAttribute(\"placeholder\") || \"\",\n        styleSelectedText: options.styleSelectedText != undefined ? options.styleSelectedText : !isMobile(),\n        scrollbarStyle: options.scrollbarStyle != undefined ? options.scrollbarStyle : \"native\",\n        configureMouse: configureMouse,\n        inputStyle: options.inputStyle != undefined ? options.inputStyle : isMobile() ? \"contenteditable\" : \"textarea\",\n        spellcheck: options.nativeSpellcheck != undefined ? options.nativeSpellcheck : true,\n        autoRefresh: options.autoRefresh != undefined ? options.autoRefresh : false\n    });\n    this.codemirror.getScrollerElement().style.minHeight = options.minHeight;\n    if (typeof options.maxHeight !== \"undefined\") {\n        this.codemirror.getScrollerElement().style.height = options.maxHeight;\n    }\n    if (options.forceSync === true) {\n        var cm = this.codemirror;\n        cm.on(\"change\", function() {\n            cm.save();\n        });\n    }\n    this.gui = {};\n    // Wrap Codemirror with container before create toolbar, etc,\n    // to use with sideBySideFullscreen option.\n    var easyMDEContainer = document.createElement(\"div\");\n    easyMDEContainer.classList.add(\"EasyMDEContainer\");\n    easyMDEContainer.setAttribute(\"role\", \"application\");\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(easyMDEContainer, cmWrapper);\n    easyMDEContainer.appendChild(cmWrapper);\n    if (options.toolbar !== false) {\n        this.gui.toolbar = this.createToolbar();\n    }\n    if (options.status !== false) {\n        this.gui.statusbar = this.createStatusbar();\n    }\n    if (options.autosave != undefined && options.autosave.enabled === true) {\n        this.autosave(); // use to load localstorage content\n        this.codemirror.on(\"change\", function() {\n            clearTimeout(self._autosave_timeout);\n            self._autosave_timeout = setTimeout(function() {\n                self.autosave();\n            }, self.options.autosave.submit_delay || self.options.autosave.delay || 1000);\n        });\n    }\n    function calcHeight(naturalWidth, naturalHeight) {\n        var height;\n        var viewportWidth = window.getComputedStyle(document.querySelector(\".CodeMirror-sizer\")).width.replace(\"px\", \"\");\n        if (naturalWidth < viewportWidth) {\n            height = naturalHeight + \"px\";\n        } else {\n            height = naturalHeight / naturalWidth * 100 + \"%\";\n        }\n        return height;\n    }\n    var _vm = this;\n    function assignImageBlockAttributes(parentEl, img) {\n        var url = new URL(img.url, document.baseURI).href;\n        parentEl.setAttribute(\"data-img-src\", url);\n        parentEl.setAttribute(\"style\", \"--bg-image:url(\" + url + \");--width:\" + img.naturalWidth + \"px;--height:\" + calcHeight(img.naturalWidth, img.naturalHeight));\n        _vm.codemirror.setSize();\n    }\n    function handleImages() {\n        if (!options.previewImagesInEditor) {\n            return;\n        }\n        easyMDEContainer.querySelectorAll(\".cm-image-marker\").forEach(function(e) {\n            var parentEl = e.parentElement;\n            if (!parentEl.innerText.match(/^!\\[.*?\\]\\(.*\\)/g)) {\n                // if img pasted on the same line with other text, don't preview, preview only images on separate line\n                return;\n            }\n            if (!parentEl.hasAttribute(\"data-img-src\")) {\n                var srcAttr = parentEl.innerText.match(/!\\[.*?\\]\\((.*?)\\)/); // might require better parsing according to markdown spec\n                if (!window.EMDEimagesCache) {\n                    window.EMDEimagesCache = {};\n                }\n                if (srcAttr && srcAttr.length >= 2) {\n                    var keySrc = srcAttr[1];\n                    if (options.imagesPreviewHandler) {\n                        var newSrc = options.imagesPreviewHandler(srcAttr[1]);\n                        // defensive check making sure the handler provided by the user returns a string\n                        if (typeof newSrc === \"string\") {\n                            keySrc = newSrc;\n                        }\n                    }\n                    if (!window.EMDEimagesCache[keySrc]) {\n                        window.EMDEimagesCache[keySrc] = {};\n                        var img = document.createElement(\"img\");\n                        img.onload = function() {\n                            window.EMDEimagesCache[keySrc] = {\n                                naturalWidth: img.naturalWidth,\n                                naturalHeight: img.naturalHeight,\n                                url: keySrc\n                            };\n                            assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                        };\n                        img.src = keySrc;\n                    } else {\n                        assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                    }\n                }\n            }\n        });\n    }\n    this.codemirror.on(\"update\", function() {\n        handleImages();\n    });\n    this.gui.sideBySide = this.createSideBySide();\n    this._rendered = this.element;\n    if (options.autofocus === true || el.autofocus) {\n        this.codemirror.focus();\n    }\n    // Fixes CodeMirror bug (#344)\n    var temp_cm = this.codemirror;\n    setTimeout((function() {\n        temp_cm.refresh();\n    }).bind(temp_cm), 0);\n};\nEasyMDE.prototype.cleanup = function() {\n    document.removeEventListener(\"keydown\", this.documentOnKeyDown);\n};\n// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.\nfunction isLocalStorageAvailable() {\n    if (typeof localStorage === \"object\") {\n        try {\n            localStorage.setItem(\"smde_localStorage\", 1);\n            localStorage.removeItem(\"smde_localStorage\");\n        } catch (e) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n    return true;\n}\nEasyMDE.prototype.autosave = function() {\n    if (isLocalStorageAvailable()) {\n        var easyMDE = this;\n        if (this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == \"\") {\n            console.log(\"EasyMDE: You must set a uniqueId to use the autosave feature\");\n            return;\n        }\n        if (this.options.autosave.binded !== true) {\n            if (easyMDE.element.form != null && easyMDE.element.form != undefined) {\n                easyMDE.element.form.addEventListener(\"submit\", function() {\n                    clearTimeout(easyMDE.autosaveTimeoutId);\n                    easyMDE.autosaveTimeoutId = undefined;\n                    localStorage.removeItem(\"smde_\" + easyMDE.options.autosave.uniqueId);\n                });\n            }\n            this.options.autosave.binded = true;\n        }\n        if (this.options.autosave.loaded !== true) {\n            if (typeof localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId) == \"string\" && localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId) != \"\") {\n                this.codemirror.setValue(localStorage.getItem(\"smde_\" + this.options.autosave.uniqueId));\n                this.options.autosave.foundSavedValue = true;\n            }\n            this.options.autosave.loaded = true;\n        }\n        var value = easyMDE.value();\n        if (value !== \"\") {\n            localStorage.setItem(\"smde_\" + this.options.autosave.uniqueId, value);\n        } else {\n            localStorage.removeItem(\"smde_\" + this.options.autosave.uniqueId);\n        }\n        var el = document.getElementById(\"autosaved\");\n        if (el != null && el != undefined && el != \"\") {\n            var d = new Date();\n            var dd = new Intl.DateTimeFormat([\n                this.options.autosave.timeFormat.locale,\n                \"en-US\"\n            ], this.options.autosave.timeFormat.format).format(d);\n            var save = this.options.autosave.text == undefined ? \"Autosaved: \" : this.options.autosave.text;\n            el.innerHTML = save + dd;\n        }\n    } else {\n        console.log(\"EasyMDE: localStorage not available, cannot autosave\");\n    }\n};\nEasyMDE.prototype.clearAutosavedValue = function() {\n    if (isLocalStorageAvailable()) {\n        if (this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == \"\") {\n            console.log(\"EasyMDE: You must set a uniqueId to clear the autosave value\");\n            return;\n        }\n        localStorage.removeItem(\"smde_\" + this.options.autosave.uniqueId);\n    } else {\n        console.log(\"EasyMDE: localStorage not available, cannot autosave\");\n    }\n};\n/**\n * Open the browse-file window to upload an image to a server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */ EasyMDE.prototype.openBrowseFileWindow = function(onSuccess, onError) {\n    var self = this;\n    var imageInput = this.gui.toolbar.getElementsByClassName(\"imageInput\")[0];\n    imageInput.click(); //dispatchEvent(new MouseEvent('click'));  // replaced with click() for IE11 compatibility.\n    function onChange(event) {\n        if (self.options.imageUploadFunction) {\n            self.uploadImagesUsingCustomFunction(self.options.imageUploadFunction, event.target.files);\n        } else {\n            self.uploadImages(event.target.files, onSuccess, onError);\n        }\n        imageInput.removeEventListener(\"change\", onChange);\n    }\n    imageInput.addEventListener(\"change\", onChange);\n};\n/**\n * Upload an image to the server.\n *\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File)\n * @param [onSuccess] {function} A callback function to execute after the image has been successfully uploaded, with one parameter:\n * - url (string): The URL of the uploaded image.\n * @param [onError] {function} A callback function to execute when the image upload fails, with one parameter:\n * - error (string): the detailed error to display to the user (based on messages from options.errorMessages).\n */ EasyMDE.prototype.uploadImage = function(file, onSuccess, onError) {\n    var self = this;\n    onSuccess = onSuccess || function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    };\n    function onErrorSup(errorMessage) {\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar(\"upload-image\", errorMessage);\n        setTimeout(function() {\n            self.updateStatusBar(\"upload-image\", self.options.imageTexts.sbInit);\n        }, 10000);\n        // run custom error handler\n        if (onError && typeof onError === \"function\") {\n            onError(errorMessage);\n        }\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(errorMessage);\n    }\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(\",\");\n        return errorMessage.replace(\"#image_name#\", file.name).replace(\"#image_size#\", humanFileSize(file.size, units)).replace(\"#image_max_size#\", humanFileSize(self.options.imageMaxSize, units));\n    }\n    if (file.size > this.options.imageMaxSize) {\n        onErrorSup(fillErrorMessage(this.options.errorMessages.fileTooLarge));\n        return;\n    }\n    var formData = new FormData();\n    formData.append(\"image\", file);\n    // insert CSRF body token if provided in config.\n    if (self.options.imageCSRFToken && !self.options.imageCSRFHeader) {\n        formData.append(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n    var request = new XMLHttpRequest();\n    request.upload.onprogress = function(event) {\n        if (event.lengthComputable) {\n            var progress = \"\" + Math.round(event.loaded * 100 / event.total);\n            self.updateStatusBar(\"upload-image\", self.options.imageTexts.sbProgress.replace(\"#file_name#\", file.name).replace(\"#progress#\", progress));\n        }\n    };\n    request.open(\"POST\", this.options.imageUploadEndpoint);\n    // insert CSRF header token if provided in config.\n    if (self.options.imageCSRFToken && self.options.imageCSRFHeader) {\n        request.setRequestHeader(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n    request.onload = function() {\n        try {\n            var response = JSON.parse(this.responseText);\n        } catch (error) {\n            console.error(\"EasyMDE: The server did not return a valid json.\");\n            onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            return;\n        }\n        if (this.status === 200 && response && !response.error && response.data && response.data.filePath) {\n            onSuccess((self.options.imagePathAbsolute ? \"\" : window.location.origin + \"/\") + response.data.filePath);\n        } else {\n            if (response.error && response.error in self.options.errorMessages) {\n                onErrorSup(fillErrorMessage(self.options.errorMessages[response.error]));\n            } else if (response.error) {\n                onErrorSup(fillErrorMessage(response.error));\n            } else {\n                console.error(\"EasyMDE: Received an unexpected response after uploading the image.\" + this.status + \" (\" + this.statusText + \")\");\n                onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            }\n        }\n    };\n    request.onerror = function(event) {\n        console.error(\"EasyMDE: An unexpected error occurred when trying to upload the image.\" + event.target.status + \" (\" + event.target.statusText + \")\");\n        onErrorSup(self.options.errorMessages.importError);\n    };\n    request.send(formData);\n};\n/**\n * Upload an image to the server using a custom upload function.\n *\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File).\n */ EasyMDE.prototype.uploadImageUsingCustomFunction = function(imageUploadFunction, file) {\n    var self = this;\n    function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    }\n    function onError(errorMessage) {\n        var filledErrorMessage = fillErrorMessage(errorMessage);\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar(\"upload-image\", filledErrorMessage);\n        setTimeout(function() {\n            self.updateStatusBar(\"upload-image\", self.options.imageTexts.sbInit);\n        }, 10000);\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(filledErrorMessage);\n    }\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(\",\");\n        return errorMessage.replace(\"#image_name#\", file.name).replace(\"#image_size#\", humanFileSize(file.size, units)).replace(\"#image_max_size#\", humanFileSize(self.options.imageMaxSize, units));\n    }\n    imageUploadFunction.apply(this, [\n        file,\n        onSuccess,\n        onError\n    ]);\n};\nEasyMDE.prototype.setPreviewMaxHeight = function() {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n    // Calc preview max height\n    var paddingTop = parseInt(window.getComputedStyle(wrapper).paddingTop);\n    var borderTopWidth = parseInt(window.getComputedStyle(wrapper).borderTopWidth);\n    var optionsMaxHeight = parseInt(this.options.maxHeight);\n    var wrapperMaxHeight = optionsMaxHeight + paddingTop * 2 + borderTopWidth * 2;\n    var previewMaxHeight = wrapperMaxHeight.toString() + \"px\";\n    preview.style.height = previewMaxHeight;\n};\nEasyMDE.prototype.createSideBySide = function() {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n    if (!preview || !preview.classList.contains(\"editor-preview-side\")) {\n        preview = document.createElement(\"div\");\n        preview.className = \"editor-preview-side\";\n        if (this.options.previewClass) {\n            if (Array.isArray(this.options.previewClass)) {\n                for(var i = 0; i < this.options.previewClass.length; i++){\n                    preview.classList.add(this.options.previewClass[i]);\n                }\n            } else if (typeof this.options.previewClass === \"string\") {\n                preview.classList.add(this.options.previewClass);\n            }\n        }\n        wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);\n    }\n    if (typeof this.options.maxHeight !== \"undefined\") {\n        this.setPreviewMaxHeight();\n    }\n    if (this.options.syncSideBySidePreviewScroll === false) return preview;\n    // Syncs scroll  editor -> preview\n    var cScroll = false;\n    var pScroll = false;\n    cm.on(\"scroll\", function(v) {\n        if (cScroll) {\n            cScroll = false;\n            return;\n        }\n        pScroll = true;\n        var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;\n        var ratio = parseFloat(v.getScrollInfo().top) / height;\n        var move = (preview.scrollHeight - preview.clientHeight) * ratio;\n        preview.scrollTop = move;\n    });\n    // Syncs scroll  preview -> editor\n    preview.onscroll = function() {\n        if (pScroll) {\n            pScroll = false;\n            return;\n        }\n        cScroll = true;\n        var height = preview.scrollHeight - preview.clientHeight;\n        var ratio = parseFloat(preview.scrollTop) / height;\n        var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;\n        cm.scrollTo(0, move);\n    };\n    return preview;\n};\nEasyMDE.prototype.createToolbar = function(items) {\n    items = items || this.options.toolbar;\n    if (!items || items.length === 0) {\n        return;\n    }\n    var i;\n    for(i = 0; i < items.length; i++){\n        if (toolbarBuiltInButtons[items[i]] != undefined) {\n            items[i] = toolbarBuiltInButtons[items[i]];\n        }\n    }\n    var bar = document.createElement(\"div\");\n    bar.className = \"editor-toolbar\";\n    bar.setAttribute(\"role\", \"toolbar\");\n    var self = this;\n    var toolbarData = {};\n    self.toolbar = items;\n    for(i = 0; i < items.length; i++){\n        if (items[i].name == \"guide\" && self.options.toolbarGuideIcon === false) continue;\n        if (self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1) continue;\n        // Fullscreen does not work well on mobile devices (even tablets)\n        // In the future, hopefully this can be resolved\n        if ((items[i].name == \"fullscreen\" || items[i].name == \"side-by-side\") && isMobile()) continue;\n        // Don't include trailing separators\n        if (items[i] === \"|\") {\n            var nonSeparatorIconsFollow = false;\n            for(var x = i + 1; x < items.length; x++){\n                if (items[x] !== \"|\" && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {\n                    nonSeparatorIconsFollow = true;\n                }\n            }\n            if (!nonSeparatorIconsFollow) continue;\n        }\n        // Create the icon and append to the toolbar\n        (function(item) {\n            var el;\n            if (item === \"|\") {\n                el = createSep();\n            } else if (item.children) {\n                el = createToolbarDropdown(item, self.options.toolbarTips, self.options.shortcuts, self);\n            } else {\n                el = createToolbarButton(item, true, self.options.toolbarTips, self.options.shortcuts, \"button\", self);\n            }\n            toolbarData[item.name || item] = el;\n            bar.appendChild(el);\n            // Create the input element (ie. <input type='file'>), used among\n            // with the 'import-image' icon to open the browse-file window.\n            if (item.name === \"upload-image\") {\n                var imageInput = document.createElement(\"input\");\n                imageInput.className = \"imageInput\";\n                imageInput.type = \"file\";\n                imageInput.multiple = true;\n                imageInput.name = self.options.imageInputName;\n                imageInput.accept = self.options.imageAccept;\n                imageInput.style.display = \"none\";\n                imageInput.style.opacity = 0;\n                bar.appendChild(imageInput);\n            }\n        })(items[i]);\n    }\n    self.toolbar_div = bar;\n    self.toolbarElements = toolbarData;\n    var cm = this.codemirror;\n    cm.on(\"cursorActivity\", function() {\n        var stat = getState(cm);\n        for(var key in toolbarData){\n            (function(key) {\n                var el = toolbarData[key];\n                if (stat[key]) {\n                    el.classList.add(\"active\");\n                } else if (key != \"fullscreen\" && key != \"side-by-side\") {\n                    el.classList.remove(\"active\");\n                }\n            })(key);\n        }\n    });\n    var cmWrapper = cm.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper);\n    return bar;\n};\nEasyMDE.prototype.createStatusbar = function(status) {\n    // Initialize\n    status = status || this.options.status;\n    var options = this.options;\n    var cm = this.codemirror;\n    // Make sure the status variable is valid\n    if (!status || status.length === 0) {\n        return;\n    }\n    // Set up the built-in items\n    var items = [];\n    var i, onUpdate, onActivity, defaultValue;\n    for(i = 0; i < status.length; i++){\n        // Reset some values\n        onUpdate = undefined;\n        onActivity = undefined;\n        defaultValue = undefined;\n        // Handle if custom or not\n        if (typeof status[i] === \"object\") {\n            items.push({\n                className: status[i].className,\n                defaultValue: status[i].defaultValue,\n                onUpdate: status[i].onUpdate,\n                onActivity: status[i].onActivity\n            });\n        } else {\n            var name = status[i];\n            if (name === \"words\") {\n                defaultValue = function(el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n                onUpdate = function(el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n            } else if (name === \"lines\") {\n                defaultValue = function(el) {\n                    el.innerHTML = cm.lineCount();\n                };\n                onUpdate = function(el) {\n                    el.innerHTML = cm.lineCount();\n                };\n            } else if (name === \"cursor\") {\n                defaultValue = function(el) {\n                    el.innerHTML = \"1:1\";\n                };\n                onActivity = function(el) {\n                    var pos = cm.getCursor();\n                    var posLine = pos.line + 1;\n                    var posColumn = pos.ch + 1;\n                    el.innerHTML = posLine + \":\" + posColumn;\n                };\n            } else if (name === \"autosave\") {\n                defaultValue = function(el) {\n                    if (options.autosave != undefined && options.autosave.enabled === true) {\n                        el.setAttribute(\"id\", \"autosaved\");\n                    }\n                };\n            } else if (name === \"upload-image\") {\n                defaultValue = function(el) {\n                    el.innerHTML = options.imageTexts.sbInit;\n                };\n            }\n            items.push({\n                className: name,\n                defaultValue: defaultValue,\n                onUpdate: onUpdate,\n                onActivity: onActivity\n            });\n        }\n    }\n    // Create element for the status bar\n    var bar = document.createElement(\"div\");\n    bar.className = \"editor-statusbar\";\n    // Create a new span for each item\n    for(i = 0; i < items.length; i++){\n        // Store in temporary variable\n        var item = items[i];\n        // Create span element\n        var el = document.createElement(\"span\");\n        el.className = item.className;\n        // Ensure the defaultValue is a function\n        if (typeof item.defaultValue === \"function\") {\n            item.defaultValue(el);\n        }\n        // Ensure the onUpdate is a function\n        if (typeof item.onUpdate === \"function\") {\n            // Create a closure around the span of the current action, then execute the onUpdate handler\n            this.codemirror.on(\"update\", function(el, item) {\n                return function() {\n                    item.onUpdate(el);\n                };\n            }(el, item));\n        }\n        if (typeof item.onActivity === \"function\") {\n            // Create a closure around the span of the current action, then execute the onActivity handler\n            this.codemirror.on(\"cursorActivity\", function(el, item) {\n                return function() {\n                    item.onActivity(el);\n                };\n            }(el, item));\n        }\n        // Append the item to the status bar\n        bar.appendChild(el);\n    }\n    // Insert the status bar into the DOM\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);\n    return bar;\n};\n/**\n * Get or set the text content.\n */ EasyMDE.prototype.value = function(val) {\n    var cm = this.codemirror;\n    if (val === undefined) {\n        return cm.getValue();\n    } else {\n        cm.getDoc().setValue(val);\n        if (this.isPreviewActive()) {\n            var wrapper = cm.getWrapperElement();\n            var preview = wrapper.lastChild;\n            var preview_result = this.options.previewRender(val, preview);\n            if (preview_result !== null) {\n                preview.innerHTML = preview_result;\n            }\n        }\n        return this;\n    }\n};\n/**\n * Bind static methods for exports.\n */ EasyMDE.toggleBold = toggleBold;\nEasyMDE.toggleItalic = toggleItalic;\nEasyMDE.toggleStrikethrough = toggleStrikethrough;\nEasyMDE.toggleBlockquote = toggleBlockquote;\nEasyMDE.toggleHeadingSmaller = toggleHeadingSmaller;\nEasyMDE.toggleHeadingBigger = toggleHeadingBigger;\nEasyMDE.toggleHeading1 = toggleHeading1;\nEasyMDE.toggleHeading2 = toggleHeading2;\nEasyMDE.toggleHeading3 = toggleHeading3;\nEasyMDE.toggleHeading4 = toggleHeading4;\nEasyMDE.toggleHeading5 = toggleHeading5;\nEasyMDE.toggleHeading6 = toggleHeading6;\nEasyMDE.toggleCodeBlock = toggleCodeBlock;\nEasyMDE.toggleUnorderedList = toggleUnorderedList;\nEasyMDE.toggleOrderedList = toggleOrderedList;\nEasyMDE.cleanBlock = cleanBlock;\nEasyMDE.drawLink = drawLink;\nEasyMDE.drawImage = drawImage;\nEasyMDE.drawUploadedImage = drawUploadedImage;\nEasyMDE.drawTable = drawTable;\nEasyMDE.drawHorizontalRule = drawHorizontalRule;\nEasyMDE.undo = undo;\nEasyMDE.redo = redo;\nEasyMDE.togglePreview = togglePreview;\nEasyMDE.toggleSideBySide = toggleSideBySide;\nEasyMDE.toggleFullScreen = toggleFullScreen;\n/**\n * Bind instance methods for exports.\n */ EasyMDE.prototype.toggleBold = function() {\n    toggleBold(this);\n};\nEasyMDE.prototype.toggleItalic = function() {\n    toggleItalic(this);\n};\nEasyMDE.prototype.toggleStrikethrough = function() {\n    toggleStrikethrough(this);\n};\nEasyMDE.prototype.toggleBlockquote = function() {\n    toggleBlockquote(this);\n};\nEasyMDE.prototype.toggleHeadingSmaller = function() {\n    toggleHeadingSmaller(this);\n};\nEasyMDE.prototype.toggleHeadingBigger = function() {\n    toggleHeadingBigger(this);\n};\nEasyMDE.prototype.toggleHeading1 = function() {\n    toggleHeading1(this);\n};\nEasyMDE.prototype.toggleHeading2 = function() {\n    toggleHeading2(this);\n};\nEasyMDE.prototype.toggleHeading3 = function() {\n    toggleHeading3(this);\n};\nEasyMDE.prototype.toggleHeading4 = function() {\n    toggleHeading4(this);\n};\nEasyMDE.prototype.toggleHeading5 = function() {\n    toggleHeading5(this);\n};\nEasyMDE.prototype.toggleHeading6 = function() {\n    toggleHeading6(this);\n};\nEasyMDE.prototype.toggleCodeBlock = function() {\n    toggleCodeBlock(this);\n};\nEasyMDE.prototype.toggleUnorderedList = function() {\n    toggleUnorderedList(this);\n};\nEasyMDE.prototype.toggleOrderedList = function() {\n    toggleOrderedList(this);\n};\nEasyMDE.prototype.cleanBlock = function() {\n    cleanBlock(this);\n};\nEasyMDE.prototype.drawLink = function() {\n    drawLink(this);\n};\nEasyMDE.prototype.drawImage = function() {\n    drawImage(this);\n};\nEasyMDE.prototype.drawUploadedImage = function() {\n    drawUploadedImage(this);\n};\nEasyMDE.prototype.drawTable = function() {\n    drawTable(this);\n};\nEasyMDE.prototype.drawHorizontalRule = function() {\n    drawHorizontalRule(this);\n};\nEasyMDE.prototype.undo = function() {\n    undo(this);\n};\nEasyMDE.prototype.redo = function() {\n    redo(this);\n};\nEasyMDE.prototype.togglePreview = function() {\n    togglePreview(this);\n};\nEasyMDE.prototype.toggleSideBySide = function() {\n    toggleSideBySide(this);\n};\nEasyMDE.prototype.toggleFullScreen = function() {\n    toggleFullScreen(this);\n};\nEasyMDE.prototype.isPreviewActive = function() {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.lastChild;\n    return preview.classList.contains(\"editor-preview-active\");\n};\nEasyMDE.prototype.isSideBySideActive = function() {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n    return preview.classList.contains(\"editor-preview-active-side\");\n};\nEasyMDE.prototype.isFullscreenActive = function() {\n    var cm = this.codemirror;\n    return cm.getOption(\"fullScreen\");\n};\nEasyMDE.prototype.getState = function() {\n    var cm = this.codemirror;\n    return getState(cm);\n};\nEasyMDE.prototype.toTextArea = function() {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var easyMDEContainer = wrapper.parentNode;\n    if (easyMDEContainer) {\n        if (this.gui.toolbar) {\n            easyMDEContainer.removeChild(this.gui.toolbar);\n        }\n        if (this.gui.statusbar) {\n            easyMDEContainer.removeChild(this.gui.statusbar);\n        }\n        if (this.gui.sideBySide) {\n            easyMDEContainer.removeChild(this.gui.sideBySide);\n        }\n    }\n    // Unwrap easyMDEcontainer before codemirror toTextArea() call\n    easyMDEContainer.parentNode.insertBefore(wrapper, easyMDEContainer);\n    easyMDEContainer.remove();\n    cm.toTextArea();\n    if (this.autosaveTimeoutId) {\n        clearTimeout(this.autosaveTimeoutId);\n        this.autosaveTimeoutId = undefined;\n        this.clearAutosavedValue();\n    }\n};\nmodule.exports = EasyMDE;\nvar _c;\n$RefreshReg$(_c, \"EasyMDE\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lYXN5bWRlL3NyYy9qcy9lYXN5bWRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDekJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUMseUJBQXlCRCxtQkFBT0EsQ0FBQztBQUNyQyxJQUFJRSxTQUFTRixzR0FBd0I7QUFHckMsaUJBQWlCO0FBQ2pCLElBQUlHLFFBQVEsTUFBTUMsSUFBSSxDQUFDQyxVQUFVQyxRQUFRO0FBQ3pDLElBQUlDLHdCQUF3QixJQUFJQyxPQUFPO0FBRXZDLGdGQUFnRjtBQUNoRixJQUFJQyxXQUFXO0lBQ1gsY0FBY0M7SUFDZCxnQkFBZ0JDO0lBQ2hCLFlBQVlDO0lBQ1osd0JBQXdCQztJQUN4Qix1QkFBdUJDO0lBQ3ZCLGFBQWFDO0lBQ2Isb0JBQW9CQztJQUNwQixxQkFBcUJDO0lBQ3JCLHVCQUF1QkM7SUFDdkIsbUJBQW1CQztJQUNuQixpQkFBaUJDO0lBQ2pCLHVCQUF1QkM7SUFDdkIsa0JBQWtCQztJQUNsQixrQkFBa0JDO0lBQ2xCLGtCQUFrQkM7SUFDbEIsa0JBQWtCQztJQUNsQixrQkFBa0JDO0lBQ2xCLGtCQUFrQkM7SUFDbEIsY0FBY0M7SUFDZCxhQUFhQztJQUNiLHNCQUFzQkM7SUFDdEIsUUFBUUM7SUFDUixRQUFRQztJQUNSLG9CQUFvQkM7SUFDcEIsb0JBQW9CQztBQUN4QjtBQUVBLElBQUlDLFlBQVk7SUFDWixjQUFjO0lBQ2QsZ0JBQWdCO0lBQ2hCLFlBQVk7SUFDWix3QkFBd0I7SUFD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d0YsVUFBVSxFQUFFO1lBQ3JCdlQsaUJBQWlCNlosV0FBVyxDQUFDLElBQUksQ0FBQzlMLEdBQUcsQ0FBQ3dGLFVBQVU7UUFDcEQ7SUFDSjtJQUVBLDhEQUE4RDtJQUM5RHZULGlCQUFpQkMsVUFBVSxDQUFDbVIsWUFBWSxDQUFDMVIsU0FBU007SUFDbERBLGlCQUFpQkUsTUFBTTtJQUV2QmhDLEdBQUcwYixVQUFVO0lBRWIsSUFBSSxJQUFJLENBQUN4RixpQkFBaUIsRUFBRTtRQUN4QjVDLGFBQWEsSUFBSSxDQUFDNEMsaUJBQWlCO1FBQ25DLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUcxWDtRQUN6QixJQUFJLENBQUNvWSxtQkFBbUI7SUFDNUI7QUFDSjtBQUVBZ0YsT0FBT0MsT0FBTyxHQUFHaFAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Vhc3ltZGUvc3JjL2pzL2Vhc3ltZGUuanM/MWRmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgQ29kZU1pcnJvciA9IHJlcXVpcmUoJ2NvZGVtaXJyb3InKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vZWRpdC9jb250aW51ZWxpc3QuanMnKTtcbnJlcXVpcmUoJy4vY29kZW1pcnJvci90YWJsaXN0Jyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvZnVsbHNjcmVlbi5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9tb2RlL21hcmtkb3duL21hcmtkb3duLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL21vZGUvb3ZlcmxheS5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L3BsYWNlaG9sZGVyLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvYXV0b3JlZnJlc2guanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vc2VsZWN0aW9uL21hcmstc2VsZWN0aW9uLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3IuanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvbW9kZS9nZm0vZ2ZtLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL21vZGUveG1sL3htbC5qcycpO1xudmFyIENvZGVNaXJyb3JTcGVsbENoZWNrZXIgPSByZXF1aXJlKCdjb2RlbWlycm9yLXNwZWxsLWNoZWNrZXInKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKS5tYXJrZWQ7XG5cblxuLy8gU29tZSB2YXJpYWJsZXNcbnZhciBpc01hYyA9IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciBhbmNob3JUb0V4dGVybmFsUmVnZXggPSBuZXcgUmVnRXhwKC8oPGEuKj9odHRwcz86XFwvXFwvLio/W15hXT4pKz8vZyk7XG5cbi8vIE1hcHBpbmcgb2YgYWN0aW9ucyB0aGF0IGNhbiBiZSBib3VuZCB0byBrZXlib2FyZCBzaG9ydGN1dHMgb3IgdG9vbGJhciBidXR0b25zXG52YXIgYmluZGluZ3MgPSB7XG4gICAgJ3RvZ2dsZUJvbGQnOiB0b2dnbGVCb2xkLFxuICAgICd0b2dnbGVJdGFsaWMnOiB0b2dnbGVJdGFsaWMsXG4gICAgJ2RyYXdMaW5rJzogZHJhd0xpbmssXG4gICAgJ3RvZ2dsZUhlYWRpbmdTbWFsbGVyJzogdG9nZ2xlSGVhZGluZ1NtYWxsZXIsXG4gICAgJ3RvZ2dsZUhlYWRpbmdCaWdnZXInOiB0b2dnbGVIZWFkaW5nQmlnZ2VyLFxuICAgICdkcmF3SW1hZ2UnOiBkcmF3SW1hZ2UsXG4gICAgJ3RvZ2dsZUJsb2NrcXVvdGUnOiB0b2dnbGVCbG9ja3F1b3RlLFxuICAgICd0b2dnbGVPcmRlcmVkTGlzdCc6IHRvZ2dsZU9yZGVyZWRMaXN0LFxuICAgICd0b2dnbGVVbm9yZGVyZWRMaXN0JzogdG9nZ2xlVW5vcmRlcmVkTGlzdCxcbiAgICAndG9nZ2xlQ29kZUJsb2NrJzogdG9nZ2xlQ29kZUJsb2NrLFxuICAgICd0b2dnbGVQcmV2aWV3JzogdG9nZ2xlUHJldmlldyxcbiAgICAndG9nZ2xlU3RyaWtldGhyb3VnaCc6IHRvZ2dsZVN0cmlrZXRocm91Z2gsXG4gICAgJ3RvZ2dsZUhlYWRpbmcxJzogdG9nZ2xlSGVhZGluZzEsXG4gICAgJ3RvZ2dsZUhlYWRpbmcyJzogdG9nZ2xlSGVhZGluZzIsXG4gICAgJ3RvZ2dsZUhlYWRpbmczJzogdG9nZ2xlSGVhZGluZzMsXG4gICAgJ3RvZ2dsZUhlYWRpbmc0JzogdG9nZ2xlSGVhZGluZzQsXG4gICAgJ3RvZ2dsZUhlYWRpbmc1JzogdG9nZ2xlSGVhZGluZzUsXG4gICAgJ3RvZ2dsZUhlYWRpbmc2JzogdG9nZ2xlSGVhZGluZzYsXG4gICAgJ2NsZWFuQmxvY2snOiBjbGVhbkJsb2NrLFxuICAgICdkcmF3VGFibGUnOiBkcmF3VGFibGUsXG4gICAgJ2RyYXdIb3Jpem9udGFsUnVsZSc6IGRyYXdIb3Jpem9udGFsUnVsZSxcbiAgICAndW5kbyc6IHVuZG8sXG4gICAgJ3JlZG8nOiByZWRvLFxuICAgICd0b2dnbGVTaWRlQnlTaWRlJzogdG9nZ2xlU2lkZUJ5U2lkZSxcbiAgICAndG9nZ2xlRnVsbFNjcmVlbic6IHRvZ2dsZUZ1bGxTY3JlZW4sXG59O1xuXG52YXIgc2hvcnRjdXRzID0ge1xuICAgICd0b2dnbGVCb2xkJzogJ0NtZC1CJyxcbiAgICAndG9nZ2xlSXRhbGljJzogJ0NtZC1JJyxcbiAgICAnZHJhd0xpbmsnOiAnQ21kLUsnLFxuICAgICd0b2dnbGVIZWFkaW5nU21hbGxlcic6ICdDbWQtSCcsXG4gICAgJ3RvZ2dsZUhlYWRpbmdCaWdnZXInOiAnU2hpZnQtQ21kLUgnLFxuICAgICd0b2dnbGVIZWFkaW5nMSc6ICdDdHJsK0FsdCsxJyxcbiAgICAndG9nZ2xlSGVhZGluZzInOiAnQ3RybCtBbHQrMicsXG4gICAgJ3RvZ2dsZUhlYWRpbmczJzogJ0N0cmwrQWx0KzMnLFxuICAgICd0b2dnbGVIZWFkaW5nNCc6ICdDdHJsK0FsdCs0JyxcbiAgICAndG9nZ2xlSGVhZGluZzUnOiAnQ3RybCtBbHQrNScsXG4gICAgJ3RvZ2dsZUhlYWRpbmc2JzogJ0N0cmwrQWx0KzYnLFxuICAgICdjbGVhbkJsb2NrJzogJ0NtZC1FJyxcbiAgICAnZHJhd0ltYWdlJzogJ0NtZC1BbHQtSScsXG4gICAgJ3RvZ2dsZUJsb2NrcXVvdGUnOiAnQ21kLVxcJycsXG4gICAgJ3RvZ2dsZU9yZGVyZWRMaXN0JzogJ0NtZC1BbHQtTCcsXG4gICAgJ3RvZ2dsZVVub3JkZXJlZExpc3QnOiAnQ21kLUwnLFxuICAgICd0b2dnbGVDb2RlQmxvY2snOiAnQ21kLUFsdC1DJyxcbiAgICAndG9nZ2xlUHJldmlldyc6ICdDbWQtUCcsXG4gICAgJ3RvZ2dsZVNpZGVCeVNpZGUnOiAnRjknLFxuICAgICd0b2dnbGVGdWxsU2NyZWVuJzogJ0YxMScsXG59O1xuXG52YXIgZ2V0QmluZGluZ05hbWUgPSBmdW5jdGlvbiAoZikge1xuICAgIGZvciAodmFyIGtleSBpbiBiaW5kaW5ncykge1xuICAgICAgICBpZiAoYmluZGluZ3Nba2V5XSA9PT0gZikge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBpc01vYmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hlY2sgPSBmYWxzZTtcbiAgICAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm98YW5kcm9pZHxpcGFkfHBsYXlib29rfHNpbGsvaS50ZXN0KGEpIHx8IC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3LShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtLXxjZWxsfGNodG18Y2xkY3xjbWQtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8LWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseSgtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmLTV8Zy1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkLShtfHB8dCl8aGVpLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzLWN8aHQoYygtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aS0oMjB8Z298bWEpfGkyMzB8aWFjKCB8LXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHwtW2Etd10pfGxpYnd8bHlueHxtMS13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bS1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dCgtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSktfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3wtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdC1nfHFhLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8LVsyLTddfGktKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aC18b298cC0pfHNka1xcL3xzZShjKC18MHwxKXw0N3xtY3xuZHxyaSl8c2doLXxzaGFyfHNpZSgtfG0pfHNrLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aC18di18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2wtfHRkZy18dGVsKGl8bSl8dGltLXx0LW1vfHRvKHBsfHNoKXx0cyg3MHxtLXxtM3xtNSl8dHgtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118LXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhcy18eW91cnx6ZXRvfHp0ZS0vaS50ZXN0KGEuc3Vic3RyKDAsIDQpKSkgY2hlY2sgPSB0cnVlO1xuICAgIH0pKG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmEpO1xuICAgIHJldHVybiBjaGVjaztcbn07XG5cbi8qKlxuICogTW9kaWZ5IEhUTUwgdG8gYWRkICd0YXJnZXQ9XCJfYmxhbmtcIicgdG8gbGlua3Mgc28gdGhleSBvcGVuIGluIG5ldyB0YWJzIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFRleHQgLSBIVE1MIHRvIGJlIG1vZGlmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbW9kaWZpZWQgSFRNTCB0ZXh0LlxuICovXG5mdW5jdGlvbiBhZGRBbmNob3JUYXJnZXRCbGFuayhodG1sVGV4dCkge1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gYW5jaG9yVG9FeHRlcm5hbFJlZ2V4LmV4ZWMoaHRtbFRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXaXRoIG9ubHkgb25lIGNhcHR1cmUgZ3JvdXAgaW4gdGhlIFJlZ0V4cCwgd2UgY2FuIHNhZmVseSB0YWtlIHRoZSBmaXJzdCBpbmRleCBmcm9tIHRoZSBtYXRjaC5cbiAgICAgICAgdmFyIGxpbmtTdHJpbmcgPSBtYXRjaFswXTtcblxuICAgICAgICBpZiAobGlua1N0cmluZy5pbmRleE9mKCd0YXJnZXQ9JykgPT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgZml4ZWRMaW5rU3RyaW5nID0gbGlua1N0cmluZy5yZXBsYWNlKC8+JC8sICcgdGFyZ2V0PVwiX2JsYW5rXCI+Jyk7XG4gICAgICAgICAgICBodG1sVGV4dCA9IGh0bWxUZXh0LnJlcGxhY2UobGlua1N0cmluZywgZml4ZWRMaW5rU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbFRleHQ7XG59XG5cbi8qKlxuICogTW9kaWZ5IEhUTUwgdG8gcmVtb3ZlIHRoZSBsaXN0LXN0eWxlIHdoZW4gcmVuZGVyaW5nIGNoZWNrYm94ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFRleHQgLSBIVE1MIHRvIGJlIG1vZGlmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbW9kaWZpZWQgSFRNTCB0ZXh0LlxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0U3R5bGVXaGVuQ2hlY2tib3goaHRtbFRleHQpIHtcblxuICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgdmFyIGh0bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGh0bWxUZXh0LCAndGV4dC9odG1sJyk7XG4gICAgdmFyIGxpc3RJdGVtcyA9IGh0bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSBsaXN0SXRlbXNbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaXN0SXRlbS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGxpc3RJdGVtQ2hpbGQgPSBsaXN0SXRlbS5jaGlsZHJlbltqXTtcblxuICAgICAgICAgICAgaWYgKGxpc3RJdGVtQ2hpbGQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIGxpc3RJdGVtQ2hpbGQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgICAgIC8vIEZyb20gR2l0aHViOiBtYXJnaW46IDAgLjJlbSAuMjVlbSAtMS42ZW07XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc3R5bGUubWFyZ2luTGVmdCA9ICctMS41ZW0nO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLnN0eWxlLmxpc3RTdHlsZVR5cGUgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbERvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIEZpeCBzaG9ydGN1dC4gTWFjIHVzZSBDb21tYW5kLCBvdGhlcnMgdXNlIEN0cmwuXG4gKi9cbmZ1bmN0aW9uIGZpeFNob3J0Y3V0KG5hbWUpIHtcbiAgICBpZiAoaXNNYWMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgnQ3RybCcsICdDbWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKCdDbWQnLCAnQ3RybCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgZHJvcGRvd24gYmxvY2tcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9vbGJhckRyb3Bkb3duKG9wdGlvbnMsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsIHBhcmVudCkge1xuICAgIHZhciBlbCA9IGNyZWF0ZVRvb2xiYXJCdXR0b24ob3B0aW9ucywgZmFsc2UsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsICdidXR0b24nLCBwYXJlbnQpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2Vhc3ltZGUtZHJvcGRvd24nKTtcblxuICAgIGVsLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudC5jbGFzc05hbWUgPSAnZWFzeW1kZS1kcm9wZG93bi1jb250ZW50JztcbiAgICBmb3IgKHZhciBjaGlsZHJlbkluZGV4ID0gMDsgY2hpbGRyZW5JbmRleCA8IG9wdGlvbnMuY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZHJlbkluZGV4KyspIHtcblxuICAgICAgICB2YXIgY2hpbGQgPSBvcHRpb25zLmNoaWxkcmVuW2NoaWxkcmVuSW5kZXhdO1xuICAgICAgICB2YXIgY2hpbGRFbGVtZW50O1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnICYmIGNoaWxkIGluIHRvb2xiYXJCdWlsdEluQnV0dG9ucykge1xuICAgICAgICAgICAgY2hpbGRFbGVtZW50ID0gY3JlYXRlVG9vbGJhckJ1dHRvbih0b29sYmFyQnVpbHRJbkJ1dHRvbnNbY2hpbGRdLCB0cnVlLCBlbmFibGVUb29sdGlwcywgc2hvcnRjdXRzLCAnYnV0dG9uJywgcGFyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkRWxlbWVudCA9IGNyZWF0ZVRvb2xiYXJCdXR0b24oY2hpbGQsIHRydWUsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsICdidXR0b24nLCBwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfSwgZmFsc2UpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGNoaWxkRWxlbWVudCk7XG4gICAgfVxuICAgIGVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYnV0dG9uIGVsZW1lbnQgZm9yIHRvb2xiYXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2xiYXJCdXR0b24ob3B0aW9ucywgZW5hYmxlQWN0aW9ucywgZW5hYmxlVG9vbHRpcHMsIHNob3J0Y3V0cywgbWFya3VwLCBwYXJlbnQpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgJ2N1c3RvbScgYXR0cmlidXRlcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gdGhhdCAnb2ZmaWNpYWwnIGF0dHJpYnV0ZXMgd2lsbCBuZXZlciBiZSBvdmVyd3JpdHRlbi5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZVByZWZpeCA9IHBhcmVudC5vcHRpb25zLnRvb2xiYXJCdXR0b25DbGFzc1ByZWZpeCA/IHBhcmVudC5vcHRpb25zLnRvb2xiYXJCdXR0b25DbGFzc1ByZWZpeCArICctJyA6ICcnO1xuICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVByZWZpeCArIG9wdGlvbnMubmFtZTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCBtYXJrdXApO1xuICAgIGVuYWJsZVRvb2x0aXBzID0gKGVuYWJsZVRvb2x0aXBzID09IHVuZGVmaW5lZCkgPyB0cnVlIDogZW5hYmxlVG9vbHRpcHM7XG5cbiAgICBpZiAob3B0aW9ucy50ZXh0KSB7XG4gICAgICAgIGVsLmlubmVyVGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICB9XG5cbiAgICAvLyBQcm9wZXJseSBoYW5kbGUgY3VzdG9tIHNob3J0Y3V0c1xuICAgIGlmIChvcHRpb25zLm5hbWUgJiYgb3B0aW9ucy5uYW1lIGluIHNob3J0Y3V0cykge1xuICAgICAgICBiaW5kaW5nc1tvcHRpb25zLm5hbWVdID0gb3B0aW9ucy5hY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgZW5hYmxlVG9vbHRpcHMpIHtcbiAgICAgICAgZWwudGl0bGUgPSBjcmVhdGVUb29sdGlwKG9wdGlvbnMudGl0bGUsIG9wdGlvbnMuYWN0aW9uLCBzaG9ydGN1dHMpO1xuXG4gICAgICAgIGlmIChpc01hYykge1xuICAgICAgICAgICAgZWwudGl0bGUgPSBlbC50aXRsZS5yZXBsYWNlKCdDdHJsJywgJ+KMmCcpO1xuICAgICAgICAgICAgZWwudGl0bGUgPSBlbC50aXRsZS5yZXBsYWNlKCdBbHQnLCAn4oylJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBvcHRpb25zLnRpdGxlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub0Rpc2FibGUpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbm8tZGlzYWJsZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vTW9iaWxlKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ25vLW1vYmlsZScpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZXJyb3JzIGlmIHRoZXJlIGlzIG5vIGNsYXNzIG5hbWUgaW4gY3VzdG9tIG9wdGlvbnNcbiAgICB2YXIgY2xhc3NOYW1lUGFydHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2xhc3NOYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjbGFzc05hbWVQYXJ0cyA9IG9wdGlvbnMuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgLy8gUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHNpbXBsZS1tYXJrZG93bi1lZGl0b3IgYnkgYWRkaW5nIGN1c3RvbSBjbGFzc2VzIHRvIHRoZSBidXR0b24uXG4gICAgdmFyIGljb25DbGFzc2VzID0gW107XG4gICAgZm9yICh2YXIgY2xhc3NOYW1lSW5kZXggPSAwOyBjbGFzc05hbWVJbmRleCA8IGNsYXNzTmFtZVBhcnRzLmxlbmd0aDsgY2xhc3NOYW1lSW5kZXgrKykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lUGFydCA9IGNsYXNzTmFtZVBhcnRzW2NsYXNzTmFtZUluZGV4XTtcbiAgICAgICAgLy8gU3BsaXQgaWNvbiBjbGFzc2VzIGZyb20gdGhlIGJ1dHRvbi5cbiAgICAgICAgLy8gUmVnZXggd2lsbCBkZXRlY3QgXCJmYVwiLCBcImZhc1wiLCBcImZhLXNvbWV0aGluZ1wiIGFuZCBcImZhLXNvbWUtaWNvbi0xXCIsIGJ1dCBub3QgXCJmYW5mYXJlXCIuXG4gICAgICAgIGlmIChjbGFzc05hbWVQYXJ0Lm1hdGNoKC9eZmEoW3NybGJdfCgtW1xcdy1dKil8JCkvKSkge1xuICAgICAgICAgICAgaWNvbkNsYXNzZXMucHVzaChjbGFzc05hbWVQYXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lUGFydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbC50YWJJbmRleCA9IC0xO1xuXG4gICAgaWYgKGljb25DbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ3JlYXRlIGljb24gZWxlbWVudCBhbmQgYXBwZW5kIGFzIGEgY2hpbGQgdG8gdGhlIGJ1dHRvblxuICAgICAgICB2YXIgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcbiAgICAgICAgZm9yICh2YXIgaWNvbkNsYXNzSW5kZXggPSAwOyBpY29uQ2xhc3NJbmRleCA8IGljb25DbGFzc2VzLmxlbmd0aDsgaWNvbkNsYXNzSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGljb25DbGFzcyA9IGljb25DbGFzc2VzW2ljb25DbGFzc0luZGV4XTtcbiAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChpY29uQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGljb24pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgY3VzdG9tIGljb24gbWFya3VwIHNldCwgdXNlIHRoYXRcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaWNvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gb3B0aW9ucy5pY29uO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFjdGlvbiAmJiBlbmFibGVBY3Rpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVsLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFjdGlvbihwYXJlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5hY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4ob3B0aW9ucy5hY3Rpb24sICdfYmxhbmsnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG4gICAgZWwuY2xhc3NOYW1lID0gJ3NlcGFyYXRvcic7XG4gICAgZWwuaW5uZXJIVE1MID0gJ3wnO1xuICAgIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcCh0aXRsZSwgYWN0aW9uLCBzaG9ydGN1dHMpIHtcbiAgICB2YXIgYWN0aW9uTmFtZTtcbiAgICB2YXIgdG9vbHRpcCA9IHRpdGxlO1xuXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgICBhY3Rpb25OYW1lID0gZ2V0QmluZGluZ05hbWUoYWN0aW9uKTtcbiAgICAgICAgaWYgKHNob3J0Y3V0c1thY3Rpb25OYW1lXSkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSAnICgnICsgZml4U2hvcnRjdXQoc2hvcnRjdXRzW2FjdGlvbk5hbWVdKSArICcpJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b29sdGlwO1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSBvZiBDb2RlTWlycm9yIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGUoY20sIHBvcykge1xuICAgIHBvcyA9IHBvcyB8fCBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIHN0YXQgPSBjbS5nZXRUb2tlbkF0KHBvcyk7XG4gICAgaWYgKCFzdGF0LnR5cGUpIHJldHVybiB7fTtcblxuICAgIHZhciB0eXBlcyA9IHN0YXQudHlwZS5zcGxpdCgnICcpO1xuXG4gICAgdmFyIHJldCA9IHt9LFxuICAgICAgICBkYXRhLCB0ZXh0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAoZGF0YSA9PT0gJ3N0cm9uZycpIHtcbiAgICAgICAgICAgIHJldC5ib2xkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAndmFyaWFibGUtMicpIHtcbiAgICAgICAgICAgIHRleHQgPSBjbS5nZXRMaW5lKHBvcy5saW5lKTtcbiAgICAgICAgICAgIGlmICgvXlxccypcXGQrXFwuXFxzLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0WydvcmRlcmVkLWxpc3QnXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldFsndW5vcmRlcmVkLWxpc3QnXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2F0b20nKSB7XG4gICAgICAgICAgICByZXQucXVvdGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdlbScpIHtcbiAgICAgICAgICAgIHJldC5pdGFsaWMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdxdW90ZScpIHtcbiAgICAgICAgICAgIHJldC5xdW90ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ3N0cmlrZXRocm91Z2gnKSB7XG4gICAgICAgICAgICByZXQuc3RyaWtldGhyb3VnaCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICAgICAgICByZXQuY29kZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2xpbmsnICYmICFyZXQuaW1hZ2UpIHtcbiAgICAgICAgICAgIHJldC5saW5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICByZXQuaW1hZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubWF0Y2goL15oZWFkZXIoLVsxLTZdKT8kLykpIHtcbiAgICAgICAgICAgIHJldFtkYXRhLnJlcGxhY2UoJ2hlYWRlcicsICdoZWFkaW5nJyldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5cbi8vIFNhdmVkIG92ZXJmbG93IHNldHRpbmdcbnZhciBzYXZlZF9vdmVyZmxvdyA9ICcnO1xuXG4vKipcbiAqIFRvZ2dsZSBmdWxsIHNjcmVlbiBvZiB0aGUgZWRpdG9yLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlRnVsbFNjcmVlbihlZGl0b3IpIHtcbiAgICAvLyBTZXQgZnVsbHNjcmVlblxuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIGNtLnNldE9wdGlvbignZnVsbFNjcmVlbicsICFjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSk7XG5cblxuICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIGJvZHkgZHVyaW5nIGZ1bGxzY3JlZW4gYWN0aXZlXG4gICAgaWYgKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB7XG4gICAgICAgIHNhdmVkX292ZXJmbG93ID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBzYXZlZF9vdmVyZmxvdztcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHNpZGVieXNpZGUgPSB3cmFwcGVyLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKHNpZGVieXNpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZScpKSB7XG4gICAgICAgIGlmIChlZGl0b3Iub3B0aW9ucy5zaWRlQnlTaWRlRnVsbHNjcmVlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGlmIHNpZGUtYnktc2lkZSBub3QtZnVsbHNjcmVlbiBvaywgYXBwbHkgY2xhc3NlcyBhcyBuZWVkZWRcbiAgICAgICAgICAgIHZhciBlYXN5TURFQ29udGFpbmVyID0gd3JhcHBlci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB7XG4gICAgICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdzaWRlZC0tbm8tZnVsbHNjcmVlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3NpZGVkLS1uby1mdWxsc2NyZWVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2dnbGVTaWRlQnlTaWRlKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRpdG9yLm9wdGlvbnMub25Ub2dnbGVGdWxsU2NyZWVuKSB7XG4gICAgICAgIGVkaXRvci5vcHRpb25zLm9uVG9nZ2xlRnVsbFNjcmVlbihjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG9yIHNldCBtYXhIZWlnaHRcbiAgICBpZiAodHlwZW9mIGVkaXRvci5vcHRpb25zLm1heEhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB7XG4gICAgICAgICAgICBjbS5nZXRTY3JvbGxlckVsZW1lbnQoKS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnaGVpZ2h0Jyk7XG4gICAgICAgICAgICBzaWRlYnlzaWRlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtLmdldFNjcm9sbGVyRWxlbWVudCgpLnN0eWxlLmhlaWdodCA9IGVkaXRvci5vcHRpb25zLm1heEhlaWdodDtcbiAgICAgICAgICAgIGVkaXRvci5zZXRQcmV2aWV3TWF4SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdG9vbGJhciBjbGFzc1xuICAgIGVkaXRvci50b29sYmFyX2Rpdi5jbGFzc0xpc3QudG9nZ2xlKCdmdWxsc2NyZWVuJyk7XG5cbiAgICAvLyBVcGRhdGUgdG9vbGJhciBidXR0b25cbiAgICBpZiAoZWRpdG9yLnRvb2xiYXJFbGVtZW50cyAmJiBlZGl0b3IudG9vbGJhckVsZW1lbnRzLmZ1bGxzY3JlZW4pIHtcbiAgICAgICAgdmFyIHRvb2xiYXJCdXR0b24gPSBlZGl0b3IudG9vbGJhckVsZW1lbnRzLmZ1bGxzY3JlZW47XG4gICAgICAgIHRvb2xiYXJCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBib2xkLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQm9sZChlZGl0b3IpIHtcbiAgICBfdG9nZ2xlQmxvY2soZWRpdG9yLCAnYm9sZCcsIGVkaXRvci5vcHRpb25zLmJsb2NrU3R5bGVzLmJvbGQpO1xufVxuXG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBpdGFsaWMuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVJdGFsaWMoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUJsb2NrKGVkaXRvciwgJ2l0YWxpYycsIGVkaXRvci5vcHRpb25zLmJsb2NrU3R5bGVzLml0YWxpYyk7XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIHN0cmlrZXRocm91Z2guXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVTdHJpa2V0aHJvdWdoKGVkaXRvcikge1xuICAgIF90b2dnbGVCbG9jayhlZGl0b3IsICdzdHJpa2V0aHJvdWdoJywgJ35+Jyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBjb2RlIGJsb2NrLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ29kZUJsb2NrKGVkaXRvcikge1xuICAgIHZhciBmZW5jZUNoYXJzVG9JbnNlcnQgPSBlZGl0b3Iub3B0aW9ucy5ibG9ja1N0eWxlcy5jb2RlO1xuXG4gICAgZnVuY3Rpb24gZmVuY2luZ19saW5lKGxpbmUpIHtcbiAgICAgICAgLyogcmV0dXJuIHRydWUsIGlmIHRoaXMgaXMgYSBgYGAgb3Igfn5+IGxpbmUgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgJ2ZlbmNpbmdfbGluZSgpIHRha2VzIGEgXFwnbGluZVxcJyBvYmplY3QgKG5vdCBhIGxpbmUgbnVtYmVyLCBvciBsaW5lIHRleHQpLiAgR290OiAnICsgdHlwZW9mIGxpbmUgKyAnOiAnICsgbGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5zdHlsZXMgJiYgbGluZS5zdHlsZXNbMl0gJiYgbGluZS5zdHlsZXNbMl0uaW5kZXhPZignZm9ybWF0dGluZy1jb2RlLWJsb2NrJykgIT09IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuX3N0YXRlKHRva2VuKSB7XG4gICAgICAgIC8vIGJhc2UgZ29lcyBhbiBleHRyYSBsZXZlbCBkZWVwIHdoZW4gbW9kZSBiYWNrZHJvcHMgYXJlIHVzZWQsIGUuZy4gc3BlbGxjaGVja2VyIG9uXG4gICAgICAgIHJldHVybiB0b2tlbi5zdGF0ZS5iYXNlLmJhc2UgfHwgdG9rZW4uc3RhdGUuYmFzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2RlX3R5cGUoY20sIGxpbmVfbnVtLCBsaW5lLCBmaXJzdFRvaywgbGFzdFRvaykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gXCJzaW5nbGVcIiwgXCJpbmRlbnRlZFwiLCBcImZlbmNlZFwiIG9yIGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIGNtIGFuZCBsaW5lX251bSBhcmUgcmVxdWlyZWQuICBPdGhlcnMgYXJlIG9wdGlvbmFsIGZvciBlZmZpY2llbmN5XG4gICAgICAgICAqICAgVG8gY2hlY2sgaW4gdGhlIG1pZGRsZSBvZiBhIGxpbmUsIHBhc3MgaW4gZmlyc3RUb2sgeW91cnNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICBsaW5lID0gbGluZSB8fCBjbS5nZXRMaW5lSGFuZGxlKGxpbmVfbnVtKTtcbiAgICAgICAgZmlyc3RUb2sgPSBmaXJzdFRvayB8fCBjbS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVfbnVtLFxuICAgICAgICAgICAgY2g6IDEsXG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0VG9rID0gbGFzdFRvayB8fCAoISFsaW5lLnRleHQgJiYgY20uZ2V0VG9rZW5BdCh7XG4gICAgICAgICAgICBsaW5lOiBsaW5lX251bSxcbiAgICAgICAgICAgIGNoOiBsaW5lLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgdHlwZXMgPSBmaXJzdFRvay50eXBlID8gZmlyc3RUb2sudHlwZS5zcGxpdCgnICcpIDogW107XG4gICAgICAgIGlmIChsYXN0VG9rICYmIHRva2VuX3N0YXRlKGxhc3RUb2spLmluZGVudGVkQ29kZSkge1xuICAgICAgICAgICAgLy8gaGF2ZSB0byBjaGVjayBsYXN0IGNoYXIsIHNpbmNlIGZpcnN0IGNoYXJzIG9mIGZpcnN0IGxpbmUgYXJlblwidCBtYXJrZWQgYXMgaW5kZW50ZWRcbiAgICAgICAgICAgIHJldHVybiAnaW5kZW50ZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVzLmluZGV4T2YoJ2NvbW1lbnQnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGhhcyB0byBiZSBhZnRlciBcImluZGVudGVkXCIgY2hlY2ssIHNpbmNlIGZpcnN0IGNoYXJzIG9mIGZpcnN0IGluZGVudGVkIGxpbmUgYXJlblwidCBtYXJrZWQgYXMgc3VjaFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuX3N0YXRlKGZpcnN0VG9rKS5mZW5jZWRDaGFycyB8fCB0b2tlbl9zdGF0ZShsYXN0VG9rKS5mZW5jZWRDaGFycyB8fCBmZW5jaW5nX2xpbmUobGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnZmVuY2VkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydEZlbmNpbmdBdFNlbGVjdGlvbihjbSwgY3VyX3N0YXJ0LCBjdXJfZW5kLCBmZW5jZUNoYXJzVG9JbnNlcnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0X2xpbmVfc2VsID0gY3VyX3N0YXJ0LmxpbmUgKyAxLFxuICAgICAgICAgICAgZW5kX2xpbmVfc2VsID0gY3VyX2VuZC5saW5lICsgMSxcbiAgICAgICAgICAgIHNlbF9tdWx0aSA9IGN1cl9zdGFydC5saW5lICE9PSBjdXJfZW5kLmxpbmUsXG4gICAgICAgICAgICByZXBsX3N0YXJ0ID0gZmVuY2VDaGFyc1RvSW5zZXJ0ICsgJ1xcbicsXG4gICAgICAgICAgICByZXBsX2VuZCA9ICdcXG4nICsgZmVuY2VDaGFyc1RvSW5zZXJ0O1xuICAgICAgICBpZiAoc2VsX211bHRpKSB7XG4gICAgICAgICAgICBlbmRfbGluZV9zZWwrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbGFzdCBjaGFyIGluY2x1ZGluZyBcXG4gb3Igbm90XG4gICAgICAgIGlmIChzZWxfbXVsdGkgJiYgY3VyX2VuZC5jaCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwbF9lbmQgPSBmZW5jZUNoYXJzVG9JbnNlcnQgKyAnXFxuJztcbiAgICAgICAgICAgIGVuZF9saW5lX3NlbC0tO1xuICAgICAgICB9XG4gICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBmYWxzZSwgW3JlcGxfc3RhcnQsIHJlcGxfZW5kXSk7XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBsaW5lOiBzdGFydF9saW5lX3NlbCxcbiAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsaW5lOiBlbmRfbGluZV9zZWwsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3IsXG4gICAgICAgIGN1cl9zdGFydCA9IGNtLmdldEN1cnNvcignc3RhcnQnKSxcbiAgICAgICAgY3VyX2VuZCA9IGNtLmdldEN1cnNvcignZW5kJyksXG4gICAgICAgIHRvayA9IGNtLmdldFRva2VuQXQoe1xuICAgICAgICAgICAgbGluZTogY3VyX3N0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjaDogY3VyX3N0YXJ0LmNoIHx8IDEsXG4gICAgICAgIH0pLCAvLyBhdm9pZCBjaCAwIHdoaWNoIGlzIGEgY3Vyc29yIHBvcyBidXQgbm90IHRva2VuXG4gICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGN1cl9zdGFydC5saW5lKSxcbiAgICAgICAgaXNfY29kZSA9IGNvZGVfdHlwZShjbSwgY3VyX3N0YXJ0LmxpbmUsIGxpbmUsIHRvayk7XG4gICAgdmFyIGJsb2NrX3N0YXJ0LCBibG9ja19lbmQsIGxpbmVDb3VudDtcblxuICAgIGlmIChpc19jb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAvLyBzaW1pbGFyIHRvIHNvbWUgRWFzeU1ERSBfdG9nZ2xlQmxvY2sgbG9naWNcbiAgICAgICAgdmFyIHN0YXJ0ID0gbGluZS50ZXh0LnNsaWNlKDAsIGN1cl9zdGFydC5jaCkucmVwbGFjZSgnYCcsICcnKSxcbiAgICAgICAgICAgIGVuZCA9IGxpbmUudGV4dC5zbGljZShjdXJfc3RhcnQuY2gpLnJlcGxhY2UoJ2AnLCAnJyk7XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydCArIGVuZCwge1xuICAgICAgICAgICAgbGluZTogY3VyX3N0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGluZTogY3VyX3N0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJfc3RhcnQuY2gtLTtcbiAgICAgICAgaWYgKGN1cl9zdGFydCAhPT0gY3VyX2VuZCkge1xuICAgICAgICAgICAgY3VyX2VuZC5jaC0tO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbihjdXJfc3RhcnQsIGN1cl9lbmQpO1xuICAgICAgICBjbS5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAoaXNfY29kZSA9PT0gJ2ZlbmNlZCcpIHtcbiAgICAgICAgaWYgKGN1cl9zdGFydC5saW5lICE9PSBjdXJfZW5kLmxpbmUgfHwgY3VyX3N0YXJ0LmNoICE9PSBjdXJfZW5kLmNoKSB7XG4gICAgICAgICAgICAvLyB1c2Ugc2VsZWN0aW9uXG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZlbmNlZCBsaW5lIHNvIHdlIGtub3cgd2hhdCB0eXBlIGl0IGlzICh0aWxkZSwgYmFja3RpY2tzLCBudW1iZXIgb2YgdGhlbSlcbiAgICAgICAgICAgIGZvciAoYmxvY2tfc3RhcnQgPSBjdXJfc3RhcnQubGluZTsgYmxvY2tfc3RhcnQgPj0gMDsgYmxvY2tfc3RhcnQtLSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX3N0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmZW5jZWRUb2sgPSBjbS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19zdGFydCxcbiAgICAgICAgICAgICAgICBjaDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGZlbmNlX2NoYXJzID0gdG9rZW5fc3RhdGUoZmVuY2VkVG9rKS5mZW5jZWRDaGFycztcbiAgICAgICAgICAgIHZhciBzdGFydF90ZXh0LCBzdGFydF9saW5lO1xuICAgICAgICAgICAgdmFyIGVuZF90ZXh0LCBlbmRfbGluZTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzZWxlY3Rpb24gZ29pbmcgdXAgYWdhaW5zdCBmZW5jZWQgbGluZXMsIGluIHdoaWNoIGNhc2Ugd2UgZG9uJ3Qgd2FudCB0byBhZGQgbW9yZSBmZW5jaW5nXG4gICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX3N0YXJ0LmxpbmUpKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0X3RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBzdGFydF9saW5lID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZlbmNpbmdfbGluZShjbS5nZXRMaW5lSGFuZGxlKGN1cl9zdGFydC5saW5lIC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIHN0YXJ0X2xpbmUgPSBjdXJfc3RhcnQubGluZSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0X3RleHQgPSBmZW5jZV9jaGFycyArICdcXG4nO1xuICAgICAgICAgICAgICAgIHN0YXJ0X2xpbmUgPSBjdXJfc3RhcnQubGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUoY20uZ2V0TGluZUhhbmRsZShjdXJfZW5kLmxpbmUpKSkge1xuICAgICAgICAgICAgICAgIGVuZF90ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgZW5kX2xpbmUgPSBjdXJfZW5kLmxpbmU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cl9lbmQuY2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kX2xpbmUgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cl9lbmQuY2ggIT09IDAgJiYgZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX2VuZC5saW5lICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgZW5kX3RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBlbmRfbGluZSA9IGN1cl9lbmQubGluZSArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZF90ZXh0ID0gZmVuY2VfY2hhcnMgKyAnXFxuJztcbiAgICAgICAgICAgICAgICBlbmRfbGluZSA9IGN1cl9lbmQubGluZSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VyX2VuZC5jaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGZ1bGwgbGFzdCBsaW5lIHNlbGVjdGVkLCBwdXR0aW5nIGN1cnNvciBhdCBiZWdpbm5pbmcgb2YgbmV4dFxuICAgICAgICAgICAgICAgIGVuZF9saW5lIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGVuZCBsaW5lIGZpcnN0LCBzbyB0aGF0IGxpbmUgbnVtYmVycyBkb24ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoZW5kX3RleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZW5kX2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZW5kX2xpbmUgKyAoZW5kX3RleHQgPyAwIDogMSksXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydF90ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogc3RhcnRfbGluZSArIChzdGFydF90ZXh0ID8gMCA6IDEpLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydF9saW5lICsgKHN0YXJ0X3RleHQgPyAxIDogMCksXG4gICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluZTogZW5kX2xpbmUgKyAoc3RhcnRfdGV4dCA/IDEgOiAtMSksXG4gICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBzZWxlY3Rpb24sIHNlYXJjaCBmb3IgZW5kcyBvZiB0aGlzIGZlbmNlZCBibG9ja1xuICAgICAgICAgICAgdmFyIHNlYXJjaF9mcm9tID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX3N0YXJ0LmxpbmUpKSkgeyAvLyBnZXRzIGEgbGl0dGxlIHRyaWNreSBpZiBjdXJzb3IgaXMgcmlnaHQgb24gYSBmZW5jZWQgbGluZVxuICAgICAgICAgICAgICAgIGlmIChjb2RlX3R5cGUoY20sIGN1cl9zdGFydC5saW5lICsgMSkgPT09ICdmZW5jZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX3N0YXJ0ID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9mcm9tID0gY3VyX3N0YXJ0LmxpbmUgKyAxOyAvLyBmb3Igc2VhcmNoaW5nIGZvciBcImVuZFwiXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tfZW5kID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9mcm9tID0gY3VyX3N0YXJ0LmxpbmUgLSAxOyAvLyBmb3Igc2VhcmNoaW5nIGZvciBcInN0YXJ0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tfc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoYmxvY2tfc3RhcnQgPSBzZWFyY2hfZnJvbTsgYmxvY2tfc3RhcnQgPj0gMDsgYmxvY2tfc3RhcnQtLSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrX2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGluZUNvdW50ID0gY20ubGluZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgZm9yIChibG9ja19lbmQgPSBzZWFyY2hfZnJvbTsgYmxvY2tfZW5kIDwgbGluZUNvdW50OyBibG9ja19lbmQrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19lbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCcnLCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX3N0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCcnLCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX2VuZCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogYmxvY2tfZW5kLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNfY29kZSA9PT0gJ2luZGVudGVkJykge1xuICAgICAgICBpZiAoY3VyX3N0YXJ0LmxpbmUgIT09IGN1cl9lbmQubGluZSB8fCBjdXJfc3RhcnQuY2ggIT09IGN1cl9lbmQuY2gpIHtcbiAgICAgICAgICAgIC8vIHVzZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGJsb2NrX3N0YXJ0ID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICBibG9ja19lbmQgPSBjdXJfZW5kLmxpbmU7XG4gICAgICAgICAgICBpZiAoY3VyX2VuZC5jaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJsb2NrX2VuZC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gc2VsZWN0aW9uLCBzZWFyY2ggZm9yIGVuZHMgb2YgdGhpcyBpbmRlbnRlZCBibG9ja1xuICAgICAgICAgICAgZm9yIChibG9ja19zdGFydCA9IGN1cl9zdGFydC5saW5lOyBibG9ja19zdGFydCA+PSAwOyBibG9ja19zdGFydC0tKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHQubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IG9yIGFsbCB3aGl0ZXNwYWNlIC0ga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZV90eXBlKGNtLCBibG9ja19zdGFydCwgbGluZSkgIT09ICdpbmRlbnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX3N0YXJ0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVDb3VudCA9IGNtLmxpbmVDb3VudCgpO1xuICAgICAgICAgICAgZm9yIChibG9ja19lbmQgPSBjdXJfc3RhcnQubGluZTsgYmxvY2tfZW5kIDwgbGluZUNvdW50OyBibG9ja19lbmQrKykge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX2VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dC5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgb3IgYWxsIHdoaXRlc3BhY2UgLSBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlX3R5cGUoY20sIGJsb2NrX2VuZCwgbGluZSkgIT09ICdpbmRlbnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX2VuZCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgYXJlIGdvaW5nIHRvIHVuLWluZGVudCBiYXNlZCBvbiBhIHNlbGVjdGVkIHNldCBvZiBsaW5lcywgYW5kIHRoZSBuZXh0IGxpbmUgaXMgaW5kZW50ZWQgdG9vLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGluc2VydCBhIGJsYW5rIGxpbmUgc28gdGhhdCB0aGUgbmV4dCBsaW5lKHMpIGNvbnRpbnVlIHRvIGJlIGluZGVudGVkIGNvZGVcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfZW5kICsgMSksXG4gICAgICAgICAgICBuZXh0X2xpbmVfbGFzdF90b2sgPSBuZXh0X2xpbmUgJiYgY20uZ2V0VG9rZW5BdCh7XG4gICAgICAgICAgICAgICAgbGluZTogYmxvY2tfZW5kICsgMSxcbiAgICAgICAgICAgICAgICBjaDogbmV4dF9saW5lLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV4dF9saW5lX2luZGVudGVkID0gbmV4dF9saW5lX2xhc3RfdG9rICYmIHRva2VuX3N0YXRlKG5leHRfbGluZV9sYXN0X3RvaykuaW5kZW50ZWRDb2RlO1xuICAgICAgICBpZiAobmV4dF9saW5lX2luZGVudGVkKSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJ1xcbicsIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19lbmQgKyAxLFxuICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gYmxvY2tfc3RhcnQ7IGkgPD0gYmxvY2tfZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNtLmluZGVudExpbmUoaSwgJ3N1YnRyYWN0Jyk7IC8vIFRPRE86IHRoaXMgZG9lc24ndCBnZXQgdHJhY2tlZCBpbiB0aGUgaGlzdG9yeSwgc28gY2FuJ3QgYmUgdW5kb25lIDooXG4gICAgICAgIH1cbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnNlcnQgY29kZSBmb3JtYXR0aW5nXG4gICAgICAgIHZhciBub19zZWxfYW5kX3N0YXJ0aW5nX29mX2xpbmUgPSAoY3VyX3N0YXJ0LmxpbmUgPT09IGN1cl9lbmQubGluZSAmJiBjdXJfc3RhcnQuY2ggPT09IGN1cl9lbmQuY2ggJiYgY3VyX3N0YXJ0LmNoID09PSAwKTtcbiAgICAgICAgdmFyIHNlbF9tdWx0aSA9IGN1cl9zdGFydC5saW5lICE9PSBjdXJfZW5kLmxpbmU7XG4gICAgICAgIGlmIChub19zZWxfYW5kX3N0YXJ0aW5nX29mX2xpbmUgfHwgc2VsX211bHRpKSB7XG4gICAgICAgICAgICBpbnNlcnRGZW5jaW5nQXRTZWxlY3Rpb24oY20sIGN1cl9zdGFydCwgY3VyX2VuZCwgZmVuY2VDaGFyc1RvSW5zZXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBmYWxzZSwgWydgJywgJ2AnXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBibG9ja3F1b3RlLlxuICovXG5mdW5jdGlvbiB0b2dnbGVCbG9ja3F1b3RlKGVkaXRvcikge1xuICAgIF90b2dnbGVMaW5lKGVkaXRvci5jb2RlbWlycm9yLCAncXVvdGUnKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZTogbm9ybWFsIC0+IGgxIC0+IGgyIC0+IGgzIC0+IGg0IC0+IGg1IC0+IGg2IC0+IG5vcm1hbFxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nU21hbGxlcihlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgJ3NtYWxsZXInKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZTogbm9ybWFsIC0+IGg2IC0+IGg1IC0+IGg0IC0+IGgzIC0+IGgyIC0+IGgxIC0+IG5vcm1hbFxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nQmlnZ2VyKGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCAnYmlnZ2VyJyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgMVxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nMShlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCAxKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSAyXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmcyKGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDIpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDNcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzMoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgMyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgNFxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nNChlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCA0KTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSA1XG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmc1KGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDUpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDZcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzYoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgNik7XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIHVsLlxuICovXG5mdW5jdGlvbiB0b2dnbGVVbm9yZGVyZWRMaXN0KGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuXG4gICAgdmFyIGxpc3RTdHlsZSA9ICcqJzsgLy8gRGVmYXVsdFxuICAgIGlmIChbJy0nLCAnKycsICcqJ10uaW5jbHVkZXMoZWRpdG9yLm9wdGlvbnMudW5vcmRlcmVkTGlzdFN0eWxlKSkge1xuICAgICAgICBsaXN0U3R5bGUgPSBlZGl0b3Iub3B0aW9ucy51bm9yZGVyZWRMaXN0U3R5bGU7XG4gICAgfVxuXG4gICAgX3RvZ2dsZUxpbmUoY20sICd1bm9yZGVyZWQtbGlzdCcsIGxpc3RTdHlsZSk7XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIG9sLlxuICovXG5mdW5jdGlvbiB0b2dnbGVPcmRlcmVkTGlzdChlZGl0b3IpIHtcbiAgICBfdG9nZ2xlTGluZShlZGl0b3IuY29kZW1pcnJvciwgJ29yZGVyZWQtbGlzdCcpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgY2xlYW4gYmxvY2sgKHJlbW92ZSBoZWFkbGluZSwgbGlzdCwgYmxvY2txdW90ZSBjb2RlLCBtYXJrZXJzKVxuICovXG5mdW5jdGlvbiBjbGVhbkJsb2NrKGVkaXRvcikge1xuICAgIF9jbGVhbkJsb2NrKGVkaXRvci5jb2RlbWlycm9yKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIGRyYXdpbmcgYSBsaW5rLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gZHJhd0xpbmsoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBlZGl0b3Iub3B0aW9ucztcbiAgICB2YXIgdXJsID0gJ2h0dHBzOi8vJztcbiAgICBpZiAob3B0aW9ucy5wcm9tcHRVUkxzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwcm9tcHQob3B0aW9ucy5wcm9tcHRUZXh0cy5saW5rLCB1cmwpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGVzY2FwZVByb21wdFVSTChyZXN1bHQpO1xuICAgIH1cbiAgICBfdG9nZ2xlTGluayhlZGl0b3IsICdsaW5rJywgb3B0aW9ucy5pbnNlcnRUZXh0cy5saW5rLCB1cmwpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgZHJhd2luZyBhbiBpbWcuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiBkcmF3SW1hZ2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBlZGl0b3Iub3B0aW9ucztcbiAgICB2YXIgdXJsID0gJ2h0dHBzOi8vJztcbiAgICBpZiAob3B0aW9ucy5wcm9tcHRVUkxzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwcm9tcHQob3B0aW9ucy5wcm9tcHRUZXh0cy5pbWFnZSwgdXJsKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBlc2NhcGVQcm9tcHRVUkwocmVzdWx0KTtcbiAgICB9XG4gICAgX3RvZ2dsZUxpbmsoZWRpdG9yLCAnaW1hZ2UnLCBvcHRpb25zLmluc2VydFRleHRzLmltYWdlLCB1cmwpO1xufVxuXG4vKipcbiAqIEVuY29kZSBhbmQgZXNjYXBlIFVSTHMgdG8gcHJldmVudCBicmVha2luZyB1cCByZW5kZXJlZCBNYXJrZG93biBsaW5rcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCBvZiB0aGUgbGluayBvciBpbWFnZVxuICovXG5mdW5jdGlvbiBlc2NhcGVQcm9tcHRVUkwodXJsKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSSh1cmwpLnJlcGxhY2UoLyhbXFxcXCgpXSkvZywgJ1xcXFwkMScpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3Igb3BlbmluZyB0aGUgYnJvd3NlLWZpbGUgd2luZG93IHRvIHVwbG9hZCBhbiBpbWFnZSB0byBhIHNlcnZlci5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yIFRoZSBFYXN5TURFIG9iamVjdFxuICovXG5mdW5jdGlvbiBkcmF3VXBsb2FkZWRJbWFnZShlZGl0b3IpIHtcbiAgICAvLyBUT0RPOiBEcmF3IHRoZSBpbWFnZSB0ZW1wbGF0ZSB3aXRoIGEgZmFrZSB1cmw/IGllOiAnIVtdKGltcG9ydGluZyBmb28ucG5nLi4uKSdcbiAgICBlZGl0b3Iub3BlbkJyb3dzZUZpbGVXaW5kb3coKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgYW4gaW1hZ2UgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWxseSBpbXBvcnRlZCBvbiB0aGUgc2VydmVyLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3IgVGhlIEVhc3lNREUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgb2YgdGhlIHVwbG9hZGVkIGltYWdlXG4gKi9cbmZ1bmN0aW9uIGFmdGVySW1hZ2VVcGxvYWRlZChlZGl0b3IsIHVybCkge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnM7XG4gICAgdmFyIGltYWdlTmFtZSA9IHVybC5zdWJzdHIodXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB2YXIgZXh0ID0gaW1hZ2VOYW1lLnN1YnN0cmluZyhpbWFnZU5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpLnJlcGxhY2UoL1xcPy4qJC8sICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQ2hlY2sgaWYgbWVkaWEgaXMgYW4gaW1hZ2VcbiAgICBpZiAoWydwbmcnLCAnanBnJywgJ2pwZWcnLCAnZ2lmJywgJ3N2ZycsICdhcG5nJywgJ2F2aWYnLCAnd2VicCddLmluY2x1ZGVzKGV4dCkpIHtcbiAgICAgICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIHN0YXQuaW1hZ2UsIG9wdGlvbnMuaW5zZXJ0VGV4dHMudXBsb2FkZWRJbWFnZSwgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dF9saW5rID0gb3B0aW9ucy5pbnNlcnRUZXh0cy5saW5rO1xuICAgICAgICB0ZXh0X2xpbmtbMF0gPSAnWycgKyBpbWFnZU5hbWU7XG4gICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBzdGF0LmxpbmssIHRleHRfbGluaywgdXJsKTtcbiAgICB9XG5cbiAgICAvLyBzaG93IHVwbG9hZGVkIGltYWdlIGZpbGVuYW1lIGZvciAxMDAwbXNcbiAgICBlZGl0b3IudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBlZGl0b3Iub3B0aW9ucy5pbWFnZVRleHRzLnNiT25VcGxvYWRlZC5yZXBsYWNlKCcjaW1hZ2VfbmFtZSMnLCBpbWFnZU5hbWUpKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgZWRpdG9yLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYkluaXQpO1xuICAgIH0sIDEwMDApO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgZHJhd2luZyBhIHRhYmxlLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gZHJhd1RhYmxlKGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnM7XG4gICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIHN0YXQudGFibGUsIG9wdGlvbnMuaW5zZXJ0VGV4dHMudGFibGUpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgZHJhd2luZyBhIGhvcml6b250YWwgcnVsZS5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIGRyYXdIb3Jpem9udGFsUnVsZShlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVkaXRvci5vcHRpb25zO1xuICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBzdGF0LmltYWdlLCBvcHRpb25zLmluc2VydFRleHRzLmhvcml6b250YWxSdWxlKTtcbn1cblxuXG4vKipcbiAqIFVuZG8gYWN0aW9uLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdW5kbyhlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICBjbS51bmRvKCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuXG4vKipcbiAqIFJlZG8gYWN0aW9uLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gcmVkbyhlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICBjbS5yZWRvKCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuXG4vKipcbiAqIFRvZ2dsZSBzaWRlIGJ5IHNpZGUgcHJldmlld1xuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlU2lkZUJ5U2lkZShlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLm5leHRTaWJsaW5nO1xuICAgIHZhciB0b29sYmFyQnV0dG9uID0gZWRpdG9yLnRvb2xiYXJFbGVtZW50cyAmJiBlZGl0b3IudG9vbGJhckVsZW1lbnRzWydzaWRlLWJ5LXNpZGUnXTtcbiAgICB2YXIgdXNlU2lkZUJ5U2lkZUxpc3RlbmVyID0gZmFsc2U7XG5cbiAgICB2YXIgZWFzeU1ERUNvbnRhaW5lciA9IHdyYXBwZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKSkge1xuICAgICAgICBpZiAoZWRpdG9yLm9wdGlvbnMuc2lkZUJ5U2lkZUZ1bGxzY3JlZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBpZiBzaWRlLWJ5LXNpZGUgbm90LWZ1bGxzY3JlZW4gb2ssIHJlbW92ZSBjbGFzc2VzIHdoZW4gaGlkaW5nIHNpZGVcbiAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2lkZWQtLW5vLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJyk7XG4gICAgICAgIGlmICh0b29sYmFyQnV0dG9uKSB0b29sYmFyQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ0NvZGVNaXJyb3Itc2lkZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSBwcmV2aWV3IGJ1dHRvbiBpcyBjbGlja2VkIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAgICAgLy8gZ2l2ZSBzb21lIHRpbWUgZm9yIHRoZSB0cmFuc2l0aW9uIGZyb20gZWRpdG9yLmNzcyB0byBmaXJlIGFuZCB0aGUgdmlldyB0byBzbGlkZSBmcm9tIHJpZ2h0IHRvIGxlZnQsXG4gICAgICAgIC8vIGluc3RlYWQgb2YganVzdCBhcHBlYXJpbmcuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkge1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3Iub3B0aW9ucy5zaWRlQnlTaWRlRnVsbHNjcmVlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2lkZS1ieS1zaWRlIG5vdC1mdWxsc2NyZWVuIG9rLCBhZGQgY2xhc3NlcyB3aGVuIG5vdCBmdWxsc2NyZWVuIGFuZCBzaG93aW5nIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzaWRlZC0tbm8tZnVsbHNjcmVlbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUZ1bGxTY3JlZW4oZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJyk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICBpZiAodG9vbGJhckJ1dHRvbikgdG9vbGJhckJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdDb2RlTWlycm9yLXNpZGVkJyk7XG4gICAgICAgIHVzZVNpZGVCeVNpZGVMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSGlkZSBub3JtYWwgcHJldmlldyBpZiBhY3RpdmVcbiAgICB2YXIgcHJldmlld05vcm1hbCA9IHdyYXBwZXIubGFzdENoaWxkO1xuICAgIGlmIChwcmV2aWV3Tm9ybWFsLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpIHtcbiAgICAgICAgcHJldmlld05vcm1hbC5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKTtcbiAgICAgICAgdmFyIHRvb2xiYXIgPSBlZGl0b3IudG9vbGJhckVsZW1lbnRzLnByZXZpZXc7XG4gICAgICAgIHZhciB0b29sYmFyX2RpdiA9IGVkaXRvci50b29sYmFyX2RpdjtcbiAgICAgICAgdG9vbGJhci5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgdG9vbGJhcl9kaXYuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQtZm9yLXByZXZpZXcnKTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBlZGl0b3Iub3B0aW9ucy5wcmV2aWV3UmVuZGVyKGVkaXRvci52YWx1ZSgpLCBwcmV2aWV3KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByZXZpZXcuaW5uZXJIVE1MID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFjbS5zaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgY20uc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uID0gc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uO1xuICAgIH1cblxuICAgIGlmICh1c2VTaWRlQnlTaWRlTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZWRpdG9yLm9wdGlvbnMucHJldmlld1JlbmRlcihlZGl0b3IudmFsdWUoKSwgcHJldmlldyk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNtLm9uKCd1cGRhdGUnLCBjbS5zaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLm9mZigndXBkYXRlJywgY20uc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZWZyZXNoIHRvIGZpeCBzZWxlY3Rpb24gYmVpbmcgb2ZmICgjMzA5KVxuICAgIGNtLnJlZnJlc2goKTtcbn1cblxuXG4vKipcbiAqIFByZXZpZXcgYWN0aW9uLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlUHJldmlldyhlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHRvb2xiYXJfZGl2ID0gZWRpdG9yLnRvb2xiYXJfZGl2O1xuICAgIHZhciB0b29sYmFyID0gZWRpdG9yLm9wdGlvbnMudG9vbGJhciA/IGVkaXRvci50b29sYmFyRWxlbWVudHMucHJldmlldyA6IGZhbHNlO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5sYXN0Q2hpbGQ7XG5cbiAgICAvLyBUdXJuIG9mZiBzaWRlIGJ5IHNpZGUgaWYgbmVlZGVkXG4gICAgdmFyIHNpZGVieXNpZGUgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpLm5leHRTaWJsaW5nO1xuICAgIGlmIChzaWRlYnlzaWRlLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKSlcbiAgICAgICAgdG9nZ2xlU2lkZUJ5U2lkZShlZGl0b3IpO1xuXG4gICAgaWYgKCFwcmV2aWV3IHx8ICFwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctZnVsbCcpKSB7XG5cbiAgICAgICAgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdlZGl0b3ItcHJldmlldy1mdWxsJztcblxuICAgICAgICBpZiAoZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzKSB7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocHJldmlldyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSkge1xuICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpO1xuICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgdG9vbGJhci5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHRvb2xiYXJfZGl2LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkLWZvci1wcmV2aWV3Jyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSBwcmV2aWV3IGJ1dHRvbiBpcyBjbGlja2VkIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAgICAgLy8gZ2l2ZSBzb21lIHRpbWUgZm9yIHRoZSB0cmFuc2l0aW9uIGZyb20gZWRpdG9yLmNzcyB0byBmaXJlIGFuZCB0aGUgdmlldyB0byBzbGlkZSBmcm9tIHJpZ2h0IHRvIGxlZnQsXG4gICAgICAgIC8vIGluc3RlYWQgb2YganVzdCBhcHBlYXJpbmcuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICB0b29sYmFyLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdG9vbGJhcl9kaXYuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQtZm9yLXByZXZpZXcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aWV3X3Jlc3VsdCA9IGVkaXRvci5vcHRpb25zLnByZXZpZXdSZW5kZXIoZWRpdG9yLnZhbHVlKCksIHByZXZpZXcpO1xuICAgIGlmIChwcmV2aWV3X3Jlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IHByZXZpZXdfcmVzdWx0O1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBfcmVwbGFjZVNlbGVjdGlvbihjbSwgYWN0aXZlLCBzdGFydEVuZCwgdXJsKSB7XG4gICAgaWYgKGNtLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciB0ZXh0O1xuICAgIHZhciBzdGFydCA9IHN0YXJ0RW5kWzBdO1xuICAgIHZhciBlbmQgPSBzdGFydEVuZFsxXTtcbiAgICB2YXIgc3RhcnRQb2ludCA9IHt9LFxuICAgICAgICBlbmRQb2ludCA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24oc3RhcnRQb2ludCwgY20uZ2V0Q3Vyc29yKCdzdGFydCcpKTtcbiAgICBPYmplY3QuYXNzaWduKGVuZFBvaW50LCBjbS5nZXRDdXJzb3IoJ2VuZCcpKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgnI3VybCMnLCB1cmwpOyAgLy8gdXJsIGlzIGluIHN0YXJ0IGZvciB1cGxvYWQtaW1hZ2VcbiAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoJyN1cmwjJywgdXJsKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICB0ZXh0ID0gY20uZ2V0TGluZShzdGFydFBvaW50LmxpbmUpO1xuICAgICAgICBzdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnRQb2ludC5jaCk7XG4gICAgICAgIGVuZCA9IHRleHQuc2xpY2Uoc3RhcnRQb2ludC5jaCk7XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydCArIGVuZCwge1xuICAgICAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzdGFydCArIHRleHQgKyBlbmQpO1xuXG4gICAgICAgIHN0YXJ0UG9pbnQuY2ggKz0gc3RhcnQubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhcnRQb2ludCAhPT0gZW5kUG9pbnQpIHtcbiAgICAgICAgICAgIGVuZFBvaW50LmNoICs9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbS5zZXRTZWxlY3Rpb24oc3RhcnRQb2ludCwgZW5kUG9pbnQpO1xuICAgIGNtLmZvY3VzKCk7XG59XG5cblxuZnVuY3Rpb24gX3RvZ2dsZUhlYWRpbmcoY20sIGRpcmVjdGlvbiwgc2l6ZSkge1xuICAgIGlmIChjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmxhc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgc3RhcnRQb2ludCA9IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICB2YXIgZW5kUG9pbnQgPSBjbS5nZXRDdXJzb3IoJ2VuZCcpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydFBvaW50LmxpbmU7IGkgPD0gZW5kUG9pbnQubGluZTsgaSsrKSB7XG4gICAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGkpO1xuICAgICAgICAgICAgdmFyIGN1cnJIZWFkaW5nTGV2ZWwgPSB0ZXh0LnNlYXJjaCgvW14jXS8pO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckhlYWRpbmdMZXZlbCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gJ2JpZ2dlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSAnIyMjIyMjICcgKyB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcjICcgKyB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJySGVhZGluZ0xldmVsID09IDYgJiYgZGlyZWN0aW9uID09ICdzbWFsbGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoNyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJySGVhZGluZ0xldmVsID09IDEgJiYgZGlyZWN0aW9uID09ICdiaWdnZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09ICdiaWdnZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMnICsgdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJIZWFkaW5nTGV2ZWwgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMnLnJlcGVhdChzaXplKSArICcgJyArIHRleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJySGVhZGluZ0xldmVsID09IHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKGN1cnJIZWFkaW5nTGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMnLnJlcGVhdChzaXplKSArICcgJyArIHRleHQuc3Vic3RyKGN1cnJIZWFkaW5nTGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCB7XG4gICAgICAgICAgICAgICAgbGluZTogaSxcbiAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KShpKTtcbiAgICB9XG4gICAgY20uZm9jdXMoKTtcbn1cblxuXG5mdW5jdGlvbiBfdG9nZ2xlTGluZShjbSwgbmFtZSwgbGlzdHN0eWxlKSB7XG4gICAgaWYgKGNtLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBsaXN0UmVnZXhwID0gL14oXFxzKikoXFwqfC18XFwrfFxcZCpcXC4pKFxccyspLztcbiAgICB2YXIgd2hpdGVzcGFjZXNSZWdleHAgPSAvXlxccyovO1xuXG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICB2YXIgcmVwbCA9IHtcbiAgICAgICAgJ3F1b3RlJzogL14oXFxzKik+XFxzKy8sXG4gICAgICAgICd1bm9yZGVyZWQtbGlzdCc6IGxpc3RSZWdleHAsXG4gICAgICAgICdvcmRlcmVkLWxpc3QnOiBsaXN0UmVnZXhwLFxuICAgIH07XG5cbiAgICB2YXIgX2dldENoYXIgPSBmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgICAgICB2YXIgbWFwID0ge1xuICAgICAgICAgICAgJ3F1b3RlJzogJz4nLFxuICAgICAgICAgICAgJ3Vub3JkZXJlZC1saXN0JzogbGlzdHN0eWxlLFxuICAgICAgICAgICAgJ29yZGVyZWQtbGlzdCc6ICclJWkuJyxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbWFwW25hbWVdLnJlcGxhY2UoJyUlaScsIGkpO1xuICAgIH07XG5cbiAgICB2YXIgX2NoZWNrQ2hhciA9IGZ1bmN0aW9uIChuYW1lLCBjaGFyKSB7XG4gICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICAncXVvdGUnOiAnPicsXG4gICAgICAgICAgICAndW5vcmRlcmVkLWxpc3QnOiAnXFxcXCcgKyBsaXN0c3R5bGUsXG4gICAgICAgICAgICAnb3JkZXJlZC1saXN0JzogJ1xcXFxkKy4nLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcnQgPSBuZXcgUmVnRXhwKG1hcFtuYW1lXSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXIgJiYgcnQudGVzdChjaGFyKTtcbiAgICB9O1xuXG4gICAgdmFyIF90b2dnbGUgPSBmdW5jdGlvbiAobmFtZSwgdGV4dCwgdW50b2dnbGVPbmx5KSB7XG4gICAgICAgIHZhciBhcnIgPSBsaXN0UmVnZXhwLmV4ZWModGV4dCk7XG4gICAgICAgIHZhciBjaGFyID0gX2dldENoYXIobmFtZSwgbGluZSk7XG4gICAgICAgIGlmIChhcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChfY2hlY2tDaGFyKG5hbWUsIGFyclsyXSkpIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ID0gYXJyWzFdICsgY2hhciArIGFyclszXSArIHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlc1JlZ2V4cCwgJycpLnJlcGxhY2UocmVwbFtuYW1lXSwgJyQxJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodW50b2dnbGVPbmx5ID09IGZhbHNlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gY2hhciArICcgJyArIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIHZhciBsaW5lID0gMTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRQb2ludC5saW5lOyBpIDw9IGVuZFBvaW50LmxpbmU7IGkrKykge1xuICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gY20uZ2V0TGluZShpKTtcbiAgICAgICAgICAgIGlmIChzdGF0W25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZXBsW25hbWVdLCAnJDEnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgdG9nZ2xpbmcgdW5vcmRlcmVkLWxpc3QgZm9ybWF0dGluZywgY2hlY2sgaWYgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgIC8vIGlzIHBhcnQgb2YgYW4gb3JkZXJlZC1saXN0LCBhbmQgaWYgc28sIHVudG9nZ2xlIHRoYXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0lvbmFydS9lYXN5LW1hcmtkb3duLWVkaXRvci9pc3N1ZXMvOTJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSAndW5vcmRlcmVkLWxpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBfdG9nZ2xlKCdvcmRlcmVkLWxpc3QnLCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCA9IF90b2dnbGUobmFtZSwgdGV4dCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCB7XG4gICAgICAgICAgICAgICAgbGluZTogaSxcbiAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KShpKTtcbiAgICB9XG4gICAgY20uZm9jdXMoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICogQHBhcmFtIHsnbGluaycgfCAnaW1hZ2UnfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRFbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqL1xuZnVuY3Rpb24gX3RvZ2dsZUxpbmsoZWRpdG9yLCB0eXBlLCBzdGFydEVuZCwgdXJsKSB7XG4gICAgaWYgKCFlZGl0b3IuY29kZW1pcnJvciB8fCBlZGl0b3IuaXNQcmV2aWV3QWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBhY3RpdmUgPSBzdGF0W3R5cGVdO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBhY3RpdmUsIHN0YXJ0RW5kLCB1cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICB2YXIgdGV4dCA9IGNtLmdldExpbmUoc3RhcnRQb2ludC5saW5lKTtcbiAgICB2YXIgc3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0UG9pbnQuY2gpO1xuICAgIHZhciBlbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0UG9pbnQuY2gpO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2xpbmsnKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKC4qKVteIV1cXFsvLCAnJDEnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2ltYWdlJykge1xuICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoLyguKikhXFxbJC8sICckMScpO1xuICAgIH1cbiAgICBlbmQgPSBlbmQucmVwbGFjZSgvXVxcKC4qP1xcKS8sICcnKTtcblxuICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydCArIGVuZCwge1xuICAgICAgICBsaW5lOiBzdGFydFBvaW50LmxpbmUsXG4gICAgICAgIGNoOiAwLFxuICAgIH0sIHtcbiAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgfSk7XG5cbiAgICBzdGFydFBvaW50LmNoIC09IHN0YXJ0RW5kWzBdLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRQb2ludCAhPT0gZW5kUG9pbnQpIHtcbiAgICAgICAgZW5kUG9pbnQuY2ggLT0gc3RhcnRFbmRbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICBjbS5zZXRTZWxlY3Rpb24oc3RhcnRQb2ludCwgZW5kUG9pbnQpO1xuICAgIGNtLmZvY3VzKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gX3RvZ2dsZUJsb2NrKGVkaXRvciwgdHlwZSwgc3RhcnRfY2hhcnMsIGVuZF9jaGFycykge1xuICAgIGlmICghZWRpdG9yLmNvZGVtaXJyb3IgfHwgZWRpdG9yLmlzUHJldmlld0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbmRfY2hhcnMgPSAodHlwZW9mIGVuZF9jaGFycyA9PT0gJ3VuZGVmaW5lZCcpID8gc3RhcnRfY2hhcnMgOiBlbmRfY2hhcnM7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG5cbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgc3RhcnQgPSBzdGFydF9jaGFycztcbiAgICB2YXIgZW5kID0gZW5kX2NoYXJzO1xuXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcblxuICAgIGlmIChzdGF0W3R5cGVdKSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRMaW5lKHN0YXJ0UG9pbnQubGluZSk7XG4gICAgICAgIHN0YXJ0ID0gdGV4dC5zbGljZSgwLCBzdGFydFBvaW50LmNoKTtcbiAgICAgICAgZW5kID0gdGV4dC5zbGljZShzdGFydFBvaW50LmNoKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2JvbGQnKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoLyhcXCpcXCp8X18pKD8hW1xcc1xcU10qKFxcKlxcKnxfXykpLywgJycpO1xuICAgICAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoLyhcXCpcXCp8X18pLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKFxcKnxfKSg/IVtcXHNcXFNdKihcXCp8XykpLywgJycpO1xuICAgICAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoLyhcXCp8XykvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKFxcKlxcKnx+fikoPyFbXFxzXFxTXSooXFwqXFwqfH5+KSkvLCAnJyk7XG4gICAgICAgICAgICBlbmQgPSBlbmQucmVwbGFjZSgvKFxcKlxcKnx+fikvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKHN0YXJ0ICsgZW5kLCB7XG4gICAgICAgICAgICBsaW5lOiBzdGFydFBvaW50LmxpbmUsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICAgICAgY2g6IDk5OTk5OTk5OTk5OTk5LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHlwZSA9PSAnYm9sZCcgfHwgdHlwZSA9PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQuY2ggLT0gMjtcbiAgICAgICAgICAgIGlmIChzdGFydFBvaW50ICE9PSBlbmRQb2ludCkge1xuICAgICAgICAgICAgICAgIGVuZFBvaW50LmNoIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaXRhbGljJykge1xuICAgICAgICAgICAgc3RhcnRQb2ludC5jaCAtPSAxO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UG9pbnQgIT09IGVuZFBvaW50KSB7XG4gICAgICAgICAgICAgICAgZW5kUG9pbnQuY2ggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2JvbGQnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnKionKS5qb2luKCcnKTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCdfXycpLmpvaW4oJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCcqJykuam9pbignJyk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnXycpLmpvaW4oJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmlrZXRocm91Z2gnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnfn4nKS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHN0YXJ0ICsgdGV4dCArIGVuZCk7XG5cbiAgICAgICAgc3RhcnRQb2ludC5jaCArPSBzdGFydF9jaGFycy5sZW5ndGg7XG4gICAgICAgIGVuZFBvaW50LmNoID0gc3RhcnRQb2ludC5jaCArIHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIGNtLnNldFNlbGVjdGlvbihzdGFydFBvaW50LCBlbmRQb2ludCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gX2NsZWFuQmxvY2soY20pIHtcbiAgICBpZiAoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5sYXN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICB2YXIgdGV4dDtcblxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydFBvaW50LmxpbmU7IGxpbmUgPD0gZW5kUG9pbnQubGluZTsgbGluZSsrKSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRMaW5lKGxpbmUpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eWyBdKihbIyBdK3xcXCp8LXxbPiBdK3xbMC05XSsoLnxcXCkpKVsgXSovLCAnJyk7XG5cbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKHRleHQsIHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgb2YgYnl0ZXMgdG8gYSBodW1hbi1yZWFkYWJsZSBmaWxlIHNpemUuIElmIHlvdSBkZXNpcmVcbiAqIHRvIGFkZCBhIHNwYWNlIGJldHdlZW4gdGhlIHZhbHVlIGFuZCB0aGUgdW5pdCwgeW91IG5lZWQgdG8gYWRkIHRoaXMgc3BhY2VcbiAqIHRvIHRoZSBnaXZlbiB1bml0cy5cbiAqIEBwYXJhbSBieXRlcyB7bnVtYmVyfSBBIG51bWJlciBvZiBieXRlcywgYXMgaW50ZWdlci4gRXg6IDQyMTEzN1xuICogQHBhcmFtIHVuaXRzIHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgaHVtYW4tcmVhZGFibGUgdW5pdHMsIGllLiBbJyBCJywgJyBLJywgJyBNQiddXG4gKiBAcmV0dXJucyBzdHJpbmcgQSBodW1hbi1yZWFkYWJsZSBmaWxlIHNpemUuIEV4OiAnNDEyIEtCJ1xuICovXG5mdW5jdGlvbiBodW1hbkZpbGVTaXplKGJ5dGVzLCB1bml0cykge1xuICAgIGlmIChNYXRoLmFicyhieXRlcykgPCAxMDI0KSB7XG4gICAgICAgIHJldHVybiAnJyArIGJ5dGVzICsgdW5pdHNbMF07XG4gICAgfVxuICAgIHZhciB1ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGJ5dGVzIC89IDEwMjQ7XG4gICAgICAgICsrdTtcbiAgICB9IHdoaWxlIChNYXRoLmFicyhieXRlcykgPj0gMTAyNCAmJiB1IDwgdW5pdHMubGVuZ3RoKTtcbiAgICByZXR1cm4gJycgKyBieXRlcy50b0ZpeGVkKDEpICsgdW5pdHNbdV07XG59XG5cbi8vIE1lcmdlIHRoZSBwcm9wZXJ0aWVzIG9mIG9uZSBvYmplY3QgaW50byBhbm90aGVyLlxuZnVuY3Rpb24gX21lcmdlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW3Byb3BlcnR5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV0uY29uY2F0KHRhcmdldFtwcm9wZXJ0eV0gaW5zdGFuY2VvZiBBcnJheSA/IHRhcmdldFtwcm9wZXJ0eV0gOiBbXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc291cmNlW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldLmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBfbWVyZ2VQcm9wZXJ0aWVzKHRhcmdldFtwcm9wZXJ0eV0gfHwge30sIHNvdXJjZVtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIE1lcmdlIGFuIGFyYml0cmFyeSBudW1iZXIgb2Ygb2JqZWN0cyBpbnRvIG9uZS5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXQgPSBfbWVyZ2VQcm9wZXJ0aWVzKHRhcmdldCwgYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBUaGUgcmlnaHQgd29yZCBjb3VudCBpbiByZXNwZWN0IGZvciBDSksuICovXG5mdW5jdGlvbiB3b3JkQ291bnQoZGF0YSkge1xuICAgIHZhciBwYXR0ZXJuID0gL1thLXpBLVowLTlfXFx1MDBBMC1cXHUwMkFGXFx1MDM5Mi1cXHUwM2M5XFx1MDQxMC1cXHUwNEY5XSt8W1xcdTRFMDAtXFx1OUZGRlxcdTM0MDAtXFx1NGRiZlxcdWY5MDAtXFx1ZmFmZlxcdTMwNDAtXFx1MzA5ZlxcdWFjMDAtXFx1ZDdhZl0rL2c7XG4gICAgdmFyIG0gPSBkYXRhLm1hdGNoKHBhdHRlcm4pO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgaWYgKG0gPT09IG51bGwpIHJldHVybiBjb3VudDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1baV0uY2hhckNvZGVBdCgwKSA+PSAweDRFMDApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IG1baV0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5cbnZhciBpY29uQ2xhc3NNYXAgPSB7XG4gICAgJ2JvbGQnOiAnZmEgZmEtYm9sZCcsXG4gICAgJ2l0YWxpYyc6ICdmYSBmYS1pdGFsaWMnLFxuICAgICdzdHJpa2V0aHJvdWdoJzogJ2ZhIGZhLXN0cmlrZXRocm91Z2gnLFxuICAgICdoZWFkaW5nJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nJyxcbiAgICAnaGVhZGluZy1zbWFsbGVyJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nIGhlYWRlci1zbWFsbGVyJyxcbiAgICAnaGVhZGluZy1iaWdnZXInOiAnZmEgZmEtaGVhZGVyIGZhLWhlYWRpbmcgaGVhZGVyLWJpZ2dlcicsXG4gICAgJ2hlYWRpbmctMSc6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItMScsXG4gICAgJ2hlYWRpbmctMic6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItMicsXG4gICAgJ2hlYWRpbmctMyc6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItMycsXG4gICAgJ2NvZGUnOiAnZmEgZmEtY29kZScsXG4gICAgJ3F1b3RlJzogJ2ZhIGZhLXF1b3RlLWxlZnQnLFxuICAgICdvcmRlcmVkLWxpc3QnOiAnZmEgZmEtbGlzdC1vbCcsXG4gICAgJ3Vub3JkZXJlZC1saXN0JzogJ2ZhIGZhLWxpc3QtdWwnLFxuICAgICdjbGVhbi1ibG9jayc6ICdmYSBmYS1lcmFzZXInLFxuICAgICdsaW5rJzogJ2ZhIGZhLWxpbmsnLFxuICAgICdpbWFnZSc6ICdmYSBmYS1pbWFnZScsXG4gICAgJ3VwbG9hZC1pbWFnZSc6ICdmYSBmYS1pbWFnZScsXG4gICAgJ3RhYmxlJzogJ2ZhIGZhLXRhYmxlJyxcbiAgICAnaG9yaXpvbnRhbC1ydWxlJzogJ2ZhIGZhLW1pbnVzJyxcbiAgICAncHJldmlldyc6ICdmYSBmYS1leWUnLFxuICAgICdzaWRlLWJ5LXNpZGUnOiAnZmEgZmEtY29sdW1ucycsXG4gICAgJ2Z1bGxzY3JlZW4nOiAnZmEgZmEtYXJyb3dzLWFsdCcsXG4gICAgJ2d1aWRlJzogJ2ZhIGZhLXF1ZXN0aW9uLWNpcmNsZScsXG4gICAgJ3VuZG8nOiAnZmEgZmEtdW5kbycsXG4gICAgJ3JlZG8nOiAnZmEgZmEtcmVwZWF0IGZhLXJlZG8nLFxufTtcblxudmFyIHRvb2xiYXJCdWlsdEluQnV0dG9ucyA9IHtcbiAgICAnYm9sZCc6IHtcbiAgICAgICAgbmFtZTogJ2JvbGQnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUJvbGQsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydib2xkJ10sXG4gICAgICAgIHRpdGxlOiAnQm9sZCcsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnaXRhbGljJzoge1xuICAgICAgICBuYW1lOiAnaXRhbGljJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVJdGFsaWMsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydpdGFsaWMnXSxcbiAgICAgICAgdGl0bGU6ICdJdGFsaWMnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3N0cmlrZXRocm91Z2gnOiB7XG4gICAgICAgIG5hbWU6ICdzdHJpa2V0aHJvdWdoJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVTdHJpa2V0aHJvdWdoLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnc3RyaWtldGhyb3VnaCddLFxuICAgICAgICB0aXRsZTogJ1N0cmlrZXRocm91Z2gnLFxuICAgIH0sXG4gICAgJ2hlYWRpbmcnOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nU21hbGxlcixcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmcnXSxcbiAgICAgICAgdGl0bGU6ICdIZWFkaW5nJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdoZWFkaW5nLXNtYWxsZXInOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nLXNtYWxsZXInLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmdTbWFsbGVyLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy1zbWFsbGVyJ10sXG4gICAgICAgIHRpdGxlOiAnU21hbGxlciBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdoZWFkaW5nLWJpZ2dlcic6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmctYmlnZ2VyJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nQmlnZ2VyLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy1iaWdnZXInXSxcbiAgICAgICAgdGl0bGU6ICdCaWdnZXIgSGVhZGluZycsXG4gICAgfSxcbiAgICAnaGVhZGluZy0xJzoge1xuICAgICAgICBuYW1lOiAnaGVhZGluZy0xJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nMSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmctMSddLFxuICAgICAgICB0aXRsZTogJ0JpZyBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdoZWFkaW5nLTInOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nLTInLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmcyLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy0yJ10sXG4gICAgICAgIHRpdGxlOiAnTWVkaXVtIEhlYWRpbmcnLFxuICAgIH0sXG4gICAgJ2hlYWRpbmctMyc6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmctMycsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSGVhZGluZzMsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydoZWFkaW5nLTMnXSxcbiAgICAgICAgdGl0bGU6ICdTbWFsbCBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdzZXBhcmF0b3ItMSc6IHtcbiAgICAgICAgbmFtZTogJ3NlcGFyYXRvci0xJyxcbiAgICB9LFxuICAgICdjb2RlJzoge1xuICAgICAgICBuYW1lOiAnY29kZScsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlQ29kZUJsb2NrLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnY29kZSddLFxuICAgICAgICB0aXRsZTogJ0NvZGUnLFxuICAgIH0sXG4gICAgJ3F1b3RlJzoge1xuICAgICAgICBuYW1lOiAncXVvdGUnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUJsb2NrcXVvdGUsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydxdW90ZSddLFxuICAgICAgICB0aXRsZTogJ1F1b3RlJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICd1bm9yZGVyZWQtbGlzdCc6IHtcbiAgICAgICAgbmFtZTogJ3Vub3JkZXJlZC1saXN0JyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVVbm9yZGVyZWRMaXN0LFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsndW5vcmRlcmVkLWxpc3QnXSxcbiAgICAgICAgdGl0bGU6ICdHZW5lcmljIExpc3QnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ29yZGVyZWQtbGlzdCc6IHtcbiAgICAgICAgbmFtZTogJ29yZGVyZWQtbGlzdCcsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlT3JkZXJlZExpc3QsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydvcmRlcmVkLWxpc3QnXSxcbiAgICAgICAgdGl0bGU6ICdOdW1iZXJlZCBMaXN0JyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdjbGVhbi1ibG9jayc6IHtcbiAgICAgICAgbmFtZTogJ2NsZWFuLWJsb2NrJyxcbiAgICAgICAgYWN0aW9uOiBjbGVhbkJsb2NrLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnY2xlYW4tYmxvY2snXSxcbiAgICAgICAgdGl0bGU6ICdDbGVhbiBibG9jaycsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTInOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItMicsXG4gICAgfSxcbiAgICAnbGluayc6IHtcbiAgICAgICAgbmFtZTogJ2xpbmsnLFxuICAgICAgICBhY3Rpb246IGRyYXdMaW5rLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnbGluayddLFxuICAgICAgICB0aXRsZTogJ0NyZWF0ZSBMaW5rJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdpbWFnZSc6IHtcbiAgICAgICAgbmFtZTogJ2ltYWdlJyxcbiAgICAgICAgYWN0aW9uOiBkcmF3SW1hZ2UsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydpbWFnZSddLFxuICAgICAgICB0aXRsZTogJ0luc2VydCBJbWFnZScsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAndXBsb2FkLWltYWdlJzoge1xuICAgICAgICBuYW1lOiAndXBsb2FkLWltYWdlJyxcbiAgICAgICAgYWN0aW9uOiBkcmF3VXBsb2FkZWRJbWFnZSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3VwbG9hZC1pbWFnZSddLFxuICAgICAgICB0aXRsZTogJ0ltcG9ydCBhbiBpbWFnZScsXG4gICAgfSxcbiAgICAndGFibGUnOiB7XG4gICAgICAgIG5hbWU6ICd0YWJsZScsXG4gICAgICAgIGFjdGlvbjogZHJhd1RhYmxlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsndGFibGUnXSxcbiAgICAgICAgdGl0bGU6ICdJbnNlcnQgVGFibGUnLFxuICAgIH0sXG4gICAgJ2hvcml6b250YWwtcnVsZSc6IHtcbiAgICAgICAgbmFtZTogJ2hvcml6b250YWwtcnVsZScsXG4gICAgICAgIGFjdGlvbjogZHJhd0hvcml6b250YWxSdWxlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaG9yaXpvbnRhbC1ydWxlJ10sXG4gICAgICAgIHRpdGxlOiAnSW5zZXJ0IEhvcml6b250YWwgTGluZScsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTMnOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItMycsXG4gICAgfSxcbiAgICAncHJldmlldyc6IHtcbiAgICAgICAgbmFtZTogJ3ByZXZpZXcnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZVByZXZpZXcsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydwcmV2aWV3J10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdUb2dnbGUgUHJldmlldycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnc2lkZS1ieS1zaWRlJzoge1xuICAgICAgICBuYW1lOiAnc2lkZS1ieS1zaWRlJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVTaWRlQnlTaWRlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnc2lkZS1ieS1zaWRlJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9Nb2JpbGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnVG9nZ2xlIFNpZGUgYnkgU2lkZScsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnZnVsbHNjcmVlbic6IHtcbiAgICAgICAgbmFtZTogJ2Z1bGxzY3JlZW4nLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUZ1bGxTY3JlZW4sXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydmdWxsc2NyZWVuJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9Nb2JpbGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnVG9nZ2xlIEZ1bGxzY3JlZW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3NlcGFyYXRvci00Jzoge1xuICAgICAgICBuYW1lOiAnc2VwYXJhdG9yLTQnLFxuICAgIH0sXG4gICAgJ2d1aWRlJzoge1xuICAgICAgICBuYW1lOiAnZ3VpZGUnLFxuICAgICAgICBhY3Rpb246ICdodHRwczovL3d3dy5tYXJrZG93bmd1aWRlLm9yZy9iYXNpYy1zeW50YXgvJyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2d1aWRlJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdNYXJrZG93biBHdWlkZScsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTUnOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItNScsXG4gICAgfSxcbiAgICAndW5kbyc6IHtcbiAgICAgICAgbmFtZTogJ3VuZG8nLFxuICAgICAgICBhY3Rpb246IHVuZG8sXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWyd1bmRvJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdVbmRvJyxcbiAgICB9LFxuICAgICdyZWRvJzoge1xuICAgICAgICBuYW1lOiAncmVkbycsXG4gICAgICAgIGFjdGlvbjogcmVkbyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3JlZG8nXSxcbiAgICAgICAgbm9EaXNhYmxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJ1JlZG8nLFxuICAgIH0sXG59O1xuXG52YXIgaW5zZXJ0VGV4dHMgPSB7XG4gICAgbGluazogWydbJywgJ10oI3VybCMpJ10sXG4gICAgaW1hZ2U6IFsnIVsnLCAnXSgjdXJsIyknXSxcbiAgICB1cGxvYWRlZEltYWdlOiBbJyFbXSgjdXJsIyknLCAnJ10sXG4gICAgLy8gdXBsb2FkZWRJbWFnZTogWychW10oI3VybCMpXFxuJywgJyddLCAvLyBUT0RPOiBOZXcgbGluZSBpbnNlcnRpb24gZG9lc24ndCB3b3JrIGhlcmUuXG4gICAgdGFibGU6IFsnJywgJ1xcblxcbnwgQ29sdW1uIDEgfCBDb2x1bW4gMiB8IENvbHVtbiAzIHxcXG58IC0tLS0tLS0tIHwgLS0tLS0tLS0gfCAtLS0tLS0tLSB8XFxufCBUZXh0ICAgICB8IFRleHQgICAgIHwgVGV4dCAgICAgfFxcblxcbiddLFxuICAgIGhvcml6b250YWxSdWxlOiBbJycsICdcXG5cXG4tLS0tLVxcblxcbiddLFxufTtcblxudmFyIHByb21wdFRleHRzID0ge1xuICAgIGxpbms6ICdVUkwgZm9yIHRoZSBsaW5rOicsXG4gICAgaW1hZ2U6ICdVUkwgb2YgdGhlIGltYWdlOicsXG59O1xuXG52YXIgdGltZUZvcm1hdCA9IHtcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgZm9ybWF0OiB7XG4gICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgfSxcbn07XG5cbnZhciBibG9ja1N0eWxlcyA9IHtcbiAgICAnYm9sZCc6ICcqKicsXG4gICAgJ2NvZGUnOiAnYGBgJyxcbiAgICAnaXRhbGljJzogJyonLFxufTtcblxuLyoqXG4gKiBUZXh0cyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgKG1haW5seSBvbiB0aGUgc3RhdHVzIGJhcikgZm9yIHRoZSBpbXBvcnQgaW1hZ2VcbiAqIGZlYXR1cmUuIENhbiBiZSB1c2VkIGZvciBjdXN0b21pemF0aW9uIG9yIGludGVybmF0aW9uYWxpemF0aW9uLlxuICovXG52YXIgaW1hZ2VUZXh0cyA9IHtcbiAgICBzYkluaXQ6ICdBdHRhY2ggZmlsZXMgYnkgZHJhZyBhbmQgZHJvcHBpbmcgb3IgcGFzdGluZyBmcm9tIGNsaXBib2FyZC4nLFxuICAgIHNiT25EcmFnRW50ZXI6ICdEcm9wIGltYWdlIHRvIHVwbG9hZCBpdC4nLFxuICAgIHNiT25Ecm9wOiAnVXBsb2FkaW5nIGltYWdlICNpbWFnZXNfbmFtZXMjLi4uJyxcbiAgICBzYlByb2dyZXNzOiAnVXBsb2FkaW5nICNmaWxlX25hbWUjOiAjcHJvZ3Jlc3MjJScsXG4gICAgc2JPblVwbG9hZGVkOiAnVXBsb2FkZWQgI2ltYWdlX25hbWUjJyxcbiAgICBzaXplVW5pdHM6ICcgQiwgS0IsIE1CJyxcbn07XG5cbi8qKlxuICogRXJyb3JzIGRpc3BsYXllZCB0byB0aGUgdXNlciwgdXNpbmcgdGhlIGBlcnJvckNhbGxiYWNrYCBvcHRpb24uIENhbiBiZSB1c2VkIGZvclxuICogY3VzdG9taXphdGlvbiBvciBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiAqL1xudmFyIGVycm9yTWVzc2FnZXMgPSB7XG4gICAgbm9GaWxlR2l2ZW46ICdZb3UgbXVzdCBzZWxlY3QgYSBmaWxlLicsXG4gICAgdHlwZU5vdEFsbG93ZWQ6ICdUaGlzIGltYWdlIHR5cGUgaXMgbm90IGFsbG93ZWQuJyxcbiAgICBmaWxlVG9vTGFyZ2U6ICdJbWFnZSAjaW1hZ2VfbmFtZSMgaXMgdG9vIGJpZyAoI2ltYWdlX3NpemUjKS5cXG4nICtcbiAgICAgICAgJ01heGltdW0gZmlsZSBzaXplIGlzICNpbWFnZV9tYXhfc2l6ZSMuJyxcbiAgICBpbXBvcnRFcnJvcjogJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gdXBsb2FkaW5nIHRoZSBpbWFnZSAjaW1hZ2VfbmFtZSMuJyxcbn07XG5cbi8qKlxuICogSW50ZXJmYWNlIG9mIEVhc3lNREUuXG4gKi9cbmZ1bmN0aW9uIEVhc3lNREUob3B0aW9ucykge1xuICAgIC8vIEhhbmRsZSBvcHRpb25zIHBhcmFtZXRlclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gVXNlZCBsYXRlciB0byByZWZlciB0byBpdFwicyBwYXJlbnRcbiAgICBvcHRpb25zLnBhcmVudCA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBpZiBGb250IEF3ZXNvbWUgbmVlZHMgdG8gYmUgYXV0byBkb3dubG9hZGVkXG4gICAgdmFyIGF1dG9Eb3dubG9hZEZBID0gdHJ1ZTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lID09PSBmYWxzZSkge1xuICAgICAgICBhdXRvRG93bmxvYWRGQSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lICE9PSB0cnVlKSB7XG4gICAgICAgIHZhciBzdHlsZVNoZWV0cyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlU2hlZXRzW2ldLmhyZWYpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZVNoZWV0c1tpXS5ocmVmLmluZGV4T2YoJy8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBhdXRvRG93bmxvYWRGQSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9Eb3dubG9hZEZBKSB7XG4gICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgbGluay5ocmVmID0gJ2h0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lL2xhdGVzdC9jc3MvZm9udC1hd2Vzb21lLm1pbi5jc3MnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH1cblxuXG4gICAgLy8gRmluZCB0aGUgdGV4dGFyZWEgdG8gdXNlXG4gICAgaWYgKG9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBlbGVtZW50IG9wdGlvbiB3YXMgc3BlY2lmaWVkLCBidXQgbm8gZWxlbWVudCB3YXMgZm91bmRcbiAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IEVycm9yLiBObyBlbGVtZW50IHdhcyBmb3VuZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gSGFuZGxlIHRvb2xiYXJcbiAgICBpZiAob3B0aW9ucy50b29sYmFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgICBvcHRpb25zLnRvb2xiYXIgPSBbXTtcblxuXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgYnVpbHQgaW4gYnV0dG9ucywgdG8gZ2V0IHRoZSBwcmVmZXJyZWQgb3JkZXJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRvb2xiYXJCdWlsdEluQnV0dG9ucykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b29sYmFyQnVpbHRJbkJ1dHRvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ3NlcGFyYXRvci0nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xiYXIucHVzaCgnfCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0b29sYmFyQnVpbHRJbkJ1dHRvbnNba2V5XS5kZWZhdWx0ID09PSB0cnVlIHx8IChvcHRpb25zLnNob3dJY29ucyAmJiBvcHRpb25zLnNob3dJY29ucy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgJiYgb3B0aW9ucy5zaG93SWNvbnMuaW5kZXhPZihrZXkpICE9IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xiYXIucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVkaXRvciBwcmV2aWV3IHN0eWxpbmcgY2xhc3MuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ByZXZpZXdDbGFzcycpKSB7XG4gICAgICAgIG9wdGlvbnMucHJldmlld0NsYXNzID0gJ2VkaXRvci1wcmV2aWV3JztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3RhdHVzIGJhclxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzdGF0dXMnKSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IFsnYXV0b3NhdmUnLCAnbGluZXMnLCAnd29yZHMnLCAnY3Vyc29yJ107XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXBsb2FkSW1hZ2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLnVuc2hpZnQoJ3VwbG9hZC1pbWFnZScpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBBZGQgZGVmYXVsdCBwcmV2aWV3IHJlbmRlcmluZyBmdW5jdGlvblxuICAgIGlmICghb3B0aW9ucy5wcmV2aWV3UmVuZGVyKSB7XG4gICAgICAgIG9wdGlvbnMucHJldmlld1JlbmRlciA9IGZ1bmN0aW9uIChwbGFpblRleHQpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IFwidGhpc1wiIHJlZmVycyB0byB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5tYXJrZG93bihwbGFpblRleHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBjb25maWdcbiAgICBvcHRpb25zLnBhcnNpbmdDb25maWcgPSBleHRlbmQoe1xuICAgICAgICBoaWdobGlnaHRGb3JtYXR0aW5nOiB0cnVlLCAvLyBuZWVkZWQgZm9yIHRvZ2dsZUNvZGVCbG9jayB0byBkZXRlY3QgdHlwZXMgb2YgY29kZVxuICAgIH0sIG9wdGlvbnMucGFyc2luZ0NvbmZpZyB8fCB7fSk7XG5cblxuICAgIC8vIE1lcmdpbmcgdGhlIGluc2VydFRleHRzLCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAgb3B0aW9ucy5pbnNlcnRUZXh0cyA9IGV4dGVuZCh7fSwgaW5zZXJ0VGV4dHMsIG9wdGlvbnMuaW5zZXJ0VGV4dHMgfHwge30pO1xuXG5cbiAgICAvLyBNZXJnaW5nIHRoZSBwcm9tcHRUZXh0cywgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgIG9wdGlvbnMucHJvbXB0VGV4dHMgPSBleHRlbmQoe30sIHByb21wdFRleHRzLCBvcHRpb25zLnByb21wdFRleHRzIHx8IHt9KTtcblxuXG4gICAgLy8gTWVyZ2luZyB0aGUgYmxvY2tTdHlsZXMsIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICBvcHRpb25zLmJsb2NrU3R5bGVzID0gZXh0ZW5kKHt9LCBibG9ja1N0eWxlcywgb3B0aW9ucy5ibG9ja1N0eWxlcyB8fCB7fSk7XG5cblxuICAgIGlmIChvcHRpb25zLmF1dG9zYXZlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBNZXJnaW5nIHRoZSBBdXRvc2F2ZSB0aW1lRm9ybWF0LCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMuYXV0b3NhdmUudGltZUZvcm1hdCA9IGV4dGVuZCh7fSwgdGltZUZvcm1hdCwgb3B0aW9ucy5hdXRvc2F2ZS50aW1lRm9ybWF0IHx8IHt9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmljb25DbGFzc01hcCA9IGV4dGVuZCh7fSwgaWNvbkNsYXNzTWFwLCBvcHRpb25zLmljb25DbGFzc01hcCB8fCB7fSk7XG5cbiAgICAvLyBNZXJnaW5nIHRoZSBzaG9ydGN1dHMsIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICBvcHRpb25zLnNob3J0Y3V0cyA9IGV4dGVuZCh7fSwgc2hvcnRjdXRzLCBvcHRpb25zLnNob3J0Y3V0cyB8fCB7fSk7XG5cbiAgICBvcHRpb25zLm1heEhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0IHx8IHVuZGVmaW5lZDtcblxuICAgIG9wdGlvbnMuZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgJ2x0cic7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4SGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBNaW4gYW5kIG1heCBoZWlnaHQgYXJlIGVxdWFsIGlmIG1heEhlaWdodCBpcyBzZXRcbiAgICAgICAgb3B0aW9ucy5taW5IZWlnaHQgPSBvcHRpb25zLm1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLm1pbkhlaWdodCA9IG9wdGlvbnMubWluSGVpZ2h0IHx8ICczMDBweCc7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5lcnJvckNhbGxiYWNrID0gb3B0aW9ucy5lcnJvckNhbGxiYWNrIHx8IGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgYWxlcnQoZXJyb3JNZXNzYWdlKTtcbiAgICB9O1xuXG4gICAgLy8gSW1wb3J0LWltYWdlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgIG9wdGlvbnMudXBsb2FkSW1hZ2UgPSBvcHRpb25zLnVwbG9hZEltYWdlIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuaW1hZ2VNYXhTaXplID0gb3B0aW9ucy5pbWFnZU1heFNpemUgfHwgMjA5NzE1MjsgLy8gMTAyNCAqIDEwMjQgKiAyXG4gICAgb3B0aW9ucy5pbWFnZUFjY2VwdCA9IG9wdGlvbnMuaW1hZ2VBY2NlcHQgfHwgJ2ltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmLCBpbWFnZS9hdmlmJztcbiAgICBvcHRpb25zLmltYWdlVGV4dHMgPSBleHRlbmQoe30sIGltYWdlVGV4dHMsIG9wdGlvbnMuaW1hZ2VUZXh0cyB8fCB7fSk7XG4gICAgb3B0aW9ucy5lcnJvck1lc3NhZ2VzID0gZXh0ZW5kKHt9LCBlcnJvck1lc3NhZ2VzLCBvcHRpb25zLmVycm9yTWVzc2FnZXMgfHwge30pO1xuICAgIG9wdGlvbnMuaW1hZ2VQYXRoQWJzb2x1dGUgPSBvcHRpb25zLmltYWdlUGF0aEFic29sdXRlIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuaW1hZ2VDU1JGTmFtZSA9IG9wdGlvbnMuaW1hZ2VDU1JGTmFtZSB8fCAnY3NyZm1pZGRsZXdhcmV0b2tlbic7XG4gICAgb3B0aW9ucy5pbWFnZUNTUkZIZWFkZXIgPSBvcHRpb25zLmltYWdlQ1NSRkhlYWRlciB8fCBmYWxzZTtcbiAgICBvcHRpb25zLmltYWdlSW5wdXROYW1lID0gb3B0aW9ucy5pbWFnZUlucHV0TmFtZSB8fCAnaW1hZ2UnO1xuXG5cbiAgICAvLyBDaGFuZ2UgdW5pcXVlX2lkIHRvIHVuaXF1ZUlkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChvcHRpb25zLmF1dG9zYXZlICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmF1dG9zYXZlLnVuaXF1ZV9pZCAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVfaWQgIT0gJycpXG4gICAgICAgIG9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQgPSBvcHRpb25zLmF1dG9zYXZlLnVuaXF1ZV9pZDtcblxuICAgIC8vIElmIG92ZXJsYXkgbW9kZSBpcyBzcGVjaWZpZWQgYW5kIGNvbWJpbmUgaXMgbm90IHByb3ZpZGVkLCBkZWZhdWx0IGl0IHRvIHRydWVcbiAgICBpZiAob3B0aW9ucy5vdmVybGF5TW9kZSAmJiBvcHRpb25zLm92ZXJsYXlNb2RlLmNvbWJpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm92ZXJsYXlNb2RlLmNvbWJpbmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGlzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cbiAgICAvLyBBdXRvIHJlbmRlclxuICAgIHRoaXMucmVuZGVyKCk7XG5cblxuICAgIC8vIFRoZSBjb2RlbWlycm9yIGNvbXBvbmVudCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciByZW5kZXJpbmdcbiAgICAvLyBzbywgdGhlIHNldHRlciBmb3IgdGhlIGluaXRpYWxWYWx1ZSBjYW4gb25seSBydW4gYWZ0ZXJcbiAgICAvLyB0aGUgZWxlbWVudCBoYXMgYmVlbiByZW5kZXJlZFxuICAgIGlmIChvcHRpb25zLmluaXRpYWxWYWx1ZSAmJiAoIXRoaXMub3B0aW9ucy5hdXRvc2F2ZSB8fCB0aGlzLm9wdGlvbnMuYXV0b3NhdmUuZm91bmRTYXZlZFZhbHVlICE9PSB0cnVlKSkge1xuICAgICAgICB0aGlzLnZhbHVlKG9wdGlvbnMuaW5pdGlhbFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51cGxvYWRJbWFnZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdkcmFnZW50ZXInLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JPbkRyYWdFbnRlcik7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2RyYWdlbmQnLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JJbml0KTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJhZ2xlYXZlJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJhZ292ZXInLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JPbkRyYWdFbnRlcik7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJvcCcsIGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlc1VzaW5nQ3VzdG9tRnVuY3Rpb24ob3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uLCBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlcyhldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ3Bhc3RlJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYudXBsb2FkSW1hZ2VzVXNpbmdDdXN0b21GdW5jdGlvbihvcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24sIGV2ZW50LmNsaXBib2FyZERhdGEuZmlsZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlcyhldmVudC5jbGlwYm9hcmREYXRhLmZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFVwbG9hZCBhc3luY2hyb25vdXNseSBhIGxpc3Qgb2YgaW1hZ2VzIHRvIGEgc2VydmVyLlxuICpcbiAqIENhbiBiZSB0cmlnZ2VyZWQgYnk6XG4gKiAtIGRyYWcmZHJvcDtcbiAqIC0gY29weS1wYXN0ZTtcbiAqIC0gdGhlIGJyb3dzZS1maWxlIHdpbmRvdyAob3BlbmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSAqdXBsb2FkLWltYWdlKiBpY29uKS5cbiAqIEBwYXJhbSB7RmlsZUxpc3R9IGZpbGVzIFRoZSBmaWxlcyB0byB1cGxvYWQgdGhlIHRoZSBzZXJ2ZXIuXG4gKiBAcGFyYW0gW29uU3VjY2Vzc10ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqIEBwYXJhbSBbb25FcnJvcl0ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VzID0gZnVuY3Rpb24gKGZpbGVzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lcy5wdXNoKGZpbGVzW2ldLm5hbWUpO1xuICAgICAgICB0aGlzLnVwbG9hZEltYWdlKGZpbGVzW2ldLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgdGhpcy5vcHRpb25zLmltYWdlVGV4dHMuc2JPbkRyb3AucmVwbGFjZSgnI2ltYWdlc19uYW1lcyMnLCBuYW1lcy5qb2luKCcsICcpKSk7XG59O1xuXG4vKipcbiAqIFVwbG9hZCBhc3luY2hyb25vdXNseSBhIGxpc3Qgb2YgaW1hZ2VzIHRvIGEgc2VydmVyLlxuICpcbiAqIENhbiBiZSB0cmlnZ2VyZWQgYnk6XG4gKiAtIGRyYWcmZHJvcDtcbiAqIC0gY29weS1wYXN0ZTtcbiAqIC0gdGhlIGJyb3dzZS1maWxlIHdpbmRvdyAob3BlbmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSAqdXBsb2FkLWltYWdlKiBpY29uKS5cbiAqIEBwYXJhbSBpbWFnZVVwbG9hZEZ1bmN0aW9uIHtGdW5jdGlvbn0gVGhlIGN1c3RvbSBmdW5jdGlvbiB0byB1cGxvYWQgdGhlIGltYWdlIHBhc3NlZCBpbiBvcHRpb25zLlxuICogQHBhcmFtIHtGaWxlTGlzdH0gZmlsZXMgVGhlIGZpbGVzIHRvIHVwbG9hZCB0aGUgdGhlIHNlcnZlci5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VzVXNpbmdDdXN0b21GdW5jdGlvbiA9IGZ1bmN0aW9uIChpbWFnZVVwbG9hZEZ1bmN0aW9uLCBmaWxlcykge1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWVzLnB1c2goZmlsZXNbaV0ubmFtZSk7XG4gICAgICAgIHRoaXMudXBsb2FkSW1hZ2VVc2luZ0N1c3RvbUZ1bmN0aW9uKGltYWdlVXBsb2FkRnVuY3Rpb24sIGZpbGVzW2ldKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHRoaXMub3B0aW9ucy5pbWFnZVRleHRzLnNiT25Ecm9wLnJlcGxhY2UoJyNpbWFnZXNfbmFtZXMjJywgbmFtZXMuam9pbignLCAnKSkpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gaXRlbSBpbiB0aGUgc3RhdHVzIGJhci5cbiAqIEBwYXJhbSBpdGVtTmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgaXRlbSB0byB1cGRhdGUgKGllLiAndXBsb2FkLWltYWdlJywgJ2F1dG9zYXZlJywgZXRjLikuXG4gKiBAcGFyYW0gY29udGVudCB7c3RyaW5nfSB0aGUgbmV3IGNvbnRlbnQgb2YgdGhlIGl0ZW0gdG8gd3JpdGUgaW4gdGhlIHN0YXR1cyBiYXIuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnVwZGF0ZVN0YXR1c0JhciA9IGZ1bmN0aW9uIChpdGVtTmFtZSwgY29udGVudCkge1xuICAgIGlmICghdGhpcy5ndWkuc3RhdHVzYmFyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmdDbGFzc2VzID0gdGhpcy5ndWkuc3RhdHVzYmFyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaXRlbU5hbWUpO1xuICAgIGlmIChtYXRjaGluZ0NsYXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuZ3VpLnN0YXR1c2Jhci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGl0ZW1OYW1lKVswXS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmIChtYXRjaGluZ0NsYXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBzdGF0dXMgYmFyIGl0ZW0gJyArIGl0ZW1OYW1lICsgJyB3YXMgbm90IGZvdW5kLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBTZXZlcmFsIHN0YXR1cyBiYXIgaXRlbXMgbmFtZWQgJyArIGl0ZW1OYW1lICsgJyB3YXMgZm91bmQuJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IG1hcmtkb3duIHJlbmRlci5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUubWFya2Rvd24gPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmIChtYXJrZWQpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgICB2YXIgbWFya2VkT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcubWFya2VkT3B0aW9ucykge1xuICAgICAgICAgICAgbWFya2VkT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcubWFya2VkT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtlZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBvcHRpb25zXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLnNpbmdsZUxpbmVCcmVha3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtYXJrZWRPcHRpb25zLmJyZWFrcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya2VkT3B0aW9ucy5icmVha3MgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcuY29kZVN5bnRheEhpZ2hsaWdodGluZyA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAvKiBHZXQgSExKUyBmcm9tIGNvbmZpZyBvciB3aW5kb3cgKi9cbiAgICAgICAgICAgIHZhciBobGpzID0gdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5obGpzIHx8IHdpbmRvdy5obGpzO1xuXG4gICAgICAgICAgICAvKiBDaGVjayBpZiBITEpTIGxvYWRlZCAqL1xuICAgICAgICAgICAgaWYgKGhsanMpIHtcbiAgICAgICAgICAgICAgICBtYXJrZWRPcHRpb25zLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChjb2RlLCBsYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5ndWFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBobGpzLmhpZ2hsaWdodChsYW5ndWFnZSwgY29kZSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHRBdXRvKGNvZGUpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBvcHRpb25zXG4gICAgICAgIG1hcmtlZC51c2UobWFya2VkT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgbWFya2Rvd24gdG8gSFRNTFxuICAgICAgICB2YXIgaHRtbFRleHQgPSBtYXJrZWQucGFyc2UodGV4dCk7XG5cbiAgICAgICAgLy8gU2FuaXRpemUgSFRNTFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5zYW5pdGl6ZXJGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaHRtbFRleHQgPSB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLnNhbml0aXplckZ1bmN0aW9uLmNhbGwodGhpcywgaHRtbFRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWRpdCB0aGUgSFRNTCBhbmNob3JzIHRvIGFkZCAndGFyZ2V0PVwiX2JsYW5rXCInIGJ5IGRlZmF1bHQuXG4gICAgICAgIGh0bWxUZXh0ID0gYWRkQW5jaG9yVGFyZ2V0QmxhbmsoaHRtbFRleHQpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0LXN0eWxlIHdoZW4gcmVuZGVyaW5nIGNoZWNrYm94ZXNcbiAgICAgICAgaHRtbFRleHQgPSByZW1vdmVMaXN0U3R5bGVXaGVuQ2hlY2tib3goaHRtbFRleHQpO1xuXG4gICAgICAgIHJldHVybiBodG1sVGV4dDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbmRlciBlZGl0b3IgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSB0aGlzLmVsZW1lbnQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RleHRhcmVhJylbMF07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkICYmIHRoaXMuX3JlbmRlcmVkID09PSBlbCkge1xuICAgICAgICAvLyBBbHJlYWR5IHJlbmRlcmVkLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50ID0gZWw7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleU1hcHMgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnNob3J0Y3V0cykge1xuICAgICAgICAvLyBudWxsIHN0YW5kcyBmb3IgXCJkbyBub3QgYmluZCB0aGlzIGNvbW1hbmRcIlxuICAgICAgICBpZiAob3B0aW9ucy5zaG9ydGN1dHNba2V5XSAhPT0gbnVsbCAmJiBiaW5kaW5nc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGtleU1hcHNbZml4U2hvcnRjdXQob3B0aW9ucy5zaG9ydGN1dHNba2V5XSldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gYmluZGluZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbihzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oYWN0aW9uLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtleU1hcHNbJ0VudGVyJ10gPSAnbmV3bGluZUFuZEluZGVudENvbnRpbnVlTWFya2Rvd25MaXN0JztcbiAgICBrZXlNYXBzWydUYWInXSA9ICd0YWJBbmRJbmRlbnRNYXJrZG93bkxpc3QnO1xuICAgIGtleU1hcHNbJ1NoaWZ0LVRhYiddID0gJ3NoaWZ0VGFiQW5kVW5pbmRlbnRNYXJrZG93bkxpc3QnO1xuICAgIGtleU1hcHNbJ0VzYyddID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgIGlmIChjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkgdG9nZ2xlRnVsbFNjcmVlbihzZWxmKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kb2N1bWVudE9uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb2RlbWlycm9yLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB0b2dnbGVGdWxsU2NyZWVuKHNlbGYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5kb2N1bWVudE9uS2V5RG93biwgZmFsc2UpO1xuXG4gICAgdmFyIG1vZGUsIGJhY2tkcm9wO1xuXG4gICAgLy8gQ29kZU1pcnJvciBvdmVybGF5IG1vZGVcbiAgICBpZiAob3B0aW9ucy5vdmVybGF5TW9kZSkge1xuICAgICAgICBDb2RlTWlycm9yLmRlZmluZU1vZGUoJ292ZXJsYXktbW9kZScsIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLm92ZXJsYXlNb2RlKENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIG9wdGlvbnMuc3BlbGxDaGVja2VyICE9PSBmYWxzZSA/ICdzcGVsbC1jaGVja2VyJyA6ICdnZm0nKSwgb3B0aW9ucy5vdmVybGF5TW9kZS5tb2RlLCBvcHRpb25zLm92ZXJsYXlNb2RlLmNvbWJpbmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2RlID0gJ292ZXJsYXktbW9kZSc7XG4gICAgICAgIGJhY2tkcm9wID0gb3B0aW9ucy5wYXJzaW5nQ29uZmlnO1xuICAgICAgICBiYWNrZHJvcC5naXRIdWJTcGljZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGUgPSBvcHRpb25zLnBhcnNpbmdDb25maWc7XG4gICAgICAgIG1vZGUubmFtZSA9ICdnZm0nO1xuICAgICAgICBtb2RlLmdpdEh1YlNwaWNlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNwZWxsQ2hlY2tlciAhPT0gZmFsc2UpIHtcbiAgICAgICAgbW9kZSA9ICdzcGVsbC1jaGVja2VyJztcbiAgICAgICAgYmFja2Ryb3AgPSBvcHRpb25zLnBhcnNpbmdDb25maWc7XG4gICAgICAgIGJhY2tkcm9wLm5hbWUgPSAnZ2ZtJztcbiAgICAgICAgYmFja2Ryb3AuZ2l0SHViU3BpY2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3BlbGxDaGVja2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNwZWxsQ2hlY2tlcih7XG4gICAgICAgICAgICAgICAgY29kZU1pcnJvckluc3RhbmNlOiBDb2RlTWlycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDb2RlTWlycm9yU3BlbGxDaGVja2VyKHtcbiAgICAgICAgICAgICAgICBjb2RlTWlycm9ySW5zdGFuY2U6IENvZGVNaXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZU1vdXNlKGNtLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGROZXc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuY29kZW1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGVsLCB7XG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGJhY2tkcm9wOiBiYWNrZHJvcCxcbiAgICAgICAgdGhlbWU6IChvcHRpb25zLnRoZW1lICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnRoZW1lIDogJ2Vhc3ltZGUnLFxuICAgICAgICB0YWJTaXplOiAob3B0aW9ucy50YWJTaXplICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnRhYlNpemUgOiAyLFxuICAgICAgICBpbmRlbnRVbml0OiAob3B0aW9ucy50YWJTaXplICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnRhYlNpemUgOiAyLFxuICAgICAgICBpbmRlbnRXaXRoVGFiczogKG9wdGlvbnMuaW5kZW50V2l0aFRhYnMgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgbGluZU51bWJlcnM6IChvcHRpb25zLmxpbmVOdW1iZXJzID09PSB0cnVlKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgYXV0b2ZvY3VzOiAob3B0aW9ucy5hdXRvZm9jdXMgPT09IHRydWUpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICBleHRyYUtleXM6IGtleU1hcHMsXG4gICAgICAgIGRpcmVjdGlvbjogb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgIGxpbmVXcmFwcGluZzogKG9wdGlvbnMubGluZVdyYXBwaW5nID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgIGFsbG93RHJvcEZpbGVUeXBlczogWyd0ZXh0L3BsYWluJ10sXG4gICAgICAgIHBsYWNlaG9sZGVyOiBvcHRpb25zLnBsYWNlaG9sZGVyIHx8IGVsLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCAnJyxcbiAgICAgICAgc3R5bGVTZWxlY3RlZFRleHQ6IChvcHRpb25zLnN0eWxlU2VsZWN0ZWRUZXh0ICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnN0eWxlU2VsZWN0ZWRUZXh0IDogIWlzTW9iaWxlKCksXG4gICAgICAgIHNjcm9sbGJhclN0eWxlOiAob3B0aW9ucy5zY3JvbGxiYXJTdHlsZSAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy5zY3JvbGxiYXJTdHlsZSA6ICduYXRpdmUnLFxuICAgICAgICBjb25maWd1cmVNb3VzZTogY29uZmlndXJlTW91c2UsXG4gICAgICAgIGlucHV0U3R5bGU6IChvcHRpb25zLmlucHV0U3R5bGUgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuaW5wdXRTdHlsZSA6IGlzTW9iaWxlKCkgPyAnY29udGVudGVkaXRhYmxlJyA6ICd0ZXh0YXJlYScsXG4gICAgICAgIHNwZWxsY2hlY2s6IChvcHRpb25zLm5hdGl2ZVNwZWxsY2hlY2sgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMubmF0aXZlU3BlbGxjaGVjayA6IHRydWUsXG4gICAgICAgIGF1dG9SZWZyZXNoOiAob3B0aW9ucy5hdXRvUmVmcmVzaCAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy5hdXRvUmVmcmVzaCA6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5jb2RlbWlycm9yLmdldFNjcm9sbGVyRWxlbWVudCgpLnN0eWxlLm1pbkhlaWdodCA9IG9wdGlvbnMubWluSGVpZ2h0O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heEhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLmdldFNjcm9sbGVyRWxlbWVudCgpLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZvcmNlU3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgICAgIGNtLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbS5zYXZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZ3VpID0ge307XG5cbiAgICAvLyBXcmFwIENvZGVtaXJyb3Igd2l0aCBjb250YWluZXIgYmVmb3JlIGNyZWF0ZSB0b29sYmFyLCBldGMsXG4gICAgLy8gdG8gdXNlIHdpdGggc2lkZUJ5U2lkZUZ1bGxzY3JlZW4gb3B0aW9uLlxuICAgIHZhciBlYXN5TURFQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdFYXN5TURFQ29udGFpbmVyJyk7XG4gICAgZWFzeU1ERUNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYXBwbGljYXRpb24nKTtcbiAgICB2YXIgY21XcmFwcGVyID0gdGhpcy5jb2RlbWlycm9yLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgY21XcmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVhc3lNREVDb250YWluZXIsIGNtV3JhcHBlcik7XG4gICAgZWFzeU1ERUNvbnRhaW5lci5hcHBlbmRDaGlsZChjbVdyYXBwZXIpO1xuXG4gICAgaWYgKG9wdGlvbnMudG9vbGJhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ndWkudG9vbGJhciA9IHRoaXMuY3JlYXRlVG9vbGJhcigpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdGF0dXMgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZ3VpLnN0YXR1c2JhciA9IHRoaXMuY3JlYXRlU3RhdHVzYmFyKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF1dG9zYXZlICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmF1dG9zYXZlLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5hdXRvc2F2ZSgpOyAvLyB1c2UgdG8gbG9hZCBsb2NhbHN0b3JhZ2UgY29udGVudFxuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9hdXRvc2F2ZV90aW1lb3V0KTtcbiAgICAgICAgICAgIHNlbGYuX2F1dG9zYXZlX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmF1dG9zYXZlKCk7XG4gICAgICAgICAgICB9LCBzZWxmLm9wdGlvbnMuYXV0b3NhdmUuc3VibWl0X2RlbGF5IHx8IHNlbGYub3B0aW9ucy5hdXRvc2F2ZS5kZWxheSB8fCAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0hlaWdodChuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGhlaWdodDtcbiAgICAgICAgdmFyIHZpZXdwb3J0V2lkdGggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuQ29kZU1pcnJvci1zaXplcicpKS53aWR0aC5yZXBsYWNlKCdweCcsICcnKTtcbiAgICAgICAgaWYgKG5hdHVyYWxXaWR0aCA8IHZpZXdwb3J0V2lkdGgpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG5hdHVyYWxIZWlnaHQgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gKG5hdHVyYWxIZWlnaHQgLyBuYXR1cmFsV2lkdGggKiAxMDApICsgJyUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIF92bSA9IHRoaXM7XG5cblxuICAgIGZ1bmN0aW9uIGFzc2lnbkltYWdlQmxvY2tBdHRyaWJ1dGVzKHBhcmVudEVsLCBpbWcpIHtcbiAgICAgICAgdmFyIHVybCA9IChuZXcgVVJMKGltZy51cmwsIGRvY3VtZW50LmJhc2VVUkkpKS5ocmVmO1xuICAgICAgICBwYXJlbnRFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW1nLXNyYycsIHVybCk7XG4gICAgICAgIHBhcmVudEVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnLS1iZy1pbWFnZTp1cmwoJyArIHVybCArICcpOy0td2lkdGg6JyArIGltZy5uYXR1cmFsV2lkdGggKyAncHg7LS1oZWlnaHQ6JyArIGNhbGNIZWlnaHQoaW1nLm5hdHVyYWxXaWR0aCwgaW1nLm5hdHVyYWxIZWlnaHQpKTtcbiAgICAgICAgX3ZtLmNvZGVtaXJyb3Iuc2V0U2l6ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUltYWdlcygpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnByZXZpZXdJbWFnZXNJbkVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuY20taW1hZ2UtbWFya2VyJykuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRFbC5pbm5lclRleHQubWF0Y2goL14hXFxbLio/XFxdXFwoLipcXCkvZykpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbWcgcGFzdGVkIG9uIHRoZSBzYW1lIGxpbmUgd2l0aCBvdGhlciB0ZXh0LCBkb24ndCBwcmV2aWV3LCBwcmV2aWV3IG9ubHkgaW1hZ2VzIG9uIHNlcGFyYXRlIGxpbmVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudEVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1pbWctc3JjJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3JjQXR0ciA9IHBhcmVudEVsLmlubmVyVGV4dC5tYXRjaCgvIVxcWy4qP1xcXVxcKCguKj8pXFwpLyk7IC8vIG1pZ2h0IHJlcXVpcmUgYmV0dGVyIHBhcnNpbmcgYWNjb3JkaW5nIHRvIG1hcmtkb3duIHNwZWNcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5FTURFaW1hZ2VzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LkVNREVpbWFnZXNDYWNoZSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzcmNBdHRyICYmIHNyY0F0dHIubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVNyYyA9IHNyY0F0dHJbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2VzUHJldmlld0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTcmMgPSBvcHRpb25zLmltYWdlc1ByZXZpZXdIYW5kbGVyKHNyY0F0dHJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZW5zaXZlIGNoZWNrIG1ha2luZyBzdXJlIHRoZSBoYW5kbGVyIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIHJldHVybnMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3U3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVNyYyA9IG5ld1NyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2luZG93LkVNREVpbWFnZXNDYWNoZVtrZXlTcmNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuRU1ERWltYWdlc0NhY2hlW2tleVNyY10gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LkVNREVpbWFnZXNDYWNoZVtrZXlTcmNdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsV2lkdGg6IGltZy5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQ6IGltZy5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGtleVNyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbkltYWdlQmxvY2tBdHRyaWJ1dGVzKHBhcmVudEVsLCB3aW5kb3cuRU1ERWltYWdlc0NhY2hlW2tleVNyY10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBrZXlTcmM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25JbWFnZUJsb2NrQXR0cmlidXRlcyhwYXJlbnRFbCwgd2luZG93LkVNREVpbWFnZXNDYWNoZVtrZXlTcmNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2RlbWlycm9yLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbmRsZUltYWdlcygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ndWkuc2lkZUJ5U2lkZSA9IHRoaXMuY3JlYXRlU2lkZUJ5U2lkZSgpO1xuICAgIHRoaXMuX3JlbmRlcmVkID0gdGhpcy5lbGVtZW50O1xuXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzID09PSB0cnVlIHx8IGVsLmF1dG9mb2N1cykge1xuICAgICAgICB0aGlzLmNvZGVtaXJyb3IuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvLyBGaXhlcyBDb2RlTWlycm9yIGJ1ZyAoIzM0NClcbiAgICB2YXIgdGVtcF9jbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVtcF9jbS5yZWZyZXNoKCk7XG4gICAgfS5iaW5kKHRlbXBfY20pLCAwKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuZG9jdW1lbnRPbktleURvd24pO1xufTtcblxuLy8gU2FmYXJpLCBpbiBQcml2YXRlIEJyb3dzaW5nIE1vZGUsIGxvb2tzIGxpa2UgaXQgc3VwcG9ydHMgbG9jYWxTdG9yYWdlIGJ1dCBhbGwgY2FsbHMgdG8gc2V0SXRlbSB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3IuIFdlJ3JlIGdvaW5nIHRvIGRldGVjdCB0aGlzIGFuZCBzZXQgYSB2YXJpYWJsZSBhY2NvcmRpbmdseS5cbmZ1bmN0aW9uIGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NtZGVfbG9jYWxTdG9yYWdlJywgMSk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnc21kZV9sb2NhbFN0b3JhZ2UnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5FYXN5TURFLnByb3RvdHlwZS5hdXRvc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICB2YXIgZWFzeU1ERSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCA9PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkID09ICcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogWW91IG11c3Qgc2V0IGEgdW5pcXVlSWQgdG8gdXNlIHRoZSBhdXRvc2F2ZSBmZWF0dXJlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9zYXZlLmJpbmRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGVhc3lNREUuZWxlbWVudC5mb3JtICE9IG51bGwgJiYgZWFzeU1ERS5lbGVtZW50LmZvcm0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZWFzeU1ERS5lbGVtZW50LmZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZWFzeU1ERS5hdXRvc2F2ZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGVhc3lNREUuYXV0b3NhdmVUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NtZGVfJyArIGVhc3lNREUub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5iaW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5sb2FkZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCkgPT0gJ3N0cmluZycgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZGVtaXJyb3Iuc2V0VmFsdWUobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5mb3VuZFNhdmVkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3NhdmUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IGVhc3lNREUudmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXV0b3NhdmVkJyk7XG4gICAgICAgIGlmIChlbCAhPSBudWxsICYmIGVsICE9IHVuZGVmaW5lZCAmJiBlbCAhPSAnJykge1xuICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGRkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoW3RoaXMub3B0aW9ucy5hdXRvc2F2ZS50aW1lRm9ybWF0LmxvY2FsZSwgJ2VuLVVTJ10sIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS50aW1lRm9ybWF0LmZvcm1hdCkuZm9ybWF0KGQpO1xuICAgICAgICAgICAgdmFyIHNhdmUgPSB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudGV4dCA9PSB1bmRlZmluZWQgPyAnQXV0b3NhdmVkOiAnIDogdGhpcy5vcHRpb25zLmF1dG9zYXZlLnRleHQ7XG5cbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHNhdmUgKyBkZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgY2Fubm90IGF1dG9zYXZlJyk7XG4gICAgfVxufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY2xlYXJBdXRvc2F2ZWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9zYXZlID09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQgPT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCA9PSAnJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IFlvdSBtdXN0IHNldCBhIHVuaXF1ZUlkIHRvIGNsZWFyIHRoZSBhdXRvc2F2ZSB2YWx1ZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IGxvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlLCBjYW5ub3QgYXV0b3NhdmUnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE9wZW4gdGhlIGJyb3dzZS1maWxlIHdpbmRvdyB0byB1cGxvYWQgYW4gaW1hZ2UgdG8gYSBzZXJ2ZXIuXG4gKiBAcGFyYW0gW29uU3VjY2Vzc10ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqIEBwYXJhbSBbb25FcnJvcl0ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUub3BlbkJyb3dzZUZpbGVXaW5kb3cgPSBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbWFnZUlucHV0ID0gdGhpcy5ndWkudG9vbGJhci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpbWFnZUlucHV0JylbMF07XG4gICAgaW1hZ2VJbnB1dC5jbGljaygpOyAvL2Rpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ2NsaWNrJykpOyAgLy8gcmVwbGFjZWQgd2l0aCBjbGljaygpIGZvciBJRTExIGNvbXBhdGliaWxpdHkuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlc1VzaW5nQ3VzdG9tRnVuY3Rpb24oc2VsZi5vcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24sIGV2ZW50LnRhcmdldC5maWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlcyhldmVudC50YXJnZXQuZmlsZXMsIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2VJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgfVxuXG4gICAgaW1hZ2VJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG59O1xuXG4vKipcbiAqIFVwbG9hZCBhbiBpbWFnZSB0byB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBmaWxlIHtGaWxlfSBUaGUgaW1hZ2UgdG8gdXBsb2FkLCBhcyBhIEhUTUw1IEZpbGUgb2JqZWN0IChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSlcbiAqIEBwYXJhbSBbb25TdWNjZXNzXSB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgaW1hZ2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkLCB3aXRoIG9uZSBwYXJhbWV0ZXI6XG4gKiAtIHVybCAoc3RyaW5nKTogVGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgaW1hZ2UuXG4gKiBAcGFyYW0gW29uRXJyb3JdIHtmdW5jdGlvbn0gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGltYWdlIHVwbG9hZCBmYWlscywgd2l0aCBvbmUgcGFyYW1ldGVyOlxuICogLSBlcnJvciAoc3RyaW5nKTogdGhlIGRldGFpbGVkIGVycm9yIHRvIGRpc3BsYXkgdG8gdGhlIHVzZXIgKGJhc2VkIG9uIG1lc3NhZ2VzIGZyb20gb3B0aW9ucy5lcnJvck1lc3NhZ2VzKS5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2UgPSBmdW5jdGlvbiAoZmlsZSwgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9uU3VjY2VzcyA9IG9uU3VjY2VzcyB8fCBmdW5jdGlvbiBvblN1Y2Nlc3MoaW1hZ2VVcmwpIHtcbiAgICAgICAgYWZ0ZXJJbWFnZVVwbG9hZGVkKHNlbGYsIGltYWdlVXJsKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25FcnJvclN1cChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgLy8gc2hvdyBlcnJvciBvbiBzdGF0dXMgYmFyIGFuZCByZXNldCBhZnRlciAxMDAwMG1zXG4gICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBlcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgICAvLyBydW4gY3VzdG9tIGVycm9yIGhhbmRsZXJcbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBydW4gZXJyb3IgaGFuZGxlciBmcm9tIG9wdGlvbnMsIHRoaXMgYWxlcnRzIHRoZSBtZXNzYWdlLlxuICAgICAgICBzZWxmLm9wdGlvbnMuZXJyb3JDYWxsYmFjayhlcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxFcnJvck1lc3NhZ2UoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciB1bml0cyA9IHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNpemVVbml0cy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX25hbWUjJywgZmlsZS5uYW1lKVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9zaXplIycsIGh1bWFuRmlsZVNpemUoZmlsZS5zaXplLCB1bml0cykpXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX21heF9zaXplIycsIGh1bWFuRmlsZVNpemUoc2VsZi5vcHRpb25zLmltYWdlTWF4U2l6ZSwgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLmltYWdlTWF4U2l6ZSkge1xuICAgICAgICBvbkVycm9yU3VwKGZpbGxFcnJvck1lc3NhZ2UodGhpcy5vcHRpb25zLmVycm9yTWVzc2FnZXMuZmlsZVRvb0xhcmdlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2ltYWdlJywgZmlsZSk7XG5cbiAgICAvLyBpbnNlcnQgQ1NSRiBib2R5IHRva2VuIGlmIHByb3ZpZGVkIGluIGNvbmZpZy5cbiAgICBpZiAoc2VsZi5vcHRpb25zLmltYWdlQ1NSRlRva2VuICYmICFzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGSGVhZGVyKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGTmFtZSwgc2VsZi5vcHRpb25zLmltYWdlQ1NSRlRva2VuKTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3QudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9ICcnICsgTWF0aC5yb3VuZCgoZXZlbnQubG9hZGVkICogMTAwKSAvIGV2ZW50LnRvdGFsKTtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYlByb2dyZXNzLnJlcGxhY2UoJyNmaWxlX25hbWUjJywgZmlsZS5uYW1lKS5yZXBsYWNlKCcjcHJvZ3Jlc3MjJywgcHJvZ3Jlc3MpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdC5vcGVuKCdQT1NUJywgdGhpcy5vcHRpb25zLmltYWdlVXBsb2FkRW5kcG9pbnQpO1xuXG4gICAgLy8gaW5zZXJ0IENTUkYgaGVhZGVyIHRva2VuIGlmIHByb3ZpZGVkIGluIGNvbmZpZy5cbiAgICBpZiAoc2VsZi5vcHRpb25zLmltYWdlQ1NSRlRva2VuICYmIHNlbGYub3B0aW9ucy5pbWFnZUNTUkZIZWFkZXIpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKHNlbGYub3B0aW9ucy5pbWFnZUNTUkZOYW1lLCBzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGVG9rZW4pO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZSh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFYXN5TURFOiBUaGUgc2VydmVyIGRpZCBub3QgcmV0dXJuIGEgdmFsaWQganNvbi4nKTtcbiAgICAgICAgICAgIG9uRXJyb3JTdXAoZmlsbEVycm9yTWVzc2FnZShzZWxmLm9wdGlvbnMuZXJyb3JNZXNzYWdlcy5pbXBvcnRFcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlICYmICFyZXNwb25zZS5lcnJvciAmJiByZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEuZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzcygoc2VsZi5vcHRpb25zLmltYWdlUGF0aEFic29sdXRlID8gJycgOiAod2luZG93LmxvY2F0aW9uLm9yaWdpbiArICcvJykpICsgcmVzcG9uc2UuZGF0YS5maWxlUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgJiYgcmVzcG9uc2UuZXJyb3IgaW4gc2VsZi5vcHRpb25zLmVycm9yTWVzc2FnZXMpIHsgIC8vIHByZWZvcm1hdHRlZCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgb25FcnJvclN1cChmaWxsRXJyb3JNZXNzYWdlKHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzW3Jlc3BvbnNlLmVycm9yXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5lcnJvcikgeyAgLy8gc2VydmVyIHNpZGUgZ2VuZXJhdGVkIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBvbkVycm9yU3VwKGZpbGxFcnJvck1lc3NhZ2UocmVzcG9uc2UuZXJyb3IpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7ICAvL3Vua25vd24gZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFYXN5TURFOiBSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHJlc3BvbnNlIGFmdGVyIHVwbG9hZGluZyB0aGUgaW1hZ2UuJ1xuICAgICAgICAgICAgICAgICAgICArIHRoaXMuc3RhdHVzICsgJyAoJyArIHRoaXMuc3RhdHVzVGV4dCArICcpJyk7XG4gICAgICAgICAgICAgICAgb25FcnJvclN1cChmaWxsRXJyb3JNZXNzYWdlKHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzLmltcG9ydEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vhc3lNREU6IEFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hlbiB0cnlpbmcgdG8gdXBsb2FkIHRoZSBpbWFnZS4nXG4gICAgICAgICAgICArIGV2ZW50LnRhcmdldC5zdGF0dXMgKyAnICgnICsgZXZlbnQudGFyZ2V0LnN0YXR1c1RleHQgKyAnKScpO1xuICAgICAgICBvbkVycm9yU3VwKHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzLmltcG9ydEVycm9yKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKGZvcm1EYXRhKTtcblxufTtcblxuLyoqXG4gKiBVcGxvYWQgYW4gaW1hZ2UgdG8gdGhlIHNlcnZlciB1c2luZyBhIGN1c3RvbSB1cGxvYWQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGltYWdlVXBsb2FkRnVuY3Rpb24ge0Z1bmN0aW9ufSBUaGUgY3VzdG9tIGZ1bmN0aW9uIHRvIHVwbG9hZCB0aGUgaW1hZ2UgcGFzc2VkIGluIG9wdGlvbnNcbiAqIEBwYXJhbSBmaWxlIHtGaWxlfSBUaGUgaW1hZ2UgdG8gdXBsb2FkLCBhcyBhIEhUTUw1IEZpbGUgb2JqZWN0IChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlVXNpbmdDdXN0b21GdW5jdGlvbiA9IGZ1bmN0aW9uIChpbWFnZVVwbG9hZEZ1bmN0aW9uLCBmaWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gb25TdWNjZXNzKGltYWdlVXJsKSB7XG4gICAgICAgIGFmdGVySW1hZ2VVcGxvYWRlZChzZWxmLCBpbWFnZVVybCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGZpbGxlZEVycm9yTWVzc2FnZSA9IGZpbGxFcnJvck1lc3NhZ2UoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgLy8gc2hvdyBlcnJvciBvbiBzdGF0dXMgYmFyIGFuZCByZXNldCBhZnRlciAxMDAwMG1zXG4gICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBmaWxsZWRFcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgICAvLyBydW4gZXJyb3IgaGFuZGxlciBmcm9tIG9wdGlvbnMsIHRoaXMgYWxlcnRzIHRoZSBtZXNzYWdlLlxuICAgICAgICBzZWxmLm9wdGlvbnMuZXJyb3JDYWxsYmFjayhmaWxsZWRFcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxFcnJvck1lc3NhZ2UoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciB1bml0cyA9IHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNpemVVbml0cy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX25hbWUjJywgZmlsZS5uYW1lKVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9zaXplIycsIGh1bWFuRmlsZVNpemUoZmlsZS5zaXplLCB1bml0cykpXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX21heF9zaXplIycsIGh1bWFuRmlsZVNpemUoc2VsZi5vcHRpb25zLmltYWdlTWF4U2l6ZSwgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBpbWFnZVVwbG9hZEZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtmaWxlLCBvblN1Y2Nlc3MsIG9uRXJyb3JdKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLnNldFByZXZpZXdNYXhIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubmV4dFNpYmxpbmc7XG5cbiAgICAvLyBDYWxjIHByZXZpZXcgbWF4IGhlaWdodFxuICAgIHZhciBwYWRkaW5nVG9wID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUod3JhcHBlcikucGFkZGluZ1RvcCk7XG4gICAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUod3JhcHBlcikuYm9yZGVyVG9wV2lkdGgpO1xuICAgIHZhciBvcHRpb25zTWF4SGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLm1heEhlaWdodCk7XG4gICAgdmFyIHdyYXBwZXJNYXhIZWlnaHQgPSBvcHRpb25zTWF4SGVpZ2h0ICsgcGFkZGluZ1RvcCAqIDIgKyBib3JkZXJUb3BXaWR0aCAqIDI7XG4gICAgdmFyIHByZXZpZXdNYXhIZWlnaHQgPSB3cmFwcGVyTWF4SGVpZ2h0LnRvU3RyaW5nKCkgKyAncHgnO1xuXG4gICAgcHJldmlldy5zdHlsZS5oZWlnaHQgPSBwcmV2aWV3TWF4SGVpZ2h0O1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY3JlYXRlU2lkZUJ5U2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5uZXh0U2libGluZztcblxuICAgIGlmICghcHJldmlldyB8fCAhcHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LXNpZGUnKSkge1xuICAgICAgICBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHByZXZpZXcuY2xhc3NOYW1lID0gJ2VkaXRvci1wcmV2aWV3LXNpZGUnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzKSB7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwcmV2aWV3LCB3cmFwcGVyLm5leHRTaWJsaW5nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5tYXhIZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2V0UHJldmlld01heEhlaWdodCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3luY1NpZGVCeVNpZGVQcmV2aWV3U2Nyb2xsID09PSBmYWxzZSkgcmV0dXJuIHByZXZpZXc7XG4gICAgLy8gU3luY3Mgc2Nyb2xsICBlZGl0b3IgLT4gcHJldmlld1xuICAgIHZhciBjU2Nyb2xsID0gZmFsc2U7XG4gICAgdmFyIHBTY3JvbGwgPSBmYWxzZTtcbiAgICBjbS5vbignc2Nyb2xsJywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKGNTY3JvbGwpIHtcbiAgICAgICAgICAgIGNTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHYuZ2V0U2Nyb2xsSW5mbygpLmhlaWdodCAtIHYuZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIHJhdGlvID0gcGFyc2VGbG9hdCh2LmdldFNjcm9sbEluZm8oKS50b3ApIC8gaGVpZ2h0O1xuICAgICAgICB2YXIgbW92ZSA9IChwcmV2aWV3LnNjcm9sbEhlaWdodCAtIHByZXZpZXcuY2xpZW50SGVpZ2h0KSAqIHJhdGlvO1xuICAgICAgICBwcmV2aWV3LnNjcm9sbFRvcCA9IG1vdmU7XG4gICAgfSk7XG5cbiAgICAvLyBTeW5jcyBzY3JvbGwgIHByZXZpZXcgLT4gZWRpdG9yXG4gICAgcHJldmlldy5vbnNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHBTY3JvbGwpIHtcbiAgICAgICAgICAgIHBTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHByZXZpZXcuc2Nyb2xsSGVpZ2h0IC0gcHJldmlldy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciByYXRpbyA9IHBhcnNlRmxvYXQocHJldmlldy5zY3JvbGxUb3ApIC8gaGVpZ2h0O1xuICAgICAgICB2YXIgbW92ZSA9IChjbS5nZXRTY3JvbGxJbmZvKCkuaGVpZ2h0IC0gY20uZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodCkgKiByYXRpbztcbiAgICAgICAgY20uc2Nyb2xsVG8oMCwgbW92ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcHJldmlldztcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmNyZWF0ZVRvb2xiYXIgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBpdGVtcyA9IGl0ZW1zIHx8IHRoaXMub3B0aW9ucy50b29sYmFyO1xuXG4gICAgaWYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRvb2xiYXJCdWlsdEluQnV0dG9uc1tpdGVtc1tpXV0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVtc1tpXSA9IHRvb2xiYXJCdWlsdEluQnV0dG9uc1tpdGVtc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyLmNsYXNzTmFtZSA9ICdlZGl0b3ItdG9vbGJhcic7XG4gICAgYmFyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sYmFyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgdG9vbGJhckRhdGEgPSB7fTtcbiAgICBzZWxmLnRvb2xiYXIgPSBpdGVtcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbXNbaV0ubmFtZSA9PSAnZ3VpZGUnICYmIHNlbGYub3B0aW9ucy50b29sYmFyR3VpZGVJY29uID09PSBmYWxzZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuaGlkZUljb25zICYmIHNlbGYub3B0aW9ucy5oaWRlSWNvbnMuaW5kZXhPZihpdGVtc1tpXS5uYW1lKSAhPSAtMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIEZ1bGxzY3JlZW4gZG9lcyBub3Qgd29yayB3ZWxsIG9uIG1vYmlsZSBkZXZpY2VzIChldmVuIHRhYmxldHMpXG4gICAgICAgIC8vIEluIHRoZSBmdXR1cmUsIGhvcGVmdWxseSB0aGlzIGNhbiBiZSByZXNvbHZlZFxuICAgICAgICBpZiAoKGl0ZW1zW2ldLm5hbWUgPT0gJ2Z1bGxzY3JlZW4nIHx8IGl0ZW1zW2ldLm5hbWUgPT0gJ3NpZGUtYnktc2lkZScpICYmIGlzTW9iaWxlKCkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuXG4gICAgICAgIC8vIERvbid0IGluY2x1ZGUgdHJhaWxpbmcgc2VwYXJhdG9yc1xuICAgICAgICBpZiAoaXRlbXNbaV0gPT09ICd8Jykge1xuICAgICAgICAgICAgdmFyIG5vblNlcGFyYXRvckljb25zRm9sbG93ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHggPSAoaSArIDEpOyB4IDwgaXRlbXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNbeF0gIT09ICd8JyAmJiAoIXNlbGYub3B0aW9ucy5oaWRlSWNvbnMgfHwgc2VsZi5vcHRpb25zLmhpZGVJY29ucy5pbmRleE9mKGl0ZW1zW3hdLm5hbWUpID09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBub25TZXBhcmF0b3JJY29uc0ZvbGxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5vblNlcGFyYXRvckljb25zRm9sbG93KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGljb24gYW5kIGFwcGVuZCB0byB0aGUgdG9vbGJhclxuICAgICAgICAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBlbDtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSAnfCcpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGNyZWF0ZVNlcCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBjcmVhdGVUb29sYmFyRHJvcGRvd24oaXRlbSwgc2VsZi5vcHRpb25zLnRvb2xiYXJUaXBzLCBzZWxmLm9wdGlvbnMuc2hvcnRjdXRzLCBzZWxmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBjcmVhdGVUb29sYmFyQnV0dG9uKGl0ZW0sIHRydWUsIHNlbGYub3B0aW9ucy50b29sYmFyVGlwcywgc2VsZi5vcHRpb25zLnNob3J0Y3V0cywgJ2J1dHRvbicsIHNlbGYpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRvb2xiYXJEYXRhW2l0ZW0ubmFtZSB8fCBpdGVtXSA9IGVsO1xuICAgICAgICAgICAgYmFyLmFwcGVuZENoaWxkKGVsKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbnB1dCBlbGVtZW50IChpZS4gPGlucHV0IHR5cGU9J2ZpbGUnPiksIHVzZWQgYW1vbmdcbiAgICAgICAgICAgIC8vIHdpdGggdGhlICdpbXBvcnQtaW1hZ2UnIGljb24gdG8gb3BlbiB0aGUgYnJvd3NlLWZpbGUgd2luZG93LlxuICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PT0gJ3VwbG9hZC1pbWFnZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5jbGFzc05hbWUgPSAnaW1hZ2VJbnB1dCc7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC50eXBlID0gJ2ZpbGUnO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQubmFtZSA9IHNlbGYub3B0aW9ucy5pbWFnZUlucHV0TmFtZTtcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0LmFjY2VwdCA9IHNlbGYub3B0aW9ucy5pbWFnZUFjY2VwdDtcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBiYXIuYXBwZW5kQ2hpbGQoaW1hZ2VJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGl0ZW1zW2ldKTtcbiAgICB9XG5cbiAgICBzZWxmLnRvb2xiYXJfZGl2ID0gYmFyO1xuICAgIHNlbGYudG9vbGJhckVsZW1lbnRzID0gdG9vbGJhckRhdGE7XG5cbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgY20ub24oJ2N1cnNvckFjdGl2aXR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdG9vbGJhckRhdGEpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdG9vbGJhckRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9ICdmdWxsc2NyZWVuJyAmJiBrZXkgIT0gJ3NpZGUtYnktc2lkZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGNtV3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgY21XcmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJhciwgY21XcmFwcGVyKTtcbiAgICByZXR1cm4gYmFyO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY3JlYXRlU3RhdHVzYmFyID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBzdGF0dXMgPSBzdGF0dXMgfHwgdGhpcy5vcHRpb25zLnN0YXR1cztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHN0YXR1cyB2YXJpYWJsZSBpcyB2YWxpZFxuICAgIGlmICghc3RhdHVzIHx8IHN0YXR1cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCB0aGUgYnVpbHQtaW4gaXRlbXNcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgaSwgb25VcGRhdGUsIG9uQWN0aXZpdHksIGRlZmF1bHRWYWx1ZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0dXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gUmVzZXQgc29tZSB2YWx1ZXNcbiAgICAgICAgb25VcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIG9uQWN0aXZpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZDtcblxuXG4gICAgICAgIC8vIEhhbmRsZSBpZiBjdXN0b20gb3Igbm90XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBzdGF0dXNbaV0uY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc3RhdHVzW2ldLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvblVwZGF0ZTogc3RhdHVzW2ldLm9uVXBkYXRlLFxuICAgICAgICAgICAgICAgIG9uQWN0aXZpdHk6IHN0YXR1c1tpXS5vbkFjdGl2aXR5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHN0YXR1c1tpXTtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd3b3JkcycpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gd29yZENvdW50KGNtLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb25VcGRhdGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gd29yZENvdW50KGNtLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdsaW5lcycpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gY20ubGluZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBjbS5saW5lQ291bnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY3Vyc29yJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnMToxJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9uQWN0aXZpdHkgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zTGluZSA9IHBvcy5saW5lICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0NvbHVtbiA9IHBvcy5jaCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHBvc0xpbmUgKyAnOicgKyBwb3NDb2x1bW47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2F1dG9zYXZlJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvc2F2ZSAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5hdXRvc2F2ZS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2F1dG9zYXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3VwbG9hZC1pbWFnZScpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gb3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICAgICAgICAgIG9uQWN0aXZpdHk6IG9uQWN0aXZpdHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgZm9yIHRoZSBzdGF0dXMgYmFyXG4gICAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhci5jbGFzc05hbWUgPSAnZWRpdG9yLXN0YXR1c2Jhcic7XG5cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBzcGFuIGZvciBlYWNoIGl0ZW1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG5cblxuICAgICAgICAvLyBDcmVhdGUgc3BhbiBlbGVtZW50XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gaXRlbS5jbGFzc05hbWU7XG5cblxuICAgICAgICAvLyBFbnN1cmUgdGhlIGRlZmF1bHRWYWx1ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5kZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZW0uZGVmYXVsdFZhbHVlKGVsKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBvblVwZGF0ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5vblVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY2xvc3VyZSBhcm91bmQgdGhlIHNwYW4gb2YgdGhlIGN1cnJlbnQgYWN0aW9uLCB0aGVuIGV4ZWN1dGUgdGhlIG9uVXBkYXRlIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuY29kZW1pcnJvci5vbigndXBkYXRlJywgKGZ1bmN0aW9uIChlbCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub25VcGRhdGUoZWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGVsLCBpdGVtKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5vbkFjdGl2aXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjbG9zdXJlIGFyb3VuZCB0aGUgc3BhbiBvZiB0aGUgY3VycmVudCBhY3Rpb24sIHRoZW4gZXhlY3V0ZSB0aGUgb25BY3Rpdml0eSBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2N1cnNvckFjdGl2aXR5JywgKGZ1bmN0aW9uIChlbCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub25BY3Rpdml0eShlbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oZWwsIGl0ZW0pKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEFwcGVuZCB0aGUgaXRlbSB0byB0aGUgc3RhdHVzIGJhclxuICAgICAgICBiYXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cblxuXG4gICAgLy8gSW5zZXJ0IHRoZSBzdGF0dXMgYmFyIGludG8gdGhlIERPTVxuICAgIHZhciBjbVdyYXBwZXIgPSB0aGlzLmNvZGVtaXJyb3IuZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICBjbVdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmFyLCBjbVdyYXBwZXIubmV4dFNpYmxpbmcpO1xuICAgIHJldHVybiBiYXI7XG59O1xuXG4vKipcbiAqIEdldCBvciBzZXQgdGhlIHRleHQgY29udGVudC5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY20uZ2V0VmFsdWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjbS5nZXREb2MoKS5zZXRWYWx1ZSh2YWwpO1xuICAgICAgICBpZiAodGhpcy5pc1ByZXZpZXdBY3RpdmUoKSkge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3X3Jlc3VsdCA9IHRoaXMub3B0aW9ucy5wcmV2aWV3UmVuZGVyKHZhbCwgcHJldmlldyk7XG4gICAgICAgICAgICBpZiAocHJldmlld19yZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IHByZXZpZXdfcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEJpbmQgc3RhdGljIG1ldGhvZHMgZm9yIGV4cG9ydHMuXG4gKi9cbkVhc3lNREUudG9nZ2xlQm9sZCA9IHRvZ2dsZUJvbGQ7XG5FYXN5TURFLnRvZ2dsZUl0YWxpYyA9IHRvZ2dsZUl0YWxpYztcbkVhc3lNREUudG9nZ2xlU3RyaWtldGhyb3VnaCA9IHRvZ2dsZVN0cmlrZXRocm91Z2g7XG5FYXN5TURFLnRvZ2dsZUJsb2NrcXVvdGUgPSB0b2dnbGVCbG9ja3F1b3RlO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nU21hbGxlciA9IHRvZ2dsZUhlYWRpbmdTbWFsbGVyO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nQmlnZ2VyID0gdG9nZ2xlSGVhZGluZ0JpZ2dlcjtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzEgPSB0b2dnbGVIZWFkaW5nMTtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzIgPSB0b2dnbGVIZWFkaW5nMjtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzMgPSB0b2dnbGVIZWFkaW5nMztcbkVhc3lNREUudG9nZ2xlSGVhZGluZzQgPSB0b2dnbGVIZWFkaW5nNDtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzUgPSB0b2dnbGVIZWFkaW5nNTtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzYgPSB0b2dnbGVIZWFkaW5nNjtcbkVhc3lNREUudG9nZ2xlQ29kZUJsb2NrID0gdG9nZ2xlQ29kZUJsb2NrO1xuRWFzeU1ERS50b2dnbGVVbm9yZGVyZWRMaXN0ID0gdG9nZ2xlVW5vcmRlcmVkTGlzdDtcbkVhc3lNREUudG9nZ2xlT3JkZXJlZExpc3QgPSB0b2dnbGVPcmRlcmVkTGlzdDtcbkVhc3lNREUuY2xlYW5CbG9jayA9IGNsZWFuQmxvY2s7XG5FYXN5TURFLmRyYXdMaW5rID0gZHJhd0xpbms7XG5FYXN5TURFLmRyYXdJbWFnZSA9IGRyYXdJbWFnZTtcbkVhc3lNREUuZHJhd1VwbG9hZGVkSW1hZ2UgPSBkcmF3VXBsb2FkZWRJbWFnZTtcbkVhc3lNREUuZHJhd1RhYmxlID0gZHJhd1RhYmxlO1xuRWFzeU1ERS5kcmF3SG9yaXpvbnRhbFJ1bGUgPSBkcmF3SG9yaXpvbnRhbFJ1bGU7XG5FYXN5TURFLnVuZG8gPSB1bmRvO1xuRWFzeU1ERS5yZWRvID0gcmVkbztcbkVhc3lNREUudG9nZ2xlUHJldmlldyA9IHRvZ2dsZVByZXZpZXc7XG5FYXN5TURFLnRvZ2dsZVNpZGVCeVNpZGUgPSB0b2dnbGVTaWRlQnlTaWRlO1xuRWFzeU1ERS50b2dnbGVGdWxsU2NyZWVuID0gdG9nZ2xlRnVsbFNjcmVlbjtcblxuLyoqXG4gKiBCaW5kIGluc3RhbmNlIG1ldGhvZHMgZm9yIGV4cG9ydHMuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUJvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlQm9sZCh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVJdGFsaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSXRhbGljKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZVN0cmlrZXRocm91Z2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlU3RyaWtldGhyb3VnaCh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVCbG9ja3F1b3RlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUJsb2NrcXVvdGUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZ1NtYWxsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZ1NtYWxsZXIodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZ0JpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nQmlnZ2VyKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmcxID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmcxKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmcyID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmcyKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmczID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmczKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmc0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmc0KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmc1ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmc1KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmc2ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmc2KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUNvZGVCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVDb2RlQmxvY2sodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlVW5vcmRlcmVkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVVbm9yZGVyZWRMaXN0KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZU9yZGVyZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZU9yZGVyZWRMaXN0KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmNsZWFuQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYW5CbG9jayh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5kcmF3TGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICBkcmF3TGluayh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZHJhd0ltYWdlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmRyYXdVcGxvYWRlZEltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGRyYXdVcGxvYWRlZEltYWdlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmRyYXdUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkcmF3VGFibGUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUuZHJhd0hvcml6b250YWxSdWxlID0gZnVuY3Rpb24gKCkge1xuICAgIGRyYXdIb3Jpem9udGFsUnVsZSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKCkge1xuICAgIHVuZG8odGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWRvKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZVByZXZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlUHJldmlldyh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVTaWRlQnlTaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZVNpZGVCeVNpZGUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlRnVsbFNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVGdWxsU2NyZWVuKHRoaXMpO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuaXNQcmV2aWV3QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLmxhc3RDaGlsZDtcblxuICAgIHJldHVybiBwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJyk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5pc1NpZGVCeVNpZGVBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubmV4dFNpYmxpbmc7XG5cbiAgICByZXR1cm4gcHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJyk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5pc0Z1bGxzY3JlZW5BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuXG4gICAgcmV0dXJuIGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuXG4gICAgcmV0dXJuIGdldFN0YXRlKGNtKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLnRvVGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgZWFzeU1ERUNvbnRhaW5lciA9IHdyYXBwZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChlYXN5TURFQ29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmd1aS50b29sYmFyKSB7XG4gICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZ3VpLnRvb2xiYXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmd1aS5zdGF0dXNiYXIpIHtcbiAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5ndWkuc3RhdHVzYmFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ndWkuc2lkZUJ5U2lkZSkge1xuICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmd1aS5zaWRlQnlTaWRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVud3JhcCBlYXN5TURFY29udGFpbmVyIGJlZm9yZSBjb2RlbWlycm9yIHRvVGV4dEFyZWEoKSBjYWxsXG4gICAgZWFzeU1ERUNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBlYXN5TURFQ29udGFpbmVyKTtcbiAgICBlYXN5TURFQ29udGFpbmVyLnJlbW92ZSgpO1xuXG4gICAgY20udG9UZXh0QXJlYSgpO1xuXG4gICAgaWYgKHRoaXMuYXV0b3NhdmVUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b3NhdmVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLmF1dG9zYXZlVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsZWFyQXV0b3NhdmVkVmFsdWUoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVhc3lNREU7XG4iXSwibmFtZXMiOlsiQ29kZU1pcnJvciIsInJlcXVpcmUiLCJDb2RlTWlycm9yU3BlbGxDaGVja2VyIiwibWFya2VkIiwiaXNNYWMiLCJ0ZXN0IiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJhbmNob3JUb0V4dGVybmFsUmVnZXgiLCJSZWdFeHAiLCJiaW5kaW5ncyIsInRvZ2dsZUJvbGQiLCJ0b2dnbGVJdGFsaWMiLCJkcmF3TGluayIsInRvZ2dsZUhlYWRpbmdTbWFsbGVyIiwidG9nZ2xlSGVhZGluZ0JpZ2dlciIsImRyYXdJbWFnZSIsInRvZ2dsZUJsb2NrcXVvdGUiLCJ0b2dnbGVPcmRlcmVkTGlzdCIsInRvZ2dsZVVub3JkZXJlZExpc3QiLCJ0b2dnbGVDb2RlQmxvY2siLCJ0b2dnbGVQcmV2aWV3IiwidG9nZ2xlU3RyaWtldGhyb3VnaCIsInRvZ2dsZUhlYWRpbmcxIiwidG9nZ2xlSGVhZGluZzIiLCJ0b2dnbGVIZWFkaW5nMyIsInRvZ2dsZUhlYWRpbmc0IiwidG9nZ2xlSGVhZGluZzUiLCJ0b2dnbGVIZWFkaW5nNiIsImNsZWFuQmxvY2siLCJkcmF3VGFibGUiLCJkcmF3SG9yaXpvbnRhbFJ1bGUiLCJ1bmRvIiwicmVkbyIsInRvZ2dsZVNpZGVCeVNpZGUiLCJ0b2dnbGVGdWxsU2NyZWVuIiwic2hvcnRjdXRzIiwiZ2V0QmluZGluZ05hbWUiLCJmIiwia2V5IiwiaXNNb2JpbGUiLCJjaGVjayIsImEiLCJzdWJzdHIiLCJ1c2VyQWdlbnQiLCJ2ZW5kb3IiLCJ3aW5kb3ciLCJvcGVyYSIsImFkZEFuY2hvclRhcmdldEJsYW5rIiwiaHRtbFRleHQiLCJtYXRjaCIsImV4ZWMiLCJsaW5rU3RyaW5nIiwiaW5kZXhPZiIsImZpeGVkTGlua1N0cmluZyIsInJlcGxhY2UiLCJyZW1vdmVMaXN0U3R5bGVXaGVuQ2hlY2tib3giLCJwYXJzZXIiLCJET01QYXJzZXIiLCJodG1sRG9jIiwicGFyc2VGcm9tU3RyaW5nIiwibGlzdEl0ZW1zIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpIiwibGVuZ3RoIiwibGlzdEl0ZW0iLCJqIiwiY2hpbGRyZW4iLCJsaXN0SXRlbUNoaWxkIiwiSFRNTElucHV0RWxlbWVudCIsInR5cGUiLCJzdHlsZSIsIm1hcmdpbkxlZnQiLCJsaXN0U3R5bGVUeXBlIiwiZG9jdW1lbnRFbGVtZW50IiwiaW5uZXJIVE1MIiwiZml4U2hvcnRjdXQiLCJuYW1lIiwiY3JlYXRlVG9vbGJhckRyb3Bkb3duIiwib3B0aW9ucyIsImVuYWJsZVRvb2x0aXBzIiwicGFyZW50IiwiZWwiLCJjcmVhdGVUb29sYmFyQnV0dG9uIiwiY2xhc3NMaXN0IiwiYWRkIiwib25jbGljayIsImZvY3VzIiwiY29udGVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImNoaWxkcmVuSW5kZXgiLCJjaGlsZCIsImNoaWxkRWxlbWVudCIsInRvb2xiYXJCdWlsdEluQnV0dG9ucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwic3RvcFByb3BhZ2F0aW9uIiwiYXBwZW5kQ2hpbGQiLCJlbmFibGVBY3Rpb25zIiwibWFya3VwIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInNldEF0dHJpYnV0ZSIsImNsYXNzTmFtZVByZWZpeCIsInRvb2xiYXJCdXR0b25DbGFzc1ByZWZpeCIsInVuZGVmaW5lZCIsInRleHQiLCJpbm5lclRleHQiLCJhY3Rpb24iLCJ0aXRsZSIsImNyZWF0ZVRvb2x0aXAiLCJub0Rpc2FibGUiLCJub01vYmlsZSIsImNsYXNzTmFtZVBhcnRzIiwic3BsaXQiLCJpY29uQ2xhc3NlcyIsImNsYXNzTmFtZUluZGV4IiwiY2xhc3NOYW1lUGFydCIsInB1c2giLCJ0YWJJbmRleCIsImljb24iLCJpY29uQ2xhc3NJbmRleCIsImljb25DbGFzcyIsInByZXZlbnREZWZhdWx0Iiwib3BlbiIsImNyZWF0ZVNlcCIsImFjdGlvbk5hbWUiLCJ0b29sdGlwIiwiZ2V0U3RhdGUiLCJjbSIsInBvcyIsImdldEN1cnNvciIsInN0YXQiLCJnZXRUb2tlbkF0IiwidHlwZXMiLCJyZXQiLCJkYXRhIiwiYm9sZCIsImdldExpbmUiLCJsaW5lIiwicXVvdGUiLCJpdGFsaWMiLCJzdHJpa2V0aHJvdWdoIiwiY29kZSIsImltYWdlIiwibGluayIsInNhdmVkX292ZXJmbG93IiwiZWRpdG9yIiwiY29kZW1pcnJvciIsInNldE9wdGlvbiIsImdldE9wdGlvbiIsImJvZHkiLCJvdmVyZmxvdyIsIndyYXBwZXIiLCJnZXRXcmFwcGVyRWxlbWVudCIsInNpZGVieXNpZGUiLCJuZXh0U2libGluZyIsImNvbnRhaW5zIiwic2lkZUJ5U2lkZUZ1bGxzY3JlZW4iLCJlYXN5TURFQ29udGFpbmVyIiwicGFyZW50Tm9kZSIsInJlbW92ZSIsIm9uVG9nZ2xlRnVsbFNjcmVlbiIsIm1heEhlaWdodCIsImdldFNjcm9sbGVyRWxlbWVudCIsInJlbW92ZVByb3BlcnR5IiwiaGVpZ2h0Iiwic2V0UHJldmlld01heEhlaWdodCIsInRvb2xiYXJfZGl2IiwidG9nZ2xlIiwidG9vbGJhckVsZW1lbnRzIiwiZnVsbHNjcmVlbiIsInRvb2xiYXJCdXR0b24iLCJfdG9nZ2xlQmxvY2siLCJibG9ja1N0eWxlcyIsImZlbmNlQ2hhcnNUb0luc2VydCIsImZlbmNpbmdfbGluZSIsInN0eWxlcyIsInRva2VuX3N0YXRlIiwidG9rZW4iLCJzdGF0ZSIsImJhc2UiLCJjb2RlX3R5cGUiLCJsaW5lX251bSIsImZpcnN0VG9rIiwibGFzdFRvayIsImdldExpbmVIYW5kbGUiLCJjaCIsImluZGVudGVkQ29kZSIsImZlbmNlZENoYXJzIiwiaW5zZXJ0RmVuY2luZ0F0U2VsZWN0aW9uIiwiY3VyX3N0YXJ0IiwiY3VyX2VuZCIsInN0YXJ0X2xpbmVfc2VsIiwiZW5kX2xpbmVfc2VsIiwic2VsX211bHRpIiwicmVwbF9zdGFydCIsInJlcGxfZW5kIiwiX3JlcGxhY2VTZWxlY3Rpb24iLCJzZXRTZWxlY3Rpb24iLCJ0b2siLCJpc19jb2RlIiwiYmxvY2tfc3RhcnQiLCJibG9ja19lbmQiLCJsaW5lQ291bnQiLCJzdGFydCIsInNsaWNlIiwiZW5kIiwicmVwbGFjZVJhbmdlIiwiZmVuY2VkVG9rIiwiZmVuY2VfY2hhcnMiLCJzdGFydF90ZXh0Iiwic3RhcnRfbGluZSIsImVuZF90ZXh0IiwiZW5kX2xpbmUiLCJvcGVyYXRpb24iLCJzZWFyY2hfZnJvbSIsIm5leHRfbGluZSIsIm5leHRfbGluZV9sYXN0X3RvayIsIm5leHRfbGluZV9pbmRlbnRlZCIsImluZGVudExpbmUiLCJub19zZWxfYW5kX3N0YXJ0aW5nX29mX2xpbmUiLCJfdG9nZ2xlTGluZSIsIl90b2dnbGVIZWFkaW5nIiwibGlzdFN0eWxlIiwiaW5jbHVkZXMiLCJ1bm9yZGVyZWRMaXN0U3R5bGUiLCJfY2xlYW5CbG9jayIsInVybCIsInByb21wdFVSTHMiLCJyZXN1bHQiLCJwcm9tcHQiLCJwcm9tcHRUZXh0cyIsImVzY2FwZVByb21wdFVSTCIsIl90b2dnbGVMaW5rIiwiaW5zZXJ0VGV4dHMiLCJlbmNvZGVVUkkiLCJkcmF3VXBsb2FkZWRJbWFnZSIsIm9wZW5Ccm93c2VGaWxlV2luZG93IiwiYWZ0ZXJJbWFnZVVwbG9hZGVkIiwiaW1hZ2VOYW1lIiwibGFzdEluZGV4T2YiLCJleHQiLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInVwbG9hZGVkSW1hZ2UiLCJ0ZXh0X2xpbmsiLCJ1cGRhdGVTdGF0dXNCYXIiLCJpbWFnZVRleHRzIiwic2JPblVwbG9hZGVkIiwic2V0VGltZW91dCIsInNiSW5pdCIsInRhYmxlIiwiaG9yaXpvbnRhbFJ1bGUiLCJwcmV2aWV3IiwidXNlU2lkZUJ5U2lkZUxpc3RlbmVyIiwicHJldmlld05vcm1hbCIsImxhc3RDaGlsZCIsInRvb2xiYXIiLCJzaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24iLCJuZXdWYWx1ZSIsInByZXZpZXdSZW5kZXIiLCJ2YWx1ZSIsIm9uIiwib2ZmIiwicmVmcmVzaCIsInByZXZpZXdDbGFzcyIsIkFycmF5IiwiaXNBcnJheSIsInByZXZpZXdfcmVzdWx0IiwiYWN0aXZlIiwic3RhcnRFbmQiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJhc3NpZ24iLCJnZXRTZWxlY3Rpb24iLCJyZXBsYWNlU2VsZWN0aW9uIiwiZGlyZWN0aW9uIiwic2l6ZSIsImN1cnJIZWFkaW5nTGV2ZWwiLCJzZWFyY2giLCJyZXBlYXQiLCJsaXN0c3R5bGUiLCJsaXN0UmVnZXhwIiwid2hpdGVzcGFjZXNSZWdleHAiLCJyZXBsIiwiX2dldENoYXIiLCJtYXAiLCJfY2hlY2tDaGFyIiwiY2hhciIsInJ0IiwiX3RvZ2dsZSIsInVudG9nZ2xlT25seSIsImFyciIsImlzUHJldmlld0FjdGl2ZSIsInN0YXJ0X2NoYXJzIiwiZW5kX2NoYXJzIiwiam9pbiIsImh1bWFuRmlsZVNpemUiLCJieXRlcyIsInVuaXRzIiwiTWF0aCIsImFicyIsInUiLCJ0b0ZpeGVkIiwiX21lcmdlUHJvcGVydGllcyIsInRhcmdldCIsInNvdXJjZSIsInByb3BlcnR5IiwiY29uY2F0IiwiY29uc3RydWN0b3IiLCJleHRlbmQiLCJhcmd1bWVudHMiLCJ3b3JkQ291bnQiLCJwYXR0ZXJuIiwibSIsImNvdW50IiwiY2hhckNvZGVBdCIsImljb25DbGFzc01hcCIsImRlZmF1bHQiLCJ0aW1lRm9ybWF0IiwibG9jYWxlIiwiZm9ybWF0IiwiaG91ciIsIm1pbnV0ZSIsInNiT25EcmFnRW50ZXIiLCJzYk9uRHJvcCIsInNiUHJvZ3Jlc3MiLCJzaXplVW5pdHMiLCJlcnJvck1lc3NhZ2VzIiwibm9GaWxlR2l2ZW4iLCJ0eXBlTm90QWxsb3dlZCIsImZpbGVUb29MYXJnZSIsImltcG9ydEVycm9yIiwiRWFzeU1ERSIsImF1dG9Eb3dubG9hZEZBIiwiYXV0b0Rvd25sb2FkRm9udEF3ZXNvbWUiLCJzdHlsZVNoZWV0cyIsImhyZWYiLCJyZWwiLCJlbGVtZW50IiwiY29uc29sZSIsImxvZyIsInNob3dJY29ucyIsInN0YXR1cyIsInVwbG9hZEltYWdlIiwidW5zaGlmdCIsInBsYWluVGV4dCIsIm1hcmtkb3duIiwicGFyc2luZ0NvbmZpZyIsImhpZ2hsaWdodEZvcm1hdHRpbmciLCJhdXRvc2F2ZSIsIm1pbkhlaWdodCIsImVycm9yQ2FsbGJhY2siLCJlcnJvck1lc3NhZ2UiLCJhbGVydCIsImltYWdlTWF4U2l6ZSIsImltYWdlQWNjZXB0IiwiaW1hZ2VQYXRoQWJzb2x1dGUiLCJpbWFnZUNTUkZOYW1lIiwiaW1hZ2VDU1JGSGVhZGVyIiwiaW1hZ2VJbnB1dE5hbWUiLCJ1bmlxdWVfaWQiLCJ1bmlxdWVJZCIsIm92ZXJsYXlNb2RlIiwiY29tYmluZSIsInJlbmRlciIsImluaXRpYWxWYWx1ZSIsImZvdW5kU2F2ZWRWYWx1ZSIsInNlbGYiLCJldmVudCIsImltYWdlVXBsb2FkRnVuY3Rpb24iLCJ1cGxvYWRJbWFnZXNVc2luZ0N1c3RvbUZ1bmN0aW9uIiwiZGF0YVRyYW5zZmVyIiwiZmlsZXMiLCJ1cGxvYWRJbWFnZXMiLCJjbGlwYm9hcmREYXRhIiwib25TdWNjZXNzIiwib25FcnJvciIsIm5hbWVzIiwidXBsb2FkSW1hZ2VVc2luZ0N1c3RvbUZ1bmN0aW9uIiwiaXRlbU5hbWUiLCJndWkiLCJzdGF0dXNiYXIiLCJtYXRjaGluZ0NsYXNzZXMiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwidGV4dENvbnRlbnQiLCJtYXJrZWRPcHRpb25zIiwicmVuZGVyaW5nQ29uZmlnIiwic2luZ2xlTGluZUJyZWFrcyIsImJyZWFrcyIsImNvZGVTeW50YXhIaWdobGlnaHRpbmciLCJobGpzIiwiaGlnaGxpZ2h0IiwibGFuZ3VhZ2UiLCJnZXRMYW5ndWFnZSIsImhpZ2hsaWdodEF1dG8iLCJ1c2UiLCJwYXJzZSIsInNhbml0aXplckZ1bmN0aW9uIiwiX3JlbmRlcmVkIiwia2V5TWFwcyIsImRvY3VtZW50T25LZXlEb3duIiwia2V5Q29kZSIsIm1vZGUiLCJiYWNrZHJvcCIsImRlZmluZU1vZGUiLCJjb25maWciLCJnZXRNb2RlIiwic3BlbGxDaGVja2VyIiwiZ2l0SHViU3BpY2UiLCJjb2RlTWlycm9ySW5zdGFuY2UiLCJjb25maWd1cmVNb3VzZSIsImFkZE5ldyIsImZyb21UZXh0QXJlYSIsInRoZW1lIiwidGFiU2l6ZSIsImluZGVudFVuaXQiLCJpbmRlbnRXaXRoVGFicyIsImxpbmVOdW1iZXJzIiwiYXV0b2ZvY3VzIiwiZXh0cmFLZXlzIiwibGluZVdyYXBwaW5nIiwiYWxsb3dEcm9wRmlsZVR5cGVzIiwicGxhY2Vob2xkZXIiLCJnZXRBdHRyaWJ1dGUiLCJzdHlsZVNlbGVjdGVkVGV4dCIsInNjcm9sbGJhclN0eWxlIiwiaW5wdXRTdHlsZSIsInNwZWxsY2hlY2siLCJuYXRpdmVTcGVsbGNoZWNrIiwiYXV0b1JlZnJlc2giLCJmb3JjZVN5bmMiLCJzYXZlIiwiY21XcmFwcGVyIiwiaW5zZXJ0QmVmb3JlIiwiY3JlYXRlVG9vbGJhciIsImNyZWF0ZVN0YXR1c2JhciIsImVuYWJsZWQiLCJjbGVhclRpbWVvdXQiLCJfYXV0b3NhdmVfdGltZW91dCIsInN1Ym1pdF9kZWxheSIsImRlbGF5IiwiY2FsY0hlaWdodCIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJ2aWV3cG9ydFdpZHRoIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInF1ZXJ5U2VsZWN0b3IiLCJ3aWR0aCIsIl92bSIsImFzc2lnbkltYWdlQmxvY2tBdHRyaWJ1dGVzIiwicGFyZW50RWwiLCJpbWciLCJVUkwiLCJiYXNlVVJJIiwic2V0U2l6ZSIsImhhbmRsZUltYWdlcyIsInByZXZpZXdJbWFnZXNJbkVkaXRvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwicGFyZW50RWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInNyY0F0dHIiLCJFTURFaW1hZ2VzQ2FjaGUiLCJrZXlTcmMiLCJpbWFnZXNQcmV2aWV3SGFuZGxlciIsIm5ld1NyYyIsIm9ubG9hZCIsInNyYyIsInNpZGVCeVNpZGUiLCJjcmVhdGVTaWRlQnlTaWRlIiwidGVtcF9jbSIsImJpbmQiLCJjbGVhbnVwIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlYXN5TURFIiwiYmluZGVkIiwiZm9ybSIsImF1dG9zYXZlVGltZW91dElkIiwibG9hZGVkIiwiZ2V0SXRlbSIsInNldFZhbHVlIiwiZ2V0RWxlbWVudEJ5SWQiLCJkIiwiRGF0ZSIsImRkIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiY2xlYXJBdXRvc2F2ZWRWYWx1ZSIsImltYWdlSW5wdXQiLCJjbGljayIsIm9uQ2hhbmdlIiwiZmlsZSIsImltYWdlVXJsIiwib25FcnJvclN1cCIsImZpbGxFcnJvck1lc3NhZ2UiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiaW1hZ2VDU1JGVG9rZW4iLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJ1cGxvYWQiLCJvbnByb2dyZXNzIiwibGVuZ3RoQ29tcHV0YWJsZSIsInByb2dyZXNzIiwicm91bmQiLCJ0b3RhbCIsImltYWdlVXBsb2FkRW5kcG9pbnQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVzcG9uc2UiLCJKU09OIiwicmVzcG9uc2VUZXh0IiwiZXJyb3IiLCJmaWxlUGF0aCIsImxvY2F0aW9uIiwib3JpZ2luIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJzZW5kIiwiZmlsbGVkRXJyb3JNZXNzYWdlIiwiYXBwbHkiLCJwYWRkaW5nVG9wIiwicGFyc2VJbnQiLCJib3JkZXJUb3BXaWR0aCIsIm9wdGlvbnNNYXhIZWlnaHQiLCJ3cmFwcGVyTWF4SGVpZ2h0IiwicHJldmlld01heEhlaWdodCIsInRvU3RyaW5nIiwic3luY1NpZGVCeVNpZGVQcmV2aWV3U2Nyb2xsIiwiY1Njcm9sbCIsInBTY3JvbGwiLCJ2IiwiZ2V0U2Nyb2xsSW5mbyIsImNsaWVudEhlaWdodCIsInJhdGlvIiwicGFyc2VGbG9hdCIsInRvcCIsIm1vdmUiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxUb3AiLCJvbnNjcm9sbCIsInNjcm9sbFRvIiwiaXRlbXMiLCJiYXIiLCJ0b29sYmFyRGF0YSIsInRvb2xiYXJHdWlkZUljb24iLCJoaWRlSWNvbnMiLCJub25TZXBhcmF0b3JJY29uc0ZvbGxvdyIsIngiLCJpdGVtIiwidG9vbGJhclRpcHMiLCJtdWx0aXBsZSIsImFjY2VwdCIsImRpc3BsYXkiLCJvcGFjaXR5Iiwib25VcGRhdGUiLCJvbkFjdGl2aXR5IiwiZGVmYXVsdFZhbHVlIiwiZ2V0VmFsdWUiLCJwb3NMaW5lIiwicG9zQ29sdW1uIiwidmFsIiwiZ2V0RG9jIiwiaXNTaWRlQnlTaWRlQWN0aXZlIiwiaXNGdWxsc2NyZWVuQWN0aXZlIiwidG9UZXh0QXJlYSIsInJlbW92ZUNoaWxkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/easymde/src/js/easymde.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/typo-js/typo.js":
/*!**************************************!*\
  !*** ./node_modules/typo-js/typo.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n/* globals chrome: false */ /* globals __dirname: false */ /* globals require: false */ /* globals Buffer: false */ /* globals module: false */ /**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */ \nvar Typo;\n(function() {\n    \"use strict\";\n    /**\n     * Typo constructor.\n     *\n     * @param {string} [dictionary] The locale code of the dictionary being used. e.g.,\n     *                              \"en_US\". This is only used to auto-load dictionaries.\n     * @param {string} [affData]    The data from the dictionary's .aff file. If omitted\n     *                              and Typo.js is being used in a Chrome extension, the .aff\n     *                              file will be loaded automatically from\n     *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n     *                              In other environments, it will be loaded from\n     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n     * @param {string} [wordsData]  The data from the dictionary's .dic file. If omitted\n     *                              and Typo.js is being used in a Chrome extension, the .dic\n     *                              file will be loaded automatically from\n     *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n     *                              In other environments, it will be loaded from\n     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n     * @param {Object} [settings]   Constructor settings. Available properties are:\n     *                              {string} [dictionaryPath]: path to load dictionary from in non-chrome\n     *                              environment.\n     *                              {Object} [flags]: flag information.\n     *                              {boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n     *                              asynchronously.\n     *                              {Function} [loadedCallback]: Called when both affData and wordsData\n     *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n     *                              is the instantiated Typo object.\n     *\n     * @returns {Typo} A Typo object.\n     */ Typo = function(dictionary, affData, wordsData, settings) {\n        settings = settings || {};\n        this.dictionary = null;\n        this.rules = {};\n        this.dictionaryTable = {};\n        this.compoundRules = [];\n        this.compoundRuleCodes = {};\n        this.replacementTable = [];\n        this.flags = settings.flags || {};\n        this.memoized = {};\n        this.loaded = false;\n        var self = this;\n        var path;\n        // Loop-control variables.\n        var i, j, _len, _jlen;\n        if (dictionary) {\n            self.dictionary = dictionary;\n            // If the data is preloaded, just setup the Typo object.\n            if (affData && wordsData) {\n                setup();\n            } else if ( true && (window.chrome && window.chrome.runtime || window.browser && window.browser.runtime)) {\n                var runtime = window.chrome && window.chrome.runtime ? window.chrome.runtime : window.browser.runtime;\n                if (settings.dictionaryPath) {\n                    path = settings.dictionaryPath;\n                } else {\n                    path = \"typo/dictionaries\";\n                }\n                if (!affData) readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n                if (!wordsData) readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n            } else {\n                if (settings.dictionaryPath) {\n                    path = settings.dictionaryPath;\n                } else if (true) {\n                    path = __dirname + \"/dictionaries\";\n                } else {}\n                if (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n                if (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n            }\n        }\n        function readDataFile(url, setFunc) {\n            var response = self._readFile(url, null, settings === null || settings === void 0 ? void 0 : settings.asyncLoad);\n            if (settings === null || settings === void 0 ? void 0 : settings.asyncLoad) {\n                response.then(function(data) {\n                    setFunc(data);\n                });\n            } else {\n                setFunc(response);\n            }\n        }\n        function setAffData(data) {\n            affData = data;\n            if (wordsData) {\n                setup();\n            }\n        }\n        function setWordsData(data) {\n            wordsData = data;\n            if (affData) {\n                setup();\n            }\n        }\n        function setup() {\n            self.rules = self._parseAFF(affData);\n            // Save the rule codes that are used in compound rules.\n            self.compoundRuleCodes = {};\n            for(i = 0, _len = self.compoundRules.length; i < _len; i++){\n                var rule = self.compoundRules[i];\n                for(j = 0, _jlen = rule.length; j < _jlen; j++){\n                    self.compoundRuleCodes[rule[j]] = [];\n                }\n            }\n            // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n            // will do the work of saving the list of words that are compound-only.\n            if (\"ONLYINCOMPOUND\" in self.flags) {\n                self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n            }\n            self.dictionaryTable = self._parseDIC(wordsData);\n            // Get rid of any codes from the compound rule codes that are never used\n            // (or that were special regex characters).  Not especially necessary...\n            for(i in self.compoundRuleCodes){\n                if (self.compoundRuleCodes[i].length === 0) {\n                    delete self.compoundRuleCodes[i];\n                }\n            }\n            // Build the full regular expressions for each compound rule.\n            // I have a feeling (but no confirmation yet) that this method of\n            // testing for compound words is probably slow.\n            for(i = 0, _len = self.compoundRules.length; i < _len; i++){\n                var ruleText = self.compoundRules[i];\n                var expressionText = \"\";\n                for(j = 0, _jlen = ruleText.length; j < _jlen; j++){\n                    var character = ruleText[j];\n                    if (character in self.compoundRuleCodes) {\n                        expressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n                    } else {\n                        expressionText += character;\n                    }\n                }\n                self.compoundRules[i] = new RegExp(\"^\" + expressionText + \"$\", \"i\");\n            }\n            self.loaded = true;\n            if ((settings === null || settings === void 0 ? void 0 : settings.asyncLoad) && (settings === null || settings === void 0 ? void 0 : settings.loadedCallback)) {\n                settings.loadedCallback(self);\n            }\n        }\n        return this;\n    };\n    Typo.prototype = {\n        /**\n         * Loads a Typo instance from a hash of all of the Typo properties.\n         *\n         * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n         */ load: function(obj) {\n            for(var i in obj){\n                if (obj.hasOwnProperty(i)) {\n                    this[i] = obj[i];\n                }\n            }\n            return this;\n        },\n        /**\n         * Read the contents of a file.\n         *\n         * @param {string} path The path (relative) to the file.\n         * @param {string} [charset=\"ISO8859-1\"] The expected charset of the file\n         * @param {boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n         *        files are read synchronously.\n         * @returns {string} The file data if async is false, otherwise a promise object. If running node.js, the data is\n         *          always returned.\n         */ _readFile: function(path, charset, async) {\n            var _a;\n            charset = charset || \"utf8\";\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                var req_1 = new XMLHttpRequest();\n                req_1.open(\"GET\", path, !!async);\n                (_a = req_1.overrideMimeType) === null || _a === void 0 ? void 0 : _a.call(req_1, \"text/plain; charset=\" + charset);\n                if (!!async) {\n                    var promise = new Promise(function(resolve, reject) {\n                        req_1.onload = function() {\n                            if (req_1.status === 200) {\n                                resolve(req_1.responseText);\n                            } else {\n                                reject(req_1.statusText);\n                            }\n                        };\n                        req_1.onerror = function() {\n                            reject(req_1.statusText);\n                        };\n                    });\n                    req_1.send(null);\n                    return promise;\n                } else {\n                    req_1.send(null);\n                    return req_1.responseText;\n                }\n            } else if (true) {\n                // Node.js\n                var fs = __webpack_require__(/*! fs */ \"?f052\");\n                try {\n                    if (fs.existsSync(path)) {\n                        return fs.readFileSync(path, charset);\n                    } else {\n                        console.log(\"Path \" + path + \" does not exist.\");\n                    }\n                } catch (e) {\n                    console.log(e);\n                }\n                return \"\";\n            }\n            return \"\";\n        },\n        /**\n         * Parse the rules out from a .aff file.\n         *\n         * @param {string} data The contents of the affix file.\n         * @returns object The rules from the file.\n         */ _parseAFF: function(data) {\n            var rules = {};\n            var line, subline, numEntries, lineParts;\n            var i, j, _len, _jlen;\n            var lines = data.split(/\\r?\\n/);\n            for(i = 0, _len = lines.length; i < _len; i++){\n                // Remove comment lines\n                line = this._removeAffixComments(lines[i]);\n                line = line.trim();\n                if (!line) {\n                    continue;\n                }\n                var definitionParts = line.split(/\\s+/);\n                var ruleType = definitionParts[0];\n                if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n                    var ruleCode = definitionParts[1];\n                    var combineable = definitionParts[2];\n                    numEntries = parseInt(definitionParts[3], 10);\n                    var entries = [];\n                    for(j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++){\n                        subline = lines[j];\n                        lineParts = subline.split(/\\s+/);\n                        var charactersToRemove = lineParts[2];\n                        var additionParts = lineParts[3].split(\"/\");\n                        var charactersToAdd = additionParts[0];\n                        if (charactersToAdd === \"0\") charactersToAdd = \"\";\n                        var continuationClasses = this.parseRuleCodes(additionParts[1]);\n                        var regexToMatch = lineParts[4];\n                        var entry = {\n                            add: charactersToAdd\n                        };\n                        if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n                        if (regexToMatch !== \".\") {\n                            if (ruleType === \"SFX\") {\n                                entry.match = new RegExp(regexToMatch + \"$\");\n                            } else {\n                                entry.match = new RegExp(\"^\" + regexToMatch);\n                            }\n                        }\n                        if (charactersToRemove != \"0\") {\n                            if (ruleType === \"SFX\") {\n                                entry.remove = new RegExp(charactersToRemove + \"$\");\n                            } else {\n                                entry.remove = charactersToRemove;\n                            }\n                        }\n                        entries.push(entry);\n                    }\n                    rules[ruleCode] = {\n                        \"type\": ruleType,\n                        \"combineable\": combineable === \"Y\",\n                        \"entries\": entries\n                    };\n                    i += numEntries;\n                } else if (ruleType === \"COMPOUNDRULE\") {\n                    numEntries = parseInt(definitionParts[1], 10);\n                    for(j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++){\n                        line = lines[j];\n                        lineParts = line.split(/\\s+/);\n                        this.compoundRules.push(lineParts[1]);\n                    }\n                    i += numEntries;\n                } else if (ruleType === \"REP\") {\n                    lineParts = line.split(/\\s+/);\n                    if (lineParts.length === 3) {\n                        this.replacementTable.push([\n                            lineParts[1],\n                            lineParts[2]\n                        ]);\n                    }\n                } else {\n                    // ONLYINCOMPOUND\n                    // COMPOUNDMIN\n                    // FLAG\n                    // KEEPCASE\n                    // NEEDAFFIX\n                    this.flags[ruleType] = definitionParts[1];\n                }\n            }\n            return rules;\n        },\n        /**\n         * Removes comments.\n         *\n         * @param {string} data A line from an affix file.\n         * @return {string} The cleaned-up line.\n         */ _removeAffixComments: function(line) {\n            // This used to remove any string starting with '#' up to the end of the line,\n            // but some COMPOUNDRULE definitions include '#' as part of the rule.\n            // So, only remove lines that begin with a comment, optionally preceded by whitespace.\n            if (line.match(/^\\s*#/)) {\n                return \"\";\n            }\n            return line;\n        },\n        /**\n         * Parses the words out from the .dic file.\n         *\n         * @param {string} data The data from the dictionary file.\n         * @returns HashMap The lookup table containing all of the words and\n         *                 word forms from the dictionary.\n         */ _parseDIC: function(data) {\n            data = this._removeDicComments(data);\n            var lines = data.split(/\\r?\\n/);\n            var dictionaryTable = {};\n            function addWord(word, rules) {\n                // Some dictionaries will list the same word multiple times with different rule sets.\n                if (!dictionaryTable.hasOwnProperty(word)) {\n                    dictionaryTable[word] = null;\n                }\n                if (rules.length > 0) {\n                    if (dictionaryTable[word] === null) {\n                        dictionaryTable[word] = [];\n                    }\n                    dictionaryTable[word].push(rules);\n                }\n            }\n            // The first line is the number of words in the dictionary.\n            for(var i = 1, _len = lines.length; i < _len; i++){\n                var line = lines[i];\n                if (!line) {\n                    continue;\n                }\n                // The line format is one of:\n                //     word\n                //     word/flags\n                //     word/flags xx:abc yy:def\n                //     word xx:abc yy:def\n                // We don't use the morphological flags (xx:abc, yy:def) and we don't want them included\n                // in the extracted flags.\n                var just_word_and_flags = line.replace(/\\s.*$/, \"\");\n                // just_word_and_flags is definitely one of:\n                //     word\n                //     word/flags\n                var parts = just_word_and_flags.split(\"/\", 2);\n                var word = parts[0];\n                // Now for each affix rule, generate that form of the word.\n                if (parts.length > 1) {\n                    var ruleCodesArray = this.parseRuleCodes(parts[1]);\n                    // Save the ruleCodes for compound word situations.\n                    if (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1) {\n                        addWord(word, ruleCodesArray);\n                    }\n                    for(var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++){\n                        var code = ruleCodesArray[j];\n                        var rule = this.rules[code];\n                        if (rule) {\n                            var newWords = this._applyRule(word, rule);\n                            for(var ii = 0, _iilen = newWords.length; ii < _iilen; ii++){\n                                var newWord = newWords[ii];\n                                addWord(newWord, []);\n                                if (rule.combineable) {\n                                    for(var k = j + 1; k < _jlen; k++){\n                                        var combineCode = ruleCodesArray[k];\n                                        var combineRule = this.rules[combineCode];\n                                        if (combineRule) {\n                                            if (combineRule.combineable && rule.type != combineRule.type) {\n                                                var otherNewWords = this._applyRule(newWord, combineRule);\n                                                for(var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++){\n                                                    var otherNewWord = otherNewWords[iii];\n                                                    addWord(otherNewWord, []);\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (code in this.compoundRuleCodes) {\n                            this.compoundRuleCodes[code].push(word);\n                        }\n                    }\n                } else {\n                    addWord(word.trim(), []);\n                }\n            }\n            return dictionaryTable;\n        },\n        /**\n         * Removes comment lines and then cleans up blank lines and trailing whitespace.\n         *\n         * @param {string} data The data from a .dic file.\n         * @return {string} The cleaned-up data.\n         */ _removeDicComments: function(data) {\n            // I can't find any official documentation on it, but at least the de_DE\n            // dictionary uses tab-indented lines as comments.\n            // Remove comments\n            data = data.replace(/^\\t.*$/mg, \"\");\n            return data;\n        },\n        parseRuleCodes: function(textCodes) {\n            if (!textCodes) {\n                return [];\n            } else if (!(\"FLAG\" in this.flags)) {\n                // The flag symbols are single characters\n                return textCodes.split(\"\");\n            } else if (this.flags.FLAG === \"long\") {\n                // The flag symbols are two characters long.\n                var flags = [];\n                for(var i = 0, _len = textCodes.length; i < _len; i += 2){\n                    flags.push(textCodes.substr(i, 2));\n                }\n                return flags;\n            } else if (this.flags.FLAG === \"num\") {\n                // The flag symbols are a CSV list of numbers.\n                return textCodes.split(\",\");\n            } else if (this.flags.FLAG === \"UTF-8\") {\n                // The flags are single UTF-8 characters.\n                // @see https://github.com/cfinke/Typo.js/issues/57\n                return Array.from(textCodes);\n            } else {\n                // It's possible that this fallback case will not work for all FLAG values,\n                // but I think it's more likely to work than not returning anything at all.\n                return textCodes.split(\"\");\n            }\n        },\n        /**\n         * Applies an affix rule to a word.\n         *\n         * @param {string} word The base word.\n         * @param {Object} rule The affix rule.\n         * @returns {string[]} The new words generated by the rule.\n         */ _applyRule: function(word, rule) {\n            var entries = rule.entries;\n            var newWords = [];\n            for(var i = 0, _len = entries.length; i < _len; i++){\n                var entry = entries[i];\n                if (!entry.match || word.match(entry.match)) {\n                    var newWord = word;\n                    if (entry.remove) {\n                        newWord = newWord.replace(entry.remove, \"\");\n                    }\n                    if (rule.type === \"SFX\") {\n                        newWord = newWord + entry.add;\n                    } else {\n                        newWord = entry.add + newWord;\n                    }\n                    newWords.push(newWord);\n                    if (\"continuationClasses\" in entry) {\n                        for(var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++){\n                            var continuationRule = this.rules[entry.continuationClasses[j]];\n                            if (continuationRule) {\n                                newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n                            }\n                        /*\n                            else {\n                                // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                                // I think the author mistakenly supplied lower-case rule codes instead\n                                // of upper-case.\n                            }\n                            */ }\n                    }\n                }\n            }\n            return newWords;\n        },\n        /**\n         * Checks whether a word or a capitalization variant exists in the current dictionary.\n         * The word is trimmed and several variations of capitalizations are checked.\n         * If you want to check a word without any changes made to it, call checkExact()\n         *\n         * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n         *\n         * @param {string} aWord The word to check.\n         * @returns {boolean}\n         */ check: function(aWord) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            if (!aWord) {\n                return false;\n            }\n            // Remove leading and trailing whitespace\n            var trimmedWord = aWord.replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n            if (this.checkExact(trimmedWord)) {\n                return true;\n            }\n            // The exact word is not in the dictionary.\n            if (trimmedWord.toUpperCase() === trimmedWord) {\n                // The word was supplied in all uppercase.\n                // Check for a capitalized form of the word.\n                var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n                if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n                    // Capitalization variants are not allowed for this word.\n                    return false;\n                }\n                if (this.checkExact(capitalizedWord)) {\n                    // The all-caps word is a capitalized word spelled correctly.\n                    return true;\n                }\n                if (this.checkExact(trimmedWord.toLowerCase())) {\n                    // The all-caps is a lowercase word spelled correctly.\n                    return true;\n                }\n            }\n            var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n            if (uncapitalizedWord !== trimmedWord) {\n                if (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n                    // Capitalization variants are not allowed for this word.\n                    return false;\n                }\n                // Check for an uncapitalized form\n                if (this.checkExact(uncapitalizedWord)) {\n                    // The word is spelled correctly but with the first letter capitalized.\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n         * Checks whether a word exists in the current dictionary.\n         *\n         * @param {string} word The word to check.\n         * @returns {boolean}\n         */ checkExact: function(word) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            var ruleCodes = this.dictionaryTable[word];\n            var i, _len;\n            if (typeof ruleCodes === \"undefined\") {\n                // Check if this might be a compound word.\n                if (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n                    for(i = 0, _len = this.compoundRules.length; i < _len; i++){\n                        if (word.match(this.compoundRules[i])) {\n                            return true;\n                        }\n                    }\n                }\n            } else if (ruleCodes === null) {\n                // a null (but not undefined) value for an entry in the dictionary table\n                // means that the word is in the dictionary but has no flags.\n                return true;\n            } else if (typeof ruleCodes === \"object\") {\n                for(i = 0, _len = ruleCodes.length; i < _len; i++){\n                    if (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n         * Looks up whether a given word is flagged with a given flag.\n         *\n         * @param {string} word The word in question.\n         * @param {string} flag The flag in question.\n         * @return {boolean}\n         */ hasFlag: function(word, flag, wordFlags) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            if (flag in this.flags) {\n                if (typeof wordFlags === \"undefined\") {\n                    wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n                }\n                if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n         * Returns a list of suggestions for a misspelled word.\n         *\n         * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n         * This suggestor is primitive, but it works.\n         *\n         * @param {string} word The misspelling.\n         * @param {number} [limit=5] The maximum number of suggestions to return.\n         * @returns {string[]} The array of suggestions.\n         */ alphabet: \"\",\n        suggest: function(word, limit) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            limit = limit || 5;\n            if (this.memoized.hasOwnProperty(word)) {\n                var memoizedLimit = this.memoized[word][\"limit\"];\n                // Only return the cached list if it's big enough or if there weren't enough suggestions\n                // to fill a smaller limit.\n                if (limit <= memoizedLimit || this.memoized[word][\"suggestions\"].length < memoizedLimit) {\n                    return this.memoized[word][\"suggestions\"].slice(0, limit);\n                }\n            }\n            if (this.check(word)) return [];\n            // Check the replacement table.\n            for(var i = 0, _len = this.replacementTable.length; i < _len; i++){\n                var replacementEntry = this.replacementTable[i];\n                if (word.indexOf(replacementEntry[0]) !== -1) {\n                    var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n                    if (this.check(correctedWord)) {\n                        return [\n                            correctedWord\n                        ];\n                    }\n                }\n            }\n            if (!this.alphabet) {\n                // Use the English alphabet as the default. Problematic, but backwards-compatible.\n                this.alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n                // Any characters defined in the affix file as substitutions can go in the alphabet too.\n                // Note that dictionaries do not include the entire alphabet in the TRY flag when it's there.\n                // For example, Q is not in the default English TRY list; that's why having the default\n                // alphabet above is useful.\n                if (\"TRY\" in this.flags) {\n                    this.alphabet += this.flags[\"TRY\"];\n                }\n                // Plus any additional characters specifically defined as being allowed in words.\n                if (\"WORDCHARS\" in this.flags) {\n                    this.alphabet += this.flags[\"WORDCHARS\"];\n                }\n                // Remove any duplicates.\n                var alphaArray = this.alphabet.split(\"\");\n                alphaArray.sort();\n                var alphaHash = {};\n                for(var i = 0; i < alphaArray.length; i++){\n                    alphaHash[alphaArray[i]] = true;\n                }\n                this.alphabet = \"\";\n                for(var i in alphaHash){\n                    this.alphabet += i;\n                }\n            }\n            var self = this;\n            /**\n             * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n             * The value of each entry is the number of unique ways that the resulting word can be made.\n             *\n             * @arg HashMap words A hash keyed by words (all with the value `true` to make lookups very quick).\n             * @arg boolean known_only Whether this function should ignore strings that are not in the dictionary.\n             */ function edits1(words, known_only) {\n                var rv = {};\n                var i, j, _iilen, _len, _jlen, _edit;\n                var alphabetLength = self.alphabet.length;\n                for(var word_1 in words){\n                    for(i = 0, _len = word_1.length + 1; i < _len; i++){\n                        var s = [\n                            word_1.substring(0, i),\n                            word_1.substring(i)\n                        ];\n                        // Remove a letter.\n                        if (s[1]) {\n                            _edit = s[0] + s[1].substring(1);\n                            if (!known_only || self.check(_edit)) {\n                                if (!(_edit in rv)) {\n                                    rv[_edit] = 1;\n                                } else {\n                                    rv[_edit] += 1;\n                                }\n                            }\n                        }\n                        // Transpose letters\n                        // Eliminate transpositions of identical letters\n                        if (s[1].length > 1 && s[1][1] !== s[1][0]) {\n                            _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n                            if (!known_only || self.check(_edit)) {\n                                if (!(_edit in rv)) {\n                                    rv[_edit] = 1;\n                                } else {\n                                    rv[_edit] += 1;\n                                }\n                            }\n                        }\n                        if (s[1]) {\n                            // Replace a letter with another letter.\n                            var lettercase = s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? \"uppercase\" : \"lowercase\";\n                            for(j = 0; j < alphabetLength; j++){\n                                var replacementLetter = self.alphabet[j];\n                                // Set the case of the replacement letter to the same as the letter being replaced.\n                                if (\"uppercase\" === lettercase) {\n                                    replacementLetter = replacementLetter.toUpperCase();\n                                }\n                                // Eliminate replacement of a letter by itself\n                                if (replacementLetter != s[1].substring(0, 1)) {\n                                    _edit = s[0] + replacementLetter + s[1].substring(1);\n                                    if (!known_only || self.check(_edit)) {\n                                        if (!(_edit in rv)) {\n                                            rv[_edit] = 1;\n                                        } else {\n                                            rv[_edit] += 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (s[1]) {\n                            // Add a letter between each letter.\n                            for(j = 0; j < alphabetLength; j++){\n                                // If the letters on each side are capitalized, capitalize the replacement.\n                                var lettercase = s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? \"uppercase\" : \"lowercase\";\n                                var replacementLetter = self.alphabet[j];\n                                if (\"uppercase\" === lettercase) {\n                                    replacementLetter = replacementLetter.toUpperCase();\n                                }\n                                _edit = s[0] + replacementLetter + s[1];\n                                if (!known_only || self.check(_edit)) {\n                                    if (!(_edit in rv)) {\n                                        rv[_edit] = 1;\n                                    } else {\n                                        rv[_edit] += 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return rv;\n            }\n            function correct(word) {\n                var _a;\n                // Get the edit-distance-1 and edit-distance-2 forms of this word.\n                var ed1 = edits1((_a = {}, _a[word] = true, _a));\n                var ed2 = edits1(ed1, true);\n                // Sort the edits based on how many different ways they were created.\n                var weighted_corrections = ed2;\n                for(var ed1word in ed1){\n                    if (!self.check(ed1word)) {\n                        continue;\n                    }\n                    if (ed1word in weighted_corrections) {\n                        weighted_corrections[ed1word] += ed1[ed1word];\n                    } else {\n                        weighted_corrections[ed1word] = ed1[ed1word];\n                    }\n                }\n                var i, _len;\n                var sorted_corrections = [];\n                for(i in weighted_corrections){\n                    if (weighted_corrections.hasOwnProperty(i)) {\n                        if (self.hasFlag(i, \"PRIORITYSUGGEST\")) {\n                            // We've defined a new affix rule called PRIORITYSUGGEST, indicating that\n                            // if this word is in the suggestions list for a misspelled word, it should\n                            // be given priority over other suggestions.\n                            //\n                            // Add a large number to its weight to push it to the top of the list.\n                            // If multiple priority suggestions are in the list, they'll still be ranked\n                            // against each other, but they'll all be above non-priority suggestions.\n                            weighted_corrections[i] += 1000;\n                        }\n                        sorted_corrections.push([\n                            i,\n                            weighted_corrections[i]\n                        ]);\n                    }\n                }\n                function sorter(a, b) {\n                    var a_val = a[1];\n                    var b_val = b[1];\n                    if (a_val < b_val) {\n                        return -1;\n                    } else if (a_val > b_val) {\n                        return 1;\n                    }\n                    // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n                    return b[0].localeCompare(a[0]);\n                }\n                sorted_corrections.sort(sorter).reverse();\n                var rv = [];\n                var capitalization_scheme = \"lowercase\";\n                if (word.toUpperCase() === word) {\n                    capitalization_scheme = \"uppercase\";\n                } else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n                    capitalization_scheme = \"capitalized\";\n                }\n                var working_limit = limit;\n                for(i = 0; i < Math.min(working_limit, sorted_corrections.length); i++){\n                    if (\"uppercase\" === capitalization_scheme) {\n                        sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n                    } else if (\"capitalized\" === capitalization_scheme) {\n                        sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n                    }\n                    if (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) === -1) {\n                        rv.push(sorted_corrections[i][0]);\n                    } else {\n                        // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n                        working_limit++;\n                    }\n                }\n                return rv;\n            }\n            this.memoized[word] = {\n                \"suggestions\": correct(word),\n                \"limit\": limit\n            };\n            return this.memoized[word][\"suggestions\"];\n        }\n    };\n})();\n// Support for use as a node.js module.\nif (true) {\n    module.exports = Typo;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90eXBvLWpzL3R5cG8uanMiLCJtYXBwaW5ncyI6IjtBQUFBLHlCQUF5QixHQUN6Qiw0QkFBNEIsR0FDNUIsMEJBQTBCLEdBQzFCLHlCQUF5QixHQUN6Qix5QkFBeUIsR0FDekI7OztDQUdDO0FBQ0QsSUFBSUE7QUFDSDtJQUNHO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E0QkMsR0FDREEsT0FBTyxTQUFVQyxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxRQUFRO1FBQ3JEQSxXQUFXQSxZQUFZLENBQUM7UUFDeEIsSUFBSSxDQUFDSCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDSSxLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQ0MsZUFBZSxHQUFHLENBQUM7UUFDeEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNDLGlCQUFpQixHQUFHLENBQUM7UUFDMUIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQ0MsS0FBSyxHQUFHTixTQUFTTSxLQUFLLElBQUksQ0FBQztRQUNoQyxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSUMsT0FBTyxJQUFJO1FBQ2YsSUFBSUM7UUFDSiwwQkFBMEI7UUFDMUIsSUFBSUMsR0FBR0MsR0FBR0MsTUFBTUM7UUFDaEIsSUFBSWpCLFlBQVk7WUFDWlksS0FBS1osVUFBVSxHQUFHQTtZQUNsQix3REFBd0Q7WUFDeEQsSUFBSUMsV0FBV0MsV0FBVztnQkFDdEJnQjtZQUNKLE9BRUssSUFBSSxLQUFrQixJQUFnQixRQUFRRSxNQUFNLElBQUlELE9BQU9DLE1BQU0sQ0FBQ0MsT0FBTyxJQUFNRixPQUFPRyxPQUFPLElBQUlILE9BQU9HLE9BQU8sQ0FBQ0QsT0FBTyxHQUFJO2dCQUNoSSxJQUFJQSxVQUFVRixPQUFPQyxN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QWE7SUFDL0JnRixPQUFPQyxPQUFPLEdBQUd6TDtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHlwby1qcy90eXBvLmpzPzFhOGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBjaHJvbWU6IGZhbHNlICovXG4vKiBnbG9iYWxzIF9fZGlybmFtZTogZmFsc2UgKi9cbi8qIGdsb2JhbHMgcmVxdWlyZTogZmFsc2UgKi9cbi8qIGdsb2JhbHMgQnVmZmVyOiBmYWxzZSAqL1xuLyogZ2xvYmFscyBtb2R1bGU6IGZhbHNlICovXG4vKipcbiAqIFR5cG8gaXMgYSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGEgc3BlbGxjaGVja2VyIHVzaW5nIGh1bnNwZWxsLXN0eWxlXG4gKiBkaWN0aW9uYXJpZXMuXG4gKi9cbnZhciBUeXBvO1xuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAvKipcbiAgICAgKiBUeXBvIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkaWN0aW9uYXJ5XSBUaGUgbG9jYWxlIGNvZGUgb2YgdGhlIGRpY3Rpb25hcnkgYmVpbmcgdXNlZC4gZS5nLixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW5fVVNcIi4gVGhpcyBpcyBvbmx5IHVzZWQgdG8gYXV0by1sb2FkIGRpY3Rpb25hcmllcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FmZkRhdGFdICAgIFRoZSBkYXRhIGZyb20gdGhlIGRpY3Rpb25hcnkncyAuYWZmIGZpbGUuIElmIG9taXR0ZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBUeXBvLmpzIGlzIGJlaW5nIHVzZWQgaW4gYSBDaHJvbWUgZXh0ZW5zaW9uLCB0aGUgLmFmZlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSB3aWxsIGJlIGxvYWRlZCBhdXRvbWF0aWNhbGx5IGZyb21cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi90eXBvL2RpY3Rpb25hcmllcy9bZGljdGlvbmFyeV0vW2RpY3Rpb25hcnldLmFmZlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgZW52aXJvbm1lbnRzLCBpdCB3aWxsIGJlIGxvYWRlZCBmcm9tXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2V0dGluZ3MuZGljdGlvbmFyeVBhdGhdL2RpY3Rpb25hcmllcy9bZGljdGlvbmFyeV0vW2RpY3Rpb25hcnldLmFmZlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbd29yZHNEYXRhXSAgVGhlIGRhdGEgZnJvbSB0aGUgZGljdGlvbmFyeSdzIC5kaWMgZmlsZS4gSWYgb21pdHRlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIFR5cG8uanMgaXMgYmVpbmcgdXNlZCBpbiBhIENocm9tZSBleHRlbnNpb24sIHRoZSAuZGljXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHdpbGwgYmUgbG9hZGVkIGF1dG9tYXRpY2FsbHkgZnJvbVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL3R5cG8vZGljdGlvbmFyaWVzL1tkaWN0aW9uYXJ5XS9bZGljdGlvbmFyeV0uZGljXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbiBvdGhlciBlbnZpcm9ubWVudHMsIGl0IHdpbGwgYmUgbG9hZGVkIGZyb21cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZXR0aW5ncy5kaWN0aW9uYXJ5UGF0aF0vZGljdGlvbmFyaWVzL1tkaWN0aW9uYXJ5XS9bZGljdGlvbmFyeV0uZGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzZXR0aW5nc10gICBDb25zdHJ1Y3RvciBzZXR0aW5ncy4gQXZhaWxhYmxlIHByb3BlcnRpZXMgYXJlOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gW2RpY3Rpb25hcnlQYXRoXTogcGF0aCB0byBsb2FkIGRpY3Rpb25hcnkgZnJvbSBpbiBub24tY2hyb21lXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnZpcm9ubWVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IFtmbGFnc106IGZsYWcgaW5mb3JtYXRpb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW2FzeW5jTG9hZF06IElmIHRydWUsIGFmZkRhdGEgYW5kIHdvcmRzRGF0YSB3aWxsIGJlIGxvYWRlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNocm9ub3VzbHkuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb259IFtsb2FkZWRDYWxsYmFja106IENhbGxlZCB3aGVuIGJvdGggYWZmRGF0YSBhbmQgd29yZHNEYXRhXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGJlZW4gbG9hZGVkLiBPbmx5IHVzZWQgaWYgYXN5bmNMb2FkIGlzIHNldCB0byB0cnVlLiBUaGUgcGFyYW1ldGVyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgaW5zdGFudGlhdGVkIFR5cG8gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1R5cG99IEEgVHlwbyBvYmplY3QuXG4gICAgICovXG4gICAgVHlwbyA9IGZ1bmN0aW9uIChkaWN0aW9uYXJ5LCBhZmZEYXRhLCB3b3Jkc0RhdGEsIHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICAgIHRoaXMuZGljdGlvbmFyeSA9IG51bGw7XG4gICAgICAgIHRoaXMucnVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5kaWN0aW9uYXJ5VGFibGUgPSB7fTtcbiAgICAgICAgdGhpcy5jb21wb3VuZFJ1bGVzID0gW107XG4gICAgICAgIHRoaXMuY29tcG91bmRSdWxlQ29kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZXBsYWNlbWVudFRhYmxlID0gW107XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXR0aW5ncy5mbGFncyB8fCB7fTtcbiAgICAgICAgdGhpcy5tZW1vaXplZCA9IHt9O1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwYXRoO1xuICAgICAgICAvLyBMb29wLWNvbnRyb2wgdmFyaWFibGVzLlxuICAgICAgICB2YXIgaSwgaiwgX2xlbiwgX2psZW47XG4gICAgICAgIGlmIChkaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICBzZWxmLmRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5O1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGEgaXMgcHJlbG9hZGVkLCBqdXN0IHNldHVwIHRoZSBUeXBvIG9iamVjdC5cbiAgICAgICAgICAgIGlmIChhZmZEYXRhICYmIHdvcmRzRGF0YSkge1xuICAgICAgICAgICAgICAgIHNldHVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2FkaW5nIGRhdGEgZm9yIGJyb3dzZXIgZXh0ZW50aW9ucy5cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgod2luZG93LmNocm9tZSAmJiB3aW5kb3cuY2hyb21lLnJ1bnRpbWUpIHx8ICh3aW5kb3cuYnJvd3NlciAmJiB3aW5kb3cuYnJvd3Nlci5ydW50aW1lKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHdpbmRvdy5jaHJvbWUgJiYgd2luZG93LmNocm9tZS5ydW50aW1lID8gd2luZG93LmNocm9tZS5ydW50aW1lIDogd2luZG93LmJyb3dzZXIucnVudGltZTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGljdGlvbmFyeVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHNldHRpbmdzLmRpY3Rpb25hcnlQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwidHlwby9kaWN0aW9uYXJpZXNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhZmZEYXRhKVxuICAgICAgICAgICAgICAgICAgICByZWFkRGF0YUZpbGUocnVudGltZS5nZXRVUkwocGF0aCArIFwiL1wiICsgZGljdGlvbmFyeSArIFwiL1wiICsgZGljdGlvbmFyeSArIFwiLmFmZlwiKSwgc2V0QWZmRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3Jkc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgIHJlYWREYXRhRmlsZShydW50aW1lLmdldFVSTChwYXRoICsgXCIvXCIgKyBkaWN0aW9uYXJ5ICsgXCIvXCIgKyBkaWN0aW9uYXJ5ICsgXCIuZGljXCIpLCBzZXRXb3Jkc0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9hZGluZyBkYXRhIGZvciBOb2RlLmpzIG9yIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kaWN0aW9uYXJ5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gc2V0dGluZ3MuZGljdGlvbmFyeVBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBfX2Rpcm5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBfX2Rpcm5hbWUgKyAnL2RpY3Rpb25hcmllcyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gJy4vZGljdGlvbmFyaWVzJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhZmZEYXRhKVxuICAgICAgICAgICAgICAgICAgICByZWFkRGF0YUZpbGUocGF0aCArIFwiL1wiICsgZGljdGlvbmFyeSArIFwiL1wiICsgZGljdGlvbmFyeSArIFwiLmFmZlwiLCBzZXRBZmZEYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmRzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZERhdGFGaWxlKHBhdGggKyBcIi9cIiArIGRpY3Rpb25hcnkgKyBcIi9cIiArIGRpY3Rpb25hcnkgKyBcIi5kaWNcIiwgc2V0V29yZHNEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkRGF0YUZpbGUodXJsLCBzZXRGdW5jKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBzZWxmLl9yZWFkRmlsZSh1cmwsIG51bGwsIHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5hc3luY0xvYWQpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5hc3luY0xvYWQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZ1bmMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRGdW5jKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRBZmZEYXRhKGRhdGEpIHtcbiAgICAgICAgICAgIGFmZkRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgaWYgKHdvcmRzRGF0YSkge1xuICAgICAgICAgICAgICAgIHNldHVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0V29yZHNEYXRhKGRhdGEpIHtcbiAgICAgICAgICAgIHdvcmRzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBpZiAoYWZmRGF0YSkge1xuICAgICAgICAgICAgICAgIHNldHVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAgICAgICBzZWxmLnJ1bGVzID0gc2VsZi5fcGFyc2VBRkYoYWZmRGF0YSk7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBydWxlIGNvZGVzIHRoYXQgYXJlIHVzZWQgaW4gY29tcG91bmQgcnVsZXMuXG4gICAgICAgICAgICBzZWxmLmNvbXBvdW5kUnVsZUNvZGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBfbGVuID0gc2VsZi5jb21wb3VuZFJ1bGVzLmxlbmd0aDsgaSA8IF9sZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gc2VsZi5jb21wb3VuZFJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIF9qbGVuID0gcnVsZS5sZW5ndGg7IGogPCBfamxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG91bmRSdWxlQ29kZXNbcnVsZVtqXV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBhZGQgdGhpcyBPTkxZSU5DT01QT1VORCBmbGFnIHRvIHNlbGYuY29tcG91bmRSdWxlQ29kZXMsIHRoZW4gX3BhcnNlRElDXG4gICAgICAgICAgICAvLyB3aWxsIGRvIHRoZSB3b3JrIG9mIHNhdmluZyB0aGUgbGlzdCBvZiB3b3JkcyB0aGF0IGFyZSBjb21wb3VuZC1vbmx5LlxuICAgICAgICAgICAgaWYgKFwiT05MWUlOQ09NUE9VTkRcIiBpbiBzZWxmLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb3VuZFJ1bGVDb2Rlc1tzZWxmLmZsYWdzLk9OTFlJTkNPTVBPVU5EXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kaWN0aW9uYXJ5VGFibGUgPSBzZWxmLl9wYXJzZURJQyh3b3Jkc0RhdGEpO1xuICAgICAgICAgICAgLy8gR2V0IHJpZCBvZiBhbnkgY29kZXMgZnJvbSB0aGUgY29tcG91bmQgcnVsZSBjb2RlcyB0aGF0IGFyZSBuZXZlciB1c2VkXG4gICAgICAgICAgICAvLyAob3IgdGhhdCB3ZXJlIHNwZWNpYWwgcmVnZXggY2hhcmFjdGVycykuICBOb3QgZXNwZWNpYWxseSBuZWNlc3NhcnkuLi5cbiAgICAgICAgICAgIGZvciAoaSBpbiBzZWxmLmNvbXBvdW5kUnVsZUNvZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29tcG91bmRSdWxlQ29kZXNbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmNvbXBvdW5kUnVsZUNvZGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBmdWxsIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIGVhY2ggY29tcG91bmQgcnVsZS5cbiAgICAgICAgICAgIC8vIEkgaGF2ZSBhIGZlZWxpbmcgKGJ1dCBubyBjb25maXJtYXRpb24geWV0KSB0aGF0IHRoaXMgbWV0aG9kIG9mXG4gICAgICAgICAgICAvLyB0ZXN0aW5nIGZvciBjb21wb3VuZCB3b3JkcyBpcyBwcm9iYWJseSBzbG93LlxuICAgICAgICAgICAgZm9yIChpID0gMCwgX2xlbiA9IHNlbGYuY29tcG91bmRSdWxlcy5sZW5ndGg7IGkgPCBfbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZVRleHQgPSBzZWxmLmNvbXBvdW5kUnVsZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25UZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBfamxlbiA9IHJ1bGVUZXh0Lmxlbmd0aDsgaiA8IF9qbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHJ1bGVUZXh0W2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyIGluIHNlbGYuY29tcG91bmRSdWxlQ29kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UZXh0ICs9IFwiKFwiICsgc2VsZi5jb21wb3VuZFJ1bGVDb2Rlc1tjaGFyYWN0ZXJdLmpvaW4oXCJ8XCIpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uVGV4dCArPSBjaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb3VuZFJ1bGVzW2ldID0gbmV3IFJlZ0V4cCgnXicgKyBleHByZXNzaW9uVGV4dCArICckJywgXCJpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuYXN5bmNMb2FkKSAmJiAoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmxvYWRlZENhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmxvYWRlZENhbGxiYWNrKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHlwby5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkcyBhIFR5cG8gaW5zdGFuY2UgZnJvbSBhIGhhc2ggb2YgYWxsIG9mIHRoZSBUeXBvIHByb3BlcnRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogQSBoYXNoIG9mIFR5cG8gcHJvcGVydGllcywgcHJvYmFibHkgZ290dGVuIGZyb20gYSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHR5cG9faW5zdGFuY2UpKS5cbiAgICAgICAgICovXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZCB0aGUgY29udGVudHMgb2YgYSBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCAocmVsYXRpdmUpIHRvIHRoZSBmaWxlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzZXQ9XCJJU084ODU5LTFcIl0gVGhlIGV4cGVjdGVkIGNoYXJzZXQgb2YgdGhlIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBhc3luYyBJZiB0cnVlLCB0aGUgZmlsZSB3aWxsIGJlIHJlYWQgYXN5bmNocm9ub3VzbHkuIEZvciBub2RlLmpzIHRoaXMgZG9lcyBub3RoaW5nLCBhbGxcbiAgICAgICAgICogICAgICAgIGZpbGVzIGFyZSByZWFkIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmaWxlIGRhdGEgaWYgYXN5bmMgaXMgZmFsc2UsIG90aGVyd2lzZSBhIHByb21pc2Ugb2JqZWN0LiBJZiBydW5uaW5nIG5vZGUuanMsIHRoZSBkYXRhIGlzXG4gICAgICAgICAqICAgICAgICAgIGFsd2F5cyByZXR1cm5lZC5cbiAgICAgICAgICovXG4gICAgICAgIF9yZWFkRmlsZTogZnVuY3Rpb24gKHBhdGgsIGNoYXJzZXQsIGFzeW5jKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjaGFyc2V0ID0gY2hhcnNldCB8fCBcInV0ZjhcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcV8xID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxXzEub3BlbihcIkdFVFwiLCBwYXRoLCAhIWFzeW5jKTtcbiAgICAgICAgICAgICAgICAoX2EgPSByZXFfMS5vdmVycmlkZU1pbWVUeXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZXFfMSwgXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PVwiICsgY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKCEhYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXFfMS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcV8xLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxXzEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXFfMS5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxXzEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxXzEuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxXzEuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXFfMS5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxXzEucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanNcbiAgICAgICAgICAgICAgICB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMocGF0aCwgY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhdGggXCIgKyBwYXRoICsgXCIgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZSB0aGUgcnVsZXMgb3V0IGZyb20gYSAuYWZmIGZpbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBjb250ZW50cyBvZiB0aGUgYWZmaXggZmlsZS5cbiAgICAgICAgICogQHJldHVybnMgb2JqZWN0IFRoZSBydWxlcyBmcm9tIHRoZSBmaWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3BhcnNlQUZGOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0ge307XG4gICAgICAgICAgICB2YXIgbGluZSwgc3VibGluZSwgbnVtRW50cmllcywgbGluZVBhcnRzO1xuICAgICAgICAgICAgdmFyIGksIGosIF9sZW4sIF9qbGVuO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgX2xlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IF9sZW47IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjb21tZW50IGxpbmVzXG4gICAgICAgICAgICAgICAgbGluZSA9IHRoaXMuX3JlbW92ZUFmZml4Q29tbWVudHMobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uUGFydHMgPSBsaW5lLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVUeXBlID0gZGVmaW5pdGlvblBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChydWxlVHlwZSA9PT0gXCJQRlhcIiB8fCBydWxlVHlwZSA9PT0gXCJTRlhcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZUNvZGUgPSBkZWZpbml0aW9uUGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21iaW5lYWJsZSA9IGRlZmluaXRpb25QYXJ0c1syXTtcbiAgICAgICAgICAgICAgICAgICAgbnVtRW50cmllcyA9IHBhcnNlSW50KGRlZmluaXRpb25QYXJ0c1szXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMSwgX2psZW4gPSBpICsgMSArIG51bUVudHJpZXM7IGogPCBfamxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJsaW5lID0gbGluZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lUGFydHMgPSBzdWJsaW5lLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyc1RvUmVtb3ZlID0gbGluZVBhcnRzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uUGFydHMgPSBsaW5lUGFydHNbM10uc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcnNUb0FkZCA9IGFkZGl0aW9uUGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyc1RvQWRkID09PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJzVG9BZGQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbkNsYXNzZXMgPSB0aGlzLnBhcnNlUnVsZUNvZGVzKGFkZGl0aW9uUGFydHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4VG9NYXRjaCA9IGxpbmVQYXJ0c1s0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQ6IGNoYXJhY3RlcnNUb0FkZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250aW51YXRpb25DbGFzc2VzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuY29udGludWF0aW9uQ2xhc3NlcyA9IGNvbnRpbnVhdGlvbkNsYXNzZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhUb01hdGNoICE9PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlVHlwZSA9PT0gXCJTRlhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5tYXRjaCA9IG5ldyBSZWdFeHAocmVnZXhUb01hdGNoICsgXCIkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubWF0Y2ggPSBuZXcgUmVnRXhwKFwiXlwiICsgcmVnZXhUb01hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyc1RvUmVtb3ZlICE9IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVUeXBlID09PSBcIlNGWFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlbW92ZSA9IG5ldyBSZWdFeHAoY2hhcmFjdGVyc1RvUmVtb3ZlICsgXCIkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVtb3ZlID0gY2hhcmFjdGVyc1RvUmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbcnVsZUNvZGVdID0geyBcInR5cGVcIjogcnVsZVR5cGUsIFwiY29tYmluZWFibGVcIjogKGNvbWJpbmVhYmxlID09PSBcIllcIiksIFwiZW50cmllc1wiOiBlbnRyaWVzIH07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gbnVtRW50cmllcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZVR5cGUgPT09IFwiQ09NUE9VTkRSVUxFXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtRW50cmllcyA9IHBhcnNlSW50KGRlZmluaXRpb25QYXJ0c1sxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMSwgX2psZW4gPSBpICsgMSArIG51bUVudHJpZXM7IGogPCBfamxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lUGFydHMgPSBsaW5lLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvdW5kUnVsZXMucHVzaChsaW5lUGFydHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gbnVtRW50cmllcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZVR5cGUgPT09IFwiUkVQXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBhcnRzID0gbGluZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlbWVudFRhYmxlLnB1c2goW2xpbmVQYXJ0c1sxXSwgbGluZVBhcnRzWzJdXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9OTFlJTkNPTVBPVU5EXG4gICAgICAgICAgICAgICAgICAgIC8vIENPTVBPVU5ETUlOXG4gICAgICAgICAgICAgICAgICAgIC8vIEZMQUdcbiAgICAgICAgICAgICAgICAgICAgLy8gS0VFUENBU0VcbiAgICAgICAgICAgICAgICAgICAgLy8gTkVFREFGRklYXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhZ3NbcnVsZVR5cGVdID0gZGVmaW5pdGlvblBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgY29tbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIEEgbGluZSBmcm9tIGFuIGFmZml4IGZpbGUuXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNsZWFuZWQtdXAgbGluZS5cbiAgICAgICAgICovXG4gICAgICAgIF9yZW1vdmVBZmZpeENvbW1lbnRzOiBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgLy8gVGhpcyB1c2VkIHRvIHJlbW92ZSBhbnkgc3RyaW5nIHN0YXJ0aW5nIHdpdGggJyMnIHVwIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUsXG4gICAgICAgICAgICAvLyBidXQgc29tZSBDT01QT1VORFJVTEUgZGVmaW5pdGlvbnMgaW5jbHVkZSAnIycgYXMgcGFydCBvZiB0aGUgcnVsZS5cbiAgICAgICAgICAgIC8vIFNvLCBvbmx5IHJlbW92ZSBsaW5lcyB0aGF0IGJlZ2luIHdpdGggYSBjb21tZW50LCBvcHRpb25hbGx5IHByZWNlZGVkIGJ5IHdoaXRlc3BhY2UuXG4gICAgICAgICAgICBpZiAobGluZS5tYXRjaCgvXlxccyojLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyB0aGUgd29yZHMgb3V0IGZyb20gdGhlIC5kaWMgZmlsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIGRhdGEgZnJvbSB0aGUgZGljdGlvbmFyeSBmaWxlLlxuICAgICAgICAgKiBAcmV0dXJucyBIYXNoTWFwIFRoZSBsb29rdXAgdGFibGUgY29udGFpbmluZyBhbGwgb2YgdGhlIHdvcmRzIGFuZFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgd29yZCBmb3JtcyBmcm9tIHRoZSBkaWN0aW9uYXJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgX3BhcnNlRElDOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX3JlbW92ZURpY0NvbW1lbnRzKGRhdGEpO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICAgICAgdmFyIGRpY3Rpb25hcnlUYWJsZSA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRkV29yZCh3b3JkLCBydWxlcykge1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgZGljdGlvbmFyaWVzIHdpbGwgbGlzdCB0aGUgc2FtZSB3b3JkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IHJ1bGUgc2V0cy5cbiAgICAgICAgICAgICAgICBpZiAoIWRpY3Rpb25hcnlUYWJsZS5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5VGFibGVbd29yZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGljdGlvbmFyeVRhYmxlW3dvcmRdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5VGFibGVbd29yZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5VGFibGVbd29yZF0ucHVzaChydWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGxpbmUgaXMgdGhlIG51bWJlciBvZiB3b3JkcyBpbiB0aGUgZGljdGlvbmFyeS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBfbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGxpbmVzLlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxpbmUgZm9ybWF0IGlzIG9uZSBvZjpcbiAgICAgICAgICAgICAgICAvLyAgICAgd29yZFxuICAgICAgICAgICAgICAgIC8vICAgICB3b3JkL2ZsYWdzXG4gICAgICAgICAgICAgICAgLy8gICAgIHdvcmQvZmxhZ3MgeHg6YWJjIHl5OmRlZlxuICAgICAgICAgICAgICAgIC8vICAgICB3b3JkIHh4OmFiYyB5eTpkZWZcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgdGhlIG1vcnBob2xvZ2ljYWwgZmxhZ3MgKHh4OmFiYywgeXk6ZGVmKSBhbmQgd2UgZG9uJ3Qgd2FudCB0aGVtIGluY2x1ZGVkXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIGV4dHJhY3RlZCBmbGFncy5cbiAgICAgICAgICAgICAgICB2YXIganVzdF93b3JkX2FuZF9mbGFncyA9IGxpbmUucmVwbGFjZSgvXFxzLiokLywgJycpO1xuICAgICAgICAgICAgICAgIC8vIGp1c3Rfd29yZF9hbmRfZmxhZ3MgaXMgZGVmaW5pdGVseSBvbmUgb2Y6XG4gICAgICAgICAgICAgICAgLy8gICAgIHdvcmRcbiAgICAgICAgICAgICAgICAvLyAgICAgd29yZC9mbGFnc1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGp1c3Rfd29yZF9hbmRfZmxhZ3Muc3BsaXQoJy8nLCAyKTtcbiAgICAgICAgICAgICAgICB2YXIgd29yZCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIC8vIE5vdyBmb3IgZWFjaCBhZmZpeCBydWxlLCBnZW5lcmF0ZSB0aGF0IGZvcm0gb2YgdGhlIHdvcmQuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVDb2Rlc0FycmF5ID0gdGhpcy5wYXJzZVJ1bGVDb2RlcyhwYXJ0c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHJ1bGVDb2RlcyBmb3IgY29tcG91bmQgd29yZCBzaXR1YXRpb25zLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShcIk5FRURBRkZJWFwiIGluIHRoaXMuZmxhZ3MpIHx8IHJ1bGVDb2Rlc0FycmF5LmluZGV4T2YodGhpcy5mbGFncy5ORUVEQUZGSVgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkV29yZCh3b3JkLCBydWxlQ29kZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIF9qbGVuID0gcnVsZUNvZGVzQXJyYXkubGVuZ3RoOyBqIDwgX2psZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBydWxlQ29kZXNBcnJheVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlc1tjb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1dvcmRzID0gdGhpcy5fYXBwbHlSdWxlKHdvcmQsIHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgX2lpbGVuID0gbmV3V29yZHMubGVuZ3RoOyBpaSA8IF9paWxlbjsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V29yZCA9IG5ld1dvcmRzW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkV29yZChuZXdXb3JkLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbWJpbmVhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBfamxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVDb2RlID0gcnVsZUNvZGVzQXJyYXlba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVSdWxlID0gdGhpcy5ydWxlc1tjb21iaW5lQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmVSdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5lUnVsZS5jb21iaW5lYWJsZSAmJiAocnVsZS50eXBlICE9IGNvbWJpbmVSdWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJOZXdXb3JkcyA9IHRoaXMuX2FwcGx5UnVsZShuZXdXb3JkLCBjb21iaW5lUnVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaWkgPSAwLCBfaWlpbGVuID0gb3RoZXJOZXdXb3Jkcy5sZW5ndGg7IGlpaSA8IF9paWlsZW47IGlpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyTmV3V29yZCA9IG90aGVyTmV3V29yZHNbaWlpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRXb3JkKG90aGVyTmV3V29yZCwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgaW4gdGhpcy5jb21wb3VuZFJ1bGVDb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG91bmRSdWxlQ29kZXNbY29kZV0ucHVzaCh3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkV29yZCh3b3JkLnRyaW0oKSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWN0aW9uYXJ5VGFibGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGNvbW1lbnQgbGluZXMgYW5kIHRoZW4gY2xlYW5zIHVwIGJsYW5rIGxpbmVzIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBUaGUgZGF0YSBmcm9tIGEgLmRpYyBmaWxlLlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjbGVhbmVkLXVwIGRhdGEuXG4gICAgICAgICAqL1xuICAgICAgICBfcmVtb3ZlRGljQ29tbWVudHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBJIGNhbid0IGZpbmQgYW55IG9mZmljaWFsIGRvY3VtZW50YXRpb24gb24gaXQsIGJ1dCBhdCBsZWFzdCB0aGUgZGVfREVcbiAgICAgICAgICAgIC8vIGRpY3Rpb25hcnkgdXNlcyB0YWItaW5kZW50ZWQgbGluZXMgYXMgY29tbWVudHMuXG4gICAgICAgICAgICAvLyBSZW1vdmUgY29tbWVudHNcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoL15cXHQuKiQvbWcsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlUnVsZUNvZGVzOiBmdW5jdGlvbiAodGV4dENvZGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRleHRDb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEoXCJGTEFHXCIgaW4gdGhpcy5mbGFncykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmxhZyBzeW1ib2xzIGFyZSBzaW5nbGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0Q29kZXMuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzLkZMQUcgPT09IFwibG9uZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZsYWcgc3ltYm9scyBhcmUgdHdvIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgX2xlbiA9IHRleHRDb2Rlcy5sZW5ndGg7IGkgPCBfbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MucHVzaCh0ZXh0Q29kZXMuc3Vic3RyKGksIDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncy5GTEFHID09PSBcIm51bVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZsYWcgc3ltYm9scyBhcmUgYSBDU1YgbGlzdCBvZiBudW1iZXJzLlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0Q29kZXMuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncy5GTEFHID09PSBcIlVURi04XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmxhZ3MgYXJlIHNpbmdsZSBVVEYtOCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NmaW5rZS9UeXBvLmpzL2lzc3Vlcy81N1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRleHRDb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBmYWxsYmFjayBjYXNlIHdpbGwgbm90IHdvcmsgZm9yIGFsbCBGTEFHIHZhbHVlcyxcbiAgICAgICAgICAgICAgICAvLyBidXQgSSB0aGluayBpdCdzIG1vcmUgbGlrZWx5IHRvIHdvcmsgdGhhbiBub3QgcmV0dXJuaW5nIGFueXRoaW5nIGF0IGFsbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dENvZGVzLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhbiBhZmZpeCBydWxlIHRvIGEgd29yZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdvcmQgVGhlIGJhc2Ugd29yZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJ1bGUgVGhlIGFmZml4IHJ1bGUuXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIG5ldyB3b3JkcyBnZW5lcmF0ZWQgYnkgdGhlIHJ1bGUuXG4gICAgICAgICAqL1xuICAgICAgICBfYXBwbHlSdWxlOiBmdW5jdGlvbiAod29yZCwgcnVsZSkge1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBydWxlLmVudHJpZXM7XG4gICAgICAgICAgICB2YXIgbmV3V29yZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBfbGVuID0gZW50cmllcy5sZW5ndGg7IGkgPCBfbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkubWF0Y2ggfHwgd29yZC5tYXRjaChlbnRyeS5tYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1dvcmQgPSB3b3JkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdXb3JkID0gbmV3V29yZC5yZXBsYWNlKGVudHJ5LnJlbW92ZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gXCJTRlhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3V29yZCA9IG5ld1dvcmQgKyBlbnRyeS5hZGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdXb3JkID0gZW50cnkuYWRkICsgbmV3V29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdXb3Jkcy5wdXNoKG5ld1dvcmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJjb250aW51YXRpb25DbGFzc2VzXCIgaW4gZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBfamxlbiA9IGVudHJ5LmNvbnRpbnVhdGlvbkNsYXNzZXMubGVuZ3RoOyBqIDwgX2psZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250aW51YXRpb25SdWxlID0gdGhpcy5ydWxlc1tlbnRyeS5jb250aW51YXRpb25DbGFzc2VzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGludWF0aW9uUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdXb3JkcyA9IG5ld1dvcmRzLmNvbmNhdCh0aGlzLl9hcHBseVJ1bGUobmV3V29yZCwgY29udGludWF0aW9uUnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBpdCBkb2VzLCBhdCBsZWFzdCBpbiB0aGUgZGVfREUgZGljdGlvbmFyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGUgYXV0aG9yIG1pc3Rha2VubHkgc3VwcGxpZWQgbG93ZXItY2FzZSBydWxlIGNvZGVzIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdXBwZXItY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdXb3JkcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIGEgd29yZCBvciBhIGNhcGl0YWxpemF0aW9uIHZhcmlhbnQgZXhpc3RzIGluIHRoZSBjdXJyZW50IGRpY3Rpb25hcnkuXG4gICAgICAgICAqIFRoZSB3b3JkIGlzIHRyaW1tZWQgYW5kIHNldmVyYWwgdmFyaWF0aW9ucyBvZiBjYXBpdGFsaXphdGlvbnMgYXJlIGNoZWNrZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIGNoZWNrIGEgd29yZCB3aXRob3V0IGFueSBjaGFuZ2VzIG1hZGUgdG8gaXQsIGNhbGwgY2hlY2tFeGFjdCgpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHQgcmU6dHJpbW1pbmcgZnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFXb3JkIFRoZSB3b3JkIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYVdvcmQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkRpY3Rpb25hcnkgbm90IGxvYWRlZC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYVdvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdmFyIHRyaW1tZWRXb3JkID0gYVdvcmQucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4YWN0KHRyaW1tZWRXb3JkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGV4YWN0IHdvcmQgaXMgbm90IGluIHRoZSBkaWN0aW9uYXJ5LlxuICAgICAgICAgICAgaWYgKHRyaW1tZWRXb3JkLnRvVXBwZXJDYXNlKCkgPT09IHRyaW1tZWRXb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHdvcmQgd2FzIHN1cHBsaWVkIGluIGFsbCB1cHBlcmNhc2UuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgY2FwaXRhbGl6ZWQgZm9ybSBvZiB0aGUgd29yZC5cbiAgICAgICAgICAgICAgICB2YXIgY2FwaXRhbGl6ZWRXb3JkID0gdHJpbW1lZFdvcmRbMF0gKyB0cmltbWVkV29yZC5zdWJzdHJpbmcoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGNhcGl0YWxpemVkV29yZCwgXCJLRUVQQ0FTRVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXBpdGFsaXphdGlvbiB2YXJpYW50cyBhcmUgbm90IGFsbG93ZWQgZm9yIHRoaXMgd29yZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4YWN0KGNhcGl0YWxpemVkV29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFsbC1jYXBzIHdvcmQgaXMgYSBjYXBpdGFsaXplZCB3b3JkIHNwZWxsZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tFeGFjdCh0cmltbWVkV29yZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYWxsLWNhcHMgaXMgYSBsb3dlcmNhc2Ugd29yZCBzcGVsbGVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVuY2FwaXRhbGl6ZWRXb3JkID0gdHJpbW1lZFdvcmRbMF0udG9Mb3dlckNhc2UoKSArIHRyaW1tZWRXb3JkLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmICh1bmNhcGl0YWxpemVkV29yZCAhPT0gdHJpbW1lZFdvcmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKHVuY2FwaXRhbGl6ZWRXb3JkLCBcIktFRVBDQVNFXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhcGl0YWxpemF0aW9uIHZhcmlhbnRzIGFyZSBub3QgYWxsb3dlZCBmb3IgdGhpcyB3b3JkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbiB1bmNhcGl0YWxpemVkIGZvcm1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4YWN0KHVuY2FwaXRhbGl6ZWRXb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd29yZCBpcyBzcGVsbGVkIGNvcnJlY3RseSBidXQgd2l0aCB0aGUgZmlyc3QgbGV0dGVyIGNhcGl0YWxpemVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBhIHdvcmQgZXhpc3RzIGluIHRoZSBjdXJyZW50IGRpY3Rpb25hcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkIFRoZSB3b3JkIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrRXhhY3Q6IGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEaWN0aW9uYXJ5IG5vdCBsb2FkZWQuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcnVsZUNvZGVzID0gdGhpcy5kaWN0aW9uYXJ5VGFibGVbd29yZF07XG4gICAgICAgICAgICB2YXIgaSwgX2xlbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZUNvZGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgbWlnaHQgYmUgYSBjb21wb3VuZCB3b3JkLlxuICAgICAgICAgICAgICAgIGlmIChcIkNPTVBPVU5ETUlOXCIgaW4gdGhpcy5mbGFncyAmJiB3b3JkLmxlbmd0aCA+PSB0aGlzLmZsYWdzLkNPTVBPVU5ETUlOKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIF9sZW4gPSB0aGlzLmNvbXBvdW5kUnVsZXMubGVuZ3RoOyBpIDwgX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29yZC5tYXRjaCh0aGlzLmNvbXBvdW5kUnVsZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlQ29kZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBhIG51bGwgKGJ1dCBub3QgdW5kZWZpbmVkKSB2YWx1ZSBmb3IgYW4gZW50cnkgaW4gdGhlIGRpY3Rpb25hcnkgdGFibGVcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB0aGF0IHRoZSB3b3JkIGlzIGluIHRoZSBkaWN0aW9uYXJ5IGJ1dCBoYXMgbm8gZmxhZ3MuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZUNvZGVzID09PSAnb2JqZWN0JykgeyAvLyB0aGlzLmRpY3Rpb25hcnlbJ2hhc093blByb3BlcnR5J10gd2lsbCBiZSBhIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIF9sZW4gPSBydWxlQ29kZXMubGVuZ3RoOyBpIDwgX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNGbGFnKHdvcmQsIFwiT05MWUlOQ09NUE9VTkRcIiwgcnVsZUNvZGVzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29rcyB1cCB3aGV0aGVyIGEgZ2l2ZW4gd29yZCBpcyBmbGFnZ2VkIHdpdGggYSBnaXZlbiBmbGFnLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd29yZCBUaGUgd29yZCBpbiBxdWVzdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZsYWcgVGhlIGZsYWcgaW4gcXVlc3Rpb24uXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXNGbGFnOiBmdW5jdGlvbiAod29yZCwgZmxhZywgd29yZEZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEaWN0aW9uYXJ5IG5vdCBsb2FkZWQuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZyBpbiB0aGlzLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3b3JkRmxhZ3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRGbGFncyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRoaXMuZGljdGlvbmFyeVRhYmxlW3dvcmRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdvcmRGbGFncyAmJiB3b3JkRmxhZ3MuaW5kZXhPZih0aGlzLmZsYWdzW2ZsYWddKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMgZm9yIGEgbWlzc3BlbGxlZCB3b3JkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly93d3cubm9ydmlnLmNvbS9zcGVsbC1jb3JyZWN0Lmh0bWwgZm9yIHRoZSBiYXNpcyBvZiB0aGlzIHN1Z2dlc3Rvci5cbiAgICAgICAgICogVGhpcyBzdWdnZXN0b3IgaXMgcHJpbWl0aXZlLCBidXQgaXQgd29ya3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkIFRoZSBtaXNzcGVsbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdD01XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3VnZ2VzdGlvbnMgdG8gcmV0dXJuLlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBhcnJheSBvZiBzdWdnZXN0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIGFscGhhYmV0OiBcIlwiLFxuICAgICAgICBzdWdnZXN0OiBmdW5jdGlvbiAod29yZCwgbGltaXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkRpY3Rpb25hcnkgbm90IGxvYWRlZC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgfHwgNTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lbW9pemVkLmhhc093blByb3BlcnR5KHdvcmQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lbW9pemVkTGltaXQgPSB0aGlzLm1lbW9pemVkW3dvcmRdWydsaW1pdCddO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmV0dXJuIHRoZSBjYWNoZWQgbGlzdCBpZiBpdCdzIGJpZyBlbm91Z2ggb3IgaWYgdGhlcmUgd2VyZW4ndCBlbm91Z2ggc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB0byBmaWxsIGEgc21hbGxlciBsaW1pdC5cbiAgICAgICAgICAgICAgICBpZiAobGltaXQgPD0gbWVtb2l6ZWRMaW1pdCB8fCB0aGlzLm1lbW9pemVkW3dvcmRdWydzdWdnZXN0aW9ucyddLmxlbmd0aCA8IG1lbW9pemVkTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVtb2l6ZWRbd29yZF1bJ3N1Z2dlc3Rpb25zJ10uc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrKHdvcmQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSByZXBsYWNlbWVudCB0YWJsZS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBfbGVuID0gdGhpcy5yZXBsYWNlbWVudFRhYmxlLmxlbmd0aDsgaSA8IF9sZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudEVudHJ5ID0gdGhpcy5yZXBsYWNlbWVudFRhYmxlW2ldO1xuICAgICAgICAgICAgICAgIGlmICh3b3JkLmluZGV4T2YocmVwbGFjZW1lbnRFbnRyeVswXSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRXb3JkID0gd29yZC5yZXBsYWNlKHJlcGxhY2VtZW50RW50cnlbMF0sIHJlcGxhY2VtZW50RW50cnlbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVjayhjb3JyZWN0ZWRXb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjb3JyZWN0ZWRXb3JkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5hbHBoYWJldCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgRW5nbGlzaCBhbHBoYWJldCBhcyB0aGUgZGVmYXVsdC4gUHJvYmxlbWF0aWMsIGJ1dCBiYWNrd2FyZHMtY29tcGF0aWJsZS5cbiAgICAgICAgICAgICAgICB0aGlzLmFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonO1xuICAgICAgICAgICAgICAgIC8vIEFueSBjaGFyYWN0ZXJzIGRlZmluZWQgaW4gdGhlIGFmZml4IGZpbGUgYXMgc3Vic3RpdHV0aW9ucyBjYW4gZ28gaW4gdGhlIGFscGhhYmV0IHRvby5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgZGljdGlvbmFyaWVzIGRvIG5vdCBpbmNsdWRlIHRoZSBlbnRpcmUgYWxwaGFiZXQgaW4gdGhlIFRSWSBmbGFnIHdoZW4gaXQncyB0aGVyZS5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgUSBpcyBub3QgaW4gdGhlIGRlZmF1bHQgRW5nbGlzaCBUUlkgbGlzdDsgdGhhdCdzIHdoeSBoYXZpbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyBhbHBoYWJldCBhYm92ZSBpcyB1c2VmdWwuXG4gICAgICAgICAgICAgICAgaWYgKCdUUlknIGluIHRoaXMuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbHBoYWJldCArPSB0aGlzLmZsYWdzWydUUlknXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGx1cyBhbnkgYWRkaXRpb25hbCBjaGFyYWN0ZXJzIHNwZWNpZmljYWxseSBkZWZpbmVkIGFzIGJlaW5nIGFsbG93ZWQgaW4gd29yZHMuXG4gICAgICAgICAgICAgICAgaWYgKCdXT1JEQ0hBUlMnIGluIHRoaXMuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbHBoYWJldCArPSB0aGlzLmZsYWdzWydXT1JEQ0hBUlMnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgICAgIHZhciBhbHBoYUFycmF5ID0gdGhpcy5hbHBoYWJldC5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICBhbHBoYUFycmF5LnNvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGFIYXNoID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbHBoYUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhSGFzaFthbHBoYUFycmF5W2ldXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGFiZXQgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGFscGhhSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFscGhhYmV0ICs9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgaGFzaCBrZXllZCBieSBhbGwgb2YgdGhlIHN0cmluZ3MgdGhhdCBjYW4gYmUgbWFkZSBieSBtYWtpbmcgYSBzaW5nbGUgZWRpdCB0byB0aGUgd29yZCAob3Igd29yZHMgaW4pIGB3b3Jkc2BcbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiBlYWNoIGVudHJ5IGlzIHRoZSBudW1iZXIgb2YgdW5pcXVlIHdheXMgdGhhdCB0aGUgcmVzdWx0aW5nIHdvcmQgY2FuIGJlIG1hZGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGFyZyBIYXNoTWFwIHdvcmRzIEEgaGFzaCBrZXllZCBieSB3b3JkcyAoYWxsIHdpdGggdGhlIHZhbHVlIGB0cnVlYCB0byBtYWtlIGxvb2t1cHMgdmVyeSBxdWljaykuXG4gICAgICAgICAgICAgKiBAYXJnIGJvb2xlYW4ga25vd25fb25seSBXaGV0aGVyIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGlnbm9yZSBzdHJpbmdzIHRoYXQgYXJlIG5vdCBpbiB0aGUgZGljdGlvbmFyeS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZWRpdHMxKHdvcmRzLCBrbm93bl9vbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGksIGosIF9paWxlbiwgX2xlbiwgX2psZW4sIF9lZGl0O1xuICAgICAgICAgICAgICAgIHZhciBhbHBoYWJldExlbmd0aCA9IHNlbGYuYWxwaGFiZXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHdvcmRfMSBpbiB3b3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBfbGVuID0gd29yZF8xLmxlbmd0aCArIDE7IGkgPCBfbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gW3dvcmRfMS5zdWJzdHJpbmcoMCwgaSksIHdvcmRfMS5zdWJzdHJpbmcoaSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGEgbGV0dGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZWRpdCA9IHNbMF0gKyBzWzFdLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtub3duX29ubHkgfHwgc2VsZi5jaGVjayhfZWRpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2VkaXQgaW4gcnYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydltfZWRpdF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnZbX2VkaXRdICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc3Bvc2UgbGV0dGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxpbWluYXRlIHRyYW5zcG9zaXRpb25zIG9mIGlkZW50aWNhbCBsZXR0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc1sxXS5sZW5ndGggPiAxICYmIHNbMV1bMV0gIT09IHNbMV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZWRpdCA9IHNbMF0gKyBzWzFdWzFdICsgc1sxXVswXSArIHNbMV0uc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha25vd25fb25seSB8fCBzZWxmLmNoZWNrKF9lZGl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZWRpdCBpbiBydikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2W19lZGl0XSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydltfZWRpdF0gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhIGxldHRlciB3aXRoIGFub3RoZXIgbGV0dGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXR0ZXJjYXNlID0gKHNbMV0uc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgPT09IHNbMV0uc3Vic3RyaW5nKDAsIDEpKSA/ICd1cHBlcmNhc2UnIDogJ2xvd2VyY2FzZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFscGhhYmV0TGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50TGV0dGVyID0gc2VsZi5hbHBoYWJldFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBjYXNlIG9mIHRoZSByZXBsYWNlbWVudCBsZXR0ZXIgdG8gdGhlIHNhbWUgYXMgdGhlIGxldHRlciBiZWluZyByZXBsYWNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCd1cHBlcmNhc2UnID09PSBsZXR0ZXJjYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudExldHRlciA9IHJlcGxhY2VtZW50TGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxpbWluYXRlIHJlcGxhY2VtZW50IG9mIGEgbGV0dGVyIGJ5IGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRMZXR0ZXIgIT0gc1sxXS5zdWJzdHJpbmcoMCwgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lZGl0ID0gc1swXSArIHJlcGxhY2VtZW50TGV0dGVyICsgc1sxXS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtub3duX29ubHkgfHwgc2VsZi5jaGVjayhfZWRpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZWRpdCBpbiBydikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnZbX2VkaXRdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2W19lZGl0XSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgbGV0dGVyIGJldHdlZW4gZWFjaCBsZXR0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFscGhhYmV0TGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxldHRlcnMgb24gZWFjaCBzaWRlIGFyZSBjYXBpdGFsaXplZCwgY2FwaXRhbGl6ZSB0aGUgcmVwbGFjZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXR0ZXJjYXNlID0gKHNbMF0uc3Vic3RyaW5nKC0xKS50b1VwcGVyQ2FzZSgpID09PSBzWzBdLnN1YnN0cmluZygtMSkgJiYgc1sxXS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSA9PT0gc1sxXS5zdWJzdHJpbmcoMCwgMSkpID8gJ3VwcGVyY2FzZScgOiAnbG93ZXJjYXNlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50TGV0dGVyID0gc2VsZi5hbHBoYWJldFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCd1cHBlcmNhc2UnID09PSBsZXR0ZXJjYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudExldHRlciA9IHJlcGxhY2VtZW50TGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2VkaXQgPSBzWzBdICsgcmVwbGFjZW1lbnRMZXR0ZXIgKyBzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtub3duX29ubHkgfHwgc2VsZi5jaGVjayhfZWRpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9lZGl0IGluIHJ2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2W19lZGl0XSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydltfZWRpdF0gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjb3JyZWN0KHdvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBlZGl0LWRpc3RhbmNlLTEgYW5kIGVkaXQtZGlzdGFuY2UtMiBmb3JtcyBvZiB0aGlzIHdvcmQuXG4gICAgICAgICAgICAgICAgdmFyIGVkMSA9IGVkaXRzMSgoX2EgPSB7fSwgX2Fbd29yZF0gPSB0cnVlLCBfYSkpO1xuICAgICAgICAgICAgICAgIHZhciBlZDIgPSBlZGl0czEoZWQxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IHRoZSBlZGl0cyBiYXNlZCBvbiBob3cgbWFueSBkaWZmZXJlbnQgd2F5cyB0aGV5IHdlcmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ZWRfY29ycmVjdGlvbnMgPSBlZDI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZWQxd29yZCBpbiBlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNoZWNrKGVkMXdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWQxd29yZCBpbiB3ZWlnaHRlZF9jb3JyZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ZWRfY29ycmVjdGlvbnNbZWQxd29yZF0gKz0gZWQxW2VkMXdvcmRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ZWRfY29ycmVjdGlvbnNbZWQxd29yZF0gPSBlZDFbZWQxd29yZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGksIF9sZW47XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRlZF9jb3JyZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiB3ZWlnaHRlZF9jb3JyZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0ZWRfY29ycmVjdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0ZsYWcoaSwgXCJQUklPUklUWVNVR0dFU1RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBkZWZpbmVkIGEgbmV3IGFmZml4IHJ1bGUgY2FsbGVkIFBSSU9SSVRZU1VHR0VTVCwgaW5kaWNhdGluZyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyB3b3JkIGlzIGluIHRoZSBzdWdnZXN0aW9ucyBsaXN0IGZvciBhIG1pc3NwZWxsZWQgd29yZCwgaXQgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgZ2l2ZW4gcHJpb3JpdHkgb3ZlciBvdGhlciBzdWdnZXN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIGxhcmdlIG51bWJlciB0byBpdHMgd2VpZ2h0IHRvIHB1c2ggaXQgdG8gdGhlIHRvcCBvZiB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBtdWx0aXBsZSBwcmlvcml0eSBzdWdnZXN0aW9ucyBhcmUgaW4gdGhlIGxpc3QsIHRoZXknbGwgc3RpbGwgYmUgcmFua2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWdhaW5zdCBlYWNoIG90aGVyLCBidXQgdGhleSdsbCBhbGwgYmUgYWJvdmUgbm9uLXByaW9yaXR5IHN1Z2dlc3Rpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodGVkX2NvcnJlY3Rpb25zW2ldICs9IDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRfY29ycmVjdGlvbnMucHVzaChbaSwgd2VpZ2h0ZWRfY29ycmVjdGlvbnNbaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYV92YWwgPSBhWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYl92YWwgPSBiWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYV92YWwgPCBiX3ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFfdmFsID4gYl92YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIElmIGEgYW5kIGIgYXJlIGVxdWFsbHkgd2VpZ2h0ZWQsIGFkZCBvdXIgb3duIHdlaWdodCBiYXNlZCBvbiBzb21ldGhpbmcgbGlrZSB0aGUga2V5IGxvY2F0aW9ucyBvbiB0aGlzIGxhbmd1YWdlJ3MgZGVmYXVsdCBrZXlib2FyZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJbMF0ubG9jYWxlQ29tcGFyZShhWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ydGVkX2NvcnJlY3Rpb25zLnNvcnQoc29ydGVyKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNhcGl0YWxpemF0aW9uX3NjaGVtZSA9IFwibG93ZXJjYXNlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmQudG9VcHBlckNhc2UoKSA9PT0gd29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpdGFsaXphdGlvbl9zY2hlbWUgPSBcInVwcGVyY2FzZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3b3JkLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKSA9PT0gd29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpdGFsaXphdGlvbl9zY2hlbWUgPSBcImNhcGl0YWxpemVkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB3b3JraW5nX2xpbWl0ID0gbGltaXQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IE1hdGgubWluKHdvcmtpbmdfbGltaXQsIHNvcnRlZF9jb3JyZWN0aW9ucy5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidXBwZXJjYXNlXCIgPT09IGNhcGl0YWxpemF0aW9uX3NjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkX2NvcnJlY3Rpb25zW2ldWzBdID0gc29ydGVkX2NvcnJlY3Rpb25zW2ldWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJjYXBpdGFsaXplZFwiID09PSBjYXBpdGFsaXphdGlvbl9zY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZF9jb3JyZWN0aW9uc1tpXVswXSA9IHNvcnRlZF9jb3JyZWN0aW9uc1tpXVswXS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHNvcnRlZF9jb3JyZWN0aW9uc1tpXVswXS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmhhc0ZsYWcoc29ydGVkX2NvcnJlY3Rpb25zW2ldWzBdLCBcIk5PU1VHR0VTVFwiKSAmJiBydi5pbmRleE9mKHNvcnRlZF9jb3JyZWN0aW9uc1tpXVswXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydi5wdXNoKHNvcnRlZF9jb3JyZWN0aW9uc1tpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvbmUgb2YgdGhlIGNvcnJlY3Rpb25zIGlzIG5vdCBlbGlnaWJsZSBhcyBhIHN1Z2dlc3Rpb24gLCBtYWtlIHN1cmUgd2Ugc3RpbGwgcmV0dXJuIHRoZSByaWdodCBudW1iZXIgb2Ygc3VnZ2VzdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nX2xpbWl0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZW1vaXplZFt3b3JkXSA9IHtcbiAgICAgICAgICAgICAgICAnc3VnZ2VzdGlvbnMnOiBjb3JyZWN0KHdvcmQpLFxuICAgICAgICAgICAgICAgICdsaW1pdCc6IGxpbWl0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVtb2l6ZWRbd29yZF1bJ3N1Z2dlc3Rpb25zJ107XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbi8vIFN1cHBvcnQgZm9yIHVzZSBhcyBhIG5vZGUuanMgbW9kdWxlLlxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUeXBvO1xufVxuIl0sIm5hbWVzIjpbIlR5cG8iLCJkaWN0aW9uYXJ5IiwiYWZmRGF0YSIsIndvcmRzRGF0YSIsInNldHRpbmdzIiwicnVsZXMiLCJkaWN0aW9uYXJ5VGFibGUiLCJjb21wb3VuZFJ1bGVzIiwiY29tcG91bmRSdWxlQ29kZXMiLCJyZXBsYWNlbWVudFRhYmxlIiwiZmxhZ3MiLCJtZW1vaXplZCIsImxvYWRlZCIsInNlbGYiLCJwYXRoIiwiaSIsImoiLCJfbGVuIiwiX2psZW4iLCJzZXR1cCIsIndpbmRvdyIsImNocm9tZSIsInJ1bnRpbWUiLCJicm93c2VyIiwiZGljdGlvbmFyeVBhdGgiLCJyZWFkRGF0YUZpbGUiLCJnZXRVUkwiLCJzZXRBZmZEYXRhIiwic2V0V29yZHNEYXRhIiwiX19kaXJuYW1lIiwidXJsIiwic2V0RnVuYyIsInJlc3BvbnNlIiwiX3JlYWRGaWxlIiwiYXN5bmNMb2FkIiwidGhlbiIsImRhdGEiLCJfcGFyc2VBRkYiLCJsZW5ndGgiLCJydWxlIiwiT05MWUlOQ09NUE9VTkQiLCJfcGFyc2VESUMiLCJydWxlVGV4dCIsImV4cHJlc3Npb25UZXh0IiwiY2hhcmFjdGVyIiwiam9pbiIsIlJlZ0V4cCIsImxvYWRlZENhbGxiYWNrIiwicHJvdG90eXBlIiwibG9hZCIsIm9iaiIsImhhc093blByb3BlcnR5IiwiY2hhcnNldCIsImFzeW5jIiwiX2EiLCJYTUxIdHRwUmVxdWVzdCIsInJlcV8xIiwib3BlbiIsIm92ZXJyaWRlTWltZVR5cGUiLCJjYWxsIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJzZW5kIiwicmVxdWlyZSIsImZzIiwiZXhpc3RzU3luYyIsInJlYWRGaWxlU3luYyIsImNvbnNvbGUiLCJsb2ciLCJlIiwibGluZSIsInN1YmxpbmUiLCJudW1FbnRyaWVzIiwibGluZVBhcnRzIiwibGluZXMiLCJzcGxpdCIsIl9yZW1vdmVBZmZpeENvbW1lbnRzIiwidHJpbSIsImRlZmluaXRpb25QYXJ0cyIsInJ1bGVUeXBlIiwicnVsZUNvZGUiLCJjb21iaW5lYWJsZSIsInBhcnNlSW50IiwiZW50cmllcyIsImNoYXJhY3RlcnNUb1JlbW92ZSIsImFkZGl0aW9uUGFydHMiLCJjaGFyYWN0ZXJzVG9BZGQiLCJjb250aW51YXRpb25DbGFzc2VzIiwicGFyc2VSdWxlQ29kZXMiLCJyZWdleFRvTWF0Y2giLCJlbnRyeSIsImFkZCIsIm1hdGNoIiwicmVtb3ZlIiwicHVzaCIsIl9yZW1vdmVEaWNDb21tZW50cyIsImFkZFdvcmQiLCJ3b3JkIiwianVzdF93b3JkX2FuZF9mbGFncyIsInJlcGxhY2UiLCJwYXJ0cyIsInJ1bGVDb2Rlc0FycmF5IiwiaW5kZXhPZiIsIk5FRURBRkZJWCIsImNvZGUiLCJuZXdXb3JkcyIsIl9hcHBseVJ1bGUiLCJpaSIsIl9paWxlbiIsIm5ld1dvcmQiLCJrIiwiY29tYmluZUNvZGUiLCJjb21iaW5lUnVsZSIsInR5cGUiLCJvdGhlck5ld1dvcmRzIiwiaWlpIiwiX2lpaWxlbiIsIm90aGVyTmV3V29yZCIsInRleHRDb2RlcyIsIkZMQUciLCJzdWJzdHIiLCJBcnJheSIsImZyb20iLCJjb250aW51YXRpb25SdWxlIiwiY29uY2F0IiwiY2hlY2siLCJhV29yZCIsInRyaW1tZWRXb3JkIiwiY2hlY2tFeGFjdCIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZWRXb3JkIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJoYXNGbGFnIiwidW5jYXBpdGFsaXplZFdvcmQiLCJydWxlQ29kZXMiLCJDT01QT1VORE1JTiIsImZsYWciLCJ3b3JkRmxhZ3MiLCJhcHBseSIsImFscGhhYmV0Iiwic3VnZ2VzdCIsImxpbWl0IiwibWVtb2l6ZWRMaW1pdCIsInNsaWNlIiwicmVwbGFjZW1lbnRFbnRyeSIsImNvcnJlY3RlZFdvcmQiLCJhbHBoYUFycmF5Iiwic29ydCIsImFscGhhSGFzaCIsImVkaXRzMSIsIndvcmRzIiwia25vd25fb25seSIsInJ2IiwiX2VkaXQiLCJhbHBoYWJldExlbmd0aCIsIndvcmRfMSIsInMiLCJsZXR0ZXJjYXNlIiwicmVwbGFjZW1lbnRMZXR0ZXIiLCJjb3JyZWN0IiwiZWQxIiwiZWQyIiwid2VpZ2h0ZWRfY29ycmVjdGlvbnMiLCJlZDF3b3JkIiwic29ydGVkX2NvcnJlY3Rpb25zIiwic29ydGVyIiwiYSIsImIiLCJhX3ZhbCIsImJfdmFsIiwibG9jYWxlQ29tcGFyZSIsInJldmVyc2UiLCJjYXBpdGFsaXphdGlvbl9zY2hlbWUiLCJ3b3JraW5nX2xpbWl0IiwiTWF0aCIsIm1pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/typo-js/typo.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/marked/lib/marked.cjs":
/*!********************************************!*\
  !*** ./node_modules/marked/lib/marked.cjs ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * marked v4.3.0 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ \nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction getDefaults() {\n    return {\n        async: false,\n        baseUrl: null,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: \"\",\n        highlight: null,\n        hooks: null,\n        langPrefix: \"language-\",\n        mangle: true,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n    };\n}\nexports.defaults = getDefaults();\nfunction changeDefaults(newDefaults) {\n    exports.defaults = newDefaults;\n}\n/**\n * Helpers\n */ var escapeTest = /[&<>\"']/;\nvar escapeReplace = new RegExp(escapeTest.source, \"g\");\nvar escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nvar escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nvar escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nvar getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n};\nfunction escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nvar unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n/**\n * @param {string} html\n */ function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function(_, n) {\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nvar caret = /(^|[^\\[])\\^/g;\n/**\n * @param {string | RegExp} regex\n * @param {string} opt\n */ function edit(regex, opt) {\n    regex = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    var obj = {\n        replace: function replace(name, val) {\n            val = val.source || val;\n            val = val.replace(caret, \"$1\");\n            regex = regex.replace(name, val);\n            return obj;\n        },\n        getRegex: function getRegex() {\n            return new RegExp(regex, opt);\n        }\n    };\n    return obj;\n}\nvar nonWordAndColonTest = /[^\\w:]/g;\nvar originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n/**\n * @param {boolean} sanitize\n * @param {string} base\n * @param {string} href\n */ function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n        var prot;\n        try {\n            prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, \"\").toLowerCase();\n        } catch (e) {\n            return null;\n        }\n        if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n            return null;\n        }\n    }\n    if (base && !originIndependentUrl.test(href)) {\n        href = resolveUrl(base, href);\n    }\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nvar baseUrls = {};\nvar justDomain = /^[^:]+:\\/*[^/]*$/;\nvar protocol = /^([^:]+:)[\\s\\S]*$/;\nvar domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n/**\n * @param {string} base\n * @param {string} href\n */ function resolveUrl(base, href) {\n    if (!baseUrls[\" \" + base]) {\n        // we can ignore everything in base after the last slash of its path component,\n        // but we might need to add _that_\n        // https://tools.ietf.org/html/rfc3986#section-3\n        if (justDomain.test(base)) {\n            baseUrls[\" \" + base] = base + \"/\";\n        } else {\n            baseUrls[\" \" + base] = rtrim(base, \"/\", true);\n        }\n    }\n    base = baseUrls[\" \" + base];\n    var relativeBase = base.indexOf(\":\") === -1;\n    if (href.substring(0, 2) === \"//\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(protocol, \"$1\") + href;\n    } else if (href.charAt(0) === \"/\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(domain, \"$1\") + href;\n    } else {\n        return base + href;\n    }\n}\nvar noopTest = {\n    exec: function noopTest() {}\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function(match, offset, str) {\n        var escaped = false, curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\"){\n            escaped = !escaped;\n        }\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    var i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (cells.length > count) {\n        cells.splice(count);\n    } else {\n        while(cells.length < count){\n            cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param {string} str\n * @param {string} c\n * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    var l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    var suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        var currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    var l = str.length;\n    var level = 0, i = 0;\n    for(; i < l; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n        console.warn(\"marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options\");\n    }\n}\n// copied from https://stackoverflow.com/a/5450113/806777\n/**\n * @param {string} pattern\n * @param {number} count\n */ function repeatString(pattern, count) {\n    if (count < 1) {\n        return \"\";\n    }\n    var result = \"\";\n    while(count > 1){\n        if (count & 1) {\n            result += pattern;\n        }\n        count >>= 1;\n        pattern += pattern;\n    }\n    return result + pattern;\n}\nfunction outputLink(cap, link, raw, lexer) {\n    var href = link.href;\n    var title = link.title ? escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        var token = {\n            type: \"link\",\n            raw: raw,\n            href: href,\n            title: title,\n            text: text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw: raw,\n        href: href,\n        title: title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    var indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map(function(node) {\n        var matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        var indentInNode = matchIndentInNode[0];\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ var Tokenizer = /*#__PURE__*/ function() {\n    function Tokenizer(options) {\n        this.options = options || exports.defaults;\n    }\n    var _proto = Tokenizer.prototype;\n    _proto.space = function space(src) {\n        var cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    };\n    _proto.code = function code(src) {\n        var cap = this.rules.block.code.exec(src);\n        if (cap) {\n            var text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    };\n    _proto.fences = function fences(src) {\n        var cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            var raw = cap[0];\n            var text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw: raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, \"$1\") : cap[2],\n                text: text\n            };\n        }\n    };\n    _proto.heading = function heading(src) {\n        var cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            var text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                var trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text: text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    };\n    _proto.hr = function hr(src) {\n        var cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    };\n    _proto.blockquote = function blockquote(src) {\n        var cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            var text = cap[0].replace(/^ *>[ \\t]?/gm, \"\");\n            var top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            var tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens: tokens,\n                text: text\n            };\n        }\n    };\n    _proto.list = function list(src) {\n        var cap = this.rules.block.list.exec(src);\n        if (cap) {\n            var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;\n            var bull = cap[1].trim();\n            var isordered = bull.length > 1;\n            var list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? \"\\\\d{1,9}\\\\\" + bull.slice(-1) : \"\\\\\" + bull;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            var itemRegex = new RegExp(\"^( {0,3}\" + bull + \")((?:[\t ][^\\\\n]*)?(?:\\\\n|$))\");\n            // Check if current bullet point can start a new List Item\n            while(src){\n                endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, function(t) {\n                    return \" \".repeat(3 * t.length);\n                });\n                nextLine = src.split(\"\\n\", 1)[0];\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimLeft();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    // Items begin with at most one blank line\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    var nextBulletRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \t][^\\\\n]*)?(?:\\\\n|$))\");\n                    var hrRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)\");\n                    var fencesBeginRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:```|~~~)\");\n                    var headingBeginRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}#\");\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            // Dedent if possible\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw: raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimRight();\n            list.items[list.items.length - 1].text = itemContents.trimRight();\n            list.raw = list.raw.trimRight();\n            var l = list.items.length;\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(i = 0; i < l; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    var spacers = list.items[i].tokens.filter(function(t) {\n                        return t.type === \"space\";\n                    });\n                    var hasMultipleLineBreaks = spacers.length > 0 && spacers.some(function(t) {\n                        return /\\n.*\\n/.test(t.raw);\n                    });\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(i = 0; i < l; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    };\n    _proto.html = function html(src) {\n        var cap = this.rules.block.html.exec(src);\n        if (cap) {\n            var token = {\n                type: \"html\",\n                raw: cap[0],\n                pre: !this.options.sanitizer && (cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\"),\n                text: cap[0]\n            };\n            if (this.options.sanitize) {\n                var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n                token.type = \"paragraph\";\n                token.text = text;\n                token.tokens = this.lexer.inline(text);\n            }\n            return token;\n        }\n    };\n    _proto.def = function def(src) {\n        var cap = this.rules.block.def.exec(src);\n        if (cap) {\n            var tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            var href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline._escapes, \"$1\") : \"\";\n            var title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag: tag,\n                raw: cap[0],\n                href: href,\n                title: title\n            };\n        }\n    };\n    _proto.table = function table(src) {\n        var cap = this.rules.block.table.exec(src);\n        if (cap) {\n            var item = {\n                type: \"table\",\n                header: splitCells(cap[1]).map(function(c) {\n                    return {\n                        text: c\n                    };\n                }),\n                align: cap[2].replace(/^ *|\\| *$/g, \"\").split(/ *\\| */),\n                rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : []\n            };\n            if (item.header.length === item.align.length) {\n                item.raw = cap[0];\n                var l = item.align.length;\n                var i, j, k, row;\n                for(i = 0; i < l; i++){\n                    if (/^ *-+: *$/.test(item.align[i])) {\n                        item.align[i] = \"right\";\n                    } else if (/^ *:-+: *$/.test(item.align[i])) {\n                        item.align[i] = \"center\";\n                    } else if (/^ *:-+ *$/.test(item.align[i])) {\n                        item.align[i] = \"left\";\n                    } else {\n                        item.align[i] = null;\n                    }\n                }\n                l = item.rows.length;\n                for(i = 0; i < l; i++){\n                    item.rows[i] = splitCells(item.rows[i], item.header.length).map(function(c) {\n                        return {\n                            text: c\n                        };\n                    });\n                }\n                // parse child tokens inside headers and cells\n                // header child tokens\n                l = item.header.length;\n                for(j = 0; j < l; j++){\n                    item.header[j].tokens = this.lexer.inline(item.header[j].text);\n                }\n                // cell child tokens\n                l = item.rows.length;\n                for(j = 0; j < l; j++){\n                    row = item.rows[j];\n                    for(k = 0; k < row.length; k++){\n                        row[k].tokens = this.lexer.inline(row[k].text);\n                    }\n                }\n                return item;\n            }\n        }\n    };\n    _proto.lheading = function lheading(src) {\n        var cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    };\n    _proto.paragraph = function paragraph(src) {\n        var cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            var text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text: text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    };\n    _proto.text = function text(src) {\n        var cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    };\n    _proto.escape = function escape$1(src) {\n        var cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    };\n    _proto.tag = function tag(src) {\n        var cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: this.options.sanitize ? \"text\" : \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n            };\n        }\n    };\n    _proto.link = function link(src) {\n        var cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            var trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                var lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    var start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    var linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            var href = cap[2];\n            var title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline._escapes, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline._escapes, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    };\n    _proto.reflink = function reflink(src, links) {\n        var cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            var link = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            link = links[link.toLowerCase()];\n            if (!link) {\n                var text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text: text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    };\n    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {\n        if (prevChar === void 0) {\n            prevChar = \"\";\n        }\n        var match = this.rules.inline.emStrong.lDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/(?:[0-9A-Za-z\\xAA\\xB2\\xB3\\xB5\\xB9\\xBA\\xBC-\\xBE\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE1-\\uDEFB\\uDF00-\\uDF23\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC58-\\uDC76\\uDC79-\\uDC9E\\uDCA7-\\uDCAF\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDCFB-\\uDD1B\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBC-\\uDDCF\\uDDD2-\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE40-\\uDE48\\uDE60-\\uDE7E\\uDE80-\\uDE9F\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDEEB-\\uDEEF\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF58-\\uDF72\\uDF78-\\uDF91\\uDFA9-\\uDFAF]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDCFA-\\uDD23\\uDD30-\\uDD39\\uDE60-\\uDE7E\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF27\\uDF30-\\uDF45\\uDF51-\\uDF54\\uDF70-\\uDF81\\uDFB0-\\uDFCB\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC52-\\uDC6F\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD03-\\uDD26\\uDD36-\\uDD3F\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDD0-\\uDDDA\\uDDDC\\uDDE1-\\uDDF4\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDEF0-\\uDEF9\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC50-\\uDC59\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEAA\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF30-\\uDF3B\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCF2\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC50-\\uDC6C\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF2\\uDFB0\\uDFC0-\\uDFD4]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF5B-\\uDF61\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE96\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD834[\\uDEE0-\\uDEF3\\uDF60-\\uDF78]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB\\uDEF0-\\uDEF9]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCC7-\\uDCCF\\uDD00-\\uDD43\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDC71-\\uDCAB\\uDCAD-\\uDCAF\\uDCB1-\\uDCB4\\uDD01-\\uDD2D\\uDD2F-\\uDD3D\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD00-\\uDD0C]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/)) return;\n        var nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || nextChar && (prevChar === \"\" || this.rules.inline.punctuation.exec(prevChar))) {\n            var lLength = match[0].length - 1;\n            var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            var endReg = match[0][0] === \"*\" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = rDelim.length;\n                if (match[3] || match[4]) {\n                    // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                var raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    var _text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw: raw,\n                        text: _text,\n                        tokens: this.lexer.inlineTokens(_text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                var text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw: raw,\n                    text: text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    };\n    _proto.codespan = function codespan(src) {\n        var cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            var text = cap[2].replace(/\\n/g, \" \");\n            var hasNonSpaceChars = /[^ ]/.test(text);\n            var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text: text\n            };\n        }\n    };\n    _proto.br = function br(src) {\n        var cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    };\n    _proto.del = function del(src) {\n        var cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    };\n    _proto.autolink = function autolink(src, mangle) {\n        var cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            var text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text: text,\n                href: href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text: text\n                    }\n                ]\n            };\n        }\n    };\n    _proto.url = function url(src, mangle) {\n        var cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            var text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                var prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n                }while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text: text,\n                href: href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text: text\n                    }\n                ]\n            };\n        }\n    };\n    _proto.inlineText = function inlineText(src, smartypants) {\n        var cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            var text;\n            if (this.lexer.state.inRawBlock) {\n                text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n            } else {\n                text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: text\n            };\n        }\n    };\n    return Tokenizer;\n}();\n/**\n * Block-Level Grammar\n */ var block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n    html: \"^ {0,3}(?:\" // optional indentation\n     + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n     + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n     + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n     + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n     + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n     + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n     + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n     + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n     + \")\",\n    def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^((?:.|\\n(?!\\n))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n};\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def).replace(\"label\", block._label).replace(\"title\", block._title).getRegex();\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */).replace(\"bull\", block.bullet).getRegex();\nblock.list = edit(block.list).replace(/bull/g, block.bullet).replace(\"hr\", \"\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))\").replace(\"def\", \"\\\\n+(?=\" + block.def.source + \")\").getRegex();\nblock._tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, \"i\").replace(\"comment\", block._comment).replace(\"tag\", block._tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nblock.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nblock.blockquote = edit(block.blockquote).replace(\"paragraph\", block.paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ block.normal = _extends({}, block);\n/**\n * GFM Block Grammar\n */ block.gfm = _extends({}, block.normal, {\n    table: \"^ *([^\\\\n ].*\\\\|.*)\\\\n\" // Header\n     + \" {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?\" // Align\n     + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\" // Cells\n});\nblock.gfm.table = edit(block.gfm.table).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nblock.gfm.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"table\", block.gfm.table) // interrupt paragraphs with table\n.replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ block.pedantic = _extends({}, block.normal, {\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", block._comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(block.normal._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", block.lheading).replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").getRegex()\n});\n/**\n * Inline-Level Grammar\n */ var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: \"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n     + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n     + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n     + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n     + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\",\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n    nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n    reflinkSearch: \"reflink|nolink(?!\\\\()\",\n    emStrong: {\n        lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n        //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n        rDelimAst: /^(?:[^_*\\\\]|\\\\.)*?\\_\\_(?:[^_*\\\\]|\\\\.)*?\\*(?:[^_*\\\\]|\\\\.)*?(?=\\_\\_)|(?:[^*\\\\]|\\\\.)+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[^punct*_\\s])/,\n        rDelimUnd: /^(?:[^_*\\\\]|\\\\.)*?\\*\\*(?:[^_*\\\\]|\\\\.)*?\\_(?:[^_*\\\\]|\\\\.)*?(?=\\*\\*)|(?:[^_\\\\]|\\\\.)+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\spunctuation])/\n};\n// list of punctuation marks from CommonMark spec\n// without * and _ to handle the different emphasis markers * and _\ninline._punctuation = \"!\\\"#$%&'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~\";\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n// lookbehind is not available on Safari as of version 16\n// inline.escapedEmSt = /(?<=(?:^|[^\\\\)(?:\\\\[^])*)\\\\[*_]/g;\ninline.escapedEmSt = /(?:^|[^\\\\])(?:\\\\\\\\)*\\\\[*_]/g;\ninline._comment = edit(block._comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, \"g\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, \"g\").replace(/punct/g, inline._punctuation).getRegex();\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink).replace(\"scheme\", inline._scheme).replace(\"email\", inline._email).getRegex();\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\ninline.tag = edit(inline.tag).replace(\"comment\", inline._comment).replace(\"attribute\", inline._attribute).getRegex();\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\ninline.link = edit(inline.link).replace(\"label\", inline._label).replace(\"href\", inline._href).replace(\"title\", inline._title).getRegex();\ninline.reflink = edit(inline.reflink).replace(\"label\", inline._label).replace(\"ref\", block._label).getRegex();\ninline.nolink = edit(inline.nolink).replace(\"ref\", block._label).getRegex();\ninline.reflinkSearch = edit(inline.reflinkSearch, \"g\").replace(\"reflink\", inline.reflink).replace(\"nolink\", inline.nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ inline.normal = _extends({}, inline);\n/**\n * Pedantic Inline Grammar\n */ inline.pedantic = _extends({}, inline.normal, {\n    strong: {\n        start: /^__|\\*\\*/,\n        middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        endAst: /\\*\\*(?!\\*)/g,\n        endUnd: /__(?!_)/g\n    },\n    em: {\n        start: /^_|\\*/,\n        middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n        endAst: /\\*(?!\\*)/g,\n        endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", inline._label).getRegex()\n});\n/**\n * GFM Inline Grammar\n */ inline.gfm = _extends({}, inline.normal, {\n    escape: edit(inline.escape).replace(\"])\", \"~|])\").getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n});\ninline.gfm.url = edit(inline.gfm.url, \"i\").replace(\"email\", inline.gfm._extended_email).getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */ inline.breaks = _extends({}, inline.gfm, {\n    br: edit(inline.br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inline.gfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n});\n/**\n * smartypants text replacement\n * @param {string} text\n */ function smartypants(text) {\n    return text// em-dashes\n    .replace(/---/g, \"\")// en-dashes\n    .replace(/--/g, \"\")// opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\")// closing singles & apostrophes\n    .replace(/'/g, \"\")// opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\")// closing doubles\n    .replace(/\"/g, \"\")// ellipses\n    .replace(/\\.{3}/g, \"\");\n}\n/**\n * mangle email addresses\n * @param {string} text\n */ function mangle(text) {\n    var out = \"\", i, ch;\n    var l = text.length;\n    for(i = 0; i < l; i++){\n        ch = text.charCodeAt(i);\n        if (Math.random() > 0.5) {\n            ch = \"x\" + ch.toString(16);\n        }\n        out += \"&#\" + ch + \";\";\n    }\n    return out;\n}\n/**\n * Block Lexer\n */ var Lexer = /*#__PURE__*/ function() {\n    function Lexer(options) {\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || exports.defaults;\n        this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        var rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n   * Expose Rules\n   */ /**\n   * Static Lex Method\n   */ Lexer.lex = function lex(src, options) {\n        var lexer = new Lexer(options);\n        return lexer.lex(src);\n    } /**\n   * Static Lex Inline Method\n   */ ;\n    Lexer.lexInline = function lexInline(src, options) {\n        var lexer = new Lexer(options);\n        return lexer.inlineTokens(src);\n    } /**\n   * Preprocessing\n   */ ;\n    var _proto = Lexer.prototype;\n    _proto.lex = function lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        var next;\n        while(next = this.inlineQueue.shift()){\n            this.inlineTokens(next.src, next.tokens);\n        }\n        return this.tokens;\n    } /**\n   * Lexing\n   */ ;\n    _proto.blockTokens = function blockTokens(src, tokens) {\n        var _this = this;\n        if (tokens === void 0) {\n            tokens = [];\n        }\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, function(_, leading, tabs) {\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        var token, lastToken, cutSrc, lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {\n                if (token = extTokenizer.call({\n                    lexer: _this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                (function() {\n                    var startIndex = Infinity;\n                    var tempSrc = src.slice(1);\n                    var tempStart = void 0;\n                    _this.options.extensions.startBlock.forEach(function(getStartIndex) {\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                })();\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                var errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    };\n    _proto.inline = function inline(src, tokens) {\n        if (tokens === void 0) {\n            tokens = [];\n        }\n        this.inlineQueue.push({\n            src: src,\n            tokens: tokens\n        });\n        return tokens;\n    } /**\n   * Lexing/Compiling\n   */ ;\n    _proto.inlineTokens = function inlineTokens(src, tokens) {\n        var _this2 = this;\n        if (tokens === void 0) {\n            tokens = [];\n        }\n        var token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        var maskedSrc = src;\n        var match;\n        var keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            var links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + repeatString(\"a\", match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + repeatString(\"a\", match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped em & strong delimiters\n        while((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n            this.tokenizer.rules.inline.escapedEmSt.lastIndex--;\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {\n                if (token = extTokenizer.call({\n                    lexer: _this2\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src, mangle)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                (function() {\n                    var startIndex = Infinity;\n                    var tempSrc = src.slice(1);\n                    var tempStart = void 0;\n                    _this2.options.extensions.startInline.forEach(function(getStartIndex) {\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                })();\n            }\n            if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                var errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    };\n    _createClass(Lexer, null, [\n        {\n            key: \"rules\",\n            get: function get() {\n                return {\n                    block: block,\n                    inline: inline\n                };\n            }\n        }\n    ]);\n    return Lexer;\n}();\n/**\n * Renderer\n */ var Renderer = /*#__PURE__*/ function() {\n    function Renderer(options) {\n        this.options = options || exports.defaults;\n    }\n    var _proto = Renderer.prototype;\n    _proto.code = function code(_code, infostring, escaped) {\n        var lang = (infostring || \"\").match(/\\S*/)[0];\n        if (this.options.highlight) {\n            var out = this.options.highlight(_code, lang);\n            if (out != null && out !== _code) {\n                escaped = true;\n                _code = out;\n            }\n        }\n        _code = _code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? _code : escape(_code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"' + this.options.langPrefix + escape(lang) + '\">' + (escaped ? _code : escape(_code, true)) + \"</code></pre>\\n\";\n    } /**\n   * @param {string} quote\n   */ ;\n    _proto.blockquote = function blockquote(quote) {\n        return \"<blockquote>\\n\" + quote + \"</blockquote>\\n\";\n    };\n    _proto.html = function html(_html) {\n        return _html;\n    } /**\n   * @param {string} text\n   * @param {string} level\n   * @param {string} raw\n   * @param {any} slugger\n   */ ;\n    _proto.heading = function heading(text, level, raw, slugger) {\n        if (this.options.headerIds) {\n            var id = this.options.headerPrefix + slugger.slug(raw);\n            return \"<h\" + level + ' id=\"' + id + '\">' + text + \"</h\" + level + \">\\n\";\n        }\n        // ignore IDs\n        return \"<h\" + level + \">\" + text + \"</h\" + level + \">\\n\";\n    };\n    _proto.hr = function hr() {\n        return this.options.xhtml ? \"<hr/>\\n\" : \"<hr>\\n\";\n    };\n    _proto.list = function list(body, ordered, start) {\n        var type = ordered ? \"ol\" : \"ul\", startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.listitem = function listitem(text) {\n        return \"<li>\" + text + \"</li>\\n\";\n    };\n    _proto.checkbox = function checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? \" /\" : \"\") + \"> \";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.paragraph = function paragraph(text) {\n        return \"<p>\" + text + \"</p>\\n\";\n    } /**\n   * @param {string} header\n   * @param {string} body\n   */ ;\n    _proto.table = function table(header, body) {\n        if (body) body = \"<tbody>\" + body + \"</tbody>\";\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    } /**\n   * @param {string} content\n   */ ;\n    _proto.tablerow = function tablerow(content) {\n        return \"<tr>\\n\" + content + \"</tr>\\n\";\n    };\n    _proto.tablecell = function tablecell(content, flags) {\n        var type = flags.header ? \"th\" : \"td\";\n        var tag = flags.align ? \"<\" + type + ' align=\"' + flags.align + '\">' : \"<\" + type + \">\";\n        return tag + content + (\"</\" + type + \">\\n\");\n    } /**\n   * span level renderer\n   * @param {string} text\n   */ ;\n    _proto.strong = function strong(text) {\n        return \"<strong>\" + text + \"</strong>\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.em = function em(text) {\n        return \"<em>\" + text + \"</em>\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.codespan = function codespan(text) {\n        return \"<code>\" + text + \"</code>\";\n    };\n    _proto.br = function br() {\n        return this.options.xhtml ? \"<br/>\" : \"<br>\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.del = function del(text) {\n        return \"<del>\" + text + \"</del>\";\n    } /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */ ;\n    _proto.link = function link(href, title, text) {\n        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (href === null) {\n            return text;\n        }\n        var out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    } /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */ ;\n    _proto.image = function image(href, title, text) {\n        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (href === null) {\n            return text;\n        }\n        var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += this.options.xhtml ? \"/>\" : \">\";\n        return out;\n    };\n    _proto.text = function text(_text) {\n        return _text;\n    };\n    return Renderer;\n}();\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ var TextRenderer = /*#__PURE__*/ function() {\n    function TextRenderer() {}\n    var _proto = TextRenderer.prototype;\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n        return text;\n    };\n    _proto.em = function em(text) {\n        return text;\n    };\n    _proto.codespan = function codespan(text) {\n        return text;\n    };\n    _proto.del = function del(text) {\n        return text;\n    };\n    _proto.html = function html(text) {\n        return text;\n    };\n    _proto.text = function text(_text) {\n        return _text;\n    };\n    _proto.link = function link(href, title, text) {\n        return \"\" + text;\n    };\n    _proto.image = function image(href, title, text) {\n        return \"\" + text;\n    };\n    _proto.br = function br() {\n        return \"\";\n    };\n    return TextRenderer;\n}();\n/**\n * Slugger generates header id\n */ var Slugger = /*#__PURE__*/ function() {\n    function Slugger() {\n        this.seen = {};\n    }\n    /**\n   * @param {string} value\n   */ var _proto = Slugger.prototype;\n    _proto.serialize = function serialize(value) {\n        return value.toLowerCase().trim()// remove html tags\n        .replace(/<[!\\/a-z].*?>/ig, \"\")// remove unwanted chars\n        .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, \"\").replace(/\\s/g, \"-\");\n    } /**\n   * Finds the next safe (unique) slug to use\n   * @param {string} originalSlug\n   * @param {boolean} isDryRun\n   */ ;\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n        var slug = originalSlug;\n        var occurenceAccumulator = 0;\n        if (this.seen.hasOwnProperty(slug)) {\n            occurenceAccumulator = this.seen[originalSlug];\n            do {\n                occurenceAccumulator++;\n                slug = originalSlug + \"-\" + occurenceAccumulator;\n            }while (this.seen.hasOwnProperty(slug));\n        }\n        if (!isDryRun) {\n            this.seen[originalSlug] = occurenceAccumulator;\n            this.seen[slug] = 0;\n        }\n        return slug;\n    } /**\n   * Convert string to unique id\n   * @param {object} [options]\n   * @param {boolean} [options.dryrun] Generates the next unique slug without\n   * updating the internal accumulator.\n   */ ;\n    _proto.slug = function slug(value, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var slug = this.serialize(value);\n        return this.getNextSafeSlug(slug, options.dryrun);\n    };\n    return Slugger;\n}();\n/**\n * Parsing & Compiling\n */ var Parser = /*#__PURE__*/ function() {\n    function Parser(options) {\n        this.options = options || exports.defaults;\n        this.options.renderer = this.options.renderer || new Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new TextRenderer();\n        this.slugger = new Slugger();\n    }\n    /**\n   * Static Parse Method\n   */ Parser.parse = function parse(tokens, options) {\n        var parser = new Parser(options);\n        return parser.parse(tokens);\n    } /**\n   * Static Parse Inline Method\n   */ ;\n    Parser.parseInline = function parseInline(tokens, options) {\n        var parser = new Parser(options);\n        return parser.parseInline(tokens);\n    } /**\n   * Parse Loop\n   */ ;\n    var _proto = Parser.prototype;\n    _proto.parse = function parse(tokens, top) {\n        if (top === void 0) {\n            top = true;\n        }\n        var out = \"\", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;\n        var l = tokens.length;\n        for(i = 0; i < l; i++){\n            token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        out += this.renderer.code(token.text, token.lang, token.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        header = \"\";\n                        // header\n                        cell = \"\";\n                        l2 = token.header.length;\n                        for(j = 0; j < l2; j++){\n                            cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                                header: true,\n                                align: token.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        body = \"\";\n                        l2 = token.rows.length;\n                        for(j = 0; j < l2; j++){\n                            row = token.rows[j];\n                            cell = \"\";\n                            l3 = row.length;\n                            for(k = 0; k < l3; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: token.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        body = this.parse(token.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        ordered = token.ordered;\n                        start = token.start;\n                        loose = token.loose;\n                        l2 = token.items.length;\n                        body = \"\";\n                        for(j = 0; j < l2; j++){\n                            item = token.items[j];\n                            checked = item.checked;\n                            task = item.task;\n                            itemBody = \"\";\n                            if (item.task) {\n                                checkbox = this.renderer.checkbox(checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox;\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        // TODO parse inline content if parameter markdown=1\n                        out += this.renderer.html(token.text);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        out += this.renderer.paragraph(this.parseInline(token.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        body = token.tokens ? this.parseInline(token.tokens) : token.text;\n                        while(i + 1 < l && tokens[i + 1].type === \"text\"){\n                            token = tokens[++i];\n                            body += \"\\n\" + (token.tokens ? this.parseInline(token.tokens) : token.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return;\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    } /**\n   * Parse Inline Tokens\n   */ ;\n    _proto.parseInline = function parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        var out = \"\", i, token, ret;\n        var l = tokens.length;\n        for(i = 0; i < l; i++){\n            token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        out += renderer.text(token.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        out += renderer.html(token.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        out += renderer.image(token.href, token.title, token.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        out += renderer.strong(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        out += renderer.em(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        out += renderer.codespan(token.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        out += renderer.del(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        out += renderer.text(token.text);\n                        break;\n                    }\n                default:\n                    {\n                        var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return;\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    };\n    return Parser;\n}();\nvar Hooks = /*#__PURE__*/ function() {\n    function Hooks(options) {\n        this.options = options || exports.defaults;\n    }\n    var _proto = Hooks.prototype;\n    /**\n   * Process markdown before marked\n   */ _proto.preprocess = function preprocess(markdown) {\n        return markdown;\n    } /**\n   * Process HTML after marked is finished\n   */ ;\n    _proto.postprocess = function postprocess(html) {\n        return html;\n    };\n    return Hooks;\n}();\nHooks.passThroughHooks = new Set([\n    \"preprocess\",\n    \"postprocess\"\n]);\nfunction onError(silent, async, callback) {\n    return function(e) {\n        e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n        if (silent) {\n            var msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n            if (async) {\n                return Promise.resolve(msg);\n            }\n            if (callback) {\n                callback(null, msg);\n                return;\n            }\n            return msg;\n        }\n        if (async) {\n            return Promise.reject(e);\n        }\n        if (callback) {\n            callback(e);\n            return;\n        }\n        throw e;\n    };\n}\nfunction parseMarkdown(lexer, parser) {\n    return function(src, opt, callback) {\n        if (typeof opt === \"function\") {\n            callback = opt;\n            opt = null;\n        }\n        var origOpt = _extends({}, opt);\n        opt = _extends({}, marked.defaults, origOpt);\n        var throwError = onError(opt.silent, opt.async, callback);\n        // throw error in case of non string input\n        if (typeof src === \"undefined\" || src === null) {\n            return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n        }\n        if (typeof src !== \"string\") {\n            return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n        }\n        checkSanitizeDeprecation(opt);\n        if (opt.hooks) {\n            opt.hooks.options = opt;\n        }\n        if (callback) {\n            var highlight = opt.highlight;\n            var tokens;\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                tokens = lexer(src, opt);\n            } catch (e) {\n                return throwError(e);\n            }\n            var done = function done(err) {\n                var out;\n                if (!err) {\n                    try {\n                        if (opt.walkTokens) {\n                            marked.walkTokens(tokens, opt.walkTokens);\n                        }\n                        out = parser(tokens, opt);\n                        if (opt.hooks) {\n                            out = opt.hooks.postprocess(out);\n                        }\n                    } catch (e) {\n                        err = e;\n                    }\n                }\n                opt.highlight = highlight;\n                return err ? throwError(err) : callback(null, out);\n            };\n            if (!highlight || highlight.length < 3) {\n                return done();\n            }\n            delete opt.highlight;\n            if (!tokens.length) return done();\n            var pending = 0;\n            marked.walkTokens(tokens, function(token) {\n                if (token.type === \"code\") {\n                    pending++;\n                    setTimeout(function() {\n                        highlight(token.text, token.lang, function(err, code) {\n                            if (err) {\n                                return done(err);\n                            }\n                            if (code != null && code !== token.text) {\n                                token.text = code;\n                                token.escaped = true;\n                            }\n                            pending--;\n                            if (pending === 0) {\n                                done();\n                            }\n                        });\n                    }, 0);\n                }\n            });\n            if (pending === 0) {\n                done();\n            }\n            return;\n        }\n        if (opt.async) {\n            return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(function(src) {\n                return lexer(src, opt);\n            }).then(function(tokens) {\n                return opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(function() {\n                    return tokens;\n                }) : tokens;\n            }).then(function(tokens) {\n                return parser(tokens, opt);\n            }).then(function(html) {\n                return opt.hooks ? opt.hooks.postprocess(html) : html;\n            })[\"catch\"](throwError);\n        }\n        try {\n            if (opt.hooks) {\n                src = opt.hooks.preprocess(src);\n            }\n            var _tokens = lexer(src, opt);\n            if (opt.walkTokens) {\n                marked.walkTokens(_tokens, opt.walkTokens);\n            }\n            var html = parser(_tokens, opt);\n            if (opt.hooks) {\n                html = opt.hooks.postprocess(html);\n            }\n            return html;\n        } catch (e) {\n            return throwError(e);\n        }\n    };\n}\n/**\n * Marked\n */ function marked(src, opt, callback) {\n    return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);\n}\n/**\n * Options\n */ marked.options = marked.setOptions = function(opt) {\n    marked.defaults = _extends({}, marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n};\nmarked.getDefaults = getDefaults;\nmarked.defaults = exports.defaults;\n/**\n * Use Extension\n */ marked.use = function() {\n    var extensions = marked.defaults.extensions || {\n        renderers: {},\n        childTokens: {}\n    };\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    args.forEach(function(pack) {\n        // copy options to new object\n        var opts = _extends({}, pack);\n        // set async to true if it was set to true before\n        opts.async = marked.defaults.async || opts.async || false;\n        // ==-- Parse \"addon\" extensions --== //\n        if (pack.extensions) {\n            pack.extensions.forEach(function(ext) {\n                if (!ext.name) {\n                    throw new Error(\"extension name required\");\n                }\n                if (ext.renderer) {\n                    // Renderer extensions\n                    var prevRenderer = extensions.renderers[ext.name];\n                    if (prevRenderer) {\n                        // Replace extension with func to run new extension but fall back if false\n                        extensions.renderers[ext.name] = function() {\n                            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                                args[_key2] = arguments[_key2];\n                            }\n                            var ret = ext.renderer.apply(this, args);\n                            if (ret === false) {\n                                ret = prevRenderer.apply(this, args);\n                            }\n                            return ret;\n                        };\n                    } else {\n                        extensions.renderers[ext.name] = ext.renderer;\n                    }\n                }\n                if (ext.tokenizer) {\n                    // Tokenizer Extensions\n                    if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                        throw new Error(\"extension level must be 'block' or 'inline'\");\n                    }\n                    if (extensions[ext.level]) {\n                        extensions[ext.level].unshift(ext.tokenizer);\n                    } else {\n                        extensions[ext.level] = [\n                            ext.tokenizer\n                        ];\n                    }\n                    if (ext.start) {\n                        // Function to check for start of token\n                        if (ext.level === \"block\") {\n                            if (extensions.startBlock) {\n                                extensions.startBlock.push(ext.start);\n                            } else {\n                                extensions.startBlock = [\n                                    ext.start\n                                ];\n                            }\n                        } else if (ext.level === \"inline\") {\n                            if (extensions.startInline) {\n                                extensions.startInline.push(ext.start);\n                            } else {\n                                extensions.startInline = [\n                                    ext.start\n                                ];\n                            }\n                        }\n                    }\n                }\n                if (ext.childTokens) {\n                    // Child tokens to be visited by walkTokens\n                    extensions.childTokens[ext.name] = ext.childTokens;\n                }\n            });\n            opts.extensions = extensions;\n        }\n        // ==-- Parse \"overwrite\" extensions --== //\n        if (pack.renderer) {\n            (function() {\n                var renderer = marked.defaults.renderer || new Renderer();\n                var _loop = function _loop(prop) {\n                    var prevRenderer = renderer[prop];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[prop] = function() {\n                        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n                            args[_key3] = arguments[_key3];\n                        }\n                        var ret = pack.renderer[prop].apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret;\n                    };\n                };\n                for(var prop in pack.renderer){\n                    _loop(prop);\n                }\n                opts.renderer = renderer;\n            })();\n        }\n        if (pack.tokenizer) {\n            (function() {\n                var tokenizer = marked.defaults.tokenizer || new Tokenizer();\n                var _loop2 = function _loop2(prop) {\n                    var prevTokenizer = tokenizer[prop];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    tokenizer[prop] = function() {\n                        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n                            args[_key4] = arguments[_key4];\n                        }\n                        var ret = pack.tokenizer[prop].apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                };\n                for(var prop in pack.tokenizer){\n                    _loop2(prop);\n                }\n                opts.tokenizer = tokenizer;\n            })();\n        }\n        // ==-- Parse Hooks extensions --== //\n        if (pack.hooks) {\n            (function() {\n                var hooks = marked.defaults.hooks || new Hooks();\n                var _loop3 = function _loop3(prop) {\n                    var prevHook = hooks[prop];\n                    if (Hooks.passThroughHooks.has(prop)) {\n                        hooks[prop] = function(arg) {\n                            if (marked.defaults.async) {\n                                return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then(function(ret) {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            var ret = pack.hooks[prop].call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        hooks[prop] = function() {\n                            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){\n                                args[_key5] = arguments[_key5];\n                            }\n                            var ret = pack.hooks[prop].apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                };\n                for(var prop in pack.hooks){\n                    _loop3(prop);\n                }\n                opts.hooks = hooks;\n            })();\n        }\n        // ==-- Parse WalkTokens extensions --== //\n        if (pack.walkTokens) {\n            var _walkTokens = marked.defaults.walkTokens;\n            opts.walkTokens = function(token) {\n                var values = [];\n                values.push(pack.walkTokens.call(this, token));\n                if (_walkTokens) {\n                    values = values.concat(_walkTokens.call(this, token));\n                }\n                return values;\n            };\n        }\n        marked.setOptions(opts);\n    });\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    var values = [];\n    var _loop4 = function _loop4() {\n        var token = _step.value;\n        values = values.concat(callback.call(marked, token));\n        switch(token.type){\n            case \"table\":\n                {\n                    for(var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;){\n                        var cell = _step2.value;\n                        values = values.concat(marked.walkTokens(cell.tokens, callback));\n                    }\n                    for(var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;){\n                        var row = _step3.value;\n                        for(var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;){\n                            var _cell = _step4.value;\n                            values = values.concat(marked.walkTokens(_cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n            case \"list\":\n                {\n                    values = values.concat(marked.walkTokens(token.items, callback));\n                    break;\n                }\n            default:\n                {\n                    if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {\n                        // Walk any extensions\n                        marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {\n                            values = values.concat(marked.walkTokens(token[childTokens], callback));\n                        });\n                    } else if (token.tokens) {\n                        values = values.concat(marked.walkTokens(token.tokens, callback));\n                    }\n                }\n        }\n    };\n    for(var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;){\n        _loop4();\n    }\n    return values;\n};\n/**\n * Parse Inline\n * @param {string} src\n */ marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);\n/**\n * Expose\n */ marked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.Tokenizer = Tokenizer;\nmarked.Slugger = Slugger;\nmarked.Hooks = Hooks;\nmarked.parse = marked;\nvar options = marked.options;\nvar setOptions = marked.setOptions;\nvar use = marked.use;\nvar walkTokens = marked.walkTokens;\nvar parseInline = marked.parseInline;\nvar parse = marked;\nvar parser = Parser.parse;\nvar lexer = Lexer.lex;\nexports.Hooks = Hooks;\nexports.Lexer = Lexer;\nexports.Parser = Parser;\nexports.Renderer = Renderer;\nexports.Slugger = Slugger;\nexports.TextRenderer = TextRenderer;\nexports.Tokenizer = Tokenizer;\nexports.getDefaults = getDefaults;\nexports.lexer = lexer;\nexports.marked = marked;\nexports.options = options;\nexports.parse = parse;\nexports.parseInline = parseInline;\nexports.parser = parser;\nexports.setOptions = setOptions;\nexports.use = use;\nexports.walkTokens = walkTokens;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5janMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEOzs7Q0FHQyxHQUVEO0FBRUEsU0FBU0Esa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFDdEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUNyQyxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFDekJFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQ2pERCxXQUFXRSxZQUFZLEdBQUc7UUFDMUIsSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFDakRDLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUVUsZUFBZU4sV0FBV08sR0FBRyxHQUFHUDtJQUNoRTtBQUNGO0FBQ0EsU0FBU1EsYUFBYUMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFDeEQsSUFBSUQsWUFBWWYsa0JBQWtCYyxZQUFZRyxTQUFTLEVBQUVGO0lBQ3pELElBQUlDLGFBQWFoQixrQkFBa0JjLGFBQWFFO0lBQ2hEUCxPQUFPQyxjQUFjLENBQUNJLGFBQWEsYUFBYTtRQUM5Q04sVUFBVTtJQUNaO0lBQ0EsT0FBT007QUFDVDtBQUNBLFNBQVNJO0lBQ1BBLFdBQVdULE9BQU9VLE1BQU0sR0FBR1YsT0FBT1UsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVW5CLE1BQU07UUFDaEUsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlrQixVQUFVakIsTUFBTSxFQUFFRCxJQUFLO1lBQ3pDLElBQUltQixTQUFTRCxTQUFTLENBQUNsQixFQUFFO1lBQ3pCLElBQUssSUFBSVMsT0FBT1UsT0FBUTtnQkFDdEIsSUFBSWIsT0FBT1EsU0FBUyxDQUFDTSxjQUFjLENBQUNDLElBQUksQ0FBQ0YsUUFBUVYsTUFBTTtvQkFDckRYLE1BQU0sQ0FBQ1csSUFBSSxHQUFHVSxNQUFNLENB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LFNBQVNILE9BQU9FLEtBQUs7QUFDekIsSUFBSTNNLFFBQVFrSixNQUFNRyxHQUFHO0FBRXJCek8sYUFBYSxHQUFHeVM7QUFDaEJ6UyxhQUFhLEdBQUdzTztBQUNoQnRPLGNBQWMsR0FBRzZSO0FBQ2pCN1IsZ0JBQWdCLEdBQUdtUTtBQUNuQm5RLGVBQWUsR0FBR3FSO0FBQ2xCclIsb0JBQW9CLEdBQUdvUjtBQUN2QnBSLGlCQUFpQixHQUFHcUc7QUFDcEJyRyxtQkFBbUIsR0FBR3JCO0FBQ3RCcUIsYUFBYSxHQUFHb0Y7QUFDaEJwRixjQUFjLEdBQUd3VDtBQUNqQnhULGVBQWUsR0FBR3NHO0FBQ2xCdEcsYUFBYSxHQUFHK1I7QUFDaEIvUixtQkFBbUIsR0FBR2lTO0FBQ3RCalMsY0FBYyxHQUFHZ1M7QUFDakJoUyxrQkFBa0IsR0FBR2dVO0FBQ3JCaFUsV0FBVyxHQUFHaVU7QUFDZGpVLGtCQUFrQixHQUFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuY2pzPzY5ODQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgdjQuMy4wIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIzLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0cygpIHtcbiAgcmV0dXJuIHtcbiAgICBhc3luYzogZmFsc2UsXG4gICAgYmFzZVVybDogbnVsbCxcbiAgICBicmVha3M6IGZhbHNlLFxuICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgZ2ZtOiB0cnVlLFxuICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICBob29rczogbnVsbCxcbiAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICBtYW5nbGU6IHRydWUsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICBzYW5pdGl6ZXI6IG51bGwsXG4gICAgc2lsZW50OiBmYWxzZSxcbiAgICBzbWFydHlwYW50czogZmFsc2UsXG4gICAgdG9rZW5pemVyOiBudWxsLFxuICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgeGh0bWw6IGZhbHNlXG4gIH07XG59XG5leHBvcnRzLmRlZmF1bHRzID0gZ2V0RGVmYXVsdHMoKTtcbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGV4cG9ydHMuZGVmYXVsdHMgPSBuZXdEZWZhdWx0cztcbn1cblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cbnZhciBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbnZhciBlc2NhcGVSZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0LnNvdXJjZSwgJ2cnKTtcbnZhciBlc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hKCNcXGR7MSw3fXwjW1h4XVthLWZBLUYwLTldezEsNn18XFx3Kyk7KS87XG52YXIgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0Tm9FbmNvZGUuc291cmNlLCAnZycpO1xudmFyIGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcbnZhciBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGdldEVzY2FwZVJlcGxhY2VtZW50KGNoKSB7XG4gIHJldHVybiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xufTtcbmZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgaWYgKGVuY29kZSkge1xuICAgIGlmIChlc2NhcGVUZXN0LnRlc3QoaHRtbCkpIHtcbiAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZXNjYXBlVGVzdE5vRW5jb2RlLnRlc3QoaHRtbCkpIHtcbiAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBodG1sO1xufVxudmFyIHVuZXNjYXBlVGVzdCA9IC8mKCMoPzpcXGQrKXwoPzojeFswLTlBLUZhLWZdKyl8KD86XFx3KykpOz8vaWc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIGZ1bmN0aW9uIChfLCBuKSB7XG4gICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcbiAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCcgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxudmFyIGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gcmVnZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRcbiAqL1xuZnVuY3Rpb24gZWRpdChyZWdleCwgb3B0KSB7XG4gIHJlZ2V4ID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICBvcHQgPSBvcHQgfHwgJyc7XG4gIHZhciBvYmogPSB7XG4gICAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShuYW1lLCB2YWwpIHtcbiAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZ2V0UmVnZXg6IGZ1bmN0aW9uIGdldFJlZ2V4KCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gb2JqO1xufVxudmFyIG5vbldvcmRBbmRDb2xvblRlc3QgPSAvW15cXHc6XS9nO1xudmFyIG9yaWdpbkluZGVwZW5kZW50VXJsID0gL14kfF5bYS16XVthLXowLTkrLi1dKjp8Xls/I10vaTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNhbml0aXplXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IGhyZWZcbiAqL1xuZnVuY3Rpb24gY2xlYW5Vcmwoc2FuaXRpemUsIGJhc2UsIGhyZWYpIHtcbiAgaWYgKHNhbml0aXplKSB7XG4gICAgdmFyIHByb3Q7XG4gICAgdHJ5IHtcbiAgICAgIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpLnJlcGxhY2Uobm9uV29yZEFuZENvbG9uVGVzdCwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgIGhyZWYgPSByZXNvbHZlVXJsKGJhc2UsIGhyZWYpO1xuICB9XG4gIHRyeSB7XG4gICAgaHJlZiA9IGVuY29kZVVSSShocmVmKS5yZXBsYWNlKC8lMjUvZywgJyUnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBocmVmO1xufVxudmFyIGJhc2VVcmxzID0ge307XG52YXIganVzdERvbWFpbiA9IC9eW146XSs6XFwvKlteL10qJC87XG52YXIgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG52YXIgZG9tYWluID0gL14oW146XSs6XFwvKlteL10qKVtcXHNcXFNdKiQvO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICovXG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2UsIGhyZWYpIHtcbiAgaWYgKCFiYXNlVXJsc1snICcgKyBiYXNlXSkge1xuICAgIC8vIHdlIGNhbiBpZ25vcmUgZXZlcnl0aGluZyBpbiBiYXNlIGFmdGVyIHRoZSBsYXN0IHNsYXNoIG9mIGl0cyBwYXRoIGNvbXBvbmVudCxcbiAgICAvLyBidXQgd2UgbWlnaHQgbmVlZCB0byBhZGQgX3RoYXRfXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zXG4gICAgaWYgKGp1c3REb21haW4udGVzdChiYXNlKSkge1xuICAgICAgYmFzZVVybHNbJyAnICsgYmFzZV0gPSBiYXNlICsgJy8nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IHJ0cmltKGJhc2UsICcvJywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGJhc2UgPSBiYXNlVXJsc1snICcgKyBiYXNlXTtcbiAgdmFyIHJlbGF0aXZlQmFzZSA9IGJhc2UuaW5kZXhPZignOicpID09PSAtMTtcbiAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UoZG9tYWluLCAnJDEnKSArIGhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICB9XG59XG52YXIgbm9vcFRlc3QgPSB7XG4gIGV4ZWM6IGZ1bmN0aW9uIG5vb3BUZXN0KCkge31cbn07XG5mdW5jdGlvbiBzcGxpdENlbGxzKHRhYmxlUm93LCBjb3VudCkge1xuICAvLyBlbnN1cmUgdGhhdCBldmVyeSBjZWxsLWRlbGltaXRpbmcgcGlwZSBoYXMgYSBzcGFjZVxuICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgdmFyIHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICBjdXJyID0gb2Zmc2V0O1xuICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgIH1cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgcmV0dXJuICd8JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgcmV0dXJuICcgfCc7XG4gICAgICB9XG4gICAgfSksXG4gICAgY2VsbHMgPSByb3cuc3BsaXQoLyBcXHwvKTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIEZpcnN0L2xhc3QgY2VsbCBpbiBhIHJvdyBjYW5ub3QgYmUgZW1wdHkgaWYgaXQgaGFzIG5vIGxlYWRpbmcvdHJhaWxpbmcgcGlwZVxuICBpZiAoIWNlbGxzWzBdLnRyaW0oKSkge1xuICAgIGNlbGxzLnNoaWZ0KCk7XG4gIH1cbiAgaWYgKGNlbGxzLmxlbmd0aCA+IDAgJiYgIWNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLnRyaW0oKSkge1xuICAgIGNlbGxzLnBvcCgpO1xuICB9XG4gIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gKiAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludmVydCBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuICovXG5mdW5jdGlvbiBydHJpbShzdHIsIGMsIGludmVydCkge1xuICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gIGlmIChsID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgdmFyIHN1ZmZMZW4gPSAwO1xuXG4gIC8vIFN0ZXAgbGVmdCB1bnRpbCB3ZSBmYWlsIHRvIG1hdGNoIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICB2YXIgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgIHN1ZmZMZW4rKztcbiAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgc3VmZkxlbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBsIC0gc3VmZkxlbik7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQoc3RyLCBiKSB7XG4gIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICB2YXIgbGV2ZWwgPSAwLFxuICAgIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09ICdcXFxcJykge1xuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICBsZXZlbCsrO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCkge1xuICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHNhbml0aXplIGFuZCBzYW5pdGl6ZXIgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuNy4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9tYXJrZWQuanMub3JnLyMvVVNJTkdfQURWQU5DRUQubWQjb3B0aW9ucycpO1xuICB9XG59XG5cbi8vIGNvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzLzgwNjc3N1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKi9cbmZ1bmN0aW9uIHJlcGVhdFN0cmluZyhwYXR0ZXJuLCBjb3VudCkge1xuICBpZiAoY291bnQgPCAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAnJztcbiAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgIGlmIChjb3VudCAmIDEpIHtcbiAgICAgIHJlc3VsdCArPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBjb3VudCA+Pj0gMTtcbiAgICBwYXR0ZXJuICs9IHBhdHRlcm47XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCArIHBhdHRlcm47XG59XG5cbmZ1bmN0aW9uIG91dHB1dExpbmsoY2FwLCBsaW5rLCByYXcsIGxleGVyKSB7XG4gIHZhciBocmVmID0gbGluay5ocmVmO1xuICB2YXIgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgdmFyIHRleHQgPSBjYXBbMV0ucmVwbGFjZSgvXFxcXChbXFxbXFxdXSkvZywgJyQxJyk7XG4gIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgIHZhciB0b2tlbiA9IHtcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIHJhdzogcmF3LFxuICAgICAgaHJlZjogaHJlZixcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyh0ZXh0KVxuICAgIH07XG4gICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2ltYWdlJyxcbiAgICByYXc6IHJhdyxcbiAgICBocmVmOiBocmVmLFxuICAgIHRpdGxlOiB0aXRsZSxcbiAgICB0ZXh0OiBlc2NhcGUodGV4dClcbiAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcbiAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICByZXR1cm4gdGV4dC5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICBpZiAobWF0Y2hJbmRlbnRJbk5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2YXIgaW5kZW50SW5Ob2RlID0gbWF0Y2hJbmRlbnRJbk5vZGVbMF07XG4gICAgaWYgKGluZGVudEluTm9kZS5sZW5ndGggPj0gaW5kZW50VG9Db2RlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5vZGUuc2xpY2UoaW5kZW50VG9Db2RlLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9KS5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBUb2tlbml6ZXJcbiAqL1xudmFyIFRva2VuaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRva2VuaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBleHBvcnRzLmRlZmF1bHRzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuICBfcHJvdG8uc3BhY2UgPSBmdW5jdGlvbiBzcGFjZShzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwICYmIGNhcFswXS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3BhY2UnLFxuICAgICAgICByYXc6IGNhcFswXVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5jb2RlID0gZnVuY3Rpb24gY29kZShzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBjb2RlQmxvY2tTdHlsZTogJ2luZGVudGVkJyxcbiAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IHJ0cmltKHRleHQsICdcXG4nKSA6IHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZmVuY2VzID0gZnVuY3Rpb24gZmVuY2VzKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmZlbmNlcy5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHJhdyA9IGNhcFswXTtcbiAgICAgIHZhciB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIHJhdzogcmF3LFxuICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogY2FwWzJdLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmhlYWRpbmcgPSBmdW5jdGlvbiBoZWFkaW5nKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciB0ZXh0ID0gY2FwWzJdLnRyaW0oKTtcblxuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgIHZhciB0cmltbWVkID0gcnRyaW0odGV4dCwgJyMnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgfSBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dClcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocihzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2hyJyxcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uYmxvY2txdW90ZSA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPlsgXFx0XT8vZ20sICcnKTtcbiAgICAgIHZhciB0b3AgPSB0aGlzLmxleGVyLnN0YXRlLnRvcDtcbiAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKHRleHQpO1xuICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0b3A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0b2tlbnM6IHRva2VucyxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgcmF3LCBpc3Rhc2ssIGlzY2hlY2tlZCwgaW5kZW50LCBpLCBibGFua0xpbmUsIGVuZHNXaXRoQmxhbmtMaW5lLCBsaW5lLCBuZXh0TGluZSwgcmF3TGluZSwgaXRlbUNvbnRlbnRzLCBlbmRFYXJseTtcbiAgICAgIHZhciBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgIHZhciBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG4gICAgICB2YXIgbGlzdCA9IHtcbiAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICByYXc6ICcnLFxuICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICBpdGVtczogW11cbiAgICAgIH07XG4gICAgICBidWxsID0gaXNvcmRlcmVkID8gXCJcXFxcZHsxLDl9XFxcXFwiICsgYnVsbC5zbGljZSgtMSkgOiBcIlxcXFxcIiArIGJ1bGw7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICB2YXIgaXRlbVJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4oIHswLDN9XCIgKyBidWxsICsgXCIpKCg/OltcXHQgXVteXFxcXG5dKik/KD86XFxcXG58JCkpXCIpO1xuXG4gICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgIGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZXMuYmxvY2suaHIudGVzdChzcmMpKSB7XG4gICAgICAgICAgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmF3ID0gY2FwWzBdO1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhdy5sZW5ndGgpO1xuICAgICAgICBsaW5lID0gY2FwWzJdLnNwbGl0KCdcXG4nLCAxKVswXS5yZXBsYWNlKC9eXFx0Ky8sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuICcgJy5yZXBlYXQoMyAqIHQubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIGluZGVudCA9IDI7XG4gICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltTGVmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuICAgICAgICAgIGluZGVudCA9IGluZGVudCA+IDQgPyAxIDogaW5kZW50OyAvLyBUcmVhdCBpbmRlbnRlZCBjb2RlIGJsb2NrcyAoPiA0IHNwYWNlcykgYXMgaGF2aW5nIG9ubHkgMSBpbmRlbnRcbiAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgaW5kZW50ICs9IGNhcFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYmxhbmtMaW5lID0gZmFsc2U7XG4gICAgICAgIGlmICghbGluZSAmJiAvXiAqJC8udGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAvLyBJdGVtcyBiZWdpbiB3aXRoIGF0IG1vc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKG5leHRMaW5lLmxlbmd0aCArIDEpO1xuICAgICAgICAgIGVuZEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgdmFyIG5leHRCdWxsZXRSZWdleCA9IG5ldyBSZWdFeHAoXCJeIHswLFwiICsgTWF0aC5taW4oMywgaW5kZW50IC0gMSkgKyBcIn0oPzpbKistXXxcXFxcZHsxLDl9Wy4pXSkoKD86WyBcXHRdW15cXFxcbl0qKT8oPzpcXFxcbnwkKSlcIik7XG4gICAgICAgICAgdmFyIGhyUmVnZXggPSBuZXcgUmVnRXhwKFwiXiB7MCxcIiArIE1hdGgubWluKDMsIGluZGVudCAtIDEpICsgXCJ9KCg/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcXFwqICopezMsfSkoPzpcXFxcbit8JClcIik7XG4gICAgICAgICAgdmFyIGZlbmNlc0JlZ2luUmVnZXggPSBuZXcgUmVnRXhwKFwiXiB7MCxcIiArIE1hdGgubWluKDMsIGluZGVudCAtIDEpICsgXCJ9KD86YGBgfH5+filcIik7XG4gICAgICAgICAgdmFyIGhlYWRpbmdCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4gezAsXCIgKyBNYXRoLm1pbigzLCBpbmRlbnQgLSAxKSArIFwifSNcIik7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBmb2xsb3dpbmcgbGluZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIExpc3QgSXRlbVxuICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgIHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgbmV4dExpbmUgPSByYXdMaW5lO1xuXG4gICAgICAgICAgICAvLyBSZS1hbGlnbiB0byBmb2xsb3cgY29tbW9ubWFyayBuZXN0aW5nIHJ1bGVzXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXiB7MSw0fSg/PSggezR9KSpbXiBdKS9nLCAnICAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBjb2RlIGZlbmNlc1xuICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGhlYWRpbmdcbiAgICAgICAgICAgIGlmIChoZWFkaW5nQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgYnVsbGV0XG4gICAgICAgICAgICBpZiAobmV4dEJ1bGxldFJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIHJ1bGUgZm91bmRcbiAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3Qoc3JjKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0TGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIW5leHRMaW5lLnRyaW0oKSkge1xuICAgICAgICAgICAgICAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgaWYgKGJsYW5rTGluZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcGFyYWdyYXBoIGNvbnRpbnVhdGlvbiB1bmxlc3MgbGFzdCBsaW5lIHdhcyBhIGRpZmZlcmVudCBibG9jayBsZXZlbCBlbGVtZW50XG4gICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmRlbnRlZCBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoZWFkaW5nQmVnaW5SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhyUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkge1xuICAgICAgICAgICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhdyArPSByYXdMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhd0xpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBsaW5lID0gbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGl0ZW0gZW5kZWQgd2l0aCBhIGJsYW5rIGxpbmUsIHRoZSBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9cXG4gKlxcbiAqJC8udGVzdChyYXcpKSB7XG4gICAgICAgICAgICBlbmRzV2l0aEJsYW5rTGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgaXNjaGVja2VkID0gaXN0YXNrWzBdICE9PSAnWyBdICc7XG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBpdGVtQ29udGVudHMucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2xpc3RfaXRlbScsXG4gICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgdGFzazogISFpc3Rhc2ssXG4gICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICB0ZXh0OiBpdGVtQ29udGVudHNcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QucmF3ICs9IHJhdztcbiAgICAgIH1cblxuICAgICAgLy8gRG8gbm90IGNvbnN1bWUgbmV3bGluZXMgYXQgZW5kIG9mIGZpbmFsIGl0ZW0uIEFsdGVybmF0aXZlbHksIG1ha2UgaXRlbVJlZ2V4ICpzdGFydCogd2l0aCBhbnkgbmV3bGluZXMgdG8gc2ltcGxpZnkvc3BlZWQgdXAgZW5kc1dpdGhCbGFua0xpbmUgbG9naWNcbiAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS5yYXcgPSByYXcudHJpbVJpZ2h0KCk7XG4gICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dCA9IGl0ZW1Db250ZW50cy50cmltUmlnaHQoKTtcbiAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcudHJpbVJpZ2h0KCk7XG4gICAgICB2YXIgbCA9IGxpc3QuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAvLyBJdGVtIGNoaWxkIHRva2VucyBoYW5kbGVkIGhlcmUgYXQgZW5kIGJlY2F1c2Ugd2UgbmVlZGVkIHRvIGhhdmUgdGhlIGZpbmFsIGl0ZW0gdG8gdHJpbSBpdCBmaXJzdFxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IGZhbHNlO1xuICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG4gICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGxpc3Qgc2hvdWxkIGJlIGxvb3NlXG4gICAgICAgICAgdmFyIHNwYWNlcnMgPSBsaXN0Lml0ZW1zW2ldLnRva2Vucy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnR5cGUgPT09ICdzcGFjZSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGhhc011bHRpcGxlTGluZUJyZWFrcyA9IHNwYWNlcnMubGVuZ3RoID4gMCAmJiBzcGFjZXJzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAvXFxuLipcXG4vLnRlc3QodC5yYXcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxpc3QubG9vc2UgPSBoYXNNdWx0aXBsZUxpbmVCcmVha3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGFsbCBpdGVtcyB0byBsb29zZSBpZiBsaXN0IGlzIGxvb3NlXG4gICAgICBpZiAobGlzdC5sb29zZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGlzdC5pdGVtc1tpXS5sb29zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmh0bWwuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplciAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSk7XG4gICAgICAgIHRva2VuLnR5cGUgPSAncGFyYWdyYXBoJztcbiAgICAgICAgdG9rZW4udGV4dCA9IHRleHQ7XG4gICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmRlZiA9IGZ1bmN0aW9uIGRlZihzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICB2YXIgaHJlZiA9IGNhcFsyXSA/IGNhcFsyXS5yZXBsYWNlKC9ePCguKik+JC8sICckMScpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogJyc7XG4gICAgICB2YXIgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGNhcFszXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXSkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGNcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICByb3dzOiBjYXBbM10gJiYgY2FwWzNdLnRyaW0oKSA/IGNhcFszXS5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0ucmF3ID0gY2FwWzBdO1xuICAgICAgICB2YXIgbCA9IGl0ZW0uYWxpZ24ubGVuZ3RoO1xuICAgICAgICB2YXIgaSwgaiwgaywgcm93O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGl0ZW0ucm93c1tpXSA9IHNwbGl0Q2VsbHMoaXRlbS5yb3dzW2ldLCBpdGVtLmhlYWRlci5sZW5ndGgpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGV4dDogY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIGNoaWxkIHRva2VucyBpbnNpZGUgaGVhZGVycyBhbmQgY2VsbHNcblxuICAgICAgICAvLyBoZWFkZXIgY2hpbGQgdG9rZW5zXG4gICAgICAgIGwgPSBpdGVtLmhlYWRlci5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICBpdGVtLmhlYWRlcltqXS50b2tlbnMgPSB0aGlzLmxleGVyLmlubGluZShpdGVtLmhlYWRlcltqXS50ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNlbGwgY2hpbGQgdG9rZW5zXG4gICAgICAgIGwgPSBpdGVtLnJvd3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgcm93ID0gaXRlbS5yb3dzW2pdO1xuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHJvd1trXS50b2tlbnMgPSB0aGlzLmxleGVyLmlubGluZShyb3dba10udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmxoZWFkaW5nID0gZnVuY3Rpb24gbGhlYWRpbmcoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFsxXSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucGFyYWdyYXBoID0gZnVuY3Rpb24gcGFyYWdyYXBoKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnBhcmFncmFwaC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHRleHQgPSBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbicgPyBjYXBbMV0uc2xpY2UoMCwgLTEpIDogY2FwWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMF0pXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZSQxKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogZXNjYXBlKGNhcFsxXSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8udGFnID0gZnVuY3Rpb24gdGFnKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148XFwvKHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICd0ZXh0JyA6ICdodG1sJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGluTGluazogdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmssXG4gICAgICAgIGluUmF3QmxvY2s6IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayxcbiAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmxpbmsgPSBmdW5jdGlvbiBsaW5rKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICBpZiAoIS8+JC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgIHZhciBydHJpbVNsYXNoID0gcnRyaW0odHJpbW1lZFVybC5zbGljZSgwLCAtMSksICdcXFxcJyk7XG4gICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgdmFyIGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG4gICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgIHZhciBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgY2FwWzJdID0gY2FwWzJdLnN1YnN0cmluZygwLCBsYXN0UGFyZW5JbmRleCk7XG4gICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBocmVmID0gY2FwWzJdO1xuICAgICAgdmFyIHRpdGxlID0gJyc7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIC8vIHNwbGl0IHBlZGFudGljIGhyZWYgYW5kIHRpdGxlXG4gICAgICAgIHZhciBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgIH1cbiAgICAgIGhyZWYgPSBocmVmLnRyaW0oKTtcbiAgICAgIGlmICgvXjwvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAhLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiB0aXRsZVxuICAgICAgfSwgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5yZWZsaW5rID0gZnVuY3Rpb24gcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgdmFyIGNhcDtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnJlZmxpbmsuZXhlYyhzcmMpKSB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHZhciBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwgbGluaywgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5lbVN0cm9uZyA9IGZ1bmN0aW9uIGVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikge1xuICAgIGlmIChwcmV2Q2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICBwcmV2Q2hhciA9ICcnO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgIGlmIChtYXRjaFszXSAmJiBwcmV2Q2hhci5tYXRjaCgvKD86WzAtOUEtWmEtelxceEFBXFx4QjJcXHhCM1xceEI1XFx4QjlcXHhCQVxceEJDLVxceEJFXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1RDAtXFx1MDVFQVxcdTA1RUYtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NjAtXFx1MDY2OVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDMC1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZBXFx1MDg3MC1cXHUwODg3XFx1MDg4OS1cXHUwODhFXFx1MDhBMC1cXHUwOEM5XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlFNi1cXHUwOUYxXFx1MDlGNC1cXHUwOUY5XFx1MDlGQ1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE2RlxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MS1cXHUwQjc3XFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEJFNi1cXHUwQkYyXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNURcXHUwQzYwXFx1MEM2MVxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwNC1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDU4LVxcdTBENjFcXHUwRDY2LVxcdTBENzhcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERFNi1cXHUwREVGXFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg2LVxcdTBFOEFcXHUwRThDLVxcdTBFQTNcXHUwRUE1XFx1MEVBNy1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjIwLVxcdTBGMzNcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGLVxcdTEwNDlcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTA5MC1cXHUxMDk5XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNjktXFx1MTM3Q1xcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcxMVxcdTE3MUYtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTdFMC1cXHUxN0U5XFx1MTdGMC1cXHUxN0Y5XFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNENcXHUxQjUwLVxcdTFCNTlcXHUxQjgzLVxcdTFCQTBcXHUxQkFFLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQzkwLVxcdTFDQkFcXHUxQ0JELVxcdTFDQkZcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTFDRkFcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MFxcdTIwNzFcXHUyMDc0LVxcdTIwNzlcXHUyMDdGLVxcdTIwODlcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE1MC1cXHUyMTg5XFx1MjQ2MC1cXHUyNDlCXFx1MjRFQS1cXHUyNEZGXFx1Mjc3Ni1cXHUyNzkzXFx1MkMwMC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyQ0ZEXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRlxcdTMxMzEtXFx1MzE4RVxcdTMxOTItXFx1MzE5NVxcdTMxQTAtXFx1MzFCRlxcdTMxRjAtXFx1MzFGRlxcdTMyMjAtXFx1MzIyOVxcdTMyNDgtXFx1MzI0RlxcdTMyNTEtXFx1MzI1RlxcdTMyODAtXFx1MzI4OVxcdTMyQjEtXFx1MzJCRlxcdTM0MDAtXFx1NERCRlxcdTRFMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdDQVxcdUE3RDBcXHVBN0QxXFx1QTdEM1xcdUE3RDUtXFx1QTdEOVxcdUE3RjItXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4MzAtXFx1QTgzNVxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RDAtXFx1QThEOVxcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QThGRVxcdUE5MDAtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2OVxcdUFCNzAtXFx1QUJFMlxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdUREMDctXFx1REQzM1xcdURENDAtXFx1REQ3OFxcdUREOEFcXHVERDhCXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMS1cXHVERUZCXFx1REYwMC1cXHVERjIzXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURENzAtXFx1REQ3QVxcdUREN0MtXFx1REQ4QVxcdUREOEMtXFx1REQ5MlxcdUREOTRcXHVERDk1XFx1REQ5Ny1cXHVEREExXFx1RERBMy1cXHVEREIxXFx1RERCMy1cXHVEREI5XFx1RERCQlxcdUREQkNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjdcXHVERjgwLVxcdURGODVcXHVERjg3LVxcdURGQjBcXHVERkIyLVxcdURGQkFdfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNTgtXFx1REM3NlxcdURDNzktXFx1REM5RVxcdURDQTctXFx1RENBRlxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1RENGQi1cXHVERDFCXFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCQy1cXHVERENGXFx1REREMi1cXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTM1XFx1REU0MC1cXHVERTQ4XFx1REU2MC1cXHVERTdFXFx1REU4MC1cXHVERTlGXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REVFQi1cXHVERUVGXFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY1OC1cXHVERjcyXFx1REY3OC1cXHVERjkxXFx1REZBOS1cXHVERkFGXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMlxcdURDRkEtXFx1REQyM1xcdUREMzAtXFx1REQzOVxcdURFNjAtXFx1REU3RVxcdURFODAtXFx1REVBOVxcdURFQjBcXHVERUIxXFx1REYwMC1cXHVERjI3XFx1REYzMC1cXHVERjQ1XFx1REY1MS1cXHVERjU0XFx1REY3MC1cXHVERjgxXFx1REZCMC1cXHVERkNCXFx1REZFMC1cXHVERkY2XXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDNTItXFx1REM2RlxcdURDNzFcXHVEQzcyXFx1REM3NVxcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDMtXFx1REQyNlxcdUREMzYtXFx1REQzRlxcdURENDRcXHVERDQ3XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdURERDAtXFx1REREQVxcdURERENcXHVEREUxLVxcdURERjRcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REVGMC1cXHVERUY5XFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDNTAtXFx1REM1OVxcdURDNUYtXFx1REM2MVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdURDRDAtXFx1RENEOVxcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTUwLVxcdURFNTlcXHVERTgwLVxcdURFQUFcXHVERUI4XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjFBXFx1REYzMC1cXHVERjNCXFx1REY0MC1cXHVERjQ2XXxcXHVEODA2W1xcdURDMDAtXFx1REMyQlxcdURDQTAtXFx1RENGMlxcdURDRkYtXFx1REQwNlxcdUREMDlcXHVERDBDLVxcdUREMTNcXHVERDE1XFx1REQxNlxcdUREMTgtXFx1REQyRlxcdUREM0ZcXHVERDQxXFx1REQ1MC1cXHVERDU5XFx1RERBMC1cXHVEREE3XFx1RERBQS1cXHVEREQwXFx1RERFMVxcdURERTNcXHVERTAwXFx1REUwQi1cXHVERTMyXFx1REUzQVxcdURFNTBcXHVERTVDLVxcdURFODlcXHVERTlEXFx1REVCMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzUwLVxcdURDNkNcXHVEQzcyLVxcdURDOEZcXHVERDAwLVxcdUREMDZcXHVERDA4XFx1REQwOVxcdUREMEItXFx1REQzMFxcdURENDZcXHVERDUwLVxcdURENTlcXHVERDYwLVxcdURENjVcXHVERDY3XFx1REQ2OFxcdURENkEtXFx1REQ4OVxcdUREOThcXHVEREEwLVxcdUREQTlcXHVERUUwLVxcdURFRjJcXHVERkIwXFx1REZDMC1cXHVERkQ0XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFxcdUQ4MEJbXFx1REY5MC1cXHVERkYwXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4MjJcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJcXHVEODc0LVxcdUQ4NzlcXHVEODgwLVxcdUQ4ODNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFNzAtXFx1REVCRVxcdURFQzAtXFx1REVDOVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNUItXFx1REY2MVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERTQwLVxcdURFOTZcXHVERjAwLVxcdURGNEFcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMFxcdURGRTFcXHVERkUzXXxcXHVEODIxW1xcdURDMDAtXFx1REZGN118XFx1RDgyM1tcXHVEQzAwLVxcdURDRDVcXHVERDAwLVxcdUREMDhdfFxcdUQ4MkJbXFx1REZGMC1cXHVERkYzXFx1REZGNS1cXHVERkZCXFx1REZGRFxcdURGRkVdfFxcdUQ4MkNbXFx1REMwMC1cXHVERDIyXFx1REQ1MC1cXHVERDUyXFx1REQ2NC1cXHVERDY3XFx1REQ3MC1cXHVERUZCXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNFtcXHVERUUwLVxcdURFRjNcXHVERjYwLVxcdURGNzhdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzN1tcXHVERjAwLVxcdURGMUVdfFxcdUQ4MzhbXFx1REQwMC1cXHVERDJDXFx1REQzNy1cXHVERDNEXFx1REQ0MC1cXHVERDQ5XFx1REQ0RVxcdURFOTAtXFx1REVBRFxcdURFQzAtXFx1REVFQlxcdURFRjAtXFx1REVGOV18XFx1RDgzOVtcXHVERkUwLVxcdURGRTZcXHVERkU4LVxcdURGRUJcXHVERkVEXFx1REZFRVxcdURGRjAtXFx1REZGRV18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0M3LVxcdURDQ0ZcXHVERDAwLVxcdURENDNcXHVERDRCXFx1REQ1MC1cXHVERDU5XXxcXHVEODNCW1xcdURDNzEtXFx1RENBQlxcdURDQUQtXFx1RENBRlxcdURDQjEtXFx1RENCNFxcdUREMDEtXFx1REQyRFxcdUREMkYtXFx1REQzRFxcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4M0NbXFx1REQwMC1cXHVERDBDXXxcXHVEODNFW1xcdURGRjAtXFx1REZGOV18XFx1RDg2OVtcXHVEQzAwLVxcdURFREZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM4XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFcXHVERUIwLVxcdURGRkZdfFxcdUQ4N0FbXFx1REMwMC1cXHVERkUwXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1RDg4NFtcXHVEQzAwLVxcdURGNEFdKS8pKSByZXR1cm47XG4gICAgdmFyIG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG4gICAgaWYgKCFuZXh0Q2hhciB8fCBuZXh0Q2hhciAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkge1xuICAgICAgdmFyIGxMZW5ndGggPSBtYXRjaFswXS5sZW5ndGggLSAxO1xuICAgICAgdmFyIHJEZWxpbSxcbiAgICAgICAgckxlbmd0aCxcbiAgICAgICAgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsXG4gICAgICAgIG1pZERlbGltVG90YWwgPSAwO1xuICAgICAgdmFyIGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQ7XG4gICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcblxuICAgICAgLy8gQ2xpcCBtYXNrZWRTcmMgdG8gc2FtZSBzZWN0aW9uIG9mIHN0cmluZyBhcyBzcmMgKG1vdmUgdG8gbGV4ZXI/KVxuICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCArIGxMZW5ndGgpO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG4gICAgICAgIGlmICghckRlbGltKSBjb250aW51ZTsgLy8gc2tpcCBzaW5nbGUgKiBpbiBfX2FiYyphYmNfX1xuXG4gICAgICAgIHJMZW5ndGggPSByRGVsaW0ubGVuZ3RoO1xuICAgICAgICBpZiAobWF0Y2hbM10gfHwgbWF0Y2hbNF0pIHtcbiAgICAgICAgICAvLyBmb3VuZCBhbm90aGVyIExlZnQgRGVsaW1cbiAgICAgICAgICBkZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbNV0gfHwgbWF0Y2hbNl0pIHtcbiAgICAgICAgICAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgaWYgKGRlbGltVG90YWwgPiAwKSBjb250aW51ZTsgLy8gSGF2ZW4ndCBmb3VuZCBlbm91Z2ggY2xvc2luZyBkZWxpbWl0ZXJzXG5cbiAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIGNoYXJhY3RlcnMuICphKioqIC0+ICphKlxuICAgICAgICByTGVuZ3RoID0gTWF0aC5taW4ockxlbmd0aCwgckxlbmd0aCArIGRlbGltVG90YWwgKyBtaWREZWxpbVRvdGFsKTtcbiAgICAgICAgdmFyIHJhdyA9IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyAobWF0Y2hbMF0ubGVuZ3RoIC0gckRlbGltLmxlbmd0aCkgKyByTGVuZ3RoKTtcblxuICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICBpZiAoTWF0aC5taW4obExlbmd0aCwgckxlbmd0aCkgJSAyKSB7XG4gICAgICAgICAgdmFyIF90ZXh0ID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2VtJyxcbiAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgdGV4dDogX3RleHQsXG4gICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKF90ZXh0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICB2YXIgdGV4dCA9IHJhdy5zbGljZSgyLCAtMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3N0cm9uZycsXG4gICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3BhbihzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICB2YXIgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgdmFyIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gL14gLy50ZXN0KHRleHQpICYmIC8gJC8udGVzdCh0ZXh0KTtcbiAgICAgIGlmIChoYXNOb25TcGFjZUNoYXJzICYmIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgdGV4dCA9IGVzY2FwZSh0ZXh0LCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb2Rlc3BhbicsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYnInLFxuICAgICAgICByYXc6IGNhcFswXVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5hdXRvbGluayA9IGZ1bmN0aW9uIGF1dG9saW5rKHNyYywgbWFuZ2xlKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmF1dG9saW5rLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgdGV4dCwgaHJlZjtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzFdKSA6IGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgdmFyIGNhcDtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgdmFyIHRleHQsIGhyZWY7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICB2YXIgcHJldkNhcFplcm87XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBwcmV2Q2FwWmVybyA9IGNhcFswXTtcbiAgICAgICAgICBjYXBbMF0gPSB0aGlzLnJ1bGVzLmlubGluZS5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKVswXTtcbiAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgaHJlZiA9ICdodHRwOi8vJyArIGNhcFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBocmVmID0gY2FwWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICB0b2tlbnM6IFt7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmlubGluZVRleHQgPSBmdW5jdGlvbiBpbmxpbmVUZXh0KHNyYywgc21hcnR5cGFudHMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHRleHQ7XG4gICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSkgOiBjYXBbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5zbWFydHlwYW50cyA/IHNtYXJ0eXBhbnRzKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBUb2tlbml6ZXI7XG59KCk7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG52YXIgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICBmZW5jZXM6IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSooPzpcXG58JCkpfH57Myx9KShbXlxcbl0qKSg/OlxcbnwkKSg/OnwoW1xcc1xcU10qPykoPzpcXG58JCkpKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS8sXG4gIGhyOiAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICBsaXN0OiAvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLyxcbiAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICArICd8Y29tbWVudFteXFxcXG5dKihcXFxcbit8JCknIC8vICgyKVxuICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICsgJ3w8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/KD86XFxcXF1cXFxcXT5cXFxcbip8JCknIC8vICg1KVxuICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICsgJ3w8KD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgY2xvc2luZyB0YWdcbiAgKyAnKScsXG4gIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuICopPyhbXjxcXHNdW15cXHNdKnw8Lio/PikoPzooPzogKyg/OlxcbiAqKT98ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcFRlc3QsXG4gIGxoZWFkaW5nOiAvXigoPzoufFxcbig/IVxcbikpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHx0YWJsZXwgK1xcbilbXlxcbl0rKSopLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcbmJsb2NrLl9sYWJlbCA9IC8oPyFcXHMqXFxdKSg/OlxcXFwufFteXFxbXFxdXFxcXF0pKy87XG5ibG9jay5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuYmxvY2suZGVmID0gZWRpdChibG9jay5kZWYpLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKS5yZXBsYWNlKCd0aXRsZScsIGJsb2NrLl90aXRsZSkuZ2V0UmVnZXgoKTtcbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVsuKV0pLztcbmJsb2NrLmxpc3RJdGVtU3RhcnQgPSBlZGl0KC9eKCAqKShidWxsKSAqLykucmVwbGFjZSgnYnVsbCcsIGJsb2NrLmJ1bGxldCkuZ2V0UmVnZXgoKTtcbmJsb2NrLmxpc3QgPSBlZGl0KGJsb2NrLmxpc3QpLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KS5yZXBsYWNlKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzooPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpKScpLnJlcGxhY2UoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJykuZ2V0UmVnZXgoKTtcbmJsb2NrLl90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbicgKyAnfGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEtNl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWUnICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJyArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJyArICd8dHJhY2t8dWwnO1xuYmxvY2suX2NvbW1lbnQgPSAvPCEtLSg/IS0/PilbXFxzXFxTXSo/KD86LS0+fCQpLztcbmJsb2NrLmh0bWwgPSBlZGl0KGJsb2NrLmh0bWwsICdpJykucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKS5nZXRSZWdleCgpO1xuYmxvY2sucGFyYWdyYXBoID0gZWRpdChibG9jay5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrLmhyKS5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKS5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXggaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuLnJlcGxhY2UoJ3x0YWJsZScsICcnKS5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4uZ2V0UmVnZXgoKTtcbmJsb2NrLmJsb2NrcXVvdGUgPSBlZGl0KGJsb2NrLmJsb2NrcXVvdGUpLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaCkuZ2V0UmVnZXgoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IF9leHRlbmRzKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBfZXh0ZW5kcyh7fSwgYmxvY2subm9ybWFsLCB7XG4gIHRhYmxlOiAnXiAqKFteXFxcXG4gXS4qXFxcXHwuKilcXFxcbicgLy8gSGVhZGVyXG4gICsgJyB7MCwzfSg/OlxcXFx8ICopPyg6Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKSg/OlxcXFx8ICopPycgLy8gQWxpZ25cbiAgKyAnKD86XFxcXG4oKD86KD8hICpcXFxcbnxocnxoZWFkaW5nfGJsb2NrcXVvdGV8Y29kZXxmZW5jZXN8bGlzdHxodG1sKS4qKD86XFxcXG58JCkpKilcXFxcbip8JCknIC8vIENlbGxzXG59KTtcblxuYmxvY2suZ2ZtLnRhYmxlID0gZWRpdChibG9jay5nZm0udGFibGUpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbi5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKS5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyB0YWJsZXMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4uZ2V0UmVnZXgoKTtcbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4ucmVwbGFjZSgndGFibGUnLCBibG9jay5nZm0udGFibGUpIC8vIGludGVycnVwdCBwYXJhZ3JhcGhzIHdpdGggdGFibGVcbi5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4uZ2V0UmVnZXgoKTtcbi8qKlxuICogUGVkYW50aWMgZ3JhbW1hciAob3JpZ2luYWwgSm9obiBHcnViZXIncyBsb29zZSBtYXJrZG93biBzcGVjaWZpY2F0aW9uKVxuICovXG5cbmJsb2NrLnBlZGFudGljID0gX2V4dGVuZHMoe30sIGJsb2NrLm5vcm1hbCwge1xuICBodG1sOiBlZGl0KCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKScgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpLnJlcGxhY2UoL3RhZy9nLCAnKD8hKD86JyArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZXx2YXJ8c2FtcHxrYmR8c3ViJyArICd8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKScgKyAnXFxcXGIpXFxcXHcrKD8hOnxbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJykuZ2V0UmVnZXgoKSxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gIGZlbmNlczogbm9vcFRlc3QsXG4gIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gIGxoZWFkaW5nOiAvXiguKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogZWRpdChibG9jay5ub3JtYWwuX3BhcmFncmFwaCkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJykucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnfGZlbmNlcycsICcnKS5yZXBsYWNlKCd8bGlzdCcsICcnKS5yZXBsYWNlKCd8aHRtbCcsICcnKS5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvLFxuICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgdXJsOiBub29wVGVzdCxcbiAgdGFnOiAnXmNvbW1lbnQnICsgJ3xePC9bYS16QS1aXVtcXFxcdzotXSpcXFxccyo+JyAvLyBzZWxmLWNsb3NpbmcgdGFnXG4gICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICsgJ3xePCFbYS16QS1aXStcXFxcc1tcXFxcc1xcXFxTXSo/PicgLy8gZGVjbGFyYXRpb24sIGUuZy4gPCFET0NUWVBFIGh0bWw+XG4gICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JyxcbiAgLy8gQ0RBVEEgc2VjdGlvblxuICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LyxcbiAgcmVmbGlua1NlYXJjaDogJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJyxcbiAgZW1TdHJvbmc6IHtcbiAgICBsRGVsaW06IC9eKD86XFwqKyg/OihbcHVuY3RfXSl8W15cXHMqXSkpfF5fKyg/OihbcHVuY3QqXSl8KFteXFxzX10pKS8sXG4gICAgLy8gICAgICAgICgxKSBhbmQgKDIpIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyLiAoMykgYW5kICg0KSBjYW4gb25seSBiZSBMZWZ0LiAgKDUpIGFuZCAoNikgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0LlxuICAgIC8vICAgICAgICAgICgpIFNraXAgb3JwaGFuIGluc2lkZSBzdHJvbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpIENvbnN1bWUgdG8gZGVsaW0gICAgICgxKSAjKioqICAgICAgICAgICAgICAgICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDMpICMqKiphLCAqKiphICAgICAgICAgICAgICAgICAoNCkgKioqIyAgICAgICAgICAgICAgKDUpICMqKiojICAgICAgICAgICAgICAgICAoNikgYSoqKmFcbiAgICByRGVsaW1Bc3Q6IC9eKD86W15fKlxcXFxdfFxcXFwuKSo/XFxfXFxfKD86W15fKlxcXFxdfFxcXFwuKSo/XFwqKD86W15fKlxcXFxdfFxcXFwuKSo/KD89XFxfXFxfKXwoPzpbXipcXFxcXXxcXFxcLikrKD89W14qXSl8W3B1bmN0X10oXFwqKykoPz1bXFxzXXwkKXwoPzpbXnB1bmN0Kl9cXHNcXFxcXXxcXFxcLikoXFwqKykoPz1bcHVuY3RfXFxzXXwkKXxbcHVuY3RfXFxzXShcXCorKSg/PVtecHVuY3QqX1xcc10pfFtcXHNdKFxcKispKD89W3B1bmN0X10pfFtwdW5jdF9dKFxcKispKD89W3B1bmN0X10pfCg/OltecHVuY3QqX1xcc1xcXFxdfFxcXFwuKShcXCorKSg/PVtecHVuY3QqX1xcc10pLyxcbiAgICByRGVsaW1VbmQ6IC9eKD86W15fKlxcXFxdfFxcXFwuKSo/XFwqXFwqKD86W15fKlxcXFxdfFxcXFwuKSo/XFxfKD86W15fKlxcXFxdfFxcXFwuKSo/KD89XFwqXFwqKXwoPzpbXl9cXFxcXXxcXFxcLikrKD89W15fXSl8W3B1bmN0Kl0oXFxfKykoPz1bXFxzXXwkKXwoPzpbXnB1bmN0Kl9cXHNcXFxcXXxcXFxcLikoXFxfKykoPz1bcHVuY3QqXFxzXXwkKXxbcHVuY3QqXFxzXShcXF8rKSg/PVtecHVuY3QqX1xcc10pfFtcXHNdKFxcXyspKD89W3B1bmN0Kl0pfFtwdW5jdCpdKFxcXyspKD89W3B1bmN0Kl0pLyAvLyBeLSBOb3QgYWxsb3dlZCBmb3IgX1xuICB9LFxuXG4gIGNvZGU6IC9eKGArKShbXmBdfFteYF1bXFxzXFxTXSo/W15gXSlcXDEoPyFgKS8sXG4gIGJyOiAvXiggezIsfXxcXFxcKVxcbig/IVxccyokKS8sXG4gIGRlbDogbm9vcFRlc3QsXG4gIHRleHQ6IC9eKGArfFteYF0pKD86KD89IHsyLH1cXG4pfFtcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCpfXXxcXGJffCQpfFteIF0oPz0gezIsfVxcbikpKS8sXG4gIHB1bmN0dWF0aW9uOiAvXihbXFxzcHVuY3R1YXRpb25dKS9cbn07XG5cbi8vIGxpc3Qgb2YgcHVuY3R1YXRpb24gbWFya3MgZnJvbSBDb21tb25NYXJrIHNwZWNcbi8vIHdpdGhvdXQgKiBhbmQgXyB0byBoYW5kbGUgdGhlIGRpZmZlcmVudCBlbXBoYXNpcyBtYXJrZXJzICogYW5kIF9cbmlubGluZS5fcHVuY3R1YXRpb24gPSAnIVwiIyQlJlxcJygpK1xcXFwtLiwvOjs8PT4/QFxcXFxbXFxcXF1gXnt8fX4nO1xuaW5saW5lLnB1bmN0dWF0aW9uID0gZWRpdChpbmxpbmUucHVuY3R1YXRpb24pLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG5cbi8vIHNlcXVlbmNlcyBlbSBzaG91bGQgc2tpcCBvdmVyIFt0aXRsZV0obGluayksIGBjb2RlYCwgPGh0bWw+XG5pbmxpbmUuYmxvY2tTa2lwID0gL1xcW1teXFxdXSo/XFxdXFwoW15cXCldKj9cXCl8YFteYF0qP2B8PFtePl0qPz4vZztcbi8vIGxvb2tiZWhpbmQgaXMgbm90IGF2YWlsYWJsZSBvbiBTYWZhcmkgYXMgb2YgdmVyc2lvbiAxNlxuLy8gaW5saW5lLmVzY2FwZWRFbVN0ID0gLyg/PD0oPzpefFteXFxcXCkoPzpcXFxcW15dKSopXFxcXFsqX10vZztcbmlubGluZS5lc2NhcGVkRW1TdCA9IC8oPzpefFteXFxcXF0pKD86XFxcXFxcXFwpKlxcXFxbKl9dL2c7XG5pbmxpbmUuX2NvbW1lbnQgPSBlZGl0KGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5sRGVsaW0gPSBlZGl0KGlubGluZS5lbVN0cm9uZy5sRGVsaW0pLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0ID0gZWRpdChpbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0LCAnZycpLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kID0gZWRpdChpbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2VzY2FwZXMgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvZztcbmlubGluZS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuaW5saW5lLl9lbWFpbCA9IC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvO1xuaW5saW5lLmF1dG9saW5rID0gZWRpdChpbmxpbmUuYXV0b2xpbmspLnJlcGxhY2UoJ3NjaGVtZScsIGlubGluZS5fc2NoZW1lKS5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcbmlubGluZS50YWcgPSBlZGl0KGlubGluZS50YWcpLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZS5fYXR0cmlidXRlKS5nZXRSZWdleCgpO1xuaW5saW5lLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG5pbmxpbmUuX2hyZWYgPSAvPCg/OlxcXFwufFteXFxuPD5cXFxcXSkrPnxbXlxcc1xceDAwLVxceDFmXSovO1xuaW5saW5lLl90aXRsZSA9IC9cIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnKD86XFxcXCc/fFteJ1xcXFxdKSonfFxcKCg/OlxcXFxcXCk/fFteKVxcXFxdKSpcXCkvO1xuaW5saW5lLmxpbmsgPSBlZGl0KGlubGluZS5saW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSkuZ2V0UmVnZXgoKTtcbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKS5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpLmdldFJlZ2V4KCk7XG5pbmxpbmUubm9saW5rID0gZWRpdChpbmxpbmUubm9saW5rKS5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpLmdldFJlZ2V4KCk7XG5pbmxpbmUucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJykucmVwbGFjZSgncmVmbGluaycsIGlubGluZS5yZWZsaW5rKS5yZXBsYWNlKCdub2xpbmsnLCBpbmxpbmUubm9saW5rKS5nZXRSZWdleCgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBfZXh0ZW5kcyh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IF9leHRlbmRzKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzoge1xuICAgIHN0YXJ0OiAvXl9ffFxcKlxcKi8sXG4gICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICBlbmRBc3Q6IC9cXCpcXCooPyFcXCopL2csXG4gICAgZW5kVW5kOiAvX18oPyFfKS9nXG4gIH0sXG4gIGVtOiB7XG4gICAgc3RhcnQ6IC9eX3xcXCovLFxuICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgZW5kQXN0OiAvXFwqKD8hXFwqKS9nLFxuICAgIGVuZFVuZDogL18oPyFfKS9nXG4gIH0sXG4gIGxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXCgoLio/KVxcKS8pLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkuZ2V0UmVnZXgoKSxcbiAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLmdldFJlZ2V4KClcbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBfZXh0ZW5kcyh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IGVkaXQoaW5saW5lLmVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypfJ1wifigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypfJ1wifildKyg/ISQpKSsvLFxuICBkZWw6IC9eKH5+PykoPz1bXlxcc35dKShbXFxzXFxTXSo/W15cXHN+XSlcXDEoPz1bXn5dfCQpLyxcbiAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn0pO1xuaW5saW5lLmdmbS51cmwgPSBlZGl0KGlubGluZS5nZm0udXJsLCAnaScpLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLmdmbS5fZXh0ZW5kZWRfZW1haWwpLmdldFJlZ2V4KCk7XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IF9leHRlbmRzKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gIGJyOiBlZGl0KGlubGluZS5icikucmVwbGFjZSgnezIsfScsICcqJykuZ2V0UmVnZXgoKSxcbiAgdGV4dDogZWRpdChpbmxpbmUuZ2ZtLnRleHQpLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpLnJlcGxhY2UoL1xcezIsXFx9L2csICcqJykuZ2V0UmVnZXgoKVxufSk7XG5cbi8qKlxuICogc21hcnR5cGFudHMgdGV4dCByZXBsYWNlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqL1xuZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAvLyBlbS1kYXNoZXNcbiAgLnJlcGxhY2UoLy0tLS9nLCBcIlxcdTIwMTRcIilcbiAgLy8gZW4tZGFzaGVzXG4gIC5yZXBsYWNlKC8tLS9nLCBcIlxcdTIwMTNcIilcbiAgLy8gb3BlbmluZyBzaW5nbGVzXG4gIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCBcIiQxXFx1MjAxOFwiKVxuICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAucmVwbGFjZSgvJy9nLCBcIlxcdTIwMTlcIilcbiAgLy8gb3BlbmluZyBkb3VibGVzXG4gIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCBcIiQxXFx1MjAxQ1wiKVxuICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgLnJlcGxhY2UoL1wiL2csIFwiXFx1MjAxRFwiKVxuICAvLyBlbGxpcHNlc1xuICAucmVwbGFjZSgvXFwuezN9L2csIFwiXFx1MjAyNlwiKTtcbn1cblxuLyoqXG4gKiBtYW5nbGUgZW1haWwgYWRkcmVzc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICovXG5mdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICB2YXIgb3V0ID0gJycsXG4gICAgaSxcbiAgICBjaDtcbiAgdmFyIGwgPSB0ZXh0Lmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cbnZhciBMZXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGV4cG9ydHMuZGVmYXVsdHM7XG4gICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcigpO1xuICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMudG9rZW5pemVyLmxleGVyID0gdGhpcztcbiAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGluTGluazogZmFsc2UsXG4gICAgICBpblJhd0Jsb2NrOiBmYWxzZSxcbiAgICAgIHRvcDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIHJ1bGVzID0ge1xuICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgIGlubGluZTogaW5saW5lLm5vcm1hbFxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5wZWRhbnRpYztcbiAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2suZ2ZtO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmJyZWFrcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5nZm07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlIFJ1bGVzXG4gICAqL1xuICAvKipcbiAgICogU3RhdGljIExleCBNZXRob2RcbiAgICovXG4gIExleGVyLmxleCA9IGZ1bmN0aW9uIGxleChzcmMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBMZXggSW5saW5lIE1ldGhvZFxuICAgKi87XG4gIExleGVyLmxleElubGluZSA9IGZ1bmN0aW9uIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIGxleGVyLmlubGluZVRva2VucyhzcmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXByb2Nlc3NpbmdcbiAgICovO1xuICB2YXIgX3Byb3RvID0gTGV4ZXIucHJvdG90eXBlO1xuICBfcHJvdG8ubGV4ID0gZnVuY3Rpb24gbGV4KHNyYykge1xuICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKTtcbiAgICB0aGlzLmJsb2NrVG9rZW5zKHNyYywgdGhpcy50b2tlbnMpO1xuICAgIHZhciBuZXh0O1xuICAgIHdoaWxlIChuZXh0ID0gdGhpcy5pbmxpbmVRdWV1ZS5zaGlmdCgpKSB7XG4gICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogTGV4aW5nXG4gICAqLztcbiAgX3Byb3RvLmJsb2NrVG9rZW5zID0gZnVuY3Rpb24gYmxvY2tUb2tlbnMoc3JjLCB0b2tlbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdG9rZW5zID0gW107XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9eKCAqKShcXHQrKS9nbSwgZnVuY3Rpb24gKF8sIGxlYWRpbmcsIHRhYnMpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgKyAnICAgICcucmVwZWF0KHRhYnMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZDtcbiAgICB3aGlsZSAoc3JjKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuYmxvY2sgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuYmxvY2suc29tZShmdW5jdGlvbiAoZXh0VG9rZW5pemVyKSB7XG4gICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHtcbiAgICAgICAgICBsZXhlcjogX3RoaXNcbiAgICAgICAgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG5ld2xpbmVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnNwYWNlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgc2luZ2xlIFxcbiBhcyBhIHNwYWNlciwgaXQncyB0ZXJtaW5hdGluZyB0aGUgbGFzdCBsaW5lLFxuICAgICAgICAgIC8vIHNvIG1vdmUgaXQgdGhlcmUgc28gdGhhdCB3ZSBkb24ndCBnZXQgdW5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ucmF3ICs9ICdcXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29kZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIEFuIGluZGVudGVkIGNvZGUgYmxvY2sgY2Fubm90IGludGVycnVwdCBhIHBhcmFncmFwaC5cbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmVuY2VzXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5mZW5jZXMoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBoZWFkaW5nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaHJcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYmxvY2txdW90ZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYmxvY2txdW90ZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGxpc3RcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBodG1sXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVmXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWYoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgIHRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10gPSB7XG4gICAgICAgICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGFibGUgKGdmbSlcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbGhlYWRpbmdcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgICAgLy8gcHJldmVudCBwYXJhZ3JhcGggY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgdmFyIHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgdmFyIHRlbXBTdGFydCA9IHZvaWQgMDtcbiAgICAgICAgICBfdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jay5mb3JFYWNoKGZ1bmN0aW9uIChnZXRTdGFydEluZGV4KSB7XG4gICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoe1xuICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RQYXJhZ3JhcGhDbGlwcGVkICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IGN1dFNyYy5sZW5ndGggIT09IHNyYy5sZW5ndGg7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXh0XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50ZXh0KHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNyYykge1xuICAgICAgICB2YXIgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcbiAgX3Byb3RvLmlubGluZSA9IGZ1bmN0aW9uIGlubGluZShzcmMsIHRva2Vucykge1xuICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdG9rZW5zID0gW107XG4gICAgfVxuICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7XG4gICAgICBzcmM6IHNyYyxcbiAgICAgIHRva2VuczogdG9rZW5zXG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAqLztcbiAgX3Byb3RvLmlubGluZVRva2VucyA9IGZ1bmN0aW9uIGlubGluZVRva2VucyhzcmMsIHRva2Vucykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdG9rZW5zID0gW107XG4gICAgfVxuICAgIHZhciB0b2tlbiwgbGFzdFRva2VuLCBjdXRTcmM7XG5cbiAgICAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuICAgIHZhciBtYXNrZWRTcmMgPSBzcmM7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBrZWVwUHJldkNoYXIsIHByZXZDaGFyO1xuXG4gICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgIHZhciBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcbiAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gTWFzayBvdXQgZXNjYXBlZCBlbSAmIHN0cm9uZyBkZWxpbWl0ZXJzXG4gICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJysrJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuZXNjYXBlZEVtU3QubGFzdEluZGV4KTtcbiAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5sYXN0SW5kZXgtLTtcbiAgICB9XG4gICAgd2hpbGUgKHNyYykge1xuICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgIH1cbiAgICAgIGtlZXBQcmV2Q2hhciA9IGZhbHNlO1xuXG4gICAgICAvLyBleHRlbnNpb25zXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuaW5saW5lICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKGZ1bmN0aW9uIChleHRUb2tlbml6ZXIpIHtcbiAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoe1xuICAgICAgICAgIGxleGVyOiBfdGhpczJcbiAgICAgICAgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGVzY2FwZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGFnXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWcoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGxpbmtcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpbmsoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnJlZmxpbmsoc3JjLCB0aGlzLnRva2Vucy5saW5rcykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBlbSAmIHN0cm9uZ1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb2RlXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGJyXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5icihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlbCAoZ2ZtKVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYXV0b2xpbmtcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYywgbWFuZ2xlKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB1cmwgKGdmbSlcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5pbkxpbmsgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudXJsKHNyYywgbWFuZ2xlKSkpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGV4dFxuICAgICAgLy8gcHJldmVudCBpbmxpbmVUZXh0IGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICB2YXIgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICB2YXIgdGVtcFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgIF90aGlzMi5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUuZm9yRWFjaChmdW5jdGlvbiAoZ2V0U3RhcnRJbmRleCkge1xuICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHtcbiAgICAgICAgICAgICAgbGV4ZXI6IHRoaXNcbiAgICAgICAgICAgIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYywgc21hcnR5cGFudHMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHtcbiAgICAgICAgICAvLyBUcmFjayBwcmV2Q2hhciBiZWZvcmUgc3RyaW5nIG9mIF9fX18gc3RhcnRlZFxuICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBrZWVwUHJldkNoYXIgPSB0cnVlO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKExleGVyLCBudWxsLCBbe1xuICAgIGtleTogXCJydWxlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmxvY2s6IGJsb2NrLFxuICAgICAgICBpbmxpbmU6IGlubGluZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExleGVyO1xufSgpO1xuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cbnZhciBSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGV4cG9ydHMuZGVmYXVsdHM7XG4gIH1cbiAgdmFyIF9wcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLmNvZGUgPSBmdW5jdGlvbiBjb2RlKF9jb2RlLCBpbmZvc3RyaW5nLCBlc2NhcGVkKSB7XG4gICAgdmFyIGxhbmcgPSAoaW5mb3N0cmluZyB8fCAnJykubWF0Y2goL1xcUyovKVswXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoX2NvZGUsIGxhbmcpO1xuICAgICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gX2NvZGUpIHtcbiAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIF9jb2RlID0gb3V0O1xuICAgICAgfVxuICAgIH1cbiAgICBfY29kZSA9IF9jb2RlLnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcbiAgICBpZiAoIWxhbmcpIHtcbiAgICAgIHJldHVybiAnPHByZT48Y29kZT4nICsgKGVzY2FwZWQgPyBfY29kZSA6IGVzY2FwZShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXggKyBlc2NhcGUobGFuZykgKyAnXCI+JyArIChlc2NhcGVkID8gX2NvZGUgOiBlc2NhcGUoX2NvZGUsIHRydWUpKSArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVvdGVcbiAgICovO1xuICBfcHJvdG8uYmxvY2txdW90ZSA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUocXVvdGUpIHtcbiAgICByZXR1cm4gXCI8YmxvY2txdW90ZT5cXG5cIiArIHF1b3RlICsgXCI8L2Jsb2NrcXVvdGU+XFxuXCI7XG4gIH07XG4gIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbChfaHRtbCkge1xuICAgIHJldHVybiBfaHRtbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd1xuICAgKiBAcGFyYW0ge2FueX0gc2x1Z2dlclxuICAgKi87XG4gIF9wcm90by5oZWFkaW5nID0gZnVuY3Rpb24gaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3LCBzbHVnZ2VyKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJJZHMpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXggKyBzbHVnZ2VyLnNsdWcocmF3KTtcbiAgICAgIHJldHVybiBcIjxoXCIgKyBsZXZlbCArIFwiIGlkPVxcXCJcIiArIGlkICsgXCJcXFwiPlwiICsgdGV4dCArIFwiPC9oXCIgKyBsZXZlbCArIFwiPlxcblwiO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBJRHNcbiAgICByZXR1cm4gXCI8aFwiICsgbGV2ZWwgKyBcIj5cIiArIHRleHQgKyBcIjwvaFwiICsgbGV2ZWwgKyBcIj5cXG5cIjtcbiAgfTtcbiAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG4gIH07XG4gIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgc3RhcnRhdHQgPSBvcmRlcmVkICYmIHN0YXJ0ICE9PSAxID8gJyBzdGFydD1cIicgKyBzdGFydCArICdcIicgOiAnJztcbiAgICByZXR1cm4gJzwnICsgdHlwZSArIHN0YXJ0YXR0ICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqLztcbiAgX3Byb3RvLmxpc3RpdGVtID0gZnVuY3Rpb24gbGlzdGl0ZW0odGV4dCkge1xuICAgIHJldHVybiBcIjxsaT5cIiArIHRleHQgKyBcIjwvbGk+XFxuXCI7XG4gIH07XG4gIF9wcm90by5jaGVja2JveCA9IGZ1bmN0aW9uIGNoZWNrYm94KGNoZWNrZWQpIHtcbiAgICByZXR1cm4gJzxpbnB1dCAnICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJykgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIicgKyAodGhpcy5vcHRpb25zLnhodG1sID8gJyAvJyA6ICcnKSArICc+ICc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovO1xuICBfcHJvdG8ucGFyYWdyYXBoID0gZnVuY3Rpb24gcGFyYWdyYXBoKHRleHQpIHtcbiAgICByZXR1cm4gXCI8cD5cIiArIHRleHQgKyBcIjwvcD5cXG5cIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAqLztcbiAgX3Byb3RvLnRhYmxlID0gZnVuY3Rpb24gdGFibGUoaGVhZGVyLCBib2R5KSB7XG4gICAgaWYgKGJvZHkpIGJvZHkgPSBcIjx0Ym9keT5cIiArIGJvZHkgKyBcIjwvdGJvZHk+XCI7XG4gICAgcmV0dXJuICc8dGFibGU+XFxuJyArICc8dGhlYWQ+XFxuJyArIGhlYWRlciArICc8L3RoZWFkPlxcbicgKyBib2R5ICsgJzwvdGFibGU+XFxuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi87XG4gIF9wcm90by50YWJsZXJvdyA9IGZ1bmN0aW9uIHRhYmxlcm93KGNvbnRlbnQpIHtcbiAgICByZXR1cm4gXCI8dHI+XFxuXCIgKyBjb250ZW50ICsgXCI8L3RyPlxcblwiO1xuICB9O1xuICBfcHJvdG8udGFibGVjZWxsID0gZnVuY3Rpb24gdGFibGVjZWxsKGNvbnRlbnQsIGZsYWdzKSB7XG4gICAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgICB2YXIgdGFnID0gZmxhZ3MuYWxpZ24gPyBcIjxcIiArIHR5cGUgKyBcIiBhbGlnbj1cXFwiXCIgKyBmbGFncy5hbGlnbiArIFwiXFxcIj5cIiA6IFwiPFwiICsgdHlwZSArIFwiPlwiO1xuICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgKFwiPC9cIiArIHR5cGUgKyBcIj5cXG5cIik7XG4gIH1cblxuICAvKipcbiAgICogc3BhbiBsZXZlbCByZW5kZXJlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi87XG4gIF9wcm90by5zdHJvbmcgPSBmdW5jdGlvbiBzdHJvbmcodGV4dCkge1xuICAgIHJldHVybiBcIjxzdHJvbmc+XCIgKyB0ZXh0ICsgXCI8L3N0cm9uZz5cIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi87XG4gIF9wcm90by5lbSA9IGZ1bmN0aW9uIGVtKHRleHQpIHtcbiAgICByZXR1cm4gXCI8ZW0+XCIgKyB0ZXh0ICsgXCI8L2VtPlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqLztcbiAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgIHJldHVybiBcIjxjb2RlPlwiICsgdGV4dCArIFwiPC9jb2RlPlwiO1xuICB9O1xuICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+JztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi87XG4gIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgIHJldHVybiBcIjxkZWw+XCIgKyB0ZXh0ICsgXCI8L2RlbD5cIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovO1xuICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICBocmVmID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG4gICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgfVxuICAgIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWZcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqLztcbiAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICBocmVmID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG4gICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2YXIgb3V0ID0gXCI8aW1nIHNyYz1cXFwiXCIgKyBocmVmICsgXCJcXFwiIGFsdD1cXFwiXCIgKyB0ZXh0ICsgXCJcXFwiXCI7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBvdXQgKz0gXCIgdGl0bGU9XFxcIlwiICsgdGl0bGUgKyBcIlxcXCJcIjtcbiAgICB9XG4gICAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbiAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgcmV0dXJuIF90ZXh0O1xuICB9O1xuICByZXR1cm4gUmVuZGVyZXI7XG59KCk7XG5cbi8qKlxuICogVGV4dFJlbmRlcmVyXG4gKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAqL1xudmFyIFRleHRSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRleHRSZW5kZXJlcigpIHt9XG4gIHZhciBfcHJvdG8gPSBUZXh0UmVuZGVyZXIucHJvdG90eXBlO1xuICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG4gIF9wcm90by5lbSA9IGZ1bmN0aW9uIGVtKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgcmV0dXJuIF90ZXh0O1xuICB9O1xuICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICByZXR1cm4gJycgKyB0ZXh0O1xuICB9O1xuICBfcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH07XG4gIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgIHJldHVybiAnJztcbiAgfTtcbiAgcmV0dXJuIFRleHRSZW5kZXJlcjtcbn0oKTtcblxuLyoqXG4gKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAqL1xudmFyIFNsdWdnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTbHVnZ2VyKCkge1xuICAgIHRoaXMuc2VlbiA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgdmFyIF9wcm90byA9IFNsdWdnZXIucHJvdG90eXBlO1xuICBfcHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpXG4gICAgLy8gcmVtb3ZlIGh0bWwgdGFnc1xuICAgIC5yZXBsYWNlKC88WyFcXC9hLXpdLio/Pi9pZywgJycpXG4gICAgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgLnJlcGxhY2UoL1tcXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0ZcXFxcJyFcIiMkJSYoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJy0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgbmV4dCBzYWZlICh1bmlxdWUpIHNsdWcgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5hbFNsdWdcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0RyeVJ1blxuICAgKi87XG4gIF9wcm90by5nZXROZXh0U2FmZVNsdWcgPSBmdW5jdGlvbiBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgIHZhciBzbHVnID0gb3JpZ2luYWxTbHVnO1xuICAgIHZhciBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IDA7XG4gICAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcbiAgICAgIGRvIHtcbiAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IrKztcbiAgICAgICAgc2x1ZyA9IG9yaWdpbmFsU2x1ZyArICctJyArIG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgfSB3aGlsZSAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKTtcbiAgICB9XG4gICAgaWYgKCFpc0RyeVJ1bikge1xuICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzbHVnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZHJ5cnVuXSBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dFxuICAgKiB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAqLztcbiAgX3Byb3RvLnNsdWcgPSBmdW5jdGlvbiBzbHVnKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgc2x1ZyA9IHRoaXMuc2VyaWFsaXplKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXROZXh0U2FmZVNsdWcoc2x1Zywgb3B0aW9ucy5kcnlydW4pO1xuICB9O1xuICByZXR1cm4gU2x1Z2dlcjtcbn0oKTtcblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cbnZhciBQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZXhwb3J0cy5kZWZhdWx0cztcbiAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyKCk7XG4gICAgdGhpcy5zbHVnZ2VyID0gbmV3IFNsdWdnZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gICAqL1xuICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKHRva2Vucyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICovO1xuICBQYXJzZXIucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiBwYXJzZUlubGluZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgTG9vcFxuICAgKi87XG4gIHZhciBfcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIHRvcCkge1xuICAgIGlmICh0b3AgPT09IHZvaWQgMCkge1xuICAgICAgdG9wID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG91dCA9ICcnLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBrLFxuICAgICAgbDIsXG4gICAgICBsMyxcbiAgICAgIHJvdyxcbiAgICAgIGNlbGwsXG4gICAgICBoZWFkZXIsXG4gICAgICBib2R5LFxuICAgICAgdG9rZW4sXG4gICAgICBvcmRlcmVkLFxuICAgICAgc3RhcnQsXG4gICAgICBsb29zZSxcbiAgICAgIGl0ZW1Cb2R5LFxuICAgICAgaXRlbSxcbiAgICAgIGNoZWNrZWQsXG4gICAgICB0YXNrLFxuICAgICAgY2hlY2tib3gsXG4gICAgICByZXQ7XG4gICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICBwYXJzZXI6IHRoaXNcbiAgICAgICAgfSwgdG9rZW4pO1xuICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyh0b2tlbi50eXBlKSkge1xuICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdocic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyksIHRva2VuLmRlcHRoLCB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSwgdGhpcy5zbHVnZ2VyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZSh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCB0b2tlbi5lc2NhcGVkKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlciA9ICcnO1xuXG4gICAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgIGwyID0gdG9rZW4uaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZSh0b2tlbi5oZWFkZXJbal0udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25bal1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICAgIGwyID0gdG9rZW4ucm93cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICByb3cgPSB0b2tlbi5yb3dzW2pdO1xuICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgIGwzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGwzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUocm93W2tdLnRva2VucyksIHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25ba11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3JkZXJlZCA9IHRva2VuLm9yZGVyZWQ7XG4gICAgICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICAgIGwyID0gdG9rZW4uaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICBjaGVja2VkID0gaXRlbS5jaGVja2VkO1xuICAgICAgICAgICAgICB0YXNrID0gaXRlbS50YXNrO1xuICAgICAgICAgICAgICBpdGVtQm9keSA9ICcnO1xuICAgICAgICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tib3ggPSB0aGlzLnJlbmRlcmVyLmNoZWNrYm94KGNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlKGl0ZW0udG9rZW5zLCBsb29zZSk7XG4gICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETyBwYXJzZSBpbmxpbmUgY29udGVudCBpZiBwYXJhbWV0ZXIgbWFya2Rvd249MVxuICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgYm9keSA9IHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSA6IHRva2VuLnRleHQ7XG4gICAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyAodG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gdG9wID8gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgoYm9keSkgOiBib2R5O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgKi87XG4gIF9wcm90by5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2VucywgcmVuZGVyZXIpIHtcbiAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgdmFyIG91dCA9ICcnLFxuICAgICAgaSxcbiAgICAgIHRva2VuLFxuICAgICAgcmV0O1xuICAgIHZhciBsID0gdG9rZW5zLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0uY2FsbCh7XG4gICAgICAgICAgcGFyc2VyOiB0aGlzXG4gICAgICAgIH0sIHRva2VuKTtcbiAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnZXNjYXBlJywgJ2h0bWwnLCAnbGluaycsICdpbWFnZScsICdzdHJvbmcnLCAnZW0nLCAnY29kZXNwYW4nLCAnYnInLCAnZGVsJywgJ3RleHQnXS5pbmNsdWRlcyh0b2tlbi50eXBlKSkge1xuICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmltYWdlKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmVtKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdjb2Rlc3Bhbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmNvZGVzcGFuKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbiAgcmV0dXJuIFBhcnNlcjtcbn0oKTtcblxudmFyIEhvb2tzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSG9va3Mob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZXhwb3J0cy5kZWZhdWx0cztcbiAgfVxuICB2YXIgX3Byb3RvID0gSG9va3MucHJvdG90eXBlO1xuICAvKipcbiAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAqL1xuICBfcHJvdG8ucHJlcHJvY2VzcyA9IGZ1bmN0aW9uIHByZXByb2Nlc3MobWFya2Rvd24pIHtcbiAgICByZXR1cm4gbWFya2Rvd247XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBIVE1MIGFmdGVyIG1hcmtlZCBpcyBmaW5pc2hlZFxuICAgKi87XG4gIF9wcm90by5wb3N0cHJvY2VzcyA9IGZ1bmN0aW9uIHBvc3Rwcm9jZXNzKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgcmV0dXJuIEhvb2tzO1xufSgpO1xuSG9va3MucGFzc1Rocm91Z2hIb29rcyA9IG5ldyBTZXQoWydwcmVwcm9jZXNzJywgJ3Bvc3Rwcm9jZXNzJ10pO1xuXG5mdW5jdGlvbiBvbkVycm9yKHNpbGVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcbiAgICBpZiAoc2lsZW50KSB7XG4gICAgICB2YXIgbXNnID0gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPicgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpICsgJzwvcHJlPic7XG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIG1zZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIGlmIChhc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VNYXJrZG93bihsZXhlciwgcGFyc2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIG9yaWdPcHQgPSBfZXh0ZW5kcyh7fSwgb3B0KTtcbiAgICBvcHQgPSBfZXh0ZW5kcyh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcmlnT3B0KTtcbiAgICB2YXIgdGhyb3dFcnJvciA9IG9uRXJyb3Iob3B0LnNpbGVudCwgb3B0LmFzeW5jLCBjYWxsYmFjayk7XG5cbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJykpO1xuICAgIH1cbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KTtcbiAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICBvcHQuaG9va3Mub3B0aW9ucyA9IG9wdDtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICAgIHZhciB0b2tlbnM7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgc3JjID0gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMgPSBsZXhlcihzcmMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICB2YXIgb3V0O1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICBvdXQgPSBvcHQuaG9va3MucG9zdHByb2Nlc3Mob3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gZXJyID8gdGhyb3dFcnJvcihlcnIpIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgIH07XG4gICAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG4gICAgICBpZiAoIXRva2Vucy5sZW5ndGgpIHJldHVybiBkb25lKCk7XG4gICAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcGVuZGluZysrO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uIChlcnIsIGNvZGUpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCAmJiBjb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYykgOiBzcmMpLnRoZW4oZnVuY3Rpb24gKHNyYykge1xuICAgICAgICByZXR1cm4gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiBvcHQud2Fsa1Rva2VucyA/IFByb21pc2UuYWxsKG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9KSA6IHRva2VucztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHRva2Vucykge1xuICAgICAgICByZXR1cm4gcGFyc2VyKHRva2Vucywgb3B0KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWw7XG4gICAgICB9KVtcImNhdGNoXCJdKHRocm93RXJyb3IpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgfVxuICAgICAgdmFyIF90b2tlbnMgPSBsZXhlcihzcmMsIG9wdCk7XG4gICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoX3Rva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGh0bWwgPSBwYXJzZXIoX3Rva2Vucywgb3B0KTtcbiAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBodG1sO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBNYXJrZWRcbiAqL1xuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICByZXR1cm4gcGFyc2VNYXJrZG93bihMZXhlci5sZXgsIFBhcnNlci5wYXJzZSkoc3JjLCBvcHQsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgbWFya2VkLmRlZmF1bHRzID0gX2V4dGVuZHMoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgcmV0dXJuIG1hcmtlZDtcbn07XG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcbm1hcmtlZC5kZWZhdWx0cyA9IGV4cG9ydHMuZGVmYXVsdHM7XG5cbi8qKlxuICogVXNlIEV4dGVuc2lvblxuICovXG5cbm1hcmtlZC51c2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBleHRlbnNpb25zID0gbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwge1xuICAgIHJlbmRlcmVyczoge30sXG4gICAgY2hpbGRUb2tlbnM6IHt9XG4gIH07XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrKSB7XG4gICAgLy8gY29weSBvcHRpb25zIHRvIG5ldyBvYmplY3RcbiAgICB2YXIgb3B0cyA9IF9leHRlbmRzKHt9LCBwYWNrKTtcblxuICAgIC8vIHNldCBhc3luYyB0byB0cnVlIGlmIGl0IHdhcyBzZXQgdG8gdHJ1ZSBiZWZvcmVcbiAgICBvcHRzLmFzeW5jID0gbWFya2VkLmRlZmF1bHRzLmFzeW5jIHx8IG9wdHMuYXN5bmMgfHwgZmFsc2U7XG5cbiAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICBpZiAocGFjay5leHRlbnNpb25zKSB7XG4gICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gICAgICAgIGlmICghZXh0Lm5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dC5yZW5kZXJlcikge1xuICAgICAgICAgIC8vIFJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICB2YXIgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdO1xuICAgICAgICAgIGlmIChwcmV2UmVuZGVyZXIpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgZXh0ZW5zaW9uIHdpdGggZnVuYyB0byBydW4gbmV3IGV4dGVuc2lvbiBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcmV0ID0gZXh0LnJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZXh0LnJlbmRlcmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0LnRva2VuaXplcikge1xuICAgICAgICAgIC8vIFRva2VuaXplciBFeHRlbnNpb25zXG4gICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgZXh0LmxldmVsICE9PSAnYmxvY2snICYmIGV4dC5sZXZlbCAhPT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRlbnNpb25zW2V4dC5sZXZlbF0pIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXS51bnNoaWZ0KGV4dC50b2tlbml6ZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHQuc3RhcnQpIHtcbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciBzdGFydCBvZiB0b2tlblxuICAgICAgICAgICAgaWYgKGV4dC5sZXZlbCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHQubGV2ZWwgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZS5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHQuY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAvLyBDaGlsZCB0b2tlbnMgdG8gYmUgdmlzaXRlZCBieSB3YWxrVG9rZW5zXG4gICAgICAgICAgZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tleHQubmFtZV0gPSBleHQuY2hpbGRUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb3B0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvLyA9PS0tIFBhcnNlIFwib3ZlcndyaXRlXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgaWYgKHBhY2sucmVuZGVyZXIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgICAgIHZhciBwcmV2UmVuZGVyZXIgPSByZW5kZXJlcltwcm9wXTtcbiAgICAgICAgICAvLyBSZXBsYWNlIHJlbmRlcmVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgcmVuZGVyZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJldCA9IHBhY2sucmVuZGVyZXJbcHJvcF0uYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgX2xvb3AocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgfSkoKTtcbiAgICB9XG4gICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW5pemVyID0gbWFya2VkLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyKCk7XG4gICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIocHJvcCkge1xuICAgICAgICAgIHZhciBwcmV2VG9rZW5pemVyID0gdG9rZW5pemVyW3Byb3BdO1xuICAgICAgICAgIC8vIFJlcGxhY2UgdG9rZW5pemVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgdG9rZW5pemVyW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXQgPSBwYWNrLnRva2VuaXplcltwcm9wXS5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgX2xvb3AyKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICAvLyA9PS0tIFBhcnNlIEhvb2tzIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLmhvb2tzKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaG9va3MgPSBtYXJrZWQuZGVmYXVsdHMuaG9va3MgfHwgbmV3IEhvb2tzKCk7XG4gICAgICAgIHZhciBfbG9vcDMgPSBmdW5jdGlvbiBfbG9vcDMocHJvcCkge1xuICAgICAgICAgIHZhciBwcmV2SG9vayA9IGhvb2tzW3Byb3BdO1xuICAgICAgICAgIGlmIChIb29rcy5wYXNzVGhyb3VnaEhvb2tzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgaG9va3NbcHJvcF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgIGlmIChtYXJrZWQuZGVmYXVsdHMuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhY2suaG9va3NbcHJvcF0uY2FsbChob29rcywgYXJnKSkudGhlbihmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcmV0ID0gcGFjay5ob29rc1twcm9wXS5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJldCA9IHBhY2suaG9va3NbcHJvcF0uYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHByZXZIb29rLmFwcGx5KGhvb2tzLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gcGFjay5ob29rcykge1xuICAgICAgICAgIF9sb29wMyhwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIC8vID09LS0gUGFyc2UgV2Fsa1Rva2VucyBleHRlbnNpb25zIC0tPT0gLy9cbiAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICB2YXIgX3dhbGtUb2tlbnMgPSBtYXJrZWQuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgIG9wdHMud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIHZhbHVlcy5wdXNoKHBhY2sud2Fsa1Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgIGlmIChfd2Fsa1Rva2Vucykge1xuICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoX3dhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9O1xuICAgIH1cbiAgICBtYXJrZWQuc2V0T3B0aW9ucyhvcHRzKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAqL1xuXG5tYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNCgpIHtcbiAgICB2YXIgdG9rZW4gPSBfc3RlcC52YWx1ZTtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGNhbGxiYWNrLmNhbGwobWFya2VkLCB0b2tlbikpO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW4uaGVhZGVyKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChtYXJrZWQud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW4ucm93cyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uocm93KSwgX3N0ZXA0OyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQoKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi5pdGVtcywgY2FsbGJhY2spKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucyAmJiBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2VucyAmJiBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgLy8gV2FsayBhbnkgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbdG9rZW4udHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbltjaGlsZFRva2Vuc10sIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnRva2Vucykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbi50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgX2xvb3A0KCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogUGFyc2UgSW5saW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gKi9cbm1hcmtlZC5wYXJzZUlubGluZSA9IHBhcnNlTWFya2Rvd24oTGV4ZXIubGV4SW5saW5lLCBQYXJzZXIucGFyc2VJbmxpbmUpO1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5tYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IFBhcnNlci5wYXJzZTtcbm1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyO1xubWFya2VkLlRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcjtcbm1hcmtlZC5MZXhlciA9IExleGVyO1xubWFya2VkLmxleGVyID0gTGV4ZXIubGV4O1xubWFya2VkLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1hcmtlZC5TbHVnZ2VyID0gU2x1Z2dlcjtcbm1hcmtlZC5Ib29rcyA9IEhvb2tzO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xudmFyIG9wdGlvbnMgPSBtYXJrZWQub3B0aW9ucztcbnZhciBzZXRPcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnM7XG52YXIgdXNlID0gbWFya2VkLnVzZTtcbnZhciB3YWxrVG9rZW5zID0gbWFya2VkLndhbGtUb2tlbnM7XG52YXIgcGFyc2VJbmxpbmUgPSBtYXJrZWQucGFyc2VJbmxpbmU7XG52YXIgcGFyc2UgPSBtYXJrZWQ7XG52YXIgcGFyc2VyID0gUGFyc2VyLnBhcnNlO1xudmFyIGxleGVyID0gTGV4ZXIubGV4O1xuXG5leHBvcnRzLkhvb2tzID0gSG9va3M7XG5leHBvcnRzLkxleGVyID0gTGV4ZXI7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbmV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbmV4cG9ydHMuU2x1Z2dlciA9IFNsdWdnZXI7XG5leHBvcnRzLlRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcjtcbmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xuZXhwb3J0cy5nZXREZWZhdWx0cyA9IGdldERlZmF1bHRzO1xuZXhwb3J0cy5sZXhlciA9IGxleGVyO1xuZXhwb3J0cy5tYXJrZWQgPSBtYXJrZWQ7XG5leHBvcnRzLm9wdGlvbnMgPSBvcHRpb25zO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUlubGluZSA9IHBhcnNlSW5saW5lO1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLnNldE9wdGlvbnMgPSBzZXRPcHRpb25zO1xuZXhwb3J0cy51c2UgPSB1c2U7XG5leHBvcnRzLndhbGtUb2tlbnMgPSB3YWxrVG9rZW5zO1xuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsInNvdXJjZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiYXJyIiwibGVuIiwiYXJyMiIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UiLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuZXh0IiwiaXNBcnJheSIsImRvbmUiLCJ2YWx1ZSIsIlR5cGVFcnJvciIsIl90b1ByaW1pdGl2ZSIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsIlN0cmluZyIsIk51bWJlciIsImFyZyIsImdldERlZmF1bHRzIiwiYXN5bmMiLCJiYXNlVXJsIiwiYnJlYWtzIiwiZXh0ZW5zaW9ucyIsImdmbSIsImhlYWRlcklkcyIsImhlYWRlclByZWZpeCIsImhpZ2hsaWdodCIsImhvb2tzIiwibGFuZ1ByZWZpeCIsIm1hbmdsZSIsInBlZGFudGljIiwicmVuZGVyZXIiLCJzYW5pdGl6ZSIsInNhbml0aXplciIsInNpbGVudCIsInNtYXJ0eXBhbnRzIiwidG9rZW5pemVyIiwid2Fsa1Rva2VucyIsInhodG1sIiwiZXhwb3J0cyIsImRlZmF1bHRzIiwiY2hhbmdlRGVmYXVsdHMiLCJuZXdEZWZhdWx0cyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiUmVnRXhwIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVzY2FwZSIsImh0bWwiLCJlbmNvZGUiLCJyZXBsYWNlIiwidW5lc2NhcGVUZXN0IiwidW5lc2NhcGUiLCJfIiwidG9Mb3dlckNhc2UiLCJjaGFyQXQiLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImNhcmV0IiwiZWRpdCIsInJlZ2V4Iiwib3B0Iiwib2JqIiwidmFsIiwiZ2V0UmVnZXgiLCJub25Xb3JkQW5kQ29sb25UZXN0Iiwib3JpZ2luSW5kZXBlbmRlbnRVcmwiLCJjbGVhblVybCIsImJhc2UiLCJocmVmIiwicHJvdCIsImRlY29kZVVSSUNvbXBvbmVudCIsImUiLCJpbmRleE9mIiwicmVzb2x2ZVVybCIsImVuY29kZVVSSSIsImJhc2VVcmxzIiwianVzdERvbWFpbiIsInByb3RvY29sIiwiZG9tYWluIiwicnRyaW0iLCJyZWxhdGl2ZUJhc2UiLCJub29wVGVzdCIsImV4ZWMiLCJzcGxpdENlbGxzIiwidGFibGVSb3ciLCJjb3VudCIsInJvdyIsIm1hdGNoIiwib2Zmc2V0Iiwic3RyIiwiZXNjYXBlZCIsImN1cnIiLCJjZWxscyIsInNwbGl0IiwidHJpbSIsInNoaWZ0IiwicG9wIiwic3BsaWNlIiwicHVzaCIsImMiLCJpbnZlcnQiLCJsIiwic3VmZkxlbiIsImN1cnJDaGFyIiwiZmluZENsb3NpbmdCcmFja2V0IiwiYiIsImxldmVsIiwiY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uIiwiY29uc29sZSIsIndhcm4iLCJyZXBlYXRTdHJpbmciLCJwYXR0ZXJuIiwicmVzdWx0Iiwib3V0cHV0TGluayIsImNhcCIsImxpbmsiLCJyYXciLCJsZXhlciIsInRpdGxlIiwidGV4dCIsInN0YXRlIiwiaW5MaW5rIiwidG9rZW4iLCJ0eXBlIiwidG9rZW5zIiwiaW5saW5lVG9rZW5zIiwiaW5kZW50Q29kZUNvbXBlbnNhdGlvbiIsIm1hdGNoSW5kZW50VG9Db2RlIiwiaW5kZW50VG9Db2RlIiwibWFwIiwibm9kZSIsIm1hdGNoSW5kZW50SW5Ob2RlIiwiaW5kZW50SW5Ob2RlIiwiam9pbiIsIlRva2VuaXplciIsIm9wdGlvbnMiLCJfcHJvdG8iLCJzcGFjZSIsInNyYyIsInJ1bGVzIiwiYmxvY2siLCJuZXdsaW5lIiwiY29kZSIsImNvZGVCbG9ja1N0eWxlIiwiZmVuY2VzIiwibGFuZyIsImlubGluZSIsIl9lc2NhcGVzIiwiaGVhZGluZyIsInRyaW1tZWQiLCJkZXB0aCIsImhyIiwiYmxvY2txdW90ZSIsInRvcCIsImJsb2NrVG9rZW5zIiwibGlzdCIsImlzdGFzayIsImlzY2hlY2tlZCIsImluZGVudCIsImJsYW5rTGluZSIsImVuZHNXaXRoQmxhbmtMaW5lIiwibGluZSIsIm5leHRMaW5lIiwicmF3TGluZSIsIml0ZW1Db250ZW50cyIsImVuZEVhcmx5IiwiYnVsbCIsImlzb3JkZXJlZCIsIm9yZGVyZWQiLCJzdGFydCIsImxvb3NlIiwiaXRlbXMiLCJpdGVtUmVnZXgiLCJ0IiwicmVwZWF0IiwidHJpbUxlZnQiLCJzZWFyY2giLCJuZXh0QnVsbGV0UmVnZXgiLCJNYXRoIiwibWluIiwiaHJSZWdleCIsImZlbmNlc0JlZ2luUmVnZXgiLCJoZWFkaW5nQmVnaW5SZWdleCIsInRhc2siLCJjaGVja2VkIiwidHJpbVJpZ2h0Iiwic3BhY2VycyIsImZpbHRlciIsImhhc011bHRpcGxlTGluZUJyZWFrcyIsInNvbWUiLCJwcmUiLCJkZWYiLCJ0YWciLCJ0YWJsZSIsIml0ZW0iLCJoZWFkZXIiLCJhbGlnbiIsInJvd3MiLCJqIiwiayIsImxoZWFkaW5nIiwicGFyYWdyYXBoIiwiZXNjYXBlJDEiLCJpblJhd0Jsb2NrIiwidHJpbW1lZFVybCIsInJ0cmltU2xhc2giLCJsYXN0UGFyZW5JbmRleCIsImxpbmtMZW4iLCJyZWZsaW5rIiwibGlua3MiLCJub2xpbmsiLCJlbVN0cm9uZyIsIm1hc2tlZFNyYyIsInByZXZDaGFyIiwibERlbGltIiwibmV4dENoYXIiLCJwdW5jdHVhdGlvbiIsImxMZW5ndGgiLCJyRGVsaW0iLCJyTGVuZ3RoIiwiZGVsaW1Ub3RhbCIsIm1pZERlbGltVG90YWwiLCJlbmRSZWciLCJyRGVsaW1Bc3QiLCJyRGVsaW1VbmQiLCJsYXN0SW5kZXgiLCJpbmRleCIsIl90ZXh0IiwiY29kZXNwYW4iLCJoYXNOb25TcGFjZUNoYXJzIiwiaGFzU3BhY2VDaGFyc09uQm90aEVuZHMiLCJiciIsImRlbCIsImF1dG9saW5rIiwidXJsIiwicHJldkNhcFplcm8iLCJfYmFja3BlZGFsIiwiaW5saW5lVGV4dCIsIl9wYXJhZ3JhcGgiLCJfbGFiZWwiLCJfdGl0bGUiLCJidWxsZXQiLCJsaXN0SXRlbVN0YXJ0IiwiX3RhZyIsIl9jb21tZW50Iiwibm9ybWFsIiwicmVmbGlua1NlYXJjaCIsIl9wdW5jdHVhdGlvbiIsImJsb2NrU2tpcCIsImVzY2FwZWRFbVN0IiwiX3NjaGVtZSIsIl9lbWFpbCIsIl9hdHRyaWJ1dGUiLCJfaHJlZiIsInN0cm9uZyIsIm1pZGRsZSIsImVuZEFzdCIsImVuZFVuZCIsImVtIiwiX2V4dGVuZGVkX2VtYWlsIiwib3V0IiwiY2hhckNvZGVBdCIsInJhbmRvbSIsIkxleGVyIiwiY3JlYXRlIiwiaW5saW5lUXVldWUiLCJsZXgiLCJsZXhJbmxpbmUiLCJfdGhpcyIsImxlYWRpbmciLCJ0YWJzIiwibGFzdFRva2VuIiwiY3V0U3JjIiwibGFzdFBhcmFncmFwaENsaXBwZWQiLCJleHRUb2tlbml6ZXIiLCJzdGFydEJsb2NrIiwic3RhcnRJbmRleCIsIkluZmluaXR5IiwidGVtcFNyYyIsInRlbXBTdGFydCIsImZvckVhY2giLCJnZXRTdGFydEluZGV4IiwiZXJyTXNnIiwiZXJyb3IiLCJFcnJvciIsIl90aGlzMiIsImtlZXBQcmV2Q2hhciIsImtleXMiLCJpbmNsdWRlcyIsImxhc3RJbmRleE9mIiwic3RhcnRJbmxpbmUiLCJnZXQiLCJSZW5kZXJlciIsIl9jb2RlIiwiaW5mb3N0cmluZyIsInF1b3RlIiwiX2h0bWwiLCJzbHVnZ2VyIiwiaWQiLCJzbHVnIiwiYm9keSIsInN0YXJ0YXR0IiwibGlzdGl0ZW0iLCJjaGVja2JveCIsInRhYmxlcm93IiwiY29udGVudCIsInRhYmxlY2VsbCIsImZsYWdzIiwiaW1hZ2UiLCJUZXh0UmVuZGVyZXIiLCJTbHVnZ2VyIiwic2VlbiIsInNlcmlhbGl6ZSIsImdldE5leHRTYWZlU2x1ZyIsIm9yaWdpbmFsU2x1ZyIsImlzRHJ5UnVuIiwib2NjdXJlbmNlQWNjdW11bGF0b3IiLCJkcnlydW4iLCJQYXJzZXIiLCJ0ZXh0UmVuZGVyZXIiLCJwYXJzZSIsInBhcnNlciIsInBhcnNlSW5saW5lIiwibDIiLCJsMyIsImNlbGwiLCJpdGVtQm9keSIsInJldCIsInJlbmRlcmVycyIsInVuc2hpZnQiLCJIb29rcyIsInByZXByb2Nlc3MiLCJtYXJrZG93biIsInBvc3Rwcm9jZXNzIiwicGFzc1Rocm91Z2hIb29rcyIsIlNldCIsIm9uRXJyb3IiLCJjYWxsYmFjayIsIm1lc3NhZ2UiLCJtc2ciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInBhcnNlTWFya2Rvd24iLCJvcmlnT3B0IiwibWFya2VkIiwidGhyb3dFcnJvciIsImVyciIsInBlbmRpbmciLCJzZXRUaW1lb3V0IiwidGhlbiIsImFsbCIsIl90b2tlbnMiLCJzZXRPcHRpb25zIiwidXNlIiwiY2hpbGRUb2tlbnMiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJwYWNrIiwib3B0cyIsImV4dCIsInByZXZSZW5kZXJlciIsIl9sZW4yIiwiX2tleTIiLCJfbG9vcCIsInByb3AiLCJfbGVuMyIsIl9rZXkzIiwiX2xvb3AyIiwicHJldlRva2VuaXplciIsIl9sZW40IiwiX2tleTQiLCJfbG9vcDMiLCJwcmV2SG9vayIsImhhcyIsIl9sZW41IiwiX2tleTUiLCJfd2Fsa1Rva2VucyIsInZhbHVlcyIsImNvbmNhdCIsIl9sb29wNCIsIl9zdGVwIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwiX2NlbGwiLCJfaXRlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/marked/lib/marked.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-simplemde-editor/dist/SimpleMdeReact.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/react-simplemde-editor/dist/SimpleMdeReact.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimpleMdeReact: function() { return /* binding */ SimpleMdeReact; },\n/* harmony export */   \"default\": function() { return /* binding */ SimpleMdeReact_default; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var easymde__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! easymde */ \"(app-pages-browser)/./node_modules/easymde/src/js/easymde.js\");\n// src/SimpleMdeReact.tsx\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nvar _id = 0;\nvar generateId = ()=>\"simplemde-editor-\".concat(++_id);\nvar useHandleEditorInstanceLifecycle = (param)=>{\n    let { options, id, currentValueRef, textRef } = param;\n    _s();\n    const [editor, setEditor] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const imageUploadCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((file, onSuccess, onError)=>{\n        const imageUpload = options == null ? void 0 : options.imageUploadFunction;\n        if (imageUpload) {\n            const _onSuccess = (url)=>{\n                onSuccess(url);\n            };\n            imageUpload(file, _onSuccess, onError);\n        }\n    }, [\n        options == null ? void 0 : options.imageUploadFunction\n    ]);\n    const editorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(editor);\n    editorRef.current = editor;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let editor2;\n        if (textRef) {\n            const initialOptions = {\n                element: textRef,\n                initialValue: currentValueRef.current\n            };\n            const imageUploadFunction = (options == null ? void 0 : options.imageUploadFunction) ? imageUploadCallback : void 0;\n            editor2 = new easymde__WEBPACK_IMPORTED_MODULE_1__(Object.assign({}, initialOptions, options, {\n                imageUploadFunction\n            }));\n            setEditor(editor2);\n        }\n        return ()=>{\n            editor2 == null ? void 0 : editor2.toTextArea();\n            editor2 == null ? void 0 : editor2.cleanup();\n        };\n    }, [\n        textRef,\n        currentValueRef,\n        id,\n        imageUploadCallback,\n        options\n    ]);\n    const codemirror = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return editor == null ? void 0 : editor.codemirror;\n    }, [\n        editor == null ? void 0 : editor.codemirror\n    ]);\n    return {\n        editor,\n        codemirror\n    };\n};\n_s(useHandleEditorInstanceLifecycle, \"opAvGIghoKWpx2pLhpw/rp9bQtg=\");\nvar SimpleMdeReact = /*#__PURE__*/ _s1(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_c = _s1((props, ref)=>{\n    _s1();\n    const { events, value, options, children, extraKeys, getLineAndCursor, getMdeInstance, getCodemirrorInstance, onChange, id: anId, placeholder, textareaProps, ...rest } = props;\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>anId !== null && anId !== void 0 ? anId : generateId(), [\n        anId\n    ]);\n    const elementWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const nonEventChangeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const currentValueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    currentValueRef.current = value;\n    const [textRef, setTextRef] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor, codemirror } = useHandleEditorInstanceLifecycle({\n        options,\n        id,\n        currentValueRef,\n        textRef\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (nonEventChangeRef.current) {\n            editor == null ? void 0 : editor.value(value !== null && value !== void 0 ? value : \"\");\n        }\n        nonEventChangeRef.current = true;\n    }, [\n        editor,\n        value\n    ]);\n    const onCodemirrorChangeHandler = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((_, changeObject)=>{\n        if ((editor == null ? void 0 : editor.value()) !== currentValueRef.current) {\n            nonEventChangeRef.current = false;\n            var _ref;\n            onChange == null ? void 0 : onChange((_ref = editor == null ? void 0 : editor.value()) !== null && _ref !== void 0 ? _ref : \"\", changeObject);\n        }\n    }, [\n        editor,\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (options == null ? void 0 : options.autofocus) {\n            codemirror == null ? void 0 : codemirror.focus();\n            codemirror == null ? void 0 : codemirror.setCursor(codemirror == null ? void 0 : codemirror.lineCount(), 0);\n        }\n    }, [\n        codemirror,\n        options == null ? void 0 : options.autofocus\n    ]);\n    const getCursorCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        codemirror && (getLineAndCursor == null ? void 0 : getLineAndCursor(codemirror.getDoc().getCursor()));\n    }, [\n        codemirror,\n        getLineAndCursor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        getCursorCallback();\n    }, [\n        getCursorCallback\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        editor && (getMdeInstance == null ? void 0 : getMdeInstance(editor));\n    }, [\n        editor,\n        getMdeInstance\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        codemirror && (getCodemirrorInstance == null ? void 0 : getCodemirrorInstance(codemirror));\n    }, [\n        codemirror,\n        getCodemirrorInstance,\n        getMdeInstance\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (extraKeys && codemirror) {\n            codemirror.setOption(\"extraKeys\", Object.assign({}, codemirror.getOption(\"extraKeys\"), extraKeys));\n        }\n    }, [\n        codemirror,\n        extraKeys\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        const toolbarNode = (_a = elementWrapperRef.current) == null ? void 0 : _a.getElementsByClassName(\"editor-toolbarNode\")[0];\n        const handler = codemirror && onCodemirrorChangeHandler;\n        if (handler) {\n            toolbarNode == null ? void 0 : toolbarNode.addEventListener(\"click\", handler);\n            return ()=>{\n                toolbarNode == null ? void 0 : toolbarNode.removeEventListener(\"click\", handler);\n            };\n        }\n        return ()=>{};\n    }, [\n        codemirror,\n        onCodemirrorChangeHandler\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        codemirror == null ? void 0 : codemirror.on(\"change\", onCodemirrorChangeHandler);\n        codemirror == null ? void 0 : codemirror.on(\"cursorActivity\", getCursorCallback);\n        return ()=>{\n            codemirror == null ? void 0 : codemirror.off(\"change\", onCodemirrorChangeHandler);\n            codemirror == null ? void 0 : codemirror.off(\"cursorActivity\", getCursorCallback);\n        };\n    }, [\n        codemirror,\n        getCursorCallback,\n        onCodemirrorChangeHandler\n    ]);\n    const prevEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(events);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const isNotFirstEffectRun = events !== prevEvents.current;\n        isNotFirstEffectRun && prevEvents.current && Object.entries(prevEvents.current).forEach((param)=>{\n            let [event, handler] = param;\n            handler && (codemirror == null ? void 0 : codemirror.off(event, handler));\n        });\n        events && Object.entries(events).forEach((param)=>{\n            let [event, handler] = param;\n            handler && (codemirror == null ? void 0 : codemirror.on(event, handler));\n        });\n        prevEvents.current = events;\n        return ()=>{\n            events && Object.entries(events).forEach((param)=>{\n                let [event, handler] = param;\n                handler && (codemirror == null ? void 0 : codemirror.off(event, handler));\n            });\n        };\n    }, [\n        codemirror,\n        events\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: \"\".concat(id, \"-wrapper\"),\n        ...rest,\n        ref: (aRef)=>{\n            if (typeof ref === \"function\") {\n                ref(aRef);\n            } else if (ref) {\n                ref.current = aRef;\n            }\n            elementWrapperRef.current = aRef;\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"textarea\", {\n        ...textareaProps,\n        id,\n        placeholder,\n        ref: setTextRef,\n        style: {\n            display: \"none\"\n        }\n    }));\n}, \"yGhZv2399NG+qTRCC8tq2adPsBE=\", false, function() {\n    return [\n        useHandleEditorInstanceLifecycle\n    ];\n})), \"yGhZv2399NG+qTRCC8tq2adPsBE=\", false, function() {\n    return [\n        useHandleEditorInstanceLifecycle\n    ];\n});\n_c1 = SimpleMdeReact;\nSimpleMdeReact.displayName = \"SimpleMdeReact\";\nvar SimpleMdeReact_default = SimpleMdeReact;\n //# sourceMappingURL=SimpleMdeReact.mjs.map\nvar _c, _c1;\n$RefreshReg$(_c, \"SimpleMdeReact$React.forwardRef\");\n$RefreshReg$(_c1, \"SimpleMdeReact\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zaW1wbGVtZGUtZWRpdG9yL2Rpc3QvU2ltcGxlTWRlUmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx5QkFBeUI7O0FBT1Y7QUFDaUI7QUFDaEMsSUFBSU8sTUFBTTtBQUNWLElBQUlDLGFBQWEsSUFBTSxvQkFBMEIsT0FBTixFQUFFRDtBQUM3QyxJQUFJRSxtQ0FBbUM7UUFBQyxFQUN0Q0MsT0FBTyxFQUNQQyxFQUFFLEVBQ0ZDLGVBQWUsRUFDZkMsT0FBTyxFQUNSOztJQUNDLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHViwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNVyxzQkFBc0JmLGtEQUFXQSxDQUNyQyxDQUFDZ0IsTUFBTUMsV0FBV0M7UUFDaEIsTUFBTUMsY0FBY1YsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUVcsbUJBQW1CO1FBQzFFLElBQUlELGFBQWE7WUFDZixNQUFNRSxhQUFhLENBQUNDO2dCQUNsQkwsVUFBVUs7WUFDWjtZQUNBSCxZQUFZSCxNQUFNSyxZQUFZSDtRQUNoQztJQUNGLEdBQ0E7UUFBQ1QsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUVcsbUJBQW1CO0tBQUM7SUFFMUQsTUFBTUcsWUFBWXBCLDZDQUFNQSxDQUFDVTtJQUN6QlUsVUFBVUMsT0FBTyxHQUFHWDtJQUNwQlosZ0RBQVNBLENBQUM7UUFDUixJQUFJd0I7UUFDSixJQUFJYixTQUFTO1lBQ1gsTUFBTWMsaUJBQWlCO2dCQUNyQkMsU0FBU2Y7Z0JBQ1RnQixjQUFjakIsZ0JBQWdCYSxPQUFPO1lBQ3ZDO1lBQ0EsTUFBTUosc0JBQXNCLENBQUNYLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFXLG1CQUFtQixJQUFJTCxzQkFBc0IsS0FBSztZQUNsSFUsVUFBVSxJQUFJcEIsb0NBQVNBLENBQ3JCd0IsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0osZ0JBQWdCakIsU0FBUztnQkFDekNXO1lB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QyxRQUFRLFlBQVk7Z0JBQzdCQSxJQUFJMEM7WUFDTixPQUFPLElBQUkxQyxLQUFLO2dCQUNkQSxJQUFJYixPQUFPLEdBQUd1RDtZQUNoQjtZQUNBN0Isa0JBQWtCMUIsT0FBTyxHQUFHdUQ7UUFDOUI7SUFDRixHQUFHLGFBQWEsaUJBQUdoRixnREFBbUIsQ0FBQyxZQUFZO1FBQ2pELEdBQUdpRCxhQUFhO1FBQ2hCdEM7UUFDQXFDO1FBQ0FWLEtBQUtlO1FBQ0w0QixPQUFPO1lBQUVDLFNBQVM7UUFBTztJQUMzQjtBQUNGOztRQXhHaUN6RTs7OztRQUFBQTs7OztBQXlHakMwQixlQUFlZ0QsV0FBVyxHQUFHO0FBQzdCLElBQUlDLHlCQUF5QmpEO0FBSTNCLENBQ0YsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zaW1wbGVtZGUtZWRpdG9yL2Rpc3QvU2ltcGxlTWRlUmVhY3QubWpzPzBlYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL1NpbXBsZU1kZVJlYWN0LnRzeFxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZUNhbGxiYWNrLFxuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZixcbiAgdXNlU3RhdGVcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgU2ltcGxlTURFIGZyb20gXCJlYXN5bWRlXCI7XG52YXIgX2lkID0gMDtcbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4gYHNpbXBsZW1kZS1lZGl0b3ItJHsrK19pZH1gO1xudmFyIHVzZUhhbmRsZUVkaXRvckluc3RhbmNlTGlmZWN5Y2xlID0gKHtcbiAgb3B0aW9ucyxcbiAgaWQsXG4gIGN1cnJlbnRWYWx1ZVJlZixcbiAgdGV4dFJlZlxufSkgPT4ge1xuICBjb25zdCBbZWRpdG9yLCBzZXRFZGl0b3JdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGltYWdlVXBsb2FkQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhcbiAgICAoZmlsZSwgb25TdWNjZXNzLCBvbkVycm9yKSA9PiB7XG4gICAgICBjb25zdCBpbWFnZVVwbG9hZCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbjtcbiAgICAgIGlmIChpbWFnZVVwbG9hZCkge1xuICAgICAgICBjb25zdCBfb25TdWNjZXNzID0gKHVybCkgPT4ge1xuICAgICAgICAgIG9uU3VjY2Vzcyh1cmwpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZVVwbG9hZChmaWxlLCBfb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb25dXG4gICk7XG4gIGNvbnN0IGVkaXRvclJlZiA9IHVzZVJlZihlZGl0b3IpO1xuICBlZGl0b3JSZWYuY3VycmVudCA9IGVkaXRvcjtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZWRpdG9yMjtcbiAgICBpZiAodGV4dFJlZikge1xuICAgICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSB7XG4gICAgICAgIGVsZW1lbnQ6IHRleHRSZWYsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogY3VycmVudFZhbHVlUmVmLmN1cnJlbnRcbiAgICAgIH07XG4gICAgICBjb25zdCBpbWFnZVVwbG9hZEZ1bmN0aW9uID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbikgPyBpbWFnZVVwbG9hZENhbGxiYWNrIDogdm9pZCAwO1xuICAgICAgZWRpdG9yMiA9IG5ldyBTaW1wbGVNREUoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxPcHRpb25zLCBvcHRpb25zLCB7XG4gICAgICAgICAgaW1hZ2VVcGxvYWRGdW5jdGlvblxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHNldEVkaXRvcihlZGl0b3IyKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVkaXRvcjIgPT0gbnVsbCA/IHZvaWQgMCA6IGVkaXRvcjIudG9UZXh0QXJlYSgpO1xuICAgICAgZWRpdG9yMiA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yMi5jbGVhbnVwKCk7XG4gICAgfTtcbiAgfSwgW3RleHRSZWYsIGN1cnJlbnRWYWx1ZVJlZiwgaWQsIGltYWdlVXBsb2FkQ2FsbGJhY2ssIG9wdGlvbnNdKTtcbiAgY29uc3QgY29kZW1pcnJvciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBlZGl0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVkaXRvci5jb2RlbWlycm9yO1xuICB9LCBbZWRpdG9yID09IG51bGwgPyB2b2lkIDAgOiBlZGl0b3IuY29kZW1pcnJvcl0pO1xuICByZXR1cm4geyBlZGl0b3IsIGNvZGVtaXJyb3IgfTtcbn07XG52YXIgU2ltcGxlTWRlUmVhY3QgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBldmVudHMsXG4gICAgdmFsdWUsXG4gICAgb3B0aW9ucyxcbiAgICBjaGlsZHJlbixcbiAgICBleHRyYUtleXMsXG4gICAgZ2V0TGluZUFuZEN1cnNvcixcbiAgICBnZXRNZGVJbnN0YW5jZSxcbiAgICBnZXRDb2RlbWlycm9ySW5zdGFuY2UsXG4gICAgb25DaGFuZ2UsXG4gICAgaWQ6IGFuSWQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgdGV4dGFyZWFQcm9wcyxcbiAgICAuLi5yZXN0XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IGFuSWQgPz8gZ2VuZXJhdGVJZCgpLCBbYW5JZF0pO1xuICBjb25zdCBlbGVtZW50V3JhcHBlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgbm9uRXZlbnRDaGFuZ2VSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IGN1cnJlbnRWYWx1ZVJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIGN1cnJlbnRWYWx1ZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIGNvbnN0IFt0ZXh0UmVmLCBzZXRUZXh0UmVmXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCB7IGVkaXRvciwgY29kZW1pcnJvciB9ID0gdXNlSGFuZGxlRWRpdG9ySW5zdGFuY2VMaWZlY3ljbGUoe1xuICAgIG9wdGlvbnMsXG4gICAgaWQsXG4gICAgY3VycmVudFZhbHVlUmVmLFxuICAgIHRleHRSZWZcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG5vbkV2ZW50Q2hhbmdlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLnZhbHVlKHZhbHVlID8/IFwiXCIpO1xuICAgIH1cbiAgICBub25FdmVudENoYW5nZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSwgW2VkaXRvciwgdmFsdWVdKTtcbiAgY29uc3Qgb25Db2RlbWlycm9yQ2hhbmdlSGFuZGxlciA9IHVzZUNhbGxiYWNrKFxuICAgIChfLCBjaGFuZ2VPYmplY3QpID0+IHtcbiAgICAgIGlmICgoZWRpdG9yID09IG51bGwgPyB2b2lkIDAgOiBlZGl0b3IudmFsdWUoKSkgIT09IGN1cnJlbnRWYWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIG5vbkV2ZW50Q2hhbmdlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2hhbmdlKChlZGl0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVkaXRvci52YWx1ZSgpKSA/PyBcIlwiLCBjaGFuZ2VPYmplY3QpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2VkaXRvciwgb25DaGFuZ2VdXG4gICk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYXV0b2ZvY3VzKSB7XG4gICAgICBjb2RlbWlycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb2RlbWlycm9yLmZvY3VzKCk7XG4gICAgICBjb2RlbWlycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb2RlbWlycm9yLnNldEN1cnNvcihjb2RlbWlycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb2RlbWlycm9yLmxpbmVDb3VudCgpLCAwKTtcbiAgICB9XG4gIH0sIFtjb2RlbWlycm9yLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmF1dG9mb2N1c10pO1xuICBjb25zdCBnZXRDdXJzb3JDYWxsYmFjayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb2RlbWlycm9yICYmIChnZXRMaW5lQW5kQ3Vyc29yID09IG51bGwgPyB2b2lkIDAgOiBnZXRMaW5lQW5kQ3Vyc29yKGNvZGVtaXJyb3IuZ2V0RG9jKCkuZ2V0Q3Vyc29yKCkpKTtcbiAgfSwgW2NvZGVtaXJyb3IsIGdldExpbmVBbmRDdXJzb3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBnZXRDdXJzb3JDYWxsYmFjaygpO1xuICB9LCBbZ2V0Q3Vyc29yQ2FsbGJhY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBlZGl0b3IgJiYgKGdldE1kZUluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBnZXRNZGVJbnN0YW5jZShlZGl0b3IpKTtcbiAgfSwgW2VkaXRvciwgZ2V0TWRlSW5zdGFuY2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb2RlbWlycm9yICYmIChnZXRDb2RlbWlycm9ySW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGdldENvZGVtaXJyb3JJbnN0YW5jZShjb2RlbWlycm9yKSk7XG4gIH0sIFtjb2RlbWlycm9yLCBnZXRDb2RlbWlycm9ySW5zdGFuY2UsIGdldE1kZUluc3RhbmNlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGV4dHJhS2V5cyAmJiBjb2RlbWlycm9yKSB7XG4gICAgICBjb2RlbWlycm9yLnNldE9wdGlvbihcbiAgICAgICAgXCJleHRyYUtleXNcIixcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgY29kZW1pcnJvci5nZXRPcHRpb24oXCJleHRyYUtleXNcIiksIGV4dHJhS2V5cylcbiAgICAgICk7XG4gICAgfVxuICB9LCBbY29kZW1pcnJvciwgZXh0cmFLZXlzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRvb2xiYXJOb2RlID0gKF9hID0gZWxlbWVudFdyYXBwZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXG4gICAgICBcImVkaXRvci10b29sYmFyTm9kZVwiXG4gICAgKVswXTtcbiAgICBjb25zdCBoYW5kbGVyID0gY29kZW1pcnJvciAmJiBvbkNvZGVtaXJyb3JDaGFuZ2VIYW5kbGVyO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICB0b29sYmFyTm9kZSA9PSBudWxsID8gdm9pZCAwIDogdG9vbGJhck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdG9vbGJhck5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xiYXJOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfSwgW2NvZGVtaXJyb3IsIG9uQ29kZW1pcnJvckNoYW5nZUhhbmRsZXJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb2RlbWlycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb2RlbWlycm9yLm9uKFwiY2hhbmdlXCIsIG9uQ29kZW1pcnJvckNoYW5nZUhhbmRsZXIpO1xuICAgIGNvZGVtaXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGNvZGVtaXJyb3Iub24oXCJjdXJzb3JBY3Rpdml0eVwiLCBnZXRDdXJzb3JDYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvZGVtaXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGNvZGVtaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIG9uQ29kZW1pcnJvckNoYW5nZUhhbmRsZXIpO1xuICAgICAgY29kZW1pcnJvciA9PSBudWxsID8gdm9pZCAwIDogY29kZW1pcnJvci5vZmYoXCJjdXJzb3JBY3Rpdml0eVwiLCBnZXRDdXJzb3JDYWxsYmFjayk7XG4gICAgfTtcbiAgfSwgW2NvZGVtaXJyb3IsIGdldEN1cnNvckNhbGxiYWNrLCBvbkNvZGVtaXJyb3JDaGFuZ2VIYW5kbGVyXSk7XG4gIGNvbnN0IHByZXZFdmVudHMgPSB1c2VSZWYoZXZlbnRzKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpc05vdEZpcnN0RWZmZWN0UnVuID0gZXZlbnRzICE9PSBwcmV2RXZlbnRzLmN1cnJlbnQ7XG4gICAgaXNOb3RGaXJzdEVmZmVjdFJ1biAmJiBwcmV2RXZlbnRzLmN1cnJlbnQgJiYgT2JqZWN0LmVudHJpZXMocHJldkV2ZW50cy5jdXJyZW50KS5mb3JFYWNoKChbZXZlbnQsIGhhbmRsZXJdKSA9PiB7XG4gICAgICBoYW5kbGVyICYmIChjb2RlbWlycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb2RlbWlycm9yLm9mZihldmVudCwgaGFuZGxlcikpO1xuICAgIH0pO1xuICAgIGV2ZW50cyAmJiBPYmplY3QuZW50cmllcyhldmVudHMpLmZvckVhY2goKFtldmVudCwgaGFuZGxlcl0pID0+IHtcbiAgICAgIGhhbmRsZXIgJiYgKGNvZGVtaXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGNvZGVtaXJyb3Iub24oZXZlbnQsIGhhbmRsZXIpKTtcbiAgICB9KTtcbiAgICBwcmV2RXZlbnRzLmN1cnJlbnQgPSBldmVudHM7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cyAmJiBPYmplY3QuZW50cmllcyhldmVudHMpLmZvckVhY2goKFtldmVudCwgaGFuZGxlcl0pID0+IHtcbiAgICAgICAgaGFuZGxlciAmJiAoY29kZW1pcnJvciA9PSBudWxsID8gdm9pZCAwIDogY29kZW1pcnJvci5vZmYoZXZlbnQsIGhhbmRsZXIpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtjb2RlbWlycm9yLCBldmVudHNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogYCR7aWR9LXdyYXBwZXJgLFxuICAgIC4uLnJlc3QsXG4gICAgcmVmOiAoYVJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYoYVJlZik7XG4gICAgICB9IGVsc2UgaWYgKHJlZikge1xuICAgICAgICByZWYuY3VycmVudCA9IGFSZWY7XG4gICAgICB9XG4gICAgICBlbGVtZW50V3JhcHBlclJlZi5jdXJyZW50ID0gYVJlZjtcbiAgICB9XG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwge1xuICAgIC4uLnRleHRhcmVhUHJvcHMsXG4gICAgaWQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgcmVmOiBzZXRUZXh0UmVmLFxuICAgIHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH1cbiAgfSkpO1xufSk7XG5TaW1wbGVNZGVSZWFjdC5kaXNwbGF5TmFtZSA9IFwiU2ltcGxlTWRlUmVhY3RcIjtcbnZhciBTaW1wbGVNZGVSZWFjdF9kZWZhdWx0ID0gU2ltcGxlTWRlUmVhY3Q7XG5leHBvcnQge1xuICBTaW1wbGVNZGVSZWFjdCxcbiAgU2ltcGxlTWRlUmVhY3RfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlTWRlUmVhY3QubWpzLm1hcCJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiU2ltcGxlTURFIiwiX2lkIiwiZ2VuZXJhdGVJZCIsInVzZUhhbmRsZUVkaXRvckluc3RhbmNlTGlmZWN5Y2xlIiwib3B0aW9ucyIsImlkIiwiY3VycmVudFZhbHVlUmVmIiwidGV4dFJlZiIsImVkaXRvciIsInNldEVkaXRvciIsImltYWdlVXBsb2FkQ2FsbGJhY2siLCJmaWxlIiwib25TdWNjZXNzIiwib25FcnJvciIsImltYWdlVXBsb2FkIiwiaW1hZ2VVcGxvYWRGdW5jdGlvbiIsIl9vblN1Y2Nlc3MiLCJ1cmwiLCJlZGl0b3JSZWYiLCJjdXJyZW50IiwiZWRpdG9yMiIsImluaXRpYWxPcHRpb25zIiwiZWxlbWVudCIsImluaXRpYWxWYWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsInRvVGV4dEFyZWEiLCJjbGVhbnVwIiwiY29kZW1pcnJvciIsIlNpbXBsZU1kZVJlYWN0IiwiZm9yd2FyZFJlZiIsInByb3BzIiwicmVmIiwiZXZlbnRzIiwidmFsdWUiLCJjaGlsZHJlbiIsImV4dHJhS2V5cyIsImdldExpbmVBbmRDdXJzb3IiLCJnZXRNZGVJbnN0YW5jZSIsImdldENvZGVtaXJyb3JJbnN0YW5jZSIsIm9uQ2hhbmdlIiwiYW5JZCIsInBsYWNlaG9sZGVyIiwidGV4dGFyZWFQcm9wcyIsInJlc3QiLCJlbGVtZW50V3JhcHBlclJlZiIsIm5vbkV2ZW50Q2hhbmdlUmVmIiwic2V0VGV4dFJlZiIsIm9uQ29kZW1pcnJvckNoYW5nZUhhbmRsZXIiLCJfIiwiY2hhbmdlT2JqZWN0IiwiYXV0b2ZvY3VzIiwiZm9jdXMiLCJzZXRDdXJzb3IiLCJsaW5lQ291bnQiLCJnZXRDdXJzb3JDYWxsYmFjayIsImdldERvYyIsImdldEN1cnNvciIsInNldE9wdGlvbiIsImdldE9wdGlvbiIsIl9hIiwidG9vbGJhck5vZGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiaGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib24iLCJvZmYiLCJwcmV2RXZlbnRzIiwiaXNOb3RGaXJzdEVmZmVjdFJ1biIsImVudHJpZXMiLCJmb3JFYWNoIiwiZXZlbnQiLCJjcmVhdGVFbGVtZW50IiwiYVJlZiIsInN0eWxlIiwiZGlzcGxheSIsImRpc3BsYXlOYW1lIiwiU2ltcGxlTWRlUmVhY3RfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-simplemde-editor/dist/SimpleMdeReact.mjs\n"));

/***/ })

}]);