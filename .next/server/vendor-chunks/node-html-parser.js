"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-html-parser";
exports.ids = ["vendor-chunks/node-html-parser"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-html-parser/dist/back.js":
/*!****************************************************!*\
  !*** ./node_modules/node-html-parser/dist/back.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction arr_back(arr) {\n    return arr[arr.length - 1];\n}\nexports[\"default\"] = arr_back;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L2JhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsU0FBU0MsU0FBU0MsR0FBRztJQUNqQixPQUFPQSxHQUFHLENBQUNBLElBQUlDLE1BQU0sR0FBRyxFQUFFO0FBQzlCO0FBQ0FKLGtCQUFlLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVyby8uL25vZGVfbW9kdWxlcy9ub2RlLWh0bWwtcGFyc2VyL2Rpc3QvYmFjay5qcz8zMmFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gYXJyX2JhY2soYXJyKSB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBhcnJfYmFjaztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFycl9iYWNrIiwiYXJyIiwibGVuZ3RoIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/back.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-html-parser/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NodeType = exports.TextNode = exports.Node = exports.valid = exports.CommentNode = exports.HTMLElement = exports.parse = void 0;\nconst comment_1 = __importDefault(__webpack_require__(/*! ./nodes/comment */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/comment.js\"));\nexports.CommentNode = comment_1.default;\nconst html_1 = __importDefault(__webpack_require__(/*! ./nodes/html */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/html.js\"));\nexports.HTMLElement = html_1.default;\nconst node_1 = __importDefault(__webpack_require__(/*! ./nodes/node */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/node.js\"));\nexports.Node = node_1.default;\nconst text_1 = __importDefault(__webpack_require__(/*! ./nodes/text */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/text.js\"));\nexports.TextNode = text_1.default;\nconst type_1 = __importDefault(__webpack_require__(/*! ./nodes/type */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/type.js\"));\nexports.NodeType = type_1.default;\nconst parse_1 = __importDefault(__webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/node-html-parser/dist/parse.js\"));\nconst valid_1 = __importDefault(__webpack_require__(/*! ./valid */ \"(rsc)/./node_modules/node-html-parser/dist/valid.js\"));\nexports.valid = valid_1.default;\nfunction parse(data, options = {}) {\n    return (0, parse_1.default)(data, options);\n}\nexports[\"default\"] = parse;\nexports.parse = parse;\nparse.parse = parse_1.default;\nparse.HTMLElement = html_1.default;\nparse.CommentNode = comment_1.default;\nparse.valid = valid_1.default;\nparse.Node = node_1.default;\nparse.TextNode = text_1.default;\nparse.NodeType = type_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLFlBQVksR0FBR0EsYUFBYSxHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ3RJLE1BQU1TLFlBQVlkLGdCQUFnQmUsbUJBQU9BLENBQUMsb0ZBQWlCO0FBQzNEVixtQkFBbUIsR0FBR1MsVUFBVUUsT0FBTztBQUN2QyxNQUFNQyxTQUFTakIsZ0JBQWdCZSxtQkFBT0EsQ0FBQyw4RUFBYztBQUNyRFYsbUJBQW1CLEdBQUdZLE9BQU9ELE9BQU87QUFDcEMsTUFBTUUsU0FBU2xCLGdCQUFnQmUsbUJBQU9BLENBQUMsOEVBQWM7QUFDckRWLFlBQVksR0FBR2EsT0FBT0YsT0FBTztBQUM3QixNQUFNRyxTQUFTbkIsZ0JBQWdCZSxtQkFBT0EsQ0FBQyw4RUFBYztBQUNyRFYsZ0JBQWdCLEdBQUdjLE9BQU9ILE9BQU87QUFDakMsTUFBTUksU0FBU3BCLGdCQUFnQmUsbUJBQU9BLENBQUMsOEVBQWM7QUFDckRWLGdCQUFnQixHQUFHZSxPQUFPSixPQUFPO0FBQ2pDLE1BQU1LLFVBQVVyQixnQkFBZ0JlLG1CQUFPQSxDQUFDLG9FQUFTO0FBQ2pELE1BQU1PLFVBQVV0QixnQkFBZ0JlLG1CQUFPQSxDQUFDLG9FQUFTO0FBQ2pEVixhQUFhLEdBQUdpQixRQUFRTixPQUFPO0FBQy9CLFNBQVNILE1BQU1VLElBQUksRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDN0IsT0FBTyxDQUFDLEdBQUdILFFBQVFMLE9BQU8sRUFBRU8sTUFBTUM7QUFDdEM7QUFDQW5CLGtCQUFlLEdBQUdRO0FBQ2xCUixhQUFhLEdBQUdRO0FBQ2hCQSxNQUFNQSxLQUFLLEdBQUdRLFFBQVFMLE9BQU87QUFDN0JILE1BQU1ELFdBQVcsR0FBR0ssT0FBT0QsT0FBTztBQUNsQ0gsTUFBTUYsV0FBVyxHQUFHRyxVQUFVRSxPQUFPO0FBQ3JDSCxNQUFNSCxLQUFLLEdBQUdZLFFBQVFOLE9BQU87QUFDN0JILE1BQU1KLElBQUksR0FBR1MsT0FBT0YsT0FBTztBQUMzQkgsTUFBTUwsUUFBUSxHQUFHVyxPQUFPSCxPQUFPO0FBQy9CSCxNQUFNTixRQUFRLEdBQUdhLE9BQU9KLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXJvLy4vbm9kZV9tb2R1bGVzL25vZGUtaHRtbC1wYXJzZXIvZGlzdC9pbmRleC5qcz8xNTI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob2RlVHlwZSA9IGV4cG9ydHMuVGV4dE5vZGUgPSBleHBvcnRzLk5vZGUgPSBleHBvcnRzLnZhbGlkID0gZXhwb3J0cy5Db21tZW50Tm9kZSA9IGV4cG9ydHMuSFRNTEVsZW1lbnQgPSBleHBvcnRzLnBhcnNlID0gdm9pZCAwO1xuY29uc3QgY29tbWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVzL2NvbW1lbnRcIikpO1xuZXhwb3J0cy5Db21tZW50Tm9kZSA9IGNvbW1lbnRfMS5kZWZhdWx0O1xuY29uc3QgaHRtbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVzL2h0bWxcIikpO1xuZXhwb3J0cy5IVE1MRWxlbWVudCA9IGh0bWxfMS5kZWZhdWx0O1xuY29uc3Qgbm9kZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVzL25vZGVcIikpO1xuZXhwb3J0cy5Ob2RlID0gbm9kZV8xLmRlZmF1bHQ7XG5jb25zdCB0ZXh0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbm9kZXMvdGV4dFwiKSk7XG5leHBvcnRzLlRleHROb2RlID0gdGV4dF8xLmRlZmF1bHQ7XG5jb25zdCB0eXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbm9kZXMvdHlwZVwiKSk7XG5leHBvcnRzLk5vZGVUeXBlID0gdHlwZV8xLmRlZmF1bHQ7XG5jb25zdCBwYXJzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlXCIpKTtcbmNvbnN0IHZhbGlkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRcIikpO1xuZXhwb3J0cy52YWxpZCA9IHZhbGlkXzEuZGVmYXVsdDtcbmZ1bmN0aW9uIHBhcnNlKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiAoMCwgcGFyc2VfMS5kZWZhdWx0KShkYXRhLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xucGFyc2UucGFyc2UgPSBwYXJzZV8xLmRlZmF1bHQ7XG5wYXJzZS5IVE1MRWxlbWVudCA9IGh0bWxfMS5kZWZhdWx0O1xucGFyc2UuQ29tbWVudE5vZGUgPSBjb21tZW50XzEuZGVmYXVsdDtcbnBhcnNlLnZhbGlkID0gdmFsaWRfMS5kZWZhdWx0O1xucGFyc2UuTm9kZSA9IG5vZGVfMS5kZWZhdWx0O1xucGFyc2UuVGV4dE5vZGUgPSB0ZXh0XzEuZGVmYXVsdDtcbnBhcnNlLk5vZGVUeXBlID0gdHlwZV8xLmRlZmF1bHQ7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTm9kZVR5cGUiLCJUZXh0Tm9kZSIsIk5vZGUiLCJ2YWxpZCIsIkNvbW1lbnROb2RlIiwiSFRNTEVsZW1lbnQiLCJwYXJzZSIsImNvbW1lbnRfMSIsInJlcXVpcmUiLCJkZWZhdWx0IiwiaHRtbF8xIiwibm9kZV8xIiwidGV4dF8xIiwidHlwZV8xIiwicGFyc2VfMSIsInZhbGlkXzEiLCJkYXRhIiwib3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/matcher.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-html-parser/dist/matcher.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst type_1 = __importDefault(__webpack_require__(/*! ./nodes/type */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/type.js\"));\nfunction isTag(node) {\n    return node && node.nodeType === type_1.default.ELEMENT_NODE;\n}\nfunction getAttributeValue(elem, name) {\n    return isTag(elem) ? elem.getAttribute(name) : undefined;\n}\nfunction getName(elem) {\n    return (elem && elem.rawTagName || \"\").toLowerCase();\n}\nfunction getChildren(node) {\n    return node && node.childNodes;\n}\nfunction getParent(node) {\n    return node ? node.parentNode : null;\n}\nfunction getText(node) {\n    return node.text;\n}\nfunction removeSubsets(nodes) {\n    let idx = nodes.length;\n    let node;\n    let ancestor;\n    let replace;\n    // Check if each node (or one of its ancestors) is already contained in the\n    // array.\n    while(--idx > -1){\n        node = ancestor = nodes[idx];\n        // Temporarily remove the node under consideration\n        nodes[idx] = null;\n        replace = true;\n        while(ancestor){\n            if (nodes.indexOf(ancestor) > -1) {\n                replace = false;\n                nodes.splice(idx, 1);\n                break;\n            }\n            ancestor = getParent(ancestor);\n        }\n        // If the node has been found to be unique, re-insert it.\n        if (replace) {\n            nodes[idx] = node;\n        }\n    }\n    return nodes;\n}\nfunction existsOne(test, elems) {\n    return elems.some((elem)=>{\n        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\n    });\n}\nfunction getSiblings(node) {\n    const parent = getParent(node);\n    return parent ? getChildren(parent) : [];\n}\nfunction hasAttrib(elem, name) {\n    return getAttributeValue(elem, name) !== undefined;\n}\nfunction findOne(test, elems) {\n    let elem = null;\n    for(let i = 0, l = elems === null || elems === void 0 ? void 0 : elems.length; i < l && !elem; i++){\n        const el = elems[i];\n        if (test(el)) {\n            elem = el;\n        } else {\n            const childs = getChildren(el);\n            if (childs && childs.length > 0) {\n                elem = findOne(test, childs);\n            }\n        }\n    }\n    return elem;\n}\nfunction findAll(test, nodes) {\n    let result = [];\n    for(let i = 0, j = nodes.length; i < j; i++){\n        if (!isTag(nodes[i])) continue;\n        if (test(nodes[i])) result.push(nodes[i]);\n        const childs = getChildren(nodes[i]);\n        if (childs) result = result.concat(findAll(test, childs));\n    }\n    return result;\n}\nexports[\"default\"] = {\n    isTag,\n    getAttributeValue,\n    getName,\n    getChildren,\n    getParent,\n    getText,\n    removeSubsets,\n    existsOne,\n    getSiblings,\n    hasAttrib,\n    findOne,\n    findAll\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L21hdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsU0FBU1AsZ0JBQWdCUSxtQkFBT0EsQ0FBQyw4RUFBYztBQUNyRCxTQUFTQyxNQUFNQyxJQUFJO0lBQ2YsT0FBT0EsUUFBUUEsS0FBS0MsUUFBUSxLQUFLSixPQUFPSyxPQUFPLENBQUNDLFlBQVk7QUFDaEU7QUFDQSxTQUFTQyxrQkFBa0JDLElBQUksRUFBRUMsSUFBSTtJQUNqQyxPQUFPUCxNQUFNTSxRQUFRQSxLQUFLRSxZQUFZLENBQUNELFFBQVFFO0FBQ25EO0FBQ0EsU0FBU0MsUUFBUUosSUFBSTtJQUNqQixPQUFPLENBQUMsUUFBU0EsS0FBS0ssVUFBVSxJQUFLLEVBQUMsRUFBR0MsV0FBVztBQUN4RDtBQUNBLFNBQVNDLFlBQVlaLElBQUk7SUFDckIsT0FBT0EsUUFBUUEsS0FBS2EsVUFBVTtBQUNsQztBQUNBLFNBQVNDLFVBQVVkLElBQUk7SUFDbkIsT0FBT0EsT0FBT0EsS0FBS2UsVUFBVSxHQUFHO0FBQ3BDO0FBQ0EsU0FBU0MsUUFBUWhCLElBQUk7SUFDakIsT0FBT0EsS0FBS2lCLElBQUk7QUFDcEI7QUFDQSxTQUFTQyxjQUFjQyxLQUFLO0lBQ3hCLElBQUlDLE1BQU1ELE1BQU1FLE1BQU07SUFDdEIsSUFBSXJCO0lBQ0osSUFBSXNCO0lBQ0osSUFBSUM7SUFDSiwyRUFBMkU7SUFDM0UsU0FBUztJQUNULE1BQU8sRUFBRUgsTUFBTSxDQUFDLEVBQUc7UUFDZnBCLE9BQU9zQixXQUFXSCxLQUFLLENBQUNDLElBQUk7UUFDNUIsa0RBQWtEO1FBQ2xERCxLQUFLLENBQUNDLElBQUksR0FBRztRQUNiRyxVQUFVO1FBQ1YsTUFBT0QsU0FBVTtZQUNiLElBQUlILE1BQU1LLE9BQU8sQ0FBQ0YsWUFBWSxDQUFDLEdBQUc7Z0JBQzlCQyxVQUFVO2dCQUNWSixNQUFNTSxNQUFNLENBQUNMLEtBQUs7Z0JBQ2xCO1lBQ0o7WUFDQUUsV0FBV1IsVUFBVVE7UUFDekI7UUFDQSx5REFBeUQ7UUFDekQsSUFBSUMsU0FBUztZQUNUSixLQUFLLENBQUNDLElBQUksR0FBR3BCO1FBQ2pCO0lBQ0o7SUFDQSxPQUFPbUI7QUFDWDtBQUNBLFNBQVNPLFVBQVVDLElBQUksRUFBRUMsS0FBSztJQUMxQixPQUFPQSxNQUFNQyxJQUFJLENBQUMsQ0FBQ3hCO1FBQ2YsT0FBT04sTUFBTU0sUUFBUXNCLEtBQUt0QixTQUFTcUIsVUFBVUMsTUFBTWYsWUFBWVAsU0FBUztJQUM1RTtBQUNKO0FBQ0EsU0FBU3lCLFlBQVk5QixJQUFJO0lBQ3JCLE1BQU0rQixTQUFTakIsVUFBVWQ7SUFDekIsT0FBTytCLFNBQVNuQixZQUFZbUIsVUFBVSxFQUFFO0FBQzVDO0FBQ0EsU0FBU0MsVUFBVTNCLElBQUksRUFBRUMsSUFBSTtJQUN6QixPQUFPRixrQkFBa0JDLE1BQU1DLFVBQVVFO0FBQzdDO0FBQ0EsU0FBU3lCLFFBQVFOLElBQUksRUFBRUMsS0FBSztJQUN4QixJQUFJdkIsT0FBTztJQUNYLElBQUssSUFBSTZCLElBQUksR0FBR0MsSUFBSVAsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1QLE1BQU0sRUFBRWEsSUFBSUMsS0FBSyxDQUFDOUIsTUFBTTZCLElBQUs7UUFDakcsTUFBTUUsS0FBS1IsS0FBSyxDQUFDTSxFQUFFO1FBQ25CLElBQUlQLEtBQUtTLEtBQUs7WUFDVi9CLE9BQU8rQjtRQUNYLE9BQ0s7WUFDRCxNQUFNQyxTQUFTekIsWUFBWXdCO1lBQzNCLElBQUlDLFVBQVVBLE9BQU9oQixNQUFNLEdBQUcsR0FBRztnQkFDN0JoQixPQUFPNEIsUUFBUU4sTUFBTVU7WUFDekI7UUFDSjtJQUNKO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTaUMsUUFBUVgsSUFBSSxFQUFFUixLQUFLO0lBQ3hCLElBQUlvQixTQUFTLEVBQUU7SUFDZixJQUFLLElBQUlMLElBQUksR0FBR00sSUFBSXJCLE1BQU1FLE1BQU0sRUFBRWEsSUFBSU0sR0FBR04sSUFBSztRQUMxQyxJQUFJLENBQUNuQyxNQUFNb0IsS0FBSyxDQUFDZSxFQUFFLEdBQ2Y7UUFDSixJQUFJUCxLQUFLUixLQUFLLENBQUNlLEVBQUUsR0FDYkssT0FBT0UsSUFBSSxDQUFDdEIsS0FBSyxDQUFDZSxFQUFFO1FBQ3hCLE1BQU1HLFNBQVN6QixZQUFZTyxLQUFLLENBQUNlLEVBQUU7UUFDbkMsSUFBSUcsUUFDQUUsU0FBU0EsT0FBT0csTUFBTSxDQUFDSixRQUFRWCxNQUFNVTtJQUM3QztJQUNBLE9BQU9FO0FBQ1g7QUFDQTVDLGtCQUFlLEdBQUc7SUFDZEk7SUFDQUs7SUFDQUs7SUFDQUc7SUFDQUU7SUFDQUU7SUFDQUU7SUFDQVE7SUFDQUk7SUFDQUU7SUFDQUM7SUFDQUs7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcm8vLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L21hdGNoZXIuanM/M2Q5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ub2Rlcy90eXBlXCIpKTtcbmZ1bmN0aW9uIGlzVGFnKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSB0eXBlXzEuZGVmYXVsdC5FTEVNRU5UX05PREU7XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSB7XG4gICAgcmV0dXJuIGlzVGFnKGVsZW0pID8gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXROYW1lKGVsZW0pIHtcbiAgICByZXR1cm4gKChlbGVtICYmIGVsZW0ucmF3VGFnTmFtZSkgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IG5vZGUucGFyZW50Tm9kZSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRUZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50ZXh0O1xufVxuZnVuY3Rpb24gcmVtb3ZlU3Vic2V0cyhub2Rlcykge1xuICAgIGxldCBpZHggPSBub2Rlcy5sZW5ndGg7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGFuY2VzdG9yO1xuICAgIGxldCByZXBsYWNlO1xuICAgIC8vIENoZWNrIGlmIGVhY2ggbm9kZSAob3Igb25lIG9mIGl0cyBhbmNlc3RvcnMpIGlzIGFscmVhZHkgY29udGFpbmVkIGluIHRoZVxuICAgIC8vIGFycmF5LlxuICAgIHdoaWxlICgtLWlkeCA+IC0xKSB7XG4gICAgICAgIG5vZGUgPSBhbmNlc3RvciA9IG5vZGVzW2lkeF07XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHJlbW92ZSB0aGUgbm9kZSB1bmRlciBjb25zaWRlcmF0aW9uXG4gICAgICAgIG5vZGVzW2lkeF0gPSBudWxsO1xuICAgICAgICByZXBsYWNlID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihhbmNlc3RvcikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gZ2V0UGFyZW50KGFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgbm9kZSBoYXMgYmVlbiBmb3VuZCB0byBiZSB1bmlxdWUsIHJlLWluc2VydCBpdC5cbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgIG5vZGVzW2lkeF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGV4aXN0c09uZSh0ZXN0LCBlbGVtcykge1xuICAgIHJldHVybiBlbGVtcy5zb21lKChlbGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpc1RhZyhlbGVtKSA/IHRlc3QoZWxlbSkgfHwgZXhpc3RzT25lKHRlc3QsIGdldENoaWxkcmVuKGVsZW0pKSA6IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2libGluZ3Mobm9kZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IGdldFBhcmVudChub2RlKTtcbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0Q2hpbGRyZW4ocGFyZW50KSA6IFtdO1xufVxuZnVuY3Rpb24gaGFzQXR0cmliKGVsZW0sIG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSkgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGZpbmRPbmUodGVzdCwgZWxlbXMpIHtcbiAgICBsZXQgZWxlbSA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbGVtcyA9PT0gbnVsbCB8fCBlbGVtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbXMubGVuZ3RoOyBpIDwgbCAmJiAhZWxlbTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZWxlbXNbaV07XG4gICAgICAgIGlmICh0ZXN0KGVsKSkge1xuICAgICAgICAgICAgZWxlbSA9IGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRzID0gZ2V0Q2hpbGRyZW4oZWwpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcyAmJiBjaGlsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVsZW0gPSBmaW5kT25lKHRlc3QsIGNoaWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiBmaW5kQWxsKHRlc3QsIG5vZGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmICghaXNUYWcobm9kZXNbaV0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0ZXN0KG5vZGVzW2ldKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGVzW2ldKTtcbiAgICAgICAgY29uc3QgY2hpbGRzID0gZ2V0Q2hpbGRyZW4obm9kZXNbaV0pO1xuICAgICAgICBpZiAoY2hpbGRzKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChmaW5kQWxsKHRlc3QsIGNoaWxkcykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGlzVGFnLFxuICAgIGdldEF0dHJpYnV0ZVZhbHVlLFxuICAgIGdldE5hbWUsXG4gICAgZ2V0Q2hpbGRyZW4sXG4gICAgZ2V0UGFyZW50LFxuICAgIGdldFRleHQsXG4gICAgcmVtb3ZlU3Vic2V0cyxcbiAgICBleGlzdHNPbmUsXG4gICAgZ2V0U2libGluZ3MsXG4gICAgaGFzQXR0cmliLFxuICAgIGZpbmRPbmUsXG4gICAgZmluZEFsbFxufTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0eXBlXzEiLCJyZXF1aXJlIiwiaXNUYWciLCJub2RlIiwibm9kZVR5cGUiLCJkZWZhdWx0IiwiRUxFTUVOVF9OT0RFIiwiZ2V0QXR0cmlidXRlVmFsdWUiLCJlbGVtIiwibmFtZSIsImdldEF0dHJpYnV0ZSIsInVuZGVmaW5lZCIsImdldE5hbWUiLCJyYXdUYWdOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRDaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJnZXRQYXJlbnQiLCJwYXJlbnROb2RlIiwiZ2V0VGV4dCIsInRleHQiLCJyZW1vdmVTdWJzZXRzIiwibm9kZXMiLCJpZHgiLCJsZW5ndGgiLCJhbmNlc3RvciIsInJlcGxhY2UiLCJpbmRleE9mIiwic3BsaWNlIiwiZXhpc3RzT25lIiwidGVzdCIsImVsZW1zIiwic29tZSIsImdldFNpYmxpbmdzIiwicGFyZW50IiwiaGFzQXR0cmliIiwiZmluZE9uZSIsImkiLCJsIiwiZWwiLCJjaGlsZHMiLCJmaW5kQWxsIiwicmVzdWx0IiwiaiIsInB1c2giLCJjb25jYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/matcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/nodes/comment.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-html-parser/dist/nodes/comment.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst node_1 = __importDefault(__webpack_require__(/*! ./node */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/node.js\"));\nconst type_1 = __importDefault(__webpack_require__(/*! ./type */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/type.js\"));\nclass CommentNode extends node_1.default {\n    clone() {\n        return new CommentNode(this.rawText, null, undefined, this.rawTagName);\n    }\n    constructor(rawText, parentNode = null, range, rawTagName = \"!--\"){\n        super(parentNode, range);\n        this.rawText = rawText;\n        this.rawTagName = rawTagName;\n        /**\n         * Node Type declaration.\n         * @type {Number}\n         */ this.nodeType = type_1.default.COMMENT_NODE;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */ get text() {\n        return this.rawText;\n    }\n    toString() {\n        return `<!--${this.rawText}-->`;\n    }\n}\nexports[\"default\"] = CommentNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L25vZGVzL2NvbW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsU0FBU1AsZ0JBQWdCUSxtQkFBT0EsQ0FBQyx3RUFBUTtBQUMvQyxNQUFNQyxTQUFTVCxnQkFBZ0JRLG1CQUFPQSxDQUFDLHdFQUFRO0FBQy9DLE1BQU1FLG9CQUFvQkgsT0FBT0ksT0FBTztJQUNwQ0MsUUFBUTtRQUNKLE9BQU8sSUFBSUYsWUFBWSxJQUFJLENBQUNHLE9BQU8sRUFBRSxNQUFNQyxXQUFXLElBQUksQ0FBQ0MsVUFBVTtJQUN6RTtJQUNBQyxZQUFZSCxPQUFPLEVBQUVJLGFBQWEsSUFBSSxFQUFFQyxLQUFLLEVBQUVILGFBQWEsS0FBSyxDQUFFO1FBQy9ELEtBQUssQ0FBQ0UsWUFBWUM7UUFDbEIsSUFBSSxDQUFDTCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxVQUFVLEdBQUdBO1FBQ2xCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0ksUUFBUSxHQUFHVixPQUFPRSxPQUFPLENBQUNTLFlBQVk7SUFDL0M7SUFDQTs7O0tBR0MsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUNSLE9BQU87SUFDdkI7SUFDQVMsV0FBVztRQUNQLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDVCxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ25DO0FBQ0o7QUFDQVIsa0JBQWUsR0FBR0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXJvLy4vbm9kZV9tb2R1bGVzL25vZGUtaHRtbC1wYXJzZXIvZGlzdC9ub2Rlcy9jb21tZW50LmpzPzM4YTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBub2RlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7XG5jb25zdCB0eXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHlwZVwiKSk7XG5jbGFzcyBDb21tZW50Tm9kZSBleHRlbmRzIG5vZGVfMS5kZWZhdWx0IHtcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21tZW50Tm9kZSh0aGlzLnJhd1RleHQsIG51bGwsIHVuZGVmaW5lZCwgdGhpcy5yYXdUYWdOYW1lKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocmF3VGV4dCwgcGFyZW50Tm9kZSA9IG51bGwsIHJhbmdlLCByYXdUYWdOYW1lID0gJyEtLScpIHtcbiAgICAgICAgc3VwZXIocGFyZW50Tm9kZSwgcmFuZ2UpO1xuICAgICAgICB0aGlzLnJhd1RleHQgPSByYXdUZXh0O1xuICAgICAgICB0aGlzLnJhd1RhZ05hbWUgPSByYXdUYWdOYW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZSBUeXBlIGRlY2xhcmF0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlVHlwZSA9IHR5cGVfMS5kZWZhdWx0LkNPTU1FTlRfTk9ERTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHVuZXNjYXBlZCB0ZXh0IHZhbHVlIG9mIGN1cnJlbnQgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGV4dCBjb250ZW50XG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1RleHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYDwhLS0ke3RoaXMucmF3VGV4dH0tLT5gO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbW1lbnROb2RlO1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm5vZGVfMSIsInJlcXVpcmUiLCJ0eXBlXzEiLCJDb21tZW50Tm9kZSIsImRlZmF1bHQiLCJjbG9uZSIsInJhd1RleHQiLCJ1bmRlZmluZWQiLCJyYXdUYWdOYW1lIiwiY29uc3RydWN0b3IiLCJwYXJlbnROb2RlIiwicmFuZ2UiLCJub2RlVHlwZSIsIkNPTU1FTlRfTk9ERSIsInRleHQiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/nodes/comment.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/nodes/html.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-html-parser/dist/nodes/html.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parse = exports.base_parse = void 0;\nconst css_select_1 = __webpack_require__(/*! css-select */ \"(rsc)/./node_modules/css-select/lib/index.js\");\nconst he_1 = __importDefault(__webpack_require__(/*! he */ \"(rsc)/./node_modules/he/he.js\"));\nconst back_1 = __importDefault(__webpack_require__(/*! ../back */ \"(rsc)/./node_modules/node-html-parser/dist/back.js\"));\nconst matcher_1 = __importDefault(__webpack_require__(/*! ../matcher */ \"(rsc)/./node_modules/node-html-parser/dist/matcher.js\"));\nconst void_tag_1 = __importDefault(__webpack_require__(/*! ../void-tag */ \"(rsc)/./node_modules/node-html-parser/dist/void-tag.js\"));\nconst comment_1 = __importDefault(__webpack_require__(/*! ./comment */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/comment.js\"));\nconst node_1 = __importDefault(__webpack_require__(/*! ./node */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/node.js\"));\nconst text_1 = __importDefault(__webpack_require__(/*! ./text */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/text.js\"));\nconst type_1 = __importDefault(__webpack_require__(/*! ./type */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/type.js\"));\nfunction decode(val) {\n    // clone string\n    return JSON.parse(JSON.stringify(he_1.default.decode(val)));\n}\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst Htags = [\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\"\n];\nconst Dtags = [\n    \"details\",\n    \"dialog\",\n    \"dd\",\n    \"div\",\n    \"dt\"\n];\nconst Ftags = [\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\"\n];\nconst tableTags = [\n    \"table\",\n    \"td\",\n    \"tr\"\n];\nconst htmlTags = [\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"br\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"ol\",\n    \"p\",\n    \"pre\",\n    \"section\",\n    \"ul\"\n];\nconst kBlockElements = new Set();\nfunction addToKBlockElement(...args) {\n    const addToSet = (array)=>{\n        for(let index = 0; index < array.length; index++){\n            const element = array[index];\n            kBlockElements.add(element);\n            kBlockElements.add(element.toUpperCase());\n        }\n    };\n    for (const arg of args)addToSet(arg);\n}\naddToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);\nclass DOMTokenList {\n    _validate(c) {\n        if (/\\s/.test(c)) {\n            throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\n        }\n    }\n    constructor(valuesInit = [], afterUpdate = ()=>null){\n        this._set = new Set(valuesInit);\n        this._afterUpdate = afterUpdate;\n    }\n    add(c) {\n        this._validate(c);\n        this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    replace(c1, c2) {\n        this._validate(c2);\n        this._set.delete(c1);\n        this._set.add(c2);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    remove(c) {\n        this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    toggle(c) {\n        this._validate(c);\n        if (this._set.has(c)) this._set.delete(c);\n        else this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    contains(c) {\n        return this._set.has(c);\n    }\n    get length() {\n        return this._set.size;\n    }\n    values() {\n        return this._set.values();\n    }\n    get value() {\n        return Array.from(this._set.values());\n    }\n    toString() {\n        return Array.from(this._set.values()).join(\" \");\n    }\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */ class HTMLElement extends node_1.default {\n    /**\n     * Quote attribute values\n     * @param attr attribute value\n     * @returns {string} quoted value\n     */ quoteAttribute(attr) {\n        if (attr == null) {\n            return \"null\";\n        }\n        return JSON.stringify(attr.replace(/\"/g, \"&quot;\")).replace(/\\\\t/g, \"\t\").replace(/\\\\n/g, \"\\n\").replace(/\\\\r/g, \"\\r\").replace(/\\\\/g, \"\");\n    }\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */ constructor(tagName, keyAttrs, rawAttrs = \"\", parentNode = null, range, voidTag = new void_tag_1.default(), _parseOptions = {}){\n        super(parentNode, range);\n        this.rawAttrs = rawAttrs;\n        this.voidTag = voidTag;\n        /**\n         * Node Type declaration.\n         */ this.nodeType = type_1.default.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || \"\";\n        this._id = keyAttrs.id || \"\";\n        this.childNodes = [];\n        this._parseOptions = _parseOptions;\n        this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], (classList)=>this.setAttribute(\"class\", classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        );\n        if (keyAttrs.id) {\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classList.toString()}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                } else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */ removeChild(node) {\n        this.childNodes = this.childNodes.filter((child)=>{\n            return child !== node;\n        });\n        return this;\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */ exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child)=>{\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n        return this;\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    set tagName(newname) {\n        this.rawTagName = newname.toLowerCase();\n    }\n    get localName() {\n        return this.rawTagName.toLowerCase();\n    }\n    get isVoidElement() {\n        return this.voidTag.isVoidElement(this.localName);\n    }\n    get id() {\n        return this._id;\n    }\n    set id(newid) {\n        this.setAttribute(\"id\", newid);\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */ get rawText() {\n        // https://github.com/taoqf/node-html-parser/issues/249\n        if (/^br$/i.test(this.rawTagName)) {\n            return \"\\n\";\n        }\n        return this.childNodes.reduce((pre, cur)=>{\n            return pre += cur.rawText;\n        }, \"\");\n    }\n    get textContent() {\n        return decode(this.rawText);\n    }\n    set textContent(val) {\n        const content = [\n            new text_1.default(val, this)\n        ];\n        this.childNodes = content;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */ get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */ get structuredText() {\n        let currentBlock = [];\n        const blocks = [\n            currentBlock\n        ];\n        function dfs(node) {\n            if (node.nodeType === type_1.default.ELEMENT_NODE) {\n                if (kBlockElements.has(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                } else {\n                    node.childNodes.forEach(dfs);\n                }\n            } else if (node.nodeType === type_1.default.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                } else {\n                    let text = node.trimmedText;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks.map((block)=>{\n            return block.join(\"\").replace(/\\s{2,}/g, \" \"); // Normalize each line's whitespace\n        }).join(\"\\n\").replace(/\\s+$/, \"\"); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : \"\";\n            return this.voidTag.formatNode(tag, attrs, this.innerHTML);\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes.map((child)=>{\n            return child.toString();\n        }).join(\"\");\n    }\n    set innerHTML(content) {\n        const r = parse(content, this._parseOptions);\n        const nodes = r.childNodes.length ? r.childNodes : [\n            new text_1.default(content, this)\n        ];\n        resetParent(nodes, this);\n        resetParent(this.childNodes, null);\n        this.childNodes = nodes;\n    }\n    set_content(content, options = {}) {\n        if (content instanceof node_1.default) {\n            content = [\n                content\n            ];\n        } else if (typeof content == \"string\") {\n            options = Object.assign(Object.assign({}, this._parseOptions), options);\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [\n                new text_1.default(r.innerHTML, this)\n            ];\n        }\n        resetParent(this.childNodes, null);\n        resetParent(content, this);\n        this.childNodes = content;\n        return this;\n    }\n    replaceWith(...nodes) {\n        const parent = this.parentNode;\n        const content = nodes.map((node)=>{\n            if (node instanceof node_1.default) {\n                return [\n                    node\n                ];\n            } else if (typeof node == \"string\") {\n                const r = parse(node, this._parseOptions);\n                return r.childNodes.length ? r.childNodes : [\n                    new text_1.default(node, this)\n                ];\n            }\n            return [];\n        }).flat();\n        const idx = parent.childNodes.findIndex((child)=>{\n            return child === this;\n        });\n        resetParent([\n            this\n        ], null);\n        parent.childNodes = [\n            ...parent.childNodes.slice(0, idx),\n            ...resetParent(content, parent),\n            ...parent.childNodes.slice(idx + 1)\n        ];\n        return this;\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */ trimRight(pattern) {\n        for(let i = 0; i < this.childNodes.length; i++){\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            } else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} structure\n     */ get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push(\"  \".repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node._id ? `#${node._id}` : \"\";\n            const classStr = node.classList.length ? `.${node.classList.value.join(\".\")}` : \"\"; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n            write(`${node.rawTagName}${idStr}${classStr}`);\n            indention++;\n            node.childNodes.forEach((childNode)=>{\n                if (childNode.nodeType === type_1.default.ELEMENT_NODE) {\n                    dfs(childNode);\n                } else if (childNode.nodeType === type_1.default.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write(\"#text\");\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join(\"\\n\");\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */ removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node)=>{\n            if (node.nodeType === type_1.default.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.trimmedRawText;\n            } else if (node.nodeType === type_1.default.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        // remove whitespace between attributes\n        const attrs = Object.keys(this.rawAttributes).map((key)=>{\n            const val = this.rawAttributes[key];\n            return `${key}=${JSON.stringify(val)}`;\n        }).join(\" \");\n        this.rawAttrs = attrs;\n        delete this._rawAttrs;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement[]}  matching elements\n     */ querySelectorAll(selector) {\n        return (0, css_select_1.selectAll)(selector, this, {\n            xmlMode: true,\n            adapter: matcher_1.default\n        });\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {(HTMLElement|null)}    matching node\n     */ querySelector(selector) {\n        return (0, css_select_1.selectOne)(selector, this, {\n            xmlMode: true,\n            adapter: matcher_1.default\n        });\n    }\n    /**\n     * find elements by their tagName\n     * @param {string} tagName the tagName of the elements to select\n     */ getElementsByTagName(tagName) {\n        const upperCasedTagName = tagName.toUpperCase();\n        const re = [];\n        const stack = [];\n        let currentNodeReference = this;\n        let index = 0;\n        // index turns to undefined once the stack is empty and the first condition occurs\n        // which happens once all relevant children are searched through\n        while(index !== undefined){\n            let child;\n            // make it work with sparse arrays\n            do {\n                child = currentNodeReference.childNodes[index++];\n            }while (index < currentNodeReference.childNodes.length && child === undefined);\n            // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\n            if (child === undefined) {\n                currentNodeReference = currentNodeReference.parentNode;\n                index = stack.pop();\n                continue;\n            }\n            if (child.nodeType === type_1.default.ELEMENT_NODE) {\n                // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName#syntax\n                if (tagName === \"*\" || child.tagName === upperCasedTagName) re.push(child);\n                // if children are existing push the current status to the stack and keep searching for elements in the level below\n                if (child.childNodes.length > 0) {\n                    stack.push(index);\n                    currentNodeReference = child;\n                    index = 0;\n                }\n            }\n        }\n        return re;\n    }\n    /**\n     * find element by it's id\n     * @param {string} id the id of the element to select\n     * @returns {HTMLElement | null} the element with the given id or null if not found\n     */ getElementById(id) {\n        const stack = [];\n        let currentNodeReference = this;\n        let index = 0;\n        // index turns to undefined once the stack is empty and the first condition occurs\n        // which happens once all relevant children are searched through\n        while(index !== undefined){\n            let child;\n            // make it work with sparse arrays\n            do {\n                child = currentNodeReference.childNodes[index++];\n            }while (index < currentNodeReference.childNodes.length && child === undefined);\n            // if the child does not exist we move on with the last provided index (which belongs to the parentNode)\n            if (child === undefined) {\n                currentNodeReference = currentNodeReference.parentNode;\n                index = stack.pop();\n                continue;\n            }\n            if (child.nodeType === type_1.default.ELEMENT_NODE) {\n                if (child._id === id) {\n                    return child;\n                }\n                // if children are existing push the current status to the stack and keep searching for elements in the level below\n                if (child.childNodes.length > 0) {\n                    stack.push(index);\n                    currentNodeReference = child;\n                    index = 0;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n     * @param selector a DOMString containing a selector list\n     * @returns {HTMLElement | null} the element with the given id or null if not found\n     */ closest(selector) {\n        const mapChild = new Map();\n        let el = this;\n        let old = null;\n        function findOne(test, elems) {\n            let elem = null;\n            for(let i = 0, l = elems.length; i < l && !elem; i++){\n                const el = elems[i];\n                if (test(el)) {\n                    elem = el;\n                } else {\n                    const child = mapChild.get(el);\n                    if (child) {\n                        elem = findOne(test, [\n                            child\n                        ]);\n                    }\n                }\n            }\n            return elem;\n        }\n        while(el){\n            mapChild.set(el, old);\n            old = el;\n            el = el.parentNode;\n        }\n        el = this;\n        while(el){\n            const e = (0, css_select_1.selectOne)(selector, el, {\n                xmlMode: true,\n                adapter: Object.assign(Object.assign({}, matcher_1.default), {\n                    getChildren (node) {\n                        const child = mapChild.get(node);\n                        return child && [\n                            child\n                        ];\n                    },\n                    getSiblings (node) {\n                        return [\n                            node\n                        ];\n                    },\n                    findOne,\n                    findAll () {\n                        return [];\n                    }\n                })\n            });\n            if (e) {\n                return e;\n            }\n            el = el.parentNode;\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */ appendChild(node) {\n        this.append(node);\n        return node;\n    }\n    /**\n     * Get attributes\n     * @access private\n     * @return {Object} parsed and unescaped attributes\n     */ get attrs() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for(const key in attrs){\n            const val = attrs[key] || \"\";\n            this._attrs[key.toLowerCase()] = decode(val);\n        }\n        return this._attrs;\n    }\n    get attributes() {\n        const ret_attrs = {};\n        const attrs = this.rawAttributes;\n        for(const key in attrs){\n            const val = attrs[key] || \"\";\n            ret_attrs[key] = decode(val);\n        }\n        return ret_attrs;\n    }\n    /**\n     * Get escaped (as-is) attributes\n     * @return {Object} parsed attributes\n     */ get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /([a-zA-Z()[\\]#@$.?:][a-zA-Z0-9-._:()[\\]#]*)(?:\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+))?/g;\n            let match;\n            while(match = re.exec(this.rawAttrs)){\n                const key = match[1];\n                let val = match[2] || null;\n                if (val && (val[0] === `'` || val[0] === `\"`)) val = val.slice(1, val.length - 1);\n                attrs[key] = attrs[key] || val;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name)=>{\n            const val = this.quoteAttribute(attrs[name]);\n            if (val === \"null\" || val === '\"\"') return name;\n            return `${name}=${val}`;\n        }).join(\" \");\n        // Update this._id\n        if (key === \"id\") {\n            this._id = \"\";\n        }\n        return this;\n    }\n    hasAttribute(key) {\n        return key.toLowerCase() in this.attrs;\n    }\n    /**\n     * Get an attribute\n     * @return {string | undefined} value of the attribute; or undefined if not exist\n     */ getAttribute(key) {\n        return this.attrs[key.toLowerCase()];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */ setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error(\"Failed to execute 'setAttribute' on 'Element'\");\n        }\n        const k2 = key.toLowerCase();\n        const attrs = this.rawAttributes;\n        for(const k in attrs){\n            if (k.toLowerCase() === k2) {\n                key = k;\n                break;\n            }\n        }\n        attrs[key] = String(value);\n        // update this.attrs\n        if (this._attrs) {\n            this._attrs[k2] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name)=>{\n            const val = this.quoteAttribute(attrs[name]);\n            if (val === \"null\" || val === '\"\"') return name;\n            return `${name}=${val}`;\n        }).join(\" \");\n        // Update this._id\n        if (key === \"id\") {\n            this._id = value;\n        }\n        return this;\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */ setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes).map((name)=>{\n            const val = attributes[name];\n            if (val === \"null\" || val === '\"\"') return name;\n            return `${name}=${this.quoteAttribute(String(val))}`;\n        }).join(\" \");\n        // Update this._id\n        if (\"id\" in attributes) {\n            this._id = attributes[\"id\"];\n        }\n        return this;\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error(\"2 arguments required\");\n        }\n        const p = parse(html, this._parseOptions);\n        if (where === \"afterend\") {\n            this.after(...p.childNodes);\n        } else if (where === \"afterbegin\") {\n            this.prepend(...p.childNodes);\n        } else if (where === \"beforeend\") {\n            this.append(...p.childNodes);\n        } else if (where === \"beforebegin\") {\n            this.before(...p.childNodes);\n        } else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        return this;\n    }\n    /** Prepend nodes or strings to this node's children. */ prepend(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        resetParent(nodes, this);\n        this.childNodes.unshift(...nodes);\n    }\n    /** Append nodes or strings to this node's children. */ append(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        resetParent(nodes, this);\n        this.childNodes.push(...nodes);\n    }\n    /** Insert nodes or strings before this node. */ before(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        const siblings = this.parentNode.childNodes;\n        resetParent(nodes, this.parentNode);\n        siblings.splice(siblings.indexOf(this), 0, ...nodes);\n    }\n    /** Insert nodes or strings after this node. */ after(...insertable) {\n        const nodes = resolveInsertable(insertable);\n        const siblings = this.parentNode.childNodes;\n        resetParent(nodes, this.parentNode);\n        siblings.splice(siblings.indexOf(this) + 1, 0, ...nodes);\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while(i < children.length){\n                const child = children[i++];\n                if (this === child) return children[i] || null;\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while(i < children.length){\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                } else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n    get previousSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = children.length;\n            while(i > 0){\n                const child = children[--i];\n                if (this === child) return children[i - 1] || null;\n            }\n            return null;\n        }\n    }\n    get previousElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = children.length;\n            let find = false;\n            while(i > 0){\n                const child = children[--i];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                } else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n    /** Get all childNodes of type {@link HTMLElement}. */ get children() {\n        const children = [];\n        for (const childNode of this.childNodes){\n            if (childNode instanceof HTMLElement) {\n                children.push(childNode);\n            }\n        }\n        return children;\n    }\n    /**\n     * Get the first child node.\n     * @return The first child or undefined if none exists.\n     */ get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get the first child node of type {@link HTMLElement}.\n     * @return The first child element or undefined if none exists.\n     */ get firstElementChild() {\n        return this.children[0];\n    }\n    /**\n     * Get the last child node.\n     * @return The last child or undefined if none exists.\n     */ get lastChild() {\n        return (0, back_1.default)(this.childNodes);\n    }\n    /**\n     * Get the last child node of type {@link HTMLElement}.\n     * @return The last child element or undefined if none exists.\n     */ get lastElementChild() {\n        return this.children[this.children.length - 1];\n    }\n    get childElementCount() {\n        return this.children.length;\n    }\n    get classNames() {\n        return this.classList.toString();\n    }\n    /** Clone this Node */ clone() {\n        return parse(this.toString(), this._parseOptions).firstChild;\n    }\n}\nexports[\"default\"] = HTMLElement;\n// #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z@\\xB7\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u03A1\\u03A3-\\u03D9\\u03DB-\\u03EF\\u03F7-\\u03FF\\u0400-\\u04FF\\u0500-\\u052F\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E00-\\u1E9B\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A-\\u212B\\u2132\\u214E\\u2160-\\u2188\\u2C60-\\u2C7F\\uA722-\\uA787\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA7FF\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64-\\uAB65\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\x37F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/gu;\n// const kMarkupPattern = /<!--[\\s\\S]*?-->|<(\\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\\s+[^>]*?(?:(?:'[^']*')|(?:\"[^\"]*\"))?)*)\\s*(\\/?)>/g;\nconst kAttributePattern = /(?:^|\\s)(id|class)\\s*=\\s*((?:'[^']*')|(?:\"[^\"]*\")|\\S+)/gi;\nconst kElementsClosedByOpening = {\n    li: {\n        li: true,\n        LI: true\n    },\n    LI: {\n        li: true,\n        LI: true\n    },\n    p: {\n        p: true,\n        div: true,\n        P: true,\n        DIV: true\n    },\n    P: {\n        p: true,\n        div: true,\n        P: true,\n        DIV: true\n    },\n    b: {\n        div: true,\n        DIV: true\n    },\n    B: {\n        div: true,\n        DIV: true\n    },\n    td: {\n        td: true,\n        th: true,\n        TD: true,\n        TH: true\n    },\n    TD: {\n        td: true,\n        th: true,\n        TD: true,\n        TH: true\n    },\n    th: {\n        td: true,\n        th: true,\n        TD: true,\n        TH: true\n    },\n    TH: {\n        td: true,\n        th: true,\n        TD: true,\n        TH: true\n    },\n    h1: {\n        h1: true,\n        H1: true\n    },\n    H1: {\n        h1: true,\n        H1: true\n    },\n    h2: {\n        h2: true,\n        H2: true\n    },\n    H2: {\n        h2: true,\n        H2: true\n    },\n    h3: {\n        h3: true,\n        H3: true\n    },\n    H3: {\n        h3: true,\n        H3: true\n    },\n    h4: {\n        h4: true,\n        H4: true\n    },\n    H4: {\n        h4: true,\n        H4: true\n    },\n    h5: {\n        h5: true,\n        H5: true\n    },\n    H5: {\n        h5: true,\n        H5: true\n    },\n    h6: {\n        h6: true,\n        H6: true\n    },\n    H6: {\n        h6: true,\n        H6: true\n    }\n};\nconst kElementsClosedByClosing = {\n    li: {\n        ul: true,\n        ol: true,\n        UL: true,\n        OL: true\n    },\n    LI: {\n        ul: true,\n        ol: true,\n        UL: true,\n        OL: true\n    },\n    a: {\n        div: true,\n        DIV: true\n    },\n    A: {\n        div: true,\n        DIV: true\n    },\n    b: {\n        div: true,\n        DIV: true\n    },\n    B: {\n        div: true,\n        DIV: true\n    },\n    i: {\n        div: true,\n        DIV: true\n    },\n    I: {\n        div: true,\n        DIV: true\n    },\n    p: {\n        div: true,\n        DIV: true\n    },\n    P: {\n        div: true,\n        DIV: true\n    },\n    td: {\n        tr: true,\n        table: true,\n        TR: true,\n        TABLE: true\n    },\n    TD: {\n        tr: true,\n        table: true,\n        TR: true,\n        TABLE: true\n    },\n    th: {\n        tr: true,\n        table: true,\n        TR: true,\n        TABLE: true\n    },\n    TH: {\n        tr: true,\n        table: true,\n        TR: true,\n        TABLE: true\n    }\n};\nconst kElementsClosedByClosingExcept = {\n    p: {\n        a: true,\n        audio: true,\n        del: true,\n        ins: true,\n        map: true,\n        noscript: true,\n        video: true\n    }\n};\nconst frameflag = \"documentfragmentcontainer\";\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */ function base_parse(data, options = {}) {\n    var _a, _b;\n    const voidTag = new void_tag_1.default((_a = options === null || options === void 0 ? void 0 : options.voidTag) === null || _a === void 0 ? void 0 : _a.closingSlash, (_b = options === null || options === void 0 ? void 0 : options.voidTag) === null || _b === void 0 ? void 0 : _b.tags);\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it)=>new RegExp(`^${it}$`, \"i\"));\n    const kIgnoreElements = element_names.filter((it)=>Boolean(elements[it])).map((it)=>new RegExp(`^${it}$`, \"i\"));\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it)=>it.test(tag));\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it)=>it.test(tag));\n    }\n    const createRange = (startPos, endPos)=>[\n            startPos - frameFlagOffset,\n            endPos - frameFlagOffset\n        ];\n    const root = new HTMLElement(null, {}, \"\", null, [\n        0,\n        data.length\n    ], voidTag, options);\n    let currentParent = root;\n    const stack = [\n        root\n    ];\n    let lastTextPos = -1;\n    let noNestedTagIndex = undefined;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    const { lowerCaseTagName, fixNestedATags } = options;\n    const dataEndPos = data.length - (frameflag.length + 2);\n    const frameFlagOffset = frameflag.length + 2;\n    while(match = kMarkupPattern.exec(data)){\n        // Note: Object destructuring here consistently tests as higher performance than array destructuring\n        // eslint-disable-next-line prefer-const\n        let { 0: matchText, 1: leadingSlash, 2: tagName, 3: attributes, 4: closingSlash } = match;\n        const matchLength = matchText.length;\n        const tagStartPos = kMarkupPattern.lastIndex - matchLength;\n        const tagEndPos = kMarkupPattern.lastIndex;\n        // Add TextNode if content\n        if (lastTextPos > -1) {\n            if (lastTextPos + matchLength < tagEndPos) {\n                const text = data.substring(lastTextPos, tagStartPos);\n                currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        // https://github.com/taoqf/node-html-parser/issues/38\n        // Skip frameflag node\n        if (tagName === frameflag) continue;\n        // Handle comments\n        if (matchText[1] === \"!\") {\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(tagStartPos + 4, tagEndPos - 3);\n                currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));\n            }\n            continue;\n        }\n        /* -- Handle tag matching -- */ // Fix tag casing if necessary\n        if (lowerCaseTagName) tagName = tagName.toLowerCase();\n        // Handle opening tags (ie. <this> not </that>)\n        if (!leadingSlash) {\n            /* Populate attributes */ const attrs = {};\n            for(let attMatch; attMatch = kAttributePattern.exec(attributes);){\n                const { 1: key, 2: val } = attMatch;\n                const isQuoted = val[0] === `'` || val[0] === `\"`;\n                attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;\n            }\n            const parentTagName = currentParent.rawTagName;\n            if (!closingSlash && kElementsClosedByOpening[parentTagName]) {\n                if (kElementsClosedByOpening[parentTagName][tagName]) {\n                    stack.pop();\n                    currentParent = (0, back_1.default)(stack);\n                }\n            }\n            // Prevent nested A tags by terminating the last A and starting a new one : see issue #144\n            if (fixNestedATags && (tagName === \"a\" || tagName === \"A\")) {\n                if (noNestedTagIndex !== undefined) {\n                    stack.splice(noNestedTagIndex);\n                    currentParent = (0, back_1.default)(stack);\n                }\n                noNestedTagIndex = stack.length;\n            }\n            const tagEndPos = kMarkupPattern.lastIndex;\n            const tagStartPos = tagEndPos - matchLength;\n            currentParent = currentParent.appendChild(// Initialize range (end position updated later for closed tags)\n            new HTMLElement(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos, tagEndPos), voidTag, options));\n            stack.push(currentParent);\n            if (is_block_text_element(tagName)) {\n                // Find closing tag\n                const closeMarkup = `</${tagName}>`;\n                const closeIndex = lowerCaseTagName ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex) : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                const textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;\n                if (element_should_be_ignore(tagName)) {\n                    const text = data.substring(tagEndPos, textEndPos);\n                    if (text.length > 0 && /\\S/.test(text)) {\n                        currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos, textEndPos)));\n                    }\n                }\n                if (closeIndex === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                } else {\n                    lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;\n                    // Cause to be treated as self-closing, because no close found\n                    leadingSlash = \"/\";\n                }\n            }\n        }\n        // Handle closing tags or self-closed elements (ie </tag> or <br>)\n        if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {\n            while(true){\n                if (noNestedTagIndex != null && (tagName === \"a\" || tagName === \"A\")) noNestedTagIndex = undefined;\n                if (currentParent.rawTagName === tagName) {\n                    // Update range end for closed tag\n                    currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];\n                    stack.pop();\n                    currentParent = (0, back_1.default)(stack);\n                    break;\n                } else {\n                    const parentTagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[parentTagName]) {\n                        if (kElementsClosedByClosing[parentTagName][tagName]) {\n                            stack.pop();\n                            currentParent = (0, back_1.default)(stack);\n                            continue;\n                        }\n                    }\n                    const openTag = currentParent.rawTagName ? currentParent.rawTagName.toLowerCase() : \"\";\n                    if (kElementsClosedByClosingExcept[openTag]) {\n                        const closingTag = tagName.toLowerCase();\n                        if (stack.length > 1) {\n                            const possibleContainer = stack[stack.length - 2];\n                            if (possibleContainer && possibleContainer.rawTagName && possibleContainer.rawTagName.toLowerCase() === closingTag && !kElementsClosedByClosingExcept[openTag][closingTag]) {\n                                // Update range end for closed tag\n                                currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];\n                                stack.pop();\n                                currentParent = (0, back_1.default)(stack);\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return stack;\n}\nexports.base_parse = base_parse;\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */ function parse(data, options = {}) {\n    const stack = base_parse(data, options);\n    const [root] = stack;\n    while(stack.length > 1){\n        // Handle each error elements.\n        const last = stack.pop();\n        const oneBefore = (0, back_1.default)(stack);\n        if (last.parentNode && last.parentNode.parentNode) {\n            if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                // this is wrong, becouse this will put the H3 outside the current right position which should be inside the current Html Element, see issue 152 for more info\n                if (options.parseNoneClosedTags !== true) {\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child)=>{\n                        oneBefore.parentNode.appendChild(child);\n                    });\n                    stack.pop();\n                }\n            } else {\n                // Single error  <div> <h3> </div> handle: Just removes <h3>\n                // Why remove? this is already a HtmlElement and the missing <H3> is already added in this case. see issue 152 for more info\n                // eslint-disable-next-line no-lonely-if\n                if (options.parseNoneClosedTags !== true) {\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child)=>{\n                        oneBefore.appendChild(child);\n                    });\n                }\n            }\n        } else {\n        // If it's final element just skip.\n        }\n    }\n    // response.childNodes.forEach((node) => {\n    // \tif (node instanceof HTMLElement) {\n    // \t\tnode.parentNode = null;\n    // \t}\n    // });\n    return root;\n}\nexports.parse = parse;\n/**\n * Resolves a list of {@link NodeInsertable} to a list of nodes,\n * and removes nodes from any potential parent.\n */ function resolveInsertable(insertable) {\n    return insertable.map((val)=>{\n        if (typeof val === \"string\") {\n            return new text_1.default(val);\n        }\n        val.remove();\n        return val;\n    });\n}\nfunction resetParent(nodes, parent) {\n    return nodes.map((node)=>{\n        node.parentNode = parent;\n        return node;\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L25vZGVzL2h0bWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUMxQyxNQUFNSSxlQUFlQyxtQkFBT0EsQ0FBQyxnRUFBWTtBQUN6QyxNQUFNQyxPQUFPWCxnQkFBZ0JVLG1CQUFPQSxDQUFDLHlDQUFJO0FBQ3pDLE1BQU1FLFNBQVNaLGdCQUFnQlUsbUJBQU9BLENBQUMsbUVBQVM7QUFDaEQsTUFBTUcsWUFBWWIsZ0JBQWdCVSxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN0RCxNQUFNSSxhQUFhZCxnQkFBZ0JVLG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3hELE1BQU1LLFlBQVlmLGdCQUFnQlUsbUJBQU9BLENBQUMsOEVBQVc7QUFDckQsTUFBTU0sU0FBU2hCLGdCQUFnQlUsbUJBQU9BLENBQUMsd0VBQVE7QUFDL0MsTUFBTU8sU0FBU2pCLGdCQUFnQlUsbUJBQU9BLENBQUMsd0VBQVE7QUFDL0MsTUFBTVEsU0FBU2xCLGdCQUFnQlUsbUJBQU9BLENBQUMsd0VBQVE7QUFDL0MsU0FBU1MsT0FBT0MsR0FBRztJQUNmLGVBQWU7SUFDZixPQUFPQyxLQUFLZCxLQUFLLENBQUNjLEtBQUtDLFNBQVMsQ0FBQ1gsS0FBS1ksT0FBTyxDQUFDSixNQUFNLENBQUNDO0FBQ3pEO0FBQ0EseUVBQXlFO0FBQ3pFLE1BQU1JLFFBQVE7SUFBQztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFVO0NBQVM7QUFDdEUsTUFBTUMsUUFBUTtJQUFDO0lBQVc7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Q0FBQyxDQUFDdkI7d0JBQ3JCeU8sVUFBVXhJLFdBQVcsQ0FBQ2pHO29CQUMxQjtnQkFDSjtZQUNKO1FBQ0osT0FDSztRQUNELG1DQUFtQztRQUN2QztJQUNKO0lBQ0EsMENBQTBDO0lBQzFDLHNDQUFzQztJQUN0Qyw0QkFBNEI7SUFDNUIsS0FBSztJQUNMLE1BQU07SUFDTixPQUFPNk07QUFDWDtBQUNBalMsYUFBYSxHQUFHRTtBQUNoQjs7O0NBR0MsR0FDRCxTQUFTMk0sa0JBQWtCRCxVQUFVO0lBQ2pDLE9BQU9BLFdBQVduSCxHQUFHLENBQUMsQ0FBQzFFO1FBQ25CLElBQUksT0FBT0EsUUFBUSxVQUFVO1lBQ3pCLE9BQU8sSUFBSUgsT0FBT00sT0FBTyxDQUFDSDtRQUM5QjtRQUNBQSxJQUFJbUMsTUFBTTtRQUNWLE9BQU9uQztJQUNYO0FBQ0o7QUFDQSxTQUFTd0csWUFBWUQsS0FBSyxFQUFFTSxNQUFNO0lBQzlCLE9BQU9OLE1BQU03QixHQUFHLENBQUMsQ0FBQ1A7UUFDZEEsS0FBS2hCLFVBQVUsR0FBRzBEO1FBQ2xCLE9BQU8xQztJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXJvLy4vbm9kZV9tb2R1bGVzL25vZGUtaHRtbC1wYXJzZXIvZGlzdC9ub2Rlcy9odG1sLmpzPzZmODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gZXhwb3J0cy5iYXNlX3BhcnNlID0gdm9pZCAwO1xuY29uc3QgY3NzX3NlbGVjdF8xID0gcmVxdWlyZShcImNzcy1zZWxlY3RcIik7XG5jb25zdCBoZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJoZVwiKSk7XG5jb25zdCBiYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2JhY2tcIikpO1xuY29uc3QgbWF0Y2hlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRjaGVyXCIpKTtcbmNvbnN0IHZvaWRfdGFnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3ZvaWQtdGFnXCIpKTtcbmNvbnN0IGNvbW1lbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50XCIpKTtcbmNvbnN0IG5vZGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtcbmNvbnN0IHRleHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90ZXh0XCIpKTtcbmNvbnN0IHR5cGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90eXBlXCIpKTtcbmZ1bmN0aW9uIGRlY29kZSh2YWwpIHtcbiAgICAvLyBjbG9uZSBzdHJpbmdcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShoZV8xLmRlZmF1bHQuZGVjb2RlKHZhbCkpKTtcbn1cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQmxvY2stbGV2ZWxfZWxlbWVudHNcbmNvbnN0IEh0YWdzID0gWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkZXInLCAnaGdyb3VwJ107XG5jb25zdCBEdGFncyA9IFsnZGV0YWlscycsICdkaWFsb2cnLCAnZGQnLCAnZGl2JywgJ2R0J107XG5jb25zdCBGdGFncyA9IFsnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nXTtcbmNvbnN0IHRhYmxlVGFncyA9IFsndGFibGUnLCAndGQnLCAndHInXTtcbmNvbnN0IGh0bWxUYWdzID0gWydhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdicicsICdocicsICdsaScsICdtYWluJywgJ25hdicsICdvbCcsICdwJywgJ3ByZScsICdzZWN0aW9uJywgJ3VsJ107XG5jb25zdCBrQmxvY2tFbGVtZW50cyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGFkZFRvS0Jsb2NrRWxlbWVudCguLi5hcmdzKSB7XG4gICAgY29uc3QgYWRkVG9TZXQgPSAoYXJyYXkpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgICAgIGtCbG9ja0VsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgIGtCbG9ja0VsZW1lbnRzLmFkZChlbGVtZW50LnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKVxuICAgICAgICBhZGRUb1NldChhcmcpO1xufVxuYWRkVG9LQmxvY2tFbGVtZW50KEh0YWdzLCBEdGFncywgRnRhZ3MsIHRhYmxlVGFncywgaHRtbFRhZ3MpO1xuY2xhc3MgRE9NVG9rZW5MaXN0IHtcbiAgICBfdmFsaWRhdGUoYykge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBET01FeGNlcHRpb24gaW4gRE9NVG9rZW5MaXN0LmFkZDogVGhlIHRva2VuICcke2N9JyBjb250YWlucyBIVE1MIHNwYWNlIGNoYXJhY3RlcnMsIHdoaWNoIGFyZSBub3QgdmFsaWQgaW4gdG9rZW5zLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlc0luaXQgPSBbXSwgYWZ0ZXJVcGRhdGUgPSAoKSA9PiBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NldCA9IG5ldyBTZXQodmFsdWVzSW5pdCk7XG4gICAgICAgIHRoaXMuX2FmdGVyVXBkYXRlID0gYWZ0ZXJVcGRhdGU7XG4gICAgfVxuICAgIGFkZChjKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKGMpO1xuICAgICAgICB0aGlzLl9zZXQuYWRkKGMpO1xuICAgICAgICB0aGlzLl9hZnRlclVwZGF0ZSh0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICB9XG4gICAgcmVwbGFjZShjMSwgYzIpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoYzIpO1xuICAgICAgICB0aGlzLl9zZXQuZGVsZXRlKGMxKTtcbiAgICAgICAgdGhpcy5fc2V0LmFkZChjMik7XG4gICAgICAgIHRoaXMuX2FmdGVyVXBkYXRlKHRoaXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIH1cbiAgICByZW1vdmUoYykge1xuICAgICAgICB0aGlzLl9zZXQuZGVsZXRlKGMpICYmIHRoaXMuX2FmdGVyVXBkYXRlKHRoaXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIH1cbiAgICB0b2dnbGUoYykge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZShjKTtcbiAgICAgICAgaWYgKHRoaXMuX3NldC5oYXMoYykpXG4gICAgICAgICAgICB0aGlzLl9zZXQuZGVsZXRlKGMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9zZXQuYWRkKGMpO1xuICAgICAgICB0aGlzLl9hZnRlclVwZGF0ZSh0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICB9XG4gICAgY29udGFpbnMoYykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhjKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldC5zaXplO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXQudmFsdWVzKCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fc2V0LnZhbHVlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3NldC52YWx1ZXMoKSkuam9pbignICcpO1xuICAgIH1cbn1cbi8qKlxuICogSFRNTEVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zIGEgc2V0IG9mIGNoaWxkcmVuLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgYSBtaW5pbWFsaXN0IGltcGxlbWVudGF0aW9uLCBubyBjb21wbGV0ZSB0cmVlXG4gKiAgIHN0cnVjdHVyZSBwcm92aWRlZCAobm8gcGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcsXG4gKiAgIHByZXZpb3VzU2libGluZyBldGMpLlxuICogQGNsYXNzIEhUTUxFbGVtZW50XG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqL1xuY2xhc3MgSFRNTEVsZW1lbnQgZXh0ZW5kcyBub2RlXzEuZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogUXVvdGUgYXR0cmlidXRlIHZhbHVlc1xuICAgICAqIEBwYXJhbSBhdHRyIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHF1b3RlZCB2YWx1ZVxuICAgICAqL1xuICAgIHF1b3RlQXR0cmlidXRlKGF0dHIpIHtcbiAgICAgICAgaWYgKGF0dHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXR0ci5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXHQvZywgJ1xcdCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQuXG4gICAgICogQHBhcmFtIGtleUF0dHJzXHRpZCBhbmQgY2xhc3MgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIFtyYXdBdHRyc11cdGF0dHJpYnV0ZXMgaW4gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSFRNTEVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YWdOYW1lLCBrZXlBdHRycywgcmF3QXR0cnMgPSAnJywgcGFyZW50Tm9kZSA9IG51bGwsIHJhbmdlLCB2b2lkVGFnID0gbmV3IHZvaWRfdGFnXzEuZGVmYXVsdCgpLCBfcGFyc2VPcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyZW50Tm9kZSwgcmFuZ2UpO1xuICAgICAgICB0aGlzLnJhd0F0dHJzID0gcmF3QXR0cnM7XG4gICAgICAgIHRoaXMudm9pZFRhZyA9IHZvaWRUYWc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlIFR5cGUgZGVjbGFyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVUeXBlID0gdHlwZV8xLmRlZmF1bHQuRUxFTUVOVF9OT0RFO1xuICAgICAgICB0aGlzLnJhd1RhZ05hbWUgPSB0YWdOYW1lO1xuICAgICAgICB0aGlzLnJhd0F0dHJzID0gcmF3QXR0cnMgfHwgJyc7XG4gICAgICAgIHRoaXMuX2lkID0ga2V5QXR0cnMuaWQgfHwgJyc7XG4gICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbnMgPSBfcGFyc2VPcHRpb25zO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdCA9IG5ldyBET01Ub2tlbkxpc3Qoa2V5QXR0cnMuY2xhc3MgPyBrZXlBdHRycy5jbGFzcy5zcGxpdCgvXFxzKy8pIDogW10sIChjbGFzc0xpc3QpID0+IHRoaXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTGlzdC50b1N0cmluZygpKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChrZXlBdHRycy5pZCkge1xuICAgICAgICAgICAgaWYgKCFyYXdBdHRycykge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3QXR0cnMgPSBgaWQ9XCIke2tleUF0dHJzLmlkfVwiYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5QXR0cnMuY2xhc3MpIHtcbiAgICAgICAgICAgIGlmICghcmF3QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbHMgPSBgY2xhc3M9XCIke3RoaXMuY2xhc3NMaXN0LnRvU3RyaW5nKCl9XCJgO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJhd0F0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmF3QXR0cnMgKz0gYCAke2Nsc31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYXdBdHRycyA9IGNscztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIENoaWxkIGVsZW1lbnQgZnJvbSBjaGlsZE5vZGVzIGFycmF5XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAgICAgbm9kZSB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2Rlcy5maWx0ZXIoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgIT09IG5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjaGFuZ2VzIGdpdmVuIGNoaWxkIHdpdGggbmV3IGNoaWxkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2xkTm9kZSAgICAgbm9kZSB0byBleGNoYW5nZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5ld05vZGUgICAgIG5ldyBub2RlXG4gICAgICovXG4gICAgZXhjaGFuZ2VDaGlsZChvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBjaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgdGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3VGFnTmFtZSA/IHRoaXMucmF3VGFnTmFtZS50b1VwcGVyQ2FzZSgpIDogdGhpcy5yYXdUYWdOYW1lO1xuICAgIH1cbiAgICBzZXQgdGFnTmFtZShuZXduYW1lKSB7XG4gICAgICAgIHRoaXMucmF3VGFnTmFtZSA9IG5ld25hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgZ2V0IGxvY2FsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3VGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBnZXQgaXNWb2lkRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm9pZFRhZy5pc1ZvaWRFbGVtZW50KHRoaXMubG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIHNldCBpZChuZXdpZCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaWQnLCBuZXdpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlc2NwYWVkIChhcy1pdCkgdGV4dCB2YWx1ZSBvZiBjdXJyZW50IG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRleHQgY29udGVudFxuICAgICAqL1xuICAgIGdldCByYXdUZXh0KCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGFvcWYvbm9kZS1odG1sLXBhcnNlci9pc3N1ZXMvMjQ5XG4gICAgICAgIGlmICgvXmJyJC9pLnRlc3QodGhpcy5yYXdUYWdOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMucmVkdWNlKChwcmUsIGN1cikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChwcmUgKz0gY3VyLnJhd1RleHQpO1xuICAgICAgICB9LCAnJyk7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZSh0aGlzLnJhd1RleHQpO1xuICAgIH1cbiAgICBzZXQgdGV4dENvbnRlbnQodmFsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBbbmV3IHRleHRfMS5kZWZhdWx0KHZhbCwgdGhpcyldO1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBjb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdW5lc2NhcGVkIHRleHQgdmFsdWUgb2YgY3VycmVudCBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0ZXh0IGNvbnRlbnRcbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZSh0aGlzLnJhd1RleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3RydWN0dXJlZCBUZXh0ICh3aXRoICdcXG4nIGV0Yy4pXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBzdHJ1Y3R1cmVkIHRleHRcbiAgICAgKi9cbiAgICBnZXQgc3RydWN0dXJlZFRleHQoKSB7XG4gICAgICAgIGxldCBjdXJyZW50QmxvY2sgPSBbXTtcbiAgICAgICAgY29uc3QgYmxvY2tzID0gW2N1cnJlbnRCbG9ja107XG4gICAgICAgIGZ1bmN0aW9uIGRmcyhub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gdHlwZV8xLmRlZmF1bHQuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtCbG9ja0VsZW1lbnRzLmhhcyhub2RlLnJhd1RhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzLnB1c2goKGN1cnJlbnRCbG9jayA9IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goZGZzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9jay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MucHVzaCgoY3VycmVudEJsb2NrID0gW10pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goZGZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSB0eXBlXzEuZGVmYXVsdC5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpdGVzcGFjZSBub2RlLCBwb3N0cG9uZWQgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9jay5wcmVwZW5kV2hpdGVzcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG5vZGUudHJpbW1lZFRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2sucHJlcGVuZFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBgICR7dGV4dH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrLnByZXBlbmRXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrLnB1c2godGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRmcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGJsb2Nrc1xuICAgICAgICAgICAgLm1hcCgoYmxvY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBibG9jay5qb2luKCcnKS5yZXBsYWNlKC9cXHN7Mix9L2csICcgJyk7IC8vIE5vcm1hbGl6ZSBlYWNoIGxpbmUncyB3aGl0ZXNwYWNlXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrJC8sICcnKTsgLy8gdHJpbVJpZ2h0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGhpcy5yYXdUYWdOYW1lO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHRoaXMucmF3QXR0cnMgPyBgICR7dGhpcy5yYXdBdHRyc31gIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52b2lkVGFnLmZvcm1hdE5vZGUodGFnLCBhdHRycywgdGhpcy5pbm5lckhUTUwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVySFRNTDtcbiAgICB9XG4gICAgZ2V0IGlubmVySFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlc1xuICAgICAgICAgICAgLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC50b1N0cmluZygpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgIH1cbiAgICBzZXQgaW5uZXJIVE1MKGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgciA9IHBhcnNlKGNvbnRlbnQsIHRoaXMuX3BhcnNlT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gci5jaGlsZE5vZGVzLmxlbmd0aCA/IHIuY2hpbGROb2RlcyA6IFtuZXcgdGV4dF8xLmRlZmF1bHQoY29udGVudCwgdGhpcyldO1xuICAgICAgICByZXNldFBhcmVudChub2RlcywgdGhpcyk7XG4gICAgICAgIHJlc2V0UGFyZW50KHRoaXMuY2hpbGROb2RlcywgbnVsbCk7XG4gICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICBzZXRfY29udGVudChjb250ZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBub2RlXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgY29udGVudCA9IFtjb250ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcGFyc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCByID0gcGFyc2UoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb250ZW50ID0gci5jaGlsZE5vZGVzLmxlbmd0aCA/IHIuY2hpbGROb2RlcyA6IFtuZXcgdGV4dF8xLmRlZmF1bHQoci5pbm5lckhUTUwsIHRoaXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXNldFBhcmVudCh0aGlzLmNoaWxkTm9kZXMsIG51bGwpO1xuICAgICAgICByZXNldFBhcmVudChjb250ZW50LCB0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gY29udGVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlcGxhY2VXaXRoKC4uLm5vZGVzKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IG5vZGVzXG4gICAgICAgICAgICAubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBub2RlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHBhcnNlKG5vZGUsIHRoaXMuX3BhcnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuY2hpbGROb2Rlcy5sZW5ndGggPyByLmNoaWxkTm9kZXMgOiBbbmV3IHRleHRfMS5kZWZhdWx0KG5vZGUsIHRoaXMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHBhcmVudC5jaGlsZE5vZGVzLmZpbmRJbmRleCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gdGhpcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2V0UGFyZW50KFt0aGlzXSwgbnVsbCk7XG4gICAgICAgIHBhcmVudC5jaGlsZE5vZGVzID0gWy4uLnBhcmVudC5jaGlsZE5vZGVzLnNsaWNlKDAsIGlkeCksIC4uLnJlc2V0UGFyZW50KGNvbnRlbnQsIHBhcmVudCksIC4uLnBhcmVudC5jaGlsZE5vZGVzLnNsaWNlKGlkeCArIDEpXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBvdXRlckhUTUwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW0gZWxlbWVudCBmcm9tIHJpZ2h0IChpbiBibG9jaykgYWZ0ZXIgc2VlaW5nIHBhdHRlcm4gaW4gYSBUZXh0Tm9kZS5cbiAgICAgKiBAcGFyYW0gIHtSZWdFeHB9IHBhdHRlcm4gcGF0dGVybiB0byBmaW5kXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgIHJlZmVyZW5jZSB0byBjdXJyZW50IG5vZGVcbiAgICAgKi9cbiAgICB0cmltUmlnaHQocGF0dGVybikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gdHlwZV8xLmRlZmF1bHQuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLnRyaW1SaWdodChwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2hpbGROb2RlLnJhd1RleHQuc2VhcmNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5yYXdUZXh0ID0gY2hpbGROb2RlLnJhd1RleHQuc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpbSBhbGwgZm9sbG93aW5nIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRE9NIHN0cnVjdHVyZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RydWN0dXJlXG4gICAgICovXG4gICAgZ2V0IHN0cnVjdHVyZSgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGxldCBpbmRlbnRpb24gPSAwO1xuICAgICAgICBmdW5jdGlvbiB3cml0ZShzdHIpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKCcgICcucmVwZWF0KGluZGVudGlvbikgKyBzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRmcyhub2RlKSB7XG4gICAgICAgICAgICBjb25zdCBpZFN0ciA9IG5vZGUuX2lkID8gYCMke25vZGUuX2lkfWAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzU3RyID0gbm9kZS5jbGFzc0xpc3QubGVuZ3RoID8gYC4ke25vZGUuY2xhc3NMaXN0LnZhbHVlLmpvaW4oJy4nKX1gIDogJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICAgICB3cml0ZShgJHtub2RlLnJhd1RhZ05hbWV9JHtpZFN0cn0ke2NsYXNzU3RyfWApO1xuICAgICAgICAgICAgaW5kZW50aW9uKys7XG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gdHlwZV8xLmRlZmF1bHQuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGRmcyhjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IHR5cGVfMS5kZWZhdWx0LlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZS5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlKCcjdGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbmRlbnRpb24tLTtcbiAgICAgICAgfVxuICAgICAgICBkZnModGhpcyk7XG4gICAgICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB3aGl0ZXNwYWNlcyBpbiB0aGlzIHN1YiB0cmVlLlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBwb2ludGVyIHRvIHRoaXNcbiAgICAgKi9cbiAgICByZW1vdmVXaGl0ZXNwYWNlKCkge1xuICAgICAgICBsZXQgbyA9IDA7XG4gICAgICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gdHlwZV8xLmRlZmF1bHQuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5yYXdUZXh0ID0gbm9kZS50cmltbWVkUmF3VGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IHR5cGVfMS5kZWZhdWx0LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzW28rK10gPSBub2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCA9IG87XG4gICAgICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlc1xuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcylcbiAgICAgICAgICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5yYXdBdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYCR7a2V5fT0ke0pTT04uc3RyaW5naWZ5KHZhbCl9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgIHRoaXMucmF3QXR0cnMgPSBhdHRycztcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Jhd0F0dHJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgbWF0Y2hpbmcgbm9kZXMuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgIHNlbGVjdG9yIFNpbXBsaWZpZWQgQ1NTIHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX0gIG1hdGNoaW5nIGVsZW1lbnRzXG4gICAgICovXG4gICAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gKDAsIGNzc19zZWxlY3RfMS5zZWxlY3RBbGwpKHNlbGVjdG9yLCB0aGlzLCB7XG4gICAgICAgICAgICB4bWxNb2RlOiB0cnVlLFxuICAgICAgICAgICAgYWRhcHRlcjogbWF0Y2hlcl8xLmRlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBDU1MgU2VsZWN0b3IgdG8gZmluZCBtYXRjaGluZyBub2RlLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICBzZWxlY3RvciBTaW1wbGlmaWVkIENTUyBzZWxlY3RvclxuICAgICAqIEByZXR1cm4geyhIVE1MRWxlbWVudHxudWxsKX0gICAgbWF0Y2hpbmcgbm9kZVxuICAgICAqL1xuICAgIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjc3Nfc2VsZWN0XzEuc2VsZWN0T25lKShzZWxlY3RvciwgdGhpcywge1xuICAgICAgICAgICAgeG1sTW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIGFkYXB0ZXI6IG1hdGNoZXJfMS5kZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZmluZCBlbGVtZW50cyBieSB0aGVpciB0YWdOYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgdGhlIHRhZ05hbWUgb2YgdGhlIGVsZW1lbnRzIHRvIHNlbGVjdFxuICAgICAqL1xuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgdXBwZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHJlID0gW107XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZVJlZmVyZW5jZSA9IHRoaXM7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIC8vIGluZGV4IHR1cm5zIHRvIHVuZGVmaW5lZCBvbmNlIHRoZSBzdGFjayBpcyBlbXB0eSBhbmQgdGhlIGZpcnN0IGNvbmRpdGlvbiBvY2N1cnNcbiAgICAgICAgLy8gd2hpY2ggaGFwcGVucyBvbmNlIGFsbCByZWxldmFudCBjaGlsZHJlbiBhcmUgc2VhcmNoZWQgdGhyb3VnaFxuICAgICAgICB3aGlsZSAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICAgICAgLy8gbWFrZSBpdCB3b3JrIHdpdGggc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY3VycmVudE5vZGVSZWZlcmVuY2UuY2hpbGROb2Rlc1tpbmRleCsrXTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4IDwgY3VycmVudE5vZGVSZWZlcmVuY2UuY2hpbGROb2Rlcy5sZW5ndGggJiYgY2hpbGQgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY2hpbGQgZG9lcyBub3QgZXhpc3Qgd2UgbW92ZSBvbiB3aXRoIHRoZSBsYXN0IHByb3ZpZGVkIGluZGV4ICh3aGljaCBiZWxvbmdzIHRvIHRoZSBwYXJlbnROb2RlKVxuICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZVJlZmVyZW5jZSA9IGN1cnJlbnROb2RlUmVmZXJlbmNlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gdHlwZV8xLmRlZmF1bHQuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0RWxlbWVudHNCeVRhZ05hbWUjc3ludGF4XG4gICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICcqJyB8fCBjaGlsZC50YWdOYW1lID09PSB1cHBlckNhc2VkVGFnTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmUucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgY2hpbGRyZW4gYXJlIGV4aXN0aW5nIHB1c2ggdGhlIGN1cnJlbnQgc3RhdHVzIHRvIHRoZSBzdGFjayBhbmQga2VlcCBzZWFyY2hpbmcgZm9yIGVsZW1lbnRzIGluIHRoZSBsZXZlbCBiZWxvd1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlUmVmZXJlbmNlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmaW5kIGVsZW1lbnQgYnkgaXQncyBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0aGUgaWQgb2YgdGhlIGVsZW1lbnQgdG8gc2VsZWN0XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH0gdGhlIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gaWQgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRFbGVtZW50QnlJZChpZCkge1xuICAgICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudE5vZGVSZWZlcmVuY2UgPSB0aGlzO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAvLyBpbmRleCB0dXJucyB0byB1bmRlZmluZWQgb25jZSB0aGUgc3RhY2sgaXMgZW1wdHkgYW5kIHRoZSBmaXJzdCBjb25kaXRpb24gb2NjdXJzXG4gICAgICAgIC8vIHdoaWNoIGhhcHBlbnMgb25jZSBhbGwgcmVsZXZhbnQgY2hpbGRyZW4gYXJlIHNlYXJjaGVkIHRocm91Z2hcbiAgICAgICAgd2hpbGUgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgIC8vIG1ha2UgaXQgd29yayB3aXRoIHNwYXJzZSBhcnJheXNcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGN1cnJlbnROb2RlUmVmZXJlbmNlLmNoaWxkTm9kZXNbaW5kZXgrK107XG4gICAgICAgICAgICB9IHdoaWxlIChpbmRleCA8IGN1cnJlbnROb2RlUmVmZXJlbmNlLmNoaWxkTm9kZXMubGVuZ3RoICYmIGNoaWxkID09PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGRvZXMgbm90IGV4aXN0IHdlIG1vdmUgb24gd2l0aCB0aGUgbGFzdCBwcm92aWRlZCBpbmRleCAod2hpY2ggYmVsb25ncyB0byB0aGUgcGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGVSZWZlcmVuY2UgPSBjdXJyZW50Tm9kZVJlZmVyZW5jZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IHR5cGVfMS5kZWZhdWx0LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5faWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgY2hpbGRyZW4gYXJlIGV4aXN0aW5nIHB1c2ggdGhlIGN1cnJlbnQgc3RhdHVzIHRvIHRoZSBzdGFjayBhbmQga2VlcCBzZWFyY2hpbmcgZm9yIGVsZW1lbnRzIGluIHRoZSBsZXZlbCBiZWxvd1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlUmVmZXJlbmNlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRyYXZlcnNlcyB0aGUgRWxlbWVudCBhbmQgaXRzIHBhcmVudHMgKGhlYWRpbmcgdG93YXJkIHRoZSBkb2N1bWVudCByb290KSB1bnRpbCBpdCBmaW5kcyBhIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBzZWxlY3RvciBzdHJpbmcuIFdpbGwgcmV0dXJuIGl0c2VsZiBvciB0aGUgbWF0Y2hpbmcgYW5jZXN0b3IuIElmIG5vIHN1Y2ggZWxlbWVudCBleGlzdHMsIGl0IHJldHVybnMgbnVsbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0b3IgYSBET01TdHJpbmcgY29udGFpbmluZyBhIHNlbGVjdG9yIGxpc3RcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfSB0aGUgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBpZCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgbWFwQ2hpbGQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBlbCA9IHRoaXM7XG4gICAgICAgIGxldCBvbGQgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmaW5kT25lKHRlc3QsIGVsZW1zKSB7XG4gICAgICAgICAgICBsZXQgZWxlbSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVsZW1zLmxlbmd0aDsgaSA8IGwgJiYgIWVsZW07IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gZWxlbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRlc3QoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbWFwQ2hpbGQuZ2V0KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZmluZE9uZSh0ZXN0LCBbY2hpbGRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgbWFwQ2hpbGQuc2V0KGVsLCBvbGQpO1xuICAgICAgICAgICAgb2xkID0gZWw7XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSAoMCwgY3NzX3NlbGVjdF8xLnNlbGVjdE9uZSkoc2VsZWN0b3IsIGVsLCB7XG4gICAgICAgICAgICAgICAgeG1sTW9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhZGFwdGVyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1hdGNoZXJfMS5kZWZhdWx0KSwgeyBnZXRDaGlsZHJlbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG1hcENoaWxkLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZCAmJiBbY2hpbGRdO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRTaWJsaW5ncyhub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmaW5kT25lLFxuICAgICAgICAgICAgICAgICAgICBmaW5kQWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9IH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSBjaGlsZCBub2RlIHRvIGNoaWxkTm9kZXNcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIG5vZGUgdG8gYXBwZW5kXG4gICAgICogQHJldHVybiB7Tm9kZX0gICAgICBub2RlIGFwcGVuZGVkXG4gICAgICovXG4gICAgYXBwZW5kQ2hpbGQobm9kZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhdHRyaWJ1dGVzXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwYXJzZWQgYW5kIHVuZXNjYXBlZCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICBpZiAodGhpcy5fYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRycyA9IHt9O1xuICAgICAgICBjb25zdCBhdHRycyA9IHRoaXMucmF3QXR0cmlidXRlcztcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGF0dHJzW2tleV0gfHwgJyc7XG4gICAgICAgICAgICB0aGlzLl9hdHRyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBkZWNvZGUodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYXR0cnM7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgICAgICBjb25zdCByZXRfYXR0cnMgPSB7fTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSB0aGlzLnJhd0F0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBhdHRyc1trZXldIHx8ICcnO1xuICAgICAgICAgICAgcmV0X2F0dHJzW2tleV0gPSBkZWNvZGUodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0X2F0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZXNjYXBlZCAoYXMtaXMpIGF0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhcnNlZCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0IHJhd0F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yYXdBdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd0F0dHJzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgICAgIGlmICh0aGlzLnJhd0F0dHJzKSB7XG4gICAgICAgICAgICBjb25zdCByZSA9IC8oW2EtekEtWigpW1xcXSNAJC4/Ol1bYS16QS1aMC05LS5fOigpW1xcXSNdKikoPzpcXHMqPVxccyooKD86J1teJ10qJyl8KD86XCJbXlwiXSpcIil8XFxTKykpPy9nO1xuICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWModGhpcy5yYXdBdHRycykpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IG1hdGNoWzJdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCAmJiAodmFsWzBdID09PSBgJ2AgfHwgdmFsWzBdID09PSBgXCJgKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDEsIHZhbC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gYXR0cnNba2V5XSB8fCB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmF3QXR0cnMgPSBhdHRycztcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cbiAgICByZW1vdmVBdHRyaWJ1dGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gdGhpcy5yYXdBdHRyaWJ1dGVzO1xuICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgLy8gVXBkYXRlIHRoaXMuYXR0cmlidXRlXG4gICAgICAgIGlmICh0aGlzLl9hdHRycykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2F0dHJzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHJhd1N0cmluZ1xuICAgICAgICB0aGlzLnJhd0F0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpXG4gICAgICAgICAgICAubWFwKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnF1b3RlQXR0cmlidXRlKGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09ICdudWxsJyB8fCB2YWwgPT09ICdcIlwiJylcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfT0ke3ZhbH1gO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoaXMuX2lkXG4gICAgICAgIGlmIChrZXkgPT09ICdpZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGhhc0F0dHJpYnV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpIGluIHRoaXMuYXR0cnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGU7IG9yIHVuZGVmaW5lZCBpZiBub3QgZXhpc3RcbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSB0byB0aGUgSFRNTEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LCBvciBudWxsIC8gdW5kZWZpbmVkIHRvIHJlbW92ZSBhbiBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdzZXRBdHRyaWJ1dGUnIG9uICdFbGVtZW50J1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrMiA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBhdHRycyA9IHRoaXMucmF3QXR0cmlidXRlcztcbiAgICAgICAgZm9yIChjb25zdCBrIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoay50b0xvd2VyQ2FzZSgpID09PSBrMikge1xuICAgICAgICAgICAgICAgIGtleSA9IGs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnNba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGlzLmF0dHJzXG4gICAgICAgIGlmICh0aGlzLl9hdHRycykge1xuICAgICAgICAgICAgdGhpcy5fYXR0cnNbazJdID0gZGVjb2RlKGF0dHJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSByYXdTdHJpbmdcbiAgICAgICAgdGhpcy5yYXdBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKVxuICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5xdW90ZUF0dHJpYnV0ZShhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICBpZiAodmFsID09PSAnbnVsbCcgfHwgdmFsID09PSAnXCJcIicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX09JHt2YWx9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGlzLl9pZFxuICAgICAgICBpZiAoa2V5ID09PSAnaWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIGFsbCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgSFRNTEVsZW1lbnQgYnkgdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0ge0F0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgdGhlIG5ldyBhdHRyaWJ1dGUgc2V0XG4gICAgICovXG4gICAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIEludmFsaWRhdGUgY3VycmVudCB0aGlzLmF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJzKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXR0cnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52YWxpZGF0ZSBjdXJyZW50IHRoaXMucmF3QXR0cmlidXRlc1xuICAgICAgICBpZiAodGhpcy5fcmF3QXR0cnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yYXdBdHRycztcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgcmF3U3RyaW5nXG4gICAgICAgIHRoaXMucmF3QXR0cnMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09ICdudWxsJyB8fCB2YWwgPT09ICdcIlwiJylcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfT0ke3RoaXMucXVvdGVBdHRyaWJ1dGUoU3RyaW5nKHZhbCkpfWA7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAvLyBVcGRhdGUgdGhpcy5faWRcbiAgICAgICAgaWYgKCdpZCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdGhpcy5faWQgPSBhdHRyaWJ1dGVzWydpZCddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpbnNlcnRBZGphY2VudEhUTUwod2hlcmUsIGh0bWwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHBhcnNlKGh0bWwsIHRoaXMuX3BhcnNlT3B0aW9ucyk7XG4gICAgICAgIGlmICh3aGVyZSA9PT0gJ2FmdGVyZW5kJykge1xuICAgICAgICAgICAgdGhpcy5hZnRlciguLi5wLmNoaWxkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdoZXJlID09PSAnYWZ0ZXJiZWdpbicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcGVuZCguLi5wLmNoaWxkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdoZXJlID09PSAnYmVmb3JlZW5kJykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQoLi4ucC5jaGlsZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aGVyZSA9PT0gJ2JlZm9yZWJlZ2luJykge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmUoLi4ucC5jaGlsZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZhbHVlIHByb3ZpZGVkICgnJHt3aGVyZX0nKSBpcyBub3Qgb25lIG9mICdiZWZvcmViZWdpbicsICdhZnRlcmJlZ2luJywgJ2JlZm9yZWVuZCcsIG9yICdhZnRlcmVuZCdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIFByZXBlbmQgbm9kZXMgb3Igc3RyaW5ncyB0byB0aGlzIG5vZGUncyBjaGlsZHJlbi4gKi9cbiAgICBwcmVwZW5kKC4uLmluc2VydGFibGUpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSByZXNvbHZlSW5zZXJ0YWJsZShpbnNlcnRhYmxlKTtcbiAgICAgICAgcmVzZXRQYXJlbnQobm9kZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXMudW5zaGlmdCguLi5ub2Rlcyk7XG4gICAgfVxuICAgIC8qKiBBcHBlbmQgbm9kZXMgb3Igc3RyaW5ncyB0byB0aGlzIG5vZGUncyBjaGlsZHJlbi4gKi9cbiAgICBhcHBlbmQoLi4uaW5zZXJ0YWJsZSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHJlc29sdmVJbnNlcnRhYmxlKGluc2VydGFibGUpO1xuICAgICAgICByZXNldFBhcmVudChub2RlcywgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hpbGROb2Rlcy5wdXNoKC4uLm5vZGVzKTtcbiAgICB9XG4gICAgLyoqIEluc2VydCBub2RlcyBvciBzdHJpbmdzIGJlZm9yZSB0aGlzIG5vZGUuICovXG4gICAgYmVmb3JlKC4uLmluc2VydGFibGUpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSByZXNvbHZlSW5zZXJ0YWJsZShpbnNlcnRhYmxlKTtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgcmVzZXRQYXJlbnQobm9kZXMsIHRoaXMucGFyZW50Tm9kZSk7XG4gICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHRoaXMpLCAwLCAuLi5ub2Rlcyk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnQgbm9kZXMgb3Igc3RyaW5ncyBhZnRlciB0aGlzIG5vZGUuICovXG4gICAgYWZ0ZXIoLi4uaW5zZXJ0YWJsZSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHJlc29sdmVJbnNlcnRhYmxlKGluc2VydGFibGUpO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICByZXNldFBhcmVudChub2RlcywgdGhpcy5wYXJlbnROb2RlKTtcbiAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YodGhpcykgKyAxLCAwLCAuLi5ub2Rlcyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpKytdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzID09PSBjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmV4dEVsZW1lbnRTaWJsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgbGV0IGZpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpKytdO1xuICAgICAgICAgICAgICAgIGlmIChmaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzID09PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcHJldmlvdXNTaWJsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgbGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWy0taV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IGNoaWxkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baSAtIDFdIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcHJldmlvdXNFbGVtZW50U2libGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGZpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bLS1pXTtcbiAgICAgICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcyA9PT0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEdldCBhbGwgY2hpbGROb2RlcyBvZiB0eXBlIHtAbGluayBIVE1MRWxlbWVudH0uICovXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiB0aGlzLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgY2hpbGQgbm9kZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBmaXJzdCBjaGlsZCBvciB1bmRlZmluZWQgaWYgbm9uZSBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgY2hpbGQgbm9kZSBvZiB0eXBlIHtAbGluayBIVE1MRWxlbWVudH0uXG4gICAgICogQHJldHVybiBUaGUgZmlyc3QgY2hpbGQgZWxlbWVudCBvciB1bmRlZmluZWQgaWYgbm9uZSBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0IGZpcnN0RWxlbWVudENoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXN0IGNoaWxkIG5vZGUuXG4gICAgICogQHJldHVybiBUaGUgbGFzdCBjaGlsZCBvciB1bmRlZmluZWQgaWYgbm9uZSBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBiYWNrXzEuZGVmYXVsdCkodGhpcy5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXN0IGNoaWxkIG5vZGUgb2YgdHlwZSB7QGxpbmsgSFRNTEVsZW1lbnR9LlxuICAgICAqIEByZXR1cm4gVGhlIGxhc3QgY2hpbGQgZWxlbWVudCBvciB1bmRlZmluZWQgaWYgbm9uZSBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0IGxhc3RFbGVtZW50Q2hpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGdldCBjaGlsZEVsZW1lbnRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgY2xhc3NOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKiBDbG9uZSB0aGlzIE5vZGUgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlKHRoaXMudG9TdHJpbmcoKSwgdGhpcy5fcGFyc2VPcHRpb25zKS5maXJzdENoaWxkO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEhUTUxFbGVtZW50O1xuLy8gI3hCNyB8IFsjeEMwLSN4RDZdIHwgWyN4RDgtI3hGNl0gfCBbI3hGOC0jeDM3RF0gfCBbI3gzN0YtI3gxRkZGXSB8IFsjeDIwMEMtI3gyMDBEXSB8IFsjeDIwM0YtI3gyMDQwXSB8IFsjeDIwNzAtI3gyMThGXSB8IFsjeDJDMDAtI3gyRkVGXSB8IFsjeDMwMDEtI3hEN0ZGXSB8IFsjeEY5MDAtI3hGRENGXSB8IFsjeEZERjAtI3hGRkZEXSB8IFsjeDEwMDAwLSN4RUZGRkZdXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jdXN0b20tZWxlbWVudHMuaHRtbCN2YWxpZC1jdXN0b20tZWxlbWVudC1uYW1lXG5jb25zdCBrTWFya3VwUGF0dGVybiA9IC88IS0tW1xcc1xcU10qPy0tPnw8KFxcLz8pKFthLXpBLVpdWy0uOjAtOV9hLXpBLVpAXFx4QjdcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx1MDBGOC1cXHUwM0ExXFx1MDNBMy1cXHUwM0Q5XFx1MDNEQi1cXHUwM0VGXFx1MDNGNy1cXHUwM0ZGXFx1MDQwMC1cXHUwNEZGXFx1MDUwMC1cXHUwNTJGXFx1MUQwMC1cXHUxRDJCXFx1MUQ2Qi1cXHUxRDc3XFx1MUQ3OS1cXHUxRDlBXFx1MUUwMC1cXHUxRTlCXFx1MUYwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIxMjZcXHUyMTJBLVxcdTIxMkJcXHUyMTMyXFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDNjAtXFx1MkM3RlxcdUE3MjItXFx1QTc4N1xcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTdGRlxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjQtXFx1QUI2NVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxceDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXSopKCg/OlxccytbXj5dKj8oPzooPzonW14nXSonKXwoPzpcIlteXCJdKlwiKSk/KSopXFxzKihcXC8/KT4vZ3U7XG4vLyBjb25zdCBrTWFya3VwUGF0dGVybiA9IC88IS0tW1xcc1xcU10qPy0tPnw8KFxcLz8pKFthLXpBLVpdWy0uOjAtOV9hLXpBLVpdKikoKD86XFxzK1tePl0qPyg/Oig/OidbXiddKicpfCg/OlwiW15cIl0qXCIpKT8pKilcXHMqKFxcLz8pPi9nO1xuY29uc3Qga0F0dHJpYnV0ZVBhdHRlcm4gPSAvKD86XnxcXHMpKGlkfGNsYXNzKVxccyo9XFxzKigoPzonW14nXSonKXwoPzpcIlteXCJdKlwiKXxcXFMrKS9naTtcbmNvbnN0IGtFbGVtZW50c0Nsb3NlZEJ5T3BlbmluZyA9IHtcbiAgICBsaTogeyBsaTogdHJ1ZSwgTEk6IHRydWUgfSxcbiAgICBMSTogeyBsaTogdHJ1ZSwgTEk6IHRydWUgfSxcbiAgICBwOiB7IHA6IHRydWUsIGRpdjogdHJ1ZSwgUDogdHJ1ZSwgRElWOiB0cnVlIH0sXG4gICAgUDogeyBwOiB0cnVlLCBkaXY6IHRydWUsIFA6IHRydWUsIERJVjogdHJ1ZSB9LFxuICAgIGI6IHsgZGl2OiB0cnVlLCBESVY6IHRydWUgfSxcbiAgICBCOiB7IGRpdjogdHJ1ZSwgRElWOiB0cnVlIH0sXG4gICAgdGQ6IHsgdGQ6IHRydWUsIHRoOiB0cnVlLCBURDogdHJ1ZSwgVEg6IHRydWUgfSxcbiAgICBURDogeyB0ZDogdHJ1ZSwgdGg6IHRydWUsIFREOiB0cnVlLCBUSDogdHJ1ZSB9LFxuICAgIHRoOiB7IHRkOiB0cnVlLCB0aDogdHJ1ZSwgVEQ6IHRydWUsIFRIOiB0cnVlIH0sXG4gICAgVEg6IHsgdGQ6IHRydWUsIHRoOiB0cnVlLCBURDogdHJ1ZSwgVEg6IHRydWUgfSxcbiAgICBoMTogeyBoMTogdHJ1ZSwgSDE6IHRydWUgfSxcbiAgICBIMTogeyBoMTogdHJ1ZSwgSDE6IHRydWUgfSxcbiAgICBoMjogeyBoMjogdHJ1ZSwgSDI6IHRydWUgfSxcbiAgICBIMjogeyBoMjogdHJ1ZSwgSDI6IHRydWUgfSxcbiAgICBoMzogeyBoMzogdHJ1ZSwgSDM6IHRydWUgfSxcbiAgICBIMzogeyBoMzogdHJ1ZSwgSDM6IHRydWUgfSxcbiAgICBoNDogeyBoNDogdHJ1ZSwgSDQ6IHRydWUgfSxcbiAgICBINDogeyBoNDogdHJ1ZSwgSDQ6IHRydWUgfSxcbiAgICBoNTogeyBoNTogdHJ1ZSwgSDU6IHRydWUgfSxcbiAgICBINTogeyBoNTogdHJ1ZSwgSDU6IHRydWUgfSxcbiAgICBoNjogeyBoNjogdHJ1ZSwgSDY6IHRydWUgfSxcbiAgICBINjogeyBoNjogdHJ1ZSwgSDY6IHRydWUgfSxcbn07XG5jb25zdCBrRWxlbWVudHNDbG9zZWRCeUNsb3NpbmcgPSB7XG4gICAgbGk6IHsgdWw6IHRydWUsIG9sOiB0cnVlLCBVTDogdHJ1ZSwgT0w6IHRydWUgfSxcbiAgICBMSTogeyB1bDogdHJ1ZSwgb2w6IHRydWUsIFVMOiB0cnVlLCBPTDogdHJ1ZSB9LFxuICAgIGE6IHsgZGl2OiB0cnVlLCBESVY6IHRydWUgfSxcbiAgICBBOiB7IGRpdjogdHJ1ZSwgRElWOiB0cnVlIH0sXG4gICAgYjogeyBkaXY6IHRydWUsIERJVjogdHJ1ZSB9LFxuICAgIEI6IHsgZGl2OiB0cnVlLCBESVY6IHRydWUgfSxcbiAgICBpOiB7IGRpdjogdHJ1ZSwgRElWOiB0cnVlIH0sXG4gICAgSTogeyBkaXY6IHRydWUsIERJVjogdHJ1ZSB9LFxuICAgIHA6IHsgZGl2OiB0cnVlLCBESVY6IHRydWUgfSxcbiAgICBQOiB7IGRpdjogdHJ1ZSwgRElWOiB0cnVlIH0sXG4gICAgdGQ6IHsgdHI6IHRydWUsIHRhYmxlOiB0cnVlLCBUUjogdHJ1ZSwgVEFCTEU6IHRydWUgfSxcbiAgICBURDogeyB0cjogdHJ1ZSwgdGFibGU6IHRydWUsIFRSOiB0cnVlLCBUQUJMRTogdHJ1ZSB9LFxuICAgIHRoOiB7IHRyOiB0cnVlLCB0YWJsZTogdHJ1ZSwgVFI6IHRydWUsIFRBQkxFOiB0cnVlIH0sXG4gICAgVEg6IHsgdHI6IHRydWUsIHRhYmxlOiB0cnVlLCBUUjogdHJ1ZSwgVEFCTEU6IHRydWUgfSxcbn07XG5jb25zdCBrRWxlbWVudHNDbG9zZWRCeUNsb3NpbmdFeGNlcHQgPSB7XG4gICAgcDogeyBhOiB0cnVlLCBhdWRpbzogdHJ1ZSwgZGVsOiB0cnVlLCBpbnM6IHRydWUsIG1hcDogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIHZpZGVvOiB0cnVlIH0sXG59O1xuY29uc3QgZnJhbWVmbGFnID0gJ2RvY3VtZW50ZnJhZ21lbnRjb250YWluZXInO1xuLyoqXG4gKiBQYXJzZXMgSFRNTCBhbmQgcmV0dXJucyBhIHJvb3QgZWxlbWVudFxuICogUGFyc2UgYSBjaHVjayBvZiBIVE1MIHNvdXJjZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gZGF0YSAgICAgIGh0bWxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgIHJvb3QgZWxlbWVudFxuICovXG5mdW5jdGlvbiBiYXNlX3BhcnNlKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3Qgdm9pZFRhZyA9IG5ldyB2b2lkX3RhZ18xLmRlZmF1bHQoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZvaWRUYWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zaW5nU2xhc2gsIChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52b2lkVGFnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGFncyk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBvcHRpb25zLmJsb2NrVGV4dEVsZW1lbnRzIHx8IHtcbiAgICAgICAgc2NyaXB0OiB0cnVlLFxuICAgICAgICBub3NjcmlwdDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IHRydWUsXG4gICAgICAgIHByZTogdHJ1ZSxcbiAgICB9O1xuICAgIGNvbnN0IGVsZW1lbnRfbmFtZXMgPSBPYmplY3Qua2V5cyhlbGVtZW50cyk7XG4gICAgY29uc3Qga0Jsb2NrVGV4dEVsZW1lbnRzID0gZWxlbWVudF9uYW1lcy5tYXAoKGl0KSA9PiBuZXcgUmVnRXhwKGBeJHtpdH0kYCwgJ2knKSk7XG4gICAgY29uc3Qga0lnbm9yZUVsZW1lbnRzID0gZWxlbWVudF9uYW1lcy5maWx0ZXIoKGl0KSA9PiBCb29sZWFuKGVsZW1lbnRzW2l0XSkpLm1hcCgoaXQpID0+IG5ldyBSZWdFeHAoYF4ke2l0fSRgLCAnaScpKTtcbiAgICBmdW5jdGlvbiBlbGVtZW50X3Nob3VsZF9iZV9pZ25vcmUodGFnKSB7XG4gICAgICAgIHJldHVybiBrSWdub3JlRWxlbWVudHMuc29tZSgoaXQpID0+IGl0LnRlc3QodGFnKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzX2Jsb2NrX3RleHRfZWxlbWVudCh0YWcpIHtcbiAgICAgICAgcmV0dXJuIGtCbG9ja1RleHRFbGVtZW50cy5zb21lKChpdCkgPT4gaXQudGVzdCh0YWcpKTtcbiAgICB9XG4gICAgY29uc3QgY3JlYXRlUmFuZ2UgPSAoc3RhcnRQb3MsIGVuZFBvcykgPT4gW3N0YXJ0UG9zIC0gZnJhbWVGbGFnT2Zmc2V0LCBlbmRQb3MgLSBmcmFtZUZsYWdPZmZzZXRdO1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgSFRNTEVsZW1lbnQobnVsbCwge30sICcnLCBudWxsLCBbMCwgZGF0YS5sZW5ndGhdLCB2b2lkVGFnLCBvcHRpb25zKTtcbiAgICBsZXQgY3VycmVudFBhcmVudCA9IHJvb3Q7XG4gICAgY29uc3Qgc3RhY2sgPSBbcm9vdF07XG4gICAgbGV0IGxhc3RUZXh0UG9zID0gLTE7XG4gICAgbGV0IG5vTmVzdGVkVGFnSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgbGV0IG1hdGNoO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YW9xZi9ub2RlLWh0bWwtcGFyc2VyL2lzc3Vlcy8zOFxuICAgIGRhdGEgPSBgPCR7ZnJhbWVmbGFnfT4ke2RhdGF9PC8ke2ZyYW1lZmxhZ30+YDtcbiAgICBjb25zdCB7IGxvd2VyQ2FzZVRhZ05hbWUsIGZpeE5lc3RlZEFUYWdzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRhdGFFbmRQb3MgPSBkYXRhLmxlbmd0aCAtIChmcmFtZWZsYWcubGVuZ3RoICsgMik7XG4gICAgY29uc3QgZnJhbWVGbGFnT2Zmc2V0ID0gZnJhbWVmbGFnLmxlbmd0aCArIDI7XG4gICAgd2hpbGUgKChtYXRjaCA9IGtNYXJrdXBQYXR0ZXJuLmV4ZWMoZGF0YSkpKSB7XG4gICAgICAgIC8vIE5vdGU6IE9iamVjdCBkZXN0cnVjdHVyaW5nIGhlcmUgY29uc2lzdGVudGx5IHRlc3RzIGFzIGhpZ2hlciBwZXJmb3JtYW5jZSB0aGFuIGFycmF5IGRlc3RydWN0dXJpbmdcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICBsZXQgeyAwOiBtYXRjaFRleHQsIDE6IGxlYWRpbmdTbGFzaCwgMjogdGFnTmFtZSwgMzogYXR0cmlidXRlcywgNDogY2xvc2luZ1NsYXNoIH0gPSBtYXRjaDtcbiAgICAgICAgY29uc3QgbWF0Y2hMZW5ndGggPSBtYXRjaFRleHQubGVuZ3RoO1xuICAgICAgICBjb25zdCB0YWdTdGFydFBvcyA9IGtNYXJrdXBQYXR0ZXJuLmxhc3RJbmRleCAtIG1hdGNoTGVuZ3RoO1xuICAgICAgICBjb25zdCB0YWdFbmRQb3MgPSBrTWFya3VwUGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgIC8vIEFkZCBUZXh0Tm9kZSBpZiBjb250ZW50XG4gICAgICAgIGlmIChsYXN0VGV4dFBvcyA+IC0xKSB7XG4gICAgICAgICAgICBpZiAobGFzdFRleHRQb3MgKyBtYXRjaExlbmd0aCA8IHRhZ0VuZFBvcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkYXRhLnN1YnN0cmluZyhsYXN0VGV4dFBvcywgdGFnU3RhcnRQb3MpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXBwZW5kQ2hpbGQobmV3IHRleHRfMS5kZWZhdWx0KHRleHQsIGN1cnJlbnRQYXJlbnQsIGNyZWF0ZVJhbmdlKGxhc3RUZXh0UG9zLCB0YWdTdGFydFBvcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0VGV4dFBvcyA9IGtNYXJrdXBQYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Rhb3FmL25vZGUtaHRtbC1wYXJzZXIvaXNzdWVzLzM4XG4gICAgICAgIC8vIFNraXAgZnJhbWVmbGFnIG5vZGVcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09IGZyYW1lZmxhZylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBIYW5kbGUgY29tbWVudHNcbiAgICAgICAgaWYgKG1hdGNoVGV4dFsxXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBrZWVwIHdoYXQgaXMgaW4gYmV0d2VlbiA8IS0tIGFuZCAtLT5cbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZGF0YS5zdWJzdHJpbmcodGFnU3RhcnRQb3MgKyA0LCB0YWdFbmRQb3MgLSAzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmFwcGVuZENoaWxkKG5ldyBjb21tZW50XzEuZGVmYXVsdCh0ZXh0LCBjdXJyZW50UGFyZW50LCBjcmVhdGVSYW5nZSh0YWdTdGFydFBvcywgdGFnRW5kUG9zKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLyogLS0gSGFuZGxlIHRhZyBtYXRjaGluZyAtLSAqL1xuICAgICAgICAvLyBGaXggdGFnIGNhc2luZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKGxvd2VyQ2FzZVRhZ05hbWUpXG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBIYW5kbGUgb3BlbmluZyB0YWdzIChpZS4gPHRoaXM+IG5vdCA8L3RoYXQ+KVxuICAgICAgICBpZiAoIWxlYWRpbmdTbGFzaCkge1xuICAgICAgICAgICAgLyogUG9wdWxhdGUgYXR0cmlidXRlcyAqL1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGF0dE1hdGNoOyAoYXR0TWF0Y2ggPSBrQXR0cmlidXRlUGF0dGVybi5leGVjKGF0dHJpYnV0ZXMpKTspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IDE6IGtleSwgMjogdmFsIH0gPSBhdHRNYXRjaDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1F1b3RlZCA9IHZhbFswXSA9PT0gYCdgIHx8IHZhbFswXSA9PT0gYFwiYDtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBpc1F1b3RlZCA/IHZhbC5zbGljZSgxLCB2YWwubGVuZ3RoIC0gMSkgOiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gY3VycmVudFBhcmVudC5yYXdUYWdOYW1lO1xuICAgICAgICAgICAgaWYgKCFjbG9zaW5nU2xhc2ggJiYga0VsZW1lbnRzQ2xvc2VkQnlPcGVuaW5nW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtFbGVtZW50c0Nsb3NlZEJ5T3BlbmluZ1twYXJlbnRUYWdOYW1lXVt0YWdOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9ICgwLCBiYWNrXzEuZGVmYXVsdCkoc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbmVzdGVkIEEgdGFncyBieSB0ZXJtaW5hdGluZyB0aGUgbGFzdCBBIGFuZCBzdGFydGluZyBhIG5ldyBvbmUgOiBzZWUgaXNzdWUgIzE0NFxuICAgICAgICAgICAgaWYgKGZpeE5lc3RlZEFUYWdzICYmICh0YWdOYW1lID09PSAnYScgfHwgdGFnTmFtZSA9PT0gJ0EnKSkge1xuICAgICAgICAgICAgICAgIGlmIChub05lc3RlZFRhZ0luZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKG5vTmVzdGVkVGFnSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gKDAsIGJhY2tfMS5kZWZhdWx0KShzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vTmVzdGVkVGFnSW5kZXggPSBzdGFjay5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YWdFbmRQb3MgPSBrTWFya3VwUGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgICAgICBjb25zdCB0YWdTdGFydFBvcyA9IHRhZ0VuZFBvcyAtIG1hdGNoTGVuZ3RoO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHJhbmdlIChlbmQgcG9zaXRpb24gdXBkYXRlZCBsYXRlciBmb3IgY2xvc2VkIHRhZ3MpXG4gICAgICAgICAgICBuZXcgSFRNTEVsZW1lbnQodGFnTmFtZSwgYXR0cnMsIGF0dHJpYnV0ZXMuc2xpY2UoMSksIG51bGwsIGNyZWF0ZVJhbmdlKHRhZ1N0YXJ0UG9zLCB0YWdFbmRQb3MpLCB2b2lkVGFnLCBvcHRpb25zKSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGlzX2Jsb2NrX3RleHRfZWxlbWVudCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgY2xvc2luZyB0YWdcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZU1hcmt1cCA9IGA8LyR7dGFnTmFtZX0+YDtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gbG93ZXJDYXNlVGFnTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IGRhdGEudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmRleE9mKGNsb3NlTWFya3VwLCBrTWFya3VwUGF0dGVybi5sYXN0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIDogZGF0YS5pbmRleE9mKGNsb3NlTWFya3VwLCBrTWFya3VwUGF0dGVybi5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmRQb3MgPSBjbG9zZUluZGV4ID09PSAtMSA/IGRhdGFFbmRQb3MgOiBjbG9zZUluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50X3Nob3VsZF9iZV9pZ25vcmUodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRhdGEuc3Vic3RyaW5nKHRhZ0VuZFBvcywgdGV4dEVuZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDAgJiYgL1xcUy8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5hcHBlbmRDaGlsZChuZXcgdGV4dF8xLmRlZmF1bHQodGV4dCwgY3VycmVudFBhcmVudCwgY3JlYXRlUmFuZ2UodGFnRW5kUG9zLCB0ZXh0RW5kUG9zKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VGV4dFBvcyA9IGtNYXJrdXBQYXR0ZXJuLmxhc3RJbmRleCA9IGRhdGEubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUZXh0UG9zID0ga01hcmt1cFBhdHRlcm4ubGFzdEluZGV4ID0gY2xvc2VJbmRleCArIGNsb3NlTWFya3VwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2F1c2UgdG8gYmUgdHJlYXRlZCBhcyBzZWxmLWNsb3NpbmcsIGJlY2F1c2Ugbm8gY2xvc2UgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1NsYXNoID0gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgY2xvc2luZyB0YWdzIG9yIHNlbGYtY2xvc2VkIGVsZW1lbnRzIChpZSA8L3RhZz4gb3IgPGJyPilcbiAgICAgICAgaWYgKGxlYWRpbmdTbGFzaCB8fCBjbG9zaW5nU2xhc2ggfHwgdm9pZFRhZy5pc1ZvaWRFbGVtZW50KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub05lc3RlZFRhZ0luZGV4ICE9IG51bGwgJiYgKHRhZ05hbWUgPT09ICdhJyB8fCB0YWdOYW1lID09PSAnQScpKVxuICAgICAgICAgICAgICAgICAgICBub05lc3RlZFRhZ0luZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFyZW50LnJhd1RhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHJhbmdlIGVuZCBmb3IgY2xvc2VkIHRhZ1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LnJhbmdlWzFdID0gY3JlYXRlUmFuZ2UoLTEsIE1hdGgubWF4KGxhc3RUZXh0UG9zLCB0YWdFbmRQb3MpKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSAoMCwgYmFja18xLmRlZmF1bHQpKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gY3VycmVudFBhcmVudC50YWdOYW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnlpbmcgdG8gY2xvc2UgY3VycmVudCB0YWcsIGFuZCBtb3ZlIG9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChrRWxlbWVudHNDbG9zZWRCeUNsb3NpbmdbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrRWxlbWVudHNDbG9zZWRCeUNsb3NpbmdbcGFyZW50VGFnTmFtZV1bdGFnTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gKDAsIGJhY2tfMS5kZWZhdWx0KShzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlblRhZyA9IGN1cnJlbnRQYXJlbnQucmF3VGFnTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LnJhd1RhZ05hbWUudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtFbGVtZW50c0Nsb3NlZEJ5Q2xvc2luZ0V4Y2VwdFtvcGVuVGFnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvc2luZ1RhZyA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVDb250YWluZXIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVDb250YWluZXIucmF3VGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNvbnRhaW5lci5yYXdUYWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGNsb3NpbmdUYWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWtFbGVtZW50c0Nsb3NlZEJ5Q2xvc2luZ0V4Y2VwdFtvcGVuVGFnXVtjbG9zaW5nVGFnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcmFuZ2UgZW5kIGZvciBjbG9zZWQgdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQucmFuZ2VbMV0gPSBjcmVhdGVSYW5nZSgtMSwgTWF0aC5tYXgobGFzdFRleHRQb3MsIHRhZ0VuZFBvcykpWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9ICgwLCBiYWNrXzEuZGVmYXVsdCkoc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGFnZ3Jlc3NpdmUgc3RyYXRlZ3kgdG8gaGFuZGxlIHVubWF0Y2hpbmcgbWFya3Vwcy5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cbmV4cG9ydHMuYmFzZV9wYXJzZSA9IGJhc2VfcGFyc2U7XG4vKipcbiAqIFBhcnNlcyBIVE1MIGFuZCByZXR1cm5zIGEgcm9vdCBlbGVtZW50XG4gKiBQYXJzZSBhIGNodWNrIG9mIEhUTUwgc291cmNlLlxuICovXG5mdW5jdGlvbiBwYXJzZShkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzdGFjayA9IGJhc2VfcGFyc2UoZGF0YSwgb3B0aW9ucyk7XG4gICAgY29uc3QgW3Jvb3RdID0gc3RhY2s7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gSGFuZGxlIGVhY2ggZXJyb3IgZWxlbWVudHMuXG4gICAgICAgIGNvbnN0IGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgY29uc3Qgb25lQmVmb3JlID0gKDAsIGJhY2tfMS5kZWZhdWx0KShzdGFjayk7XG4gICAgICAgIGlmIChsYXN0LnBhcmVudE5vZGUgJiYgbGFzdC5wYXJlbnROb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0LnBhcmVudE5vZGUgPT09IG9uZUJlZm9yZSAmJiBsYXN0LnRhZ05hbWUgPT09IG9uZUJlZm9yZS50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFpciBlcnJvciBjYXNlIDxoMz4gPGgzPiBoYW5kbGUgOiBGaXhlcyB0byA8aDM+IDwvaDM+XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB3cm9uZywgYmVjb3VzZSB0aGlzIHdpbGwgcHV0IHRoZSBIMyBvdXRzaWRlIHRoZSBjdXJyZW50IHJpZ2h0IHBvc2l0aW9uIHdoaWNoIHNob3VsZCBiZSBpbnNpZGUgdGhlIGN1cnJlbnQgSHRtbCBFbGVtZW50LCBzZWUgaXNzdWUgMTUyIGZvciBtb3JlIGluZm9cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZU5vbmVDbG9zZWRUYWdzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uZUJlZm9yZS5yZW1vdmVDaGlsZChsYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVCZWZvcmUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZXJyb3IgIDxkaXY+IDxoMz4gPC9kaXY+IGhhbmRsZTogSnVzdCByZW1vdmVzIDxoMz5cbiAgICAgICAgICAgICAgICAvLyBXaHkgcmVtb3ZlPyB0aGlzIGlzIGFscmVhZHkgYSBIdG1sRWxlbWVudCBhbmQgdGhlIG1pc3NpbmcgPEgzPiBpcyBhbHJlYWR5IGFkZGVkIGluIHRoaXMgY2FzZS4gc2VlIGlzc3VlIDE1MiBmb3IgbW9yZSBpbmZvXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlTm9uZUNsb3NlZFRhZ3MgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25lQmVmb3JlLnJlbW92ZUNoaWxkKGxhc3QpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0LmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZUJlZm9yZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgZmluYWwgZWxlbWVudCBqdXN0IHNraXAuXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVzcG9uc2UuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgLy8gXHRpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgLy8gXHRcdG5vZGUucGFyZW50Tm9kZSA9IG51bGw7XG4gICAgLy8gXHR9XG4gICAgLy8gfSk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vKipcbiAqIFJlc29sdmVzIGEgbGlzdCBvZiB7QGxpbmsgTm9kZUluc2VydGFibGV9IHRvIGEgbGlzdCBvZiBub2RlcyxcbiAqIGFuZCByZW1vdmVzIG5vZGVzIGZyb20gYW55IHBvdGVudGlhbCBwYXJlbnQuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVJbnNlcnRhYmxlKGluc2VydGFibGUpIHtcbiAgICByZXR1cm4gaW5zZXJ0YWJsZS5tYXAoKHZhbCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGV4dF8xLmRlZmF1bHQodmFsKTtcbiAgICAgICAgfVxuICAgICAgICB2YWwucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXNldFBhcmVudChub2RlcywgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlIiwiYmFzZV9wYXJzZSIsImNzc19zZWxlY3RfMSIsInJlcXVpcmUiLCJoZV8xIiwiYmFja18xIiwibWF0Y2hlcl8xIiwidm9pZF90YWdfMSIsImNvbW1lbnRfMSIsIm5vZGVfMSIsInRleHRfMSIsInR5cGVfMSIsImRlY29kZSIsInZhbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWZhdWx0IiwiSHRhZ3MiLCJEdGFncyIsIkZ0YWdzIiwidGFibGVUYWdzIiwiaHRtbFRhZ3MiLCJrQmxvY2tFbGVtZW50cyIsIlNldCIsImFkZFRvS0Jsb2NrRWxlbWVudCIsImFyZ3MiLCJhZGRUb1NldCIsImFycmF5IiwiaW5kZXgiLCJsZW5ndGgiLCJlbGVtZW50IiwiYWRkIiwidG9VcHBlckNhc2UiLCJhcmciLCJET01Ub2tlbkxpc3QiLCJfdmFsaWRhdGUiLCJjIiwidGVzdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJ2YWx1ZXNJbml0IiwiYWZ0ZXJVcGRhdGUiLCJfc2V0IiwiX2FmdGVyVXBkYXRlIiwicmVwbGFjZSIsImMxIiwiYzIiLCJkZWxldGUiLCJyZW1vdmUiLCJ0b2dnbGUiLCJoYXMiLCJjb250YWlucyIsInNpemUiLCJ2YWx1ZXMiLCJBcnJheSIsImZyb20iLCJ0b1N0cmluZyIsImpvaW4iLCJIVE1MRWxlbWVudCIsInF1b3RlQXR0cmlidXRlIiwiYXR0ciIsInRhZ05hbWUiLCJrZXlBdHRycyIsInJhd0F0dHJzIiwicGFyZW50Tm9kZSIsInJhbmdlIiwidm9pZFRhZyIsIl9wYXJzZU9wdGlvbnMiLCJub2RlVHlwZSIsIkVMRU1FTlRfTk9ERSIsInJhd1RhZ05hbWUiLCJfaWQiLCJpZCIsImNoaWxkTm9kZXMiLCJjbGFzc0xpc3QiLCJjbGFzcyIsInNwbGl0Iiwic2V0QXR0cmlidXRlIiwiY2xzIiwicmVtb3ZlQ2hpbGQiLCJub2RlIiwiZmlsdGVyIiwiY2hpbGQiLCJleGNoYW5nZUNoaWxkIiwib2xkTm9kZSIsIm5ld05vZGUiLCJjaGlsZHJlbiIsIm1hcCIsIm5ld25hbWUiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsTmFtZSIsImlzVm9pZEVsZW1lbnQiLCJuZXdpZCIsInJhd1RleHQiLCJyZWR1Y2UiLCJwcmUiLCJjdXIiLCJ0ZXh0Q29udGVudCIsImNvbnRlbnQiLCJ0ZXh0Iiwic3RydWN0dXJlZFRleHQiLCJjdXJyZW50QmxvY2siLCJibG9ja3MiLCJkZnMiLCJwdXNoIiwiZm9yRWFjaCIsIlRFWFRfTk9ERSIsImlzV2hpdGVzcGFjZSIsInByZXBlbmRXaGl0ZXNwYWNlIiwidHJpbW1lZFRleHQiLCJibG9jayIsInRhZyIsImF0dHJzIiwiZm9ybWF0Tm9kZSIsImlubmVySFRNTCIsInIiLCJub2RlcyIsInJlc2V0UGFyZW50Iiwic2V0X2NvbnRlbnQiLCJvcHRpb25zIiwiYXNzaWduIiwicmVwbGFjZVdpdGgiLCJwYXJlbnQiLCJmbGF0IiwiaWR4IiwiZmluZEluZGV4Iiwic2xpY2UiLCJvdXRlckhUTUwiLCJ0cmltUmlnaHQiLCJwYXR0ZXJuIiwiaSIsImNoaWxkTm9kZSIsInNlYXJjaCIsInN1YnN0ciIsInN0cnVjdHVyZSIsInJlcyIsImluZGVudGlvbiIsIndyaXRlIiwic3RyIiwicmVwZWF0IiwiaWRTdHIiLCJjbGFzc1N0ciIsInJlbW92ZVdoaXRlc3BhY2UiLCJvIiwidHJpbW1lZFJhd1RleHQiLCJrZXlzIiwicmF3QXR0cmlidXRlcyIsImtleSIsIl9yYXdBdHRycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzZWxlY3RvciIsInNlbGVjdEFsbCIsInhtbE1vZGUiLCJhZGFwdGVyIiwicXVlcnlTZWxlY3RvciIsInNlbGVjdE9uZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwidXBwZXJDYXNlZFRhZ05hbWUiLCJyZSIsInN0YWNrIiwiY3VycmVudE5vZGVSZWZlcmVuY2UiLCJ1bmRlZmluZWQiLCJwb3AiLCJnZXRFbGVtZW50QnlJZCIsImNsb3Nlc3QiLCJtYXBDaGlsZCIsIk1hcCIsImVsIiwib2xkIiwiZmluZE9uZSIsImVsZW1zIiwiZWxlbSIsImwiLCJnZXQiLCJzZXQiLCJlIiwiZ2V0Q2hpbGRyZW4iLCJnZXRTaWJsaW5ncyIsImZpbmRBbGwiLCJhcHBlbmRDaGlsZCIsImFwcGVuZCIsIl9hdHRycyIsImF0dHJpYnV0ZXMiLCJyZXRfYXR0cnMiLCJtYXRjaCIsImV4ZWMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJuYW1lIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiYXJndW1lbnRzIiwiazIiLCJrIiwiU3RyaW5nIiwic2V0QXR0cmlidXRlcyIsImluc2VydEFkamFjZW50SFRNTCIsIndoZXJlIiwiaHRtbCIsInAiLCJhZnRlciIsInByZXBlbmQiLCJiZWZvcmUiLCJpbnNlcnRhYmxlIiwicmVzb2x2ZUluc2VydGFibGUiLCJ1bnNoaWZ0Iiwic2libGluZ3MiLCJzcGxpY2UiLCJpbmRleE9mIiwibmV4dFNpYmxpbmciLCJuZXh0RWxlbWVudFNpYmxpbmciLCJmaW5kIiwicHJldmlvdXNTaWJsaW5nIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImZpcnN0Q2hpbGQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImxhc3RDaGlsZCIsImxhc3RFbGVtZW50Q2hpbGQiLCJjaGlsZEVsZW1lbnRDb3VudCIsImNsYXNzTmFtZXMiLCJjbG9uZSIsImtNYXJrdXBQYXR0ZXJuIiwia0F0dHJpYnV0ZVBhdHRlcm4iLCJrRWxlbWVudHNDbG9zZWRCeU9wZW5pbmciLCJsaSIsIkxJIiwiZGl2IiwiUCIsIkRJViIsImIiLCJCIiwidGQiLCJ0aCIsIlREIiwiVEgiLCJoMSIsIkgxIiwiaDIiLCJIMiIsImgzIiwiSDMiLCJoNCIsIkg0IiwiaDUiLCJINSIsImg2IiwiSDYiLCJrRWxlbWVudHNDbG9zZWRCeUNsb3NpbmciLCJ1bCIsIm9sIiwiVUwiLCJPTCIsImEiLCJBIiwiSSIsInRyIiwidGFibGUiLCJUUiIsIlRBQkxFIiwia0VsZW1lbnRzQ2xvc2VkQnlDbG9zaW5nRXhjZXB0IiwiYXVkaW8iLCJkZWwiLCJpbnMiLCJub3NjcmlwdCIsInZpZGVvIiwiZnJhbWVmbGFnIiwiZGF0YSIsIl9hIiwiX2IiLCJjbG9zaW5nU2xhc2giLCJ0YWdzIiwiZWxlbWVudHMiLCJibG9ja1RleHRFbGVtZW50cyIsInNjcmlwdCIsInN0eWxlIiwiZWxlbWVudF9uYW1lcyIsImtCbG9ja1RleHRFbGVtZW50cyIsIml0IiwiUmVnRXhwIiwia0lnbm9yZUVsZW1lbnRzIiwiQm9vbGVhbiIsImVsZW1lbnRfc2hvdWxkX2JlX2lnbm9yZSIsInNvbWUiLCJpc19ibG9ja190ZXh0X2VsZW1lbnQiLCJjcmVhdGVSYW5nZSIsInN0YXJ0UG9zIiwiZW5kUG9zIiwiZnJhbWVGbGFnT2Zmc2V0Iiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJsYXN0VGV4dFBvcyIsIm5vTmVzdGVkVGFnSW5kZXgiLCJsb3dlckNhc2VUYWdOYW1lIiwiZml4TmVzdGVkQVRhZ3MiLCJkYXRhRW5kUG9zIiwibWF0Y2hUZXh0IiwibGVhZGluZ1NsYXNoIiwibWF0Y2hMZW5ndGgiLCJ0YWdTdGFydFBvcyIsImxhc3RJbmRleCIsInRhZ0VuZFBvcyIsInN1YnN0cmluZyIsImNvbW1lbnQiLCJhdHRNYXRjaCIsImlzUXVvdGVkIiwicGFyZW50VGFnTmFtZSIsImNsb3NlTWFya3VwIiwiY2xvc2VJbmRleCIsInRvTG9jYWxlTG93ZXJDYXNlIiwidGV4dEVuZFBvcyIsIk1hdGgiLCJtYXgiLCJvcGVuVGFnIiwiY2xvc2luZ1RhZyIsInBvc3NpYmxlQ29udGFpbmVyIiwibGFzdCIsIm9uZUJlZm9yZSIsInBhcnNlTm9uZUNsb3NlZFRhZ3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/nodes/html.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/nodes/node.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-html-parser/dist/nodes/node.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst he_1 = __webpack_require__(/*! he */ \"(rsc)/./node_modules/he/he.js\");\n/**\n * Node Class as base class for TextNode and HTMLElement.\n */ class Node {\n    constructor(parentNode = null, range){\n        this.parentNode = parentNode;\n        this.childNodes = [];\n        Object.defineProperty(this, \"range\", {\n            enumerable: false,\n            writable: true,\n            configurable: true,\n            value: range !== null && range !== void 0 ? range : [\n                -1,\n                -1\n            ]\n        });\n    }\n    /**\n     * Remove current node\n     */ remove() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            this.parentNode.childNodes = children.filter((child)=>{\n                return this !== child;\n            });\n            this.parentNode = null;\n        }\n        return this;\n    }\n    get innerText() {\n        return this.rawText;\n    }\n    get textContent() {\n        return (0, he_1.decode)(this.rawText);\n    }\n    set textContent(val) {\n        this.rawText = (0, he_1.encode)(val);\n    }\n}\nexports[\"default\"] = Node;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L25vZGVzL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsT0FBT0MsbUJBQU9BLENBQUMseUNBQUk7QUFDekI7O0NBRUMsR0FDRCxNQUFNQztJQUNGQyxZQUFZQyxhQUFhLElBQUksRUFBRUMsS0FBSyxDQUFFO1FBQ2xDLElBQUksQ0FBQ0QsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNFLFVBQVUsR0FBRyxFQUFFO1FBQ3BCVixPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNVLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxjQUFjO1lBQ2RWLE9BQU9NLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUlBLFFBQVE7Z0JBQUMsQ0FBQztnQkFBRyxDQUFDO2FBQUU7UUFDaEU7SUFDSjtJQUNBOztLQUVDLEdBQ0RLLFNBQVM7UUFDTCxJQUFJLElBQUksQ0FBQ04sVUFBVSxFQUFFO1lBQ2pCLE1BQU1PLFdBQVcsSUFBSSxDQUFDUCxVQUFVLENBQUNFLFVBQVU7WUFDM0MsSUFBSSxDQUFDRixVQUFVLENBQUNFLFVBQVUsR0FBR0ssU0FBU0MsTUFBTSxDQUFDLENBQUNDO2dCQUMxQyxPQUFPLElBQUksS0FBS0E7WUFDcEI7WUFDQSxJQUFJLENBQUNULFVBQVUsR0FBRztRQUN0QjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0EsSUFBSVUsWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDQyxPQUFPO0lBQ3ZCO0lBQ0EsSUFBSUMsY0FBYztRQUNkLE9BQU8sQ0FBQyxHQUFHaEIsS0FBS2lCLE1BQU0sRUFBRSxJQUFJLENBQUNGLE9BQU87SUFDeEM7SUFDQSxJQUFJQyxZQUFZRSxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFDSCxPQUFPLEdBQUcsQ0FBQyxHQUFHZixLQUFLbUIsTUFBTSxFQUFFRDtJQUNwQztBQUNKO0FBQ0FwQixrQkFBZSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcm8vLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L25vZGVzL25vZGUuanM/YTYxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGhlXzEgPSByZXF1aXJlKFwiaGVcIik7XG4vKipcbiAqIE5vZGUgQ2xhc3MgYXMgYmFzZSBjbGFzcyBmb3IgVGV4dE5vZGUgYW5kIEhUTUxFbGVtZW50LlxuICovXG5jbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnROb2RlID0gbnVsbCwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gW107XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmFuZ2UnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHJhbmdlICE9PSBudWxsICYmIHJhbmdlICE9PSB2b2lkIDAgPyByYW5nZSA6IFstMSwgLTFdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY3VycmVudCBub2RlXG4gICAgICovXG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMgPSBjaGlsZHJlbi5maWx0ZXIoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgaW5uZXJUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdUZXh0O1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaGVfMS5kZWNvZGUpKHRoaXMucmF3VGV4dCk7XG4gICAgfVxuICAgIHNldCB0ZXh0Q29udGVudCh2YWwpIHtcbiAgICAgICAgdGhpcy5yYXdUZXh0ID0gKDAsIGhlXzEuZW5jb2RlKSh2YWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE5vZGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoZV8xIiwicmVxdWlyZSIsIk5vZGUiLCJjb25zdHJ1Y3RvciIsInBhcmVudE5vZGUiLCJyYW5nZSIsImNoaWxkTm9kZXMiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJyZW1vdmUiLCJjaGlsZHJlbiIsImZpbHRlciIsImNoaWxkIiwiaW5uZXJUZXh0IiwicmF3VGV4dCIsInRleHRDb250ZW50IiwiZGVjb2RlIiwidmFsIiwiZW5jb2RlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/nodes/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/nodes/text.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-html-parser/dist/nodes/text.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst he_1 = __webpack_require__(/*! he */ \"(rsc)/./node_modules/he/he.js\");\nconst node_1 = __importDefault(__webpack_require__(/*! ./node */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/node.js\"));\nconst type_1 = __importDefault(__webpack_require__(/*! ./type */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/type.js\"));\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */ class TextNode extends node_1.default {\n    clone() {\n        return new TextNode(this._rawText, null);\n    }\n    constructor(rawText, parentNode = null, range){\n        super(parentNode, range);\n        /**\n         * Node Type declaration.\n         * @type {Number}\n         */ this.nodeType = type_1.default.TEXT_NODE;\n        this.rawTagName = \"\";\n        this._rawText = rawText;\n    }\n    get rawText() {\n        return this._rawText;\n    }\n    /**\n     * Set rawText and invalidate trimmed caches\n     */ set rawText(text) {\n        this._rawText = text;\n        this._trimmedRawText = void 0;\n        this._trimmedText = void 0;\n    }\n    /**\n     * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space\n     */ get trimmedRawText() {\n        if (this._trimmedRawText !== undefined) return this._trimmedRawText;\n        this._trimmedRawText = trimText(this.rawText);\n        return this._trimmedRawText;\n    }\n    /**\n     * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\n     */ get trimmedText() {\n        if (this._trimmedText !== undefined) return this._trimmedText;\n        this._trimmedText = trimText(this.text);\n        return this._trimmedText;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */ get text() {\n        return (0, he_1.decode)(this.rawText);\n    }\n    /**\n     * Detect if the node contains only white space.\n     * @return {boolean}\n     */ get isWhitespace() {\n        return /^(\\s|&nbsp;)*$/.test(this.rawText);\n    }\n    toString() {\n        return this.rawText;\n    }\n}\nexports[\"default\"] = TextNode;\n/**\n * Trim whitespace except single leading/trailing non-breaking space\n */ function trimText(text) {\n    let i = 0;\n    let startPos;\n    let endPos;\n    while(i >= 0 && i < text.length){\n        if (/\\S/.test(text[i])) {\n            if (startPos === undefined) {\n                startPos = i;\n                i = text.length;\n            } else {\n                endPos = i;\n                i = void 0;\n            }\n        }\n        if (startPos === undefined) i++;\n        else i--;\n    }\n    if (startPos === undefined) startPos = 0;\n    if (endPos === undefined) endPos = text.length - 1;\n    const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\n    const hasTrailingSpace = endPos < text.length - 1 && /[^\\S\\r\\n]/.test(text[endPos + 1]);\n    return (hasLeadingSpace ? \" \" : \"\") + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? \" \" : \"\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L25vZGVzL3RleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsT0FBT0MsbUJBQU9BLENBQUMseUNBQUk7QUFDekIsTUFBTUMsU0FBU1QsZ0JBQWdCUSxtQkFBT0EsQ0FBQyx3RUFBUTtBQUMvQyxNQUFNRSxTQUFTVixnQkFBZ0JRLG1CQUFPQSxDQUFDLHdFQUFRO0FBQy9DOzs7Q0FHQyxHQUNELE1BQU1HLGlCQUFpQkYsT0FBT0csT0FBTztJQUNqQ0MsUUFBUTtRQUNKLE9BQU8sSUFBSUYsU0FBUyxJQUFJLENBQUNHLFFBQVEsRUFBRTtJQUN2QztJQUNBQyxZQUFZQyxPQUFPLEVBQUVDLGFBQWEsSUFBSSxFQUFFQyxLQUFLLENBQUU7UUFDM0MsS0FBSyxDQUFDRCxZQUFZQztRQUNsQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBR1QsT0FBT0UsT0FBTyxDQUFDUSxTQUFTO1FBQ3hDLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ1AsUUFBUSxHQUFHRTtJQUNwQjtJQUNBLElBQUlBLFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ0YsUUFBUTtJQUN4QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUUsUUFBUU0sSUFBSSxFQUFFO1FBQ2QsSUFBSSxDQUFDUixRQUFRLEdBQUdRO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEtBQUs7UUFDNUIsSUFBSSxDQUFDQyxZQUFZLEdBQUcsS0FBSztJQUM3QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUMsaUJBQWlCO1FBQ2pCLElBQUksSUFBSSxDQUFDRixlQUFlLEtBQUtHLFdBQ3pCLE9BQU8sSUFBSSxDQUFDSCxlQUFlO1FBQy9CLElBQUksQ0FBQ0EsZUFBZSxHQUFHSSxTQUFTLElBQUksQ0FBQ1gsT0FBTztRQUM1QyxPQUFPLElBQUksQ0FBQ08sZUFBZTtJQUMvQjtJQUNBOztLQUVDLEdBQ0QsSUFBSUssY0FBYztRQUNkLElBQUksSUFBSSxDQUFDSixZQUFZLEtBQUtFLFdBQ3RCLE9BQU8sSUFBSSxDQUFDRixZQUFZO1FBQzVCLElBQUksQ0FBQ0EsWUFBWSxHQUFHRyxTQUFTLElBQUksQ0FBQ0wsSUFBSTtRQUN0QyxPQUFPLElBQUksQ0FBQ0UsWUFBWTtJQUM1QjtJQUNBOzs7S0FHQyxHQUNELElBQUlGLE9BQU87UUFDUCxPQUFPLENBQUMsR0FBR2YsS0FBS3NCLE1BQU0sRUFBRSxJQUFJLENBQUNiLE9BQU87SUFDeEM7SUFDQTs7O0tBR0MsR0FDRCxJQUFJYyxlQUFlO1FBQ2YsT0FBTyxpQkFBaUJDLElBQUksQ0FBQyxJQUFJLENBQUNmLE9BQU87SUFDN0M7SUFDQWdCLFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQ2hCLE9BQU87SUFDdkI7QUFDSjtBQUNBWCxrQkFBZSxHQUFHTTtBQUNsQjs7Q0FFQyxHQUNELFNBQVNnQixTQUFTTCxJQUFJO0lBQ2xCLElBQUlXLElBQUk7SUFDUixJQUFJQztJQUNKLElBQUlDO0lBQ0osTUFBT0YsS0FBSyxLQUFLQSxJQUFJWCxLQUFLYyxNQUFNLENBQUU7UUFDOUIsSUFBSSxLQUFLTCxJQUFJLENBQUNULElBQUksQ0FBQ1csRUFBRSxHQUFHO1lBQ3BCLElBQUlDLGFBQWFSLFdBQVc7Z0JBQ3hCUSxXQUFXRDtnQkFDWEEsSUFBSVgsS0FBS2MsTUFBTTtZQUNuQixPQUNLO2dCQUNERCxTQUFTRjtnQkFDVEEsSUFBSSxLQUFLO1lBQ2I7UUFDSjtRQUNBLElBQUlDLGFBQWFSLFdBQ2JPO2FBRUFBO0lBQ1I7SUFDQSxJQUFJQyxhQUFhUixXQUNiUSxXQUFXO0lBQ2YsSUFBSUMsV0FBV1QsV0FDWFMsU0FBU2IsS0FBS2MsTUFBTSxHQUFHO0lBQzNCLE1BQU1DLGtCQUFrQkgsV0FBVyxLQUFLLFlBQVlILElBQUksQ0FBQ1QsSUFBSSxDQUFDWSxXQUFXLEVBQUU7SUFDM0UsTUFBTUksbUJBQW1CSCxTQUFVYixLQUFLYyxNQUFNLEdBQUcsS0FBTSxZQUFZTCxJQUFJLENBQUNULElBQUksQ0FBQ2EsU0FBUyxFQUFFO0lBQ3hGLE9BQU8sQ0FBQ0Usa0JBQWtCLE1BQU0sRUFBQyxJQUFLZixLQUFLaUIsS0FBSyxDQUFDTCxVQUFVQyxTQUFTLEtBQU1HLENBQUFBLG1CQUFtQixNQUFNLEVBQUM7QUFDeEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXJvLy4vbm9kZV9tb2R1bGVzL25vZGUtaHRtbC1wYXJzZXIvZGlzdC9ub2Rlcy90ZXh0LmpzPzUyYTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBoZV8xID0gcmVxdWlyZShcImhlXCIpO1xuY29uc3Qgbm9kZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO1xuY29uc3QgdHlwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3R5cGVcIikpO1xuLyoqXG4gKiBUZXh0Tm9kZSB0byBjb250YWluIGEgdGV4dCBlbGVtZW50IGluIERPTSB0cmVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFtkZXNjcmlwdGlvbl1cbiAqL1xuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBub2RlXzEuZGVmYXVsdCB7XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy5fcmF3VGV4dCwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHJhd1RleHQsIHBhcmVudE5vZGUgPSBudWxsLCByYW5nZSkge1xuICAgICAgICBzdXBlcihwYXJlbnROb2RlLCByYW5nZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlIFR5cGUgZGVjbGFyYXRpb24uXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVUeXBlID0gdHlwZV8xLmRlZmF1bHQuVEVYVF9OT0RFO1xuICAgICAgICB0aGlzLnJhd1RhZ05hbWUgPSAnJztcbiAgICAgICAgdGhpcy5fcmF3VGV4dCA9IHJhd1RleHQ7XG4gICAgfVxuICAgIGdldCByYXdUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF3VGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHJhd1RleHQgYW5kIGludmFsaWRhdGUgdHJpbW1lZCBjYWNoZXNcbiAgICAgKi9cbiAgICBzZXQgcmF3VGV4dCh0ZXh0KSB7XG4gICAgICAgIHRoaXMuX3Jhd1RleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLl90cmltbWVkUmF3VGV4dCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fdHJpbW1lZFRleHQgPSB2b2lkIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmF3IHRleHQgd2l0aCBhbGwgd2hpdGVzcGFjZSB0cmltbWVkIGV4Y2VwdCBzaW5nbGUgbGVhZGluZy90cmFpbGluZyBub24tYnJlYWtpbmcgc3BhY2VcbiAgICAgKi9cbiAgICBnZXQgdHJpbW1lZFJhd1RleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmltbWVkUmF3VGV4dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyaW1tZWRSYXdUZXh0O1xuICAgICAgICB0aGlzLl90cmltbWVkUmF3VGV4dCA9IHRyaW1UZXh0KHRoaXMucmF3VGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmltbWVkUmF3VGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZXh0IHdpdGggYWxsIHdoaXRlc3BhY2UgdHJpbW1lZCBleGNlcHQgc2luZ2xlIGxlYWRpbmcvdHJhaWxpbmcgbm9uLWJyZWFraW5nIHNwYWNlXG4gICAgICovXG4gICAgZ2V0IHRyaW1tZWRUZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fdHJpbW1lZFRleHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmltbWVkVGV4dDtcbiAgICAgICAgdGhpcy5fdHJpbW1lZFRleHQgPSB0cmltVGV4dCh0aGlzLnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpbW1lZFRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1bmVzY2FwZWQgdGV4dCB2YWx1ZSBvZiBjdXJyZW50IG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRleHQgY29udGVudFxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gKDAsIGhlXzEuZGVjb2RlKSh0aGlzLnJhd1RleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIG5vZGUgY29udGFpbnMgb25seSB3aGl0ZSBzcGFjZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBpc1doaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiAvXihcXHN8Jm5ic3A7KSokLy50ZXN0KHRoaXMucmF3VGV4dCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdUZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHROb2RlO1xuLyoqXG4gKiBUcmltIHdoaXRlc3BhY2UgZXhjZXB0IHNpbmdsZSBsZWFkaW5nL3RyYWlsaW5nIG5vbi1icmVha2luZyBzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltVGV4dCh0ZXh0KSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBzdGFydFBvcztcbiAgICBsZXQgZW5kUG9zO1xuICAgIHdoaWxlIChpID49IDAgJiYgaSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmICgvXFxTLy50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRQb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gaTtcbiAgICAgICAgICAgICAgICBpID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRQb3MgPSBpO1xuICAgICAgICAgICAgICAgIGkgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0UG9zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zID09PSB1bmRlZmluZWQpXG4gICAgICAgIHN0YXJ0UG9zID0gMDtcbiAgICBpZiAoZW5kUG9zID09PSB1bmRlZmluZWQpXG4gICAgICAgIGVuZFBvcyA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBoYXNMZWFkaW5nU3BhY2UgPSBzdGFydFBvcyA+IDAgJiYgL1teXFxTXFxyXFxuXS8udGVzdCh0ZXh0W3N0YXJ0UG9zIC0gMV0pO1xuICAgIGNvbnN0IGhhc1RyYWlsaW5nU3BhY2UgPSBlbmRQb3MgPCAodGV4dC5sZW5ndGggLSAxKSAmJiAvW15cXFNcXHJcXG5dLy50ZXN0KHRleHRbZW5kUG9zICsgMV0pO1xuICAgIHJldHVybiAoaGFzTGVhZGluZ1NwYWNlID8gJyAnIDogJycpICsgdGV4dC5zbGljZShzdGFydFBvcywgZW5kUG9zICsgMSkgKyAoaGFzVHJhaWxpbmdTcGFjZSA/ICcgJyA6ICcnKTtcbn1cbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoZV8xIiwicmVxdWlyZSIsIm5vZGVfMSIsInR5cGVfMSIsIlRleHROb2RlIiwiZGVmYXVsdCIsImNsb25lIiwiX3Jhd1RleHQiLCJjb25zdHJ1Y3RvciIsInJhd1RleHQiLCJwYXJlbnROb2RlIiwicmFuZ2UiLCJub2RlVHlwZSIsIlRFWFRfTk9ERSIsInJhd1RhZ05hbWUiLCJ0ZXh0IiwiX3RyaW1tZWRSYXdUZXh0IiwiX3RyaW1tZWRUZXh0IiwidHJpbW1lZFJhd1RleHQiLCJ1bmRlZmluZWQiLCJ0cmltVGV4dCIsInRyaW1tZWRUZXh0IiwiZGVjb2RlIiwiaXNXaGl0ZXNwYWNlIiwidGVzdCIsInRvU3RyaW5nIiwiaSIsInN0YXJ0UG9zIiwiZW5kUG9zIiwibGVuZ3RoIiwiaGFzTGVhZGluZ1NwYWNlIiwiaGFzVHJhaWxpbmdTcGFjZSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/nodes/text.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/nodes/type.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-html-parser/dist/nodes/type.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar NodeType;\n(function(NodeType) {\n    NodeType[NodeType[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\n    NodeType[NodeType[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\n    NodeType[NodeType[\"COMMENT_NODE\"] = 8] = \"COMMENT_NODE\";\n})(NodeType || (NodeType = {}));\nexports[\"default\"] = NodeType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L25vZGVzL3R5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGVBQWUsR0FBRyxFQUFFLEdBQUc7SUFDekNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDdENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGVBQWUsR0FBRyxFQUFFLEdBQUc7QUFDN0MsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCRixrQkFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcm8vLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L25vZGVzL3R5cGUuanM/NmE3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBOb2RlVHlwZTtcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkVMRU1FTlRfTk9ERVwiXSA9IDFdID0gXCJFTEVNRU5UX05PREVcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIlRFWFRfTk9ERVwiXSA9IDNdID0gXCJURVhUX05PREVcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNPTU1FTlRfTk9ERVwiXSA9IDhdID0gXCJDT01NRU5UX05PREVcIjtcbn0pKE5vZGVUeXBlIHx8IChOb2RlVHlwZSA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBOb2RlVHlwZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk5vZGVUeXBlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/nodes/type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-html-parser/dist/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar html_1 = __webpack_require__(/*! ./nodes/html */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/html.js\");\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return html_1.parse;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsU0FBU0MsbUJBQU9BLENBQUMsOEVBQWM7QUFDbkNOLDJDQUEwQztJQUFFTyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxPQUFPSSxLQUFLO0lBQUU7QUFBRSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXJvLy4vbm9kZV9tb2R1bGVzL25vZGUtaHRtbC1wYXJzZXIvZGlzdC9wYXJzZS5qcz9iZDVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGh0bWxfMSA9IHJlcXVpcmUoXCIuL25vZGVzL2h0bWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodG1sXzEucGFyc2U7IH0gfSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiaHRtbF8xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJwYXJzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/valid.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-html-parser/dist/valid.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst html_1 = __webpack_require__(/*! ./nodes/html */ \"(rsc)/./node_modules/node-html-parser/dist/nodes/html.js\");\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */ function valid(data, options = {}) {\n    const stack = (0, html_1.base_parse)(data, options);\n    return Boolean(stack.length === 1);\n}\nexports[\"default\"] = valid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L3ZhbGlkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLDhFQUFjO0FBQ3JDOzs7Q0FHQyxHQUNELFNBQVNDLE1BQU1DLElBQUksRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDN0IsTUFBTUMsUUFBUSxDQUFDLEdBQUdMLE9BQU9NLFVBQVUsRUFBRUgsTUFBTUM7SUFDM0MsT0FBT0csUUFBUUYsTUFBTUcsTUFBTSxLQUFLO0FBQ3BDO0FBQ0FWLGtCQUFlLEdBQUdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVyby8uL25vZGVfbW9kdWxlcy9ub2RlLWh0bWwtcGFyc2VyL2Rpc3QvdmFsaWQuanM/NDFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGh0bWxfMSA9IHJlcXVpcmUoXCIuL25vZGVzL2h0bWxcIik7XG4vKipcbiAqIFBhcnNlcyBIVE1MIGFuZCByZXR1cm5zIGEgcm9vdCBlbGVtZW50XG4gKiBQYXJzZSBhIGNodWNrIG9mIEhUTUwgc291cmNlLlxuICovXG5mdW5jdGlvbiB2YWxpZChkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzdGFjayA9ICgwLCBodG1sXzEuYmFzZV9wYXJzZSkoZGF0YSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oc3RhY2subGVuZ3RoID09PSAxKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaHRtbF8xIiwicmVxdWlyZSIsInZhbGlkIiwiZGF0YSIsIm9wdGlvbnMiLCJzdGFjayIsImJhc2VfcGFyc2UiLCJCb29sZWFuIiwibGVuZ3RoIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/valid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-html-parser/dist/void-tag.js":
/*!********************************************************!*\
  !*** ./node_modules/node-html-parser/dist/void-tag.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nclass VoidTag {\n    constructor(addClosingSlash = false, tags){\n        this.addClosingSlash = addClosingSlash;\n        if (Array.isArray(tags)) {\n            this.voidTags = tags.reduce((set, tag)=>{\n                return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);\n            }, new Set());\n        } else {\n            this.voidTags = [\n                \"area\",\n                \"base\",\n                \"br\",\n                \"col\",\n                \"embed\",\n                \"hr\",\n                \"img\",\n                \"input\",\n                \"link\",\n                \"meta\",\n                \"param\",\n                \"source\",\n                \"track\",\n                \"wbr\"\n            ].reduce((set, tag)=>{\n                return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);\n            }, new Set());\n        }\n    }\n    formatNode(tag, attrs, innerHTML) {\n        const addClosingSlash = this.addClosingSlash;\n        const closingSpace = addClosingSlash && attrs && !attrs.endsWith(\" \") ? \" \" : \"\";\n        const closingSlash = addClosingSlash ? `${closingSpace}/` : \"\";\n        return this.isVoidElement(tag.toLowerCase()) ? `<${tag}${attrs}${closingSlash}>` : `<${tag}${attrs}>${innerHTML}</${tag}>`;\n    }\n    isVoidElement(tag) {\n        return this.voidTags.has(tag);\n    }\n}\nexports[\"default\"] = VoidTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L3ZvaWQtdGFnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DO0lBQ0ZDLFlBQVlDLGtCQUFrQixLQUFLLEVBQUVDLElBQUksQ0FBRTtRQUN2QyxJQUFJLENBQUNELGVBQWUsR0FBR0E7UUFDdkIsSUFBSUUsTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQ3JCLElBQUksQ0FBQ0csUUFBUSxHQUFHSCxLQUFLSSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0M7Z0JBQzlCLE9BQU9ELElBQUlFLEdBQUcsQ0FBQ0QsSUFBSUUsV0FBVyxJQUFJRCxHQUFHLENBQUNELElBQUlHLFdBQVcsSUFBSUYsR0FBRyxDQUFDRDtZQUNqRSxHQUFHLElBQUlJO1FBQ1gsT0FDSztZQUNELElBQUksQ0FBQ1AsUUFBUSxHQUFHO2dCQUFDO2dCQUFRO2dCQUFRO2dCQUFNO2dCQUFPO2dCQUFTO2dCQUFNO2dCQUFPO2dCQUFTO2dCQUFRO2dCQUFRO2dCQUFTO2dCQUFVO2dCQUFTO2FBQU0sQ0FBQ0MsTUFBTSxDQUFDLENBQUNDLEtBQUtDO2dCQUN6SSxPQUFPRCxJQUFJRSxHQUFHLENBQUNELElBQUlFLFdBQVcsSUFBSUQsR0FBRyxDQUFDRCxJQUFJRyxXQUFXLElBQUlGLEdBQUcsQ0FBQ0Q7WUFDakUsR0FBRyxJQUFJSTtRQUNYO0lBQ0o7SUFDQUMsV0FBV0wsR0FBRyxFQUFFTSxLQUFLLEVBQUVDLFNBQVMsRUFBRTtRQUM5QixNQUFNZCxrQkFBa0IsSUFBSSxDQUFDQSxlQUFlO1FBQzVDLE1BQU1lLGVBQWUsbUJBQW9CRixTQUFTLENBQUNBLE1BQU1HLFFBQVEsQ0FBQyxPQUFRLE1BQU07UUFDaEYsTUFBTUMsZUFBZWpCLGtCQUFrQixDQUFDLEVBQUVlLGFBQWEsQ0FBQyxDQUFDLEdBQUc7UUFDNUQsT0FBTyxJQUFJLENBQUNHLGFBQWEsQ0FBQ1gsSUFBSUUsV0FBVyxNQUFNLENBQUMsQ0FBQyxFQUFFRixJQUFJLEVBQUVNLE1BQU0sRUFBRUksYUFBYSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRVYsSUFBSSxFQUFFTSxNQUFNLENBQUMsRUFBRUMsVUFBVSxFQUFFLEVBQUVQLElBQUksQ0FBQyxDQUFDO0lBQzlIO0lBQ0FXLGNBQWNYLEdBQUcsRUFBRTtRQUNmLE9BQU8sSUFBSSxDQUFDSCxRQUFRLENBQUNlLEdBQUcsQ0FBQ1o7SUFDN0I7QUFDSjtBQUNBWCxrQkFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcm8vLi9ub2RlX21vZHVsZXMvbm9kZS1odG1sLXBhcnNlci9kaXN0L3ZvaWQtdGFnLmpzP2E3MDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBWb2lkVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihhZGRDbG9zaW5nU2xhc2ggPSBmYWxzZSwgdGFncykge1xuICAgICAgICB0aGlzLmFkZENsb3NpbmdTbGFzaCA9IGFkZENsb3NpbmdTbGFzaDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgICAgIHRoaXMudm9pZFRhZ3MgPSB0YWdzLnJlZHVjZSgoc2V0LCB0YWcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LmFkZCh0YWcudG9Mb3dlckNhc2UoKSkuYWRkKHRhZy50b1VwcGVyQ2FzZSgpKS5hZGQodGFnKTtcbiAgICAgICAgICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZvaWRUYWdzID0gWydhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2VtYmVkJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdsaW5rJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3diciddLnJlZHVjZSgoc2V0LCB0YWcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LmFkZCh0YWcudG9Mb3dlckNhc2UoKSkuYWRkKHRhZy50b1VwcGVyQ2FzZSgpKS5hZGQodGFnKTtcbiAgICAgICAgICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9ybWF0Tm9kZSh0YWcsIGF0dHJzLCBpbm5lckhUTUwpIHtcbiAgICAgICAgY29uc3QgYWRkQ2xvc2luZ1NsYXNoID0gdGhpcy5hZGRDbG9zaW5nU2xhc2g7XG4gICAgICAgIGNvbnN0IGNsb3NpbmdTcGFjZSA9IChhZGRDbG9zaW5nU2xhc2ggJiYgYXR0cnMgJiYgIWF0dHJzLmVuZHNXaXRoKCcgJykpID8gJyAnIDogJyc7XG4gICAgICAgIGNvbnN0IGNsb3NpbmdTbGFzaCA9IGFkZENsb3NpbmdTbGFzaCA/IGAke2Nsb3NpbmdTcGFjZX0vYCA6ICcnO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZvaWRFbGVtZW50KHRhZy50b0xvd2VyQ2FzZSgpKSA/IGA8JHt0YWd9JHthdHRyc30ke2Nsb3NpbmdTbGFzaH0+YCA6IGA8JHt0YWd9JHthdHRyc30+JHtpbm5lckhUTUx9PC8ke3RhZ30+YDtcbiAgICB9XG4gICAgaXNWb2lkRWxlbWVudCh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm9pZFRhZ3MuaGFzKHRhZyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVm9pZFRhZztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlZvaWRUYWciLCJjb25zdHJ1Y3RvciIsImFkZENsb3NpbmdTbGFzaCIsInRhZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJ2b2lkVGFncyIsInJlZHVjZSIsInNldCIsInRhZyIsImFkZCIsInRvTG93ZXJDYXNlIiwidG9VcHBlckNhc2UiLCJTZXQiLCJmb3JtYXROb2RlIiwiYXR0cnMiLCJpbm5lckhUTUwiLCJjbG9zaW5nU3BhY2UiLCJlbmRzV2l0aCIsImNsb3NpbmdTbGFzaCIsImlzVm9pZEVsZW1lbnQiLCJoYXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-html-parser/dist/void-tag.js\n");

/***/ })

};
;